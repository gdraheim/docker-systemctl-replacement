#! /usr/bin/env python3
""" Testcases for docker-systemctl-replacement functionality """

# pylint: disable=line-too-long,too-many-lines,too-many-locals,too-many-statements,too-many-public-methods,too-many-branches,too-many-nested-blocks,too-many-arguments,too-many-positional-arguments,too-many-return-statements
# pylint: disable=bare-except,broad-exception-caught,pointless-statement,multiple-statements,f-string-without-interpolation,import-outside-toplevel,no-else-return
# pylint: disable=missing-function-docstring,unused-variable,unused-argument,unspecified-encoding,redefined-outer-name,using-constant-test,invalid-name
# pylint: disable=fixme,consider-using-with,condition-evals-to-constant,chained-comparison
__copyright__ = "(C) Guido Draheim, licensed under the EUPL"""
__version__ = "2.1.1152"

from typing import List, Tuple, Generator, Iterator, Union, Optional, TextIO, Mapping

import subprocess
import os
import os.path
import time
import errno
import datetime
import unittest
import shutil
import inspect
import string
import random
import logging
import re
import sys
import collections
import signal
import shlex
from fnmatch import fnmatchcase as fnmatch
from glob import glob

string_types = (str, bytes)

logg = logging.getLogger("TESTING")
NIX = ""
SKIP = True
TODO = False
KEEP = 0
LONGER = 2
KILLWAIT = 20
_sed = "sed"
_docker = "docker"
_python = "/usr/bin/python3"
_python2 = "/usr/bin/python"
_systemctl_py = "systemctl2/systemctl3.py"
_bin_sleep="/bin/sleep"
COVERAGE = NIX # an image name in dockertests3.py

TESTING_LISTEN = False
EXIT_SUCCESS = 0
EXIT_FAILURE = 1

QUICK = "-c MAXTIMEOUT=9"

_maindir = os.path.dirname(sys.argv[0])
_mirror = os.path.join(_maindir, "docker_mirror.py")

realpath = os.path.realpath

_top_list = "ps -eo etime,pid,ppid,args --sort etime,pid"

def _recent(top_list: Union[str, List[str]]) -> str:
    result = []
    for line in lines4(top_list):
        if "[kworker" in line: continue
        if " containerd-shim " in line: continue
        if " mplayer " in line: continue
        if " chrome " in line: continue
        if "/chrome" in line: continue
        if "/testsuite" in line: continue
        if "/xfce4" in line: continue
        if "/pulse" in line: continue
        if "/gvfs/" in line: continue
        if "/dbus-daemon" in line: continue
        if "/ibus/" in line: continue
        if "/lib/tracker" in line: continue
        if "/lib/gnome" in line: continue
        if "/lib/gdm" in line: continue
        if "signal-desktop/signal-desktop" in line: continue
        if "teams/teams" in line: continue
        if "slack/slack" in line: continue
        if "bin/telegram" in line: continue
        if "bin/nextcloud" in line: continue
        if _top_list in line: continue
        if " 1 [" in line: continue
        if " 2 [" in line: continue
        # matching on ELAPSED TIME up to 4 minutes
        if re.search("^\\s*[0]*[0123]:[0-9]*\\s", line):
            result.append(" "+line)
        if " ELAPSED " in line:
            result.append(" "+line)
    return "\n".join(result)

def reply_tool() -> str:
    here = os.path.abspath(os.path.dirname(sys.argv[0]))
    return os.path.join(here, "reply.py")

def package_tool(image: str, checks: bool = False) -> str:
    if "opensuse" in image:
        if not checks:
            # --gpgcheck-strict / --no-gpg-checks
            # --gpgcheck-allow-unsigned( --gpgcheck-allow-unsigned-repo --gpgcheck-allow-unsigned-package)
            # return "zypper --gpgcheck-allow-unsigned-repo"
            return "zypper"
        return "zypper"
    if "ubuntu" in image:
        # sources.list:
        # deb [ allow-insecure=yes ] # disables but keeps warning
        # deb [ trusted=yes ] # disables GPG
        # --allow-unauthenticated
        # -o APT::Get::AllowUnauthenticated=true
        # -o Acquire::Check-Valid-Until=false
        # -o APT::Ignore::gpg-pubkey
        # -o Acquire::AllowInsecureRepositories=true
        # -o Acquire::AllowDowngradeToInsecureRepositories=true
        if not checks:
            return "apt-get -o Acquire::AllowInsecureRepositories=true"
        return "apt-get"
    if not checks:
        return "yum --setopt=repo_gpgcheck=false"
    return "yum"
def refresh_tool(image: str, checks: bool = False) -> str:
    # https://github.com/openSUSE/docker-containers/issues/64
    #  {package} rr oss-update"
    #  {package} ar -f http://download.opensuse.org/update/leap/42.3/oss/openSUSE:Leap:42.3:Update.repo"
    if "opensuse:42.3" in image:
        cmds = [
            "zypper mr --no-gpgcheck oss-update",
            "zypper refresh"]
        return "bash -c '%s'" % (" && ".join(cmds))  # pylint: disable=consider-using-f-string
    if "opensuse/leap:15." in image:
        cmds = [
            "zypper mr --no-gpgcheck --all",
            "zypper refresh"]
        return "bash -c '%s'" % (" && ".join(cmds))  # pylint: disable=consider-using-f-string
    if "opensuse" in image:
        return "zypper refresh"
    if "ubuntu" in image:
        if not checks:
            return "apt-get -o Acquire::AllowInsecureRepositories=true update"
        return "apt-get update"
    if "almalinux" in image:
        cmds = ["echo sslverify=false >> /etc/yum.conf"]
        return "bash -c '%s'" % (" && ".join(cmds))  # pylint: disable=consider-using-f-string
    return "true"
def python_package(python: str, image: Optional[str] = None) -> str:
    package = os.path.basename(python)
    if package.endswith("2"):
        if image and "opensuse" in image:
            return "python-base"
        if image and "centos:8" in image:
            return "python2"
        if image and "almalinux" in image:
            return "python2"
        if image and "ubuntu:2" in image:
            return "python2"
        return package.replace("python2", "python")
    if "python3.6" in package:
        return "python3"
    return package.replace(".", "") # python3.11 => python311
def coverage_tool(image: Optional[str] = None, python: Optional[str] = None) -> str:
    python = python or _python
    if "python3" in python:
        return python + " -m coverage"
    return "coverage2"
def coverage_run(image: Optional[str] = None, python: Optional[str] = None, append: Optional[str] = None) -> str:
    append = append or "--append"
    options = " run '--omit=*/six.py,*/extern/*.py,*/unitconfparser.py' " + append
    return coverage_tool(image, python) + options + " -- "
def coverage_package(image: Optional[str] = None, python: Optional[str] = None) -> str:
    python = python or _python
    package = "python-coverage"
    if "python3" in python:
        python3 = python_package(python, image)
        package = F"{python3}-coverage"
        if image and "centos:8" in image:
            package = "platform-python-coverage"
    else:
        if image and "centos:8" in image:
            package = "python2-coverage"
    logg.info("detect coverage_package for %s => %s (%s)", python, package, image)
    return package
def cover(image: Optional[str] = None, python: Optional[str] = None, append: Optional[str] = None) -> str:
    if not COVERAGE: return ""
    return coverage_run(image, python, append)

def q_str(part: Union[str, int, None]) -> str:
    if part is None:
        return ""
    if isinstance(part, int):
        return str(part)
    return "'%s'" % part  # pylint: disable=consider-using-f-string
def decodes(text: Union[str, bytes, None]) -> str:
    if text is None: return ""
    if isinstance(text, bytes):
        encoded = sys.getdefaultencoding()
        if encoded in ["ascii"]:
            encoded = "utf-8"
        try:
            return text.decode(encoded)
        except:
            return text.decode("latin-1")
    return text
def sh____(cmd: Union[str, List[str]], shell: bool = True) -> int:
    if isinstance(cmd, string_types):
        logg.info(": %s", cmd)
    else:
        logg.info(": %s", " ".join([q_str(item) for item in cmd]))
    return subprocess.check_call(cmd, shell=shell)
def sx____(cmd: Union[str, List[str]], shell: bool = True) -> int:
    if isinstance(cmd, string_types):
        logg.info(": %s", cmd)
    else:
        logg.info(": %s", " ".join([q_str(item) for item in cmd]))
    return subprocess.call(cmd, shell=shell)
def output(cmd: Union[str, List[str]], shell: bool = True, env: Optional[Mapping[str, str]] = None) -> str:
    if isinstance(cmd, string_types):
        logg.info(": %s", cmd)
    else:
        logg.info(": %s", " ".join([q_str(item) for item in cmd]))
    run = subprocess.Popen(cmd, shell=shell, stdout=subprocess.PIPE, env=env)
    out, err = run.communicate()
    return decodes(out)
def output2(cmd: Union[str, List[str]], shell: bool = True, env: Optional[Mapping[str, str]] = None) -> Tuple[str, int]:
    if isinstance(cmd, string_types):
        logg.info(": %s", cmd)
    else:
        logg.info(": %s", " ".join([q_str(item) for item in cmd]))
    run = subprocess.Popen(cmd, shell=shell, stdout=subprocess.PIPE, env=env)
    out, err = run.communicate()
    return decodes(out), run.returncode
def output3(cmd: Union[str, List[str]], shell: bool = True, env: Optional[Mapping[str, str]] = None) -> Tuple[str, str, int]:
    if isinstance(cmd, string_types):
        logg.info(": %s", cmd)
    else:
        logg.info(": %s", " ".join([q_str(item) for item in cmd]))
    run = subprocess.Popen(cmd, shell=shell, stdout=subprocess.PIPE, stderr=subprocess.PIPE, env=env)
    out, err = run.communicate()
    return decodes(out), decodes(err), run.returncode

BackgroundProcess = collections.namedtuple("BackgroundProcess", ["pid", "run", "log"])
def background(cmd: str, shell: bool = True) -> BackgroundProcess:
    log = open(os.devnull, "wb")
    exe = list(shlex.split(cmd))
    run = subprocess.Popen(exe, stdout=log, stderr=log)
    pid = run.pid
    logg.info("PID %s = %s", pid, cmd)
    return BackgroundProcess(pid, run, log)

def reads(filename: str) -> str:
    return decodes(open(filename, "rb").read())
def _lines4(textlines: Union[str, List[str], Iterator[str], TextIO]) -> List[str]:
    if isinstance(textlines, string_types):
        linelist = decodes(textlines).split("\n")
        if len(linelist) and linelist[-1] == "":
            linelist = linelist[:-1]
        return linelist
    return list(textlines)
def lines4(textlines: Union[str, List[str], Iterator[str], TextIO]) -> List[str]:
    linelist = []
    for line in _lines4(textlines):
        linelist.append(line.rstrip())
    return linelist
def sorted4(textlines: Union[str, List[str], Iterator[str], TextIO]) -> List[str]:
    return list(sorted(_lines4(textlines)))
def each_grep(pattern: str, textlines: Union[str, List[str], TextIO]) -> Iterator[str]:
    for line in _lines4(textlines):
        if re.search(pattern, line.rstrip()):
            yield line.rstrip()
def grep(pattern: str, textlines: Union[str, List[str], TextIO]) -> List[str]:
    return list(each_grep(pattern, textlines))
def greps(textlines: Union[str, List[str], TextIO], pattern: str) -> List[str]:
    return list(each_grep(pattern, textlines))
def running(textlines: Union[str, List[str]]) -> List[str]:
    return list(each_non_runuser(each_non_defunct(textlines)))
def each_non_defunct(textlines: Union[str, List[str], Iterator[str]]) -> Iterator[str]:
    for line in _lines4(textlines):
        if '<defunct>' in line:
            continue
        yield line
def each_non_runuser(textlines: Union[str, List[str], Iterator[str]]) -> Iterator[str]:
    for line in _lines4(textlines):
        if 'runuser -u' in line:
            continue
        yield line
def each_clean(textlines: Union[str, List[str]]) -> Iterator[str]:
    for line in _lines4(textlines):
        if '<defunct>' in line:
            continue
        if 'runuser -u' in line:
            continue
        if 'ps -eo pid,' in line:
            continue
        yield line
def clean(textlines: Union[str, List[str]]) -> str:
    return " " + "\n ".join(each_clean(textlines))

def i2(part: str, indent: str = "  ") -> str:
    if isinstance(part, string_types):
        if "\n" in part.strip():
            lines = part.strip().split("\n")
            text = indent
            newline = "\n" + indent
            text += newline.join(lines)
            if part.endswith("\n"):
                text += "\n"
            return text
    return part
def o22(part: str, maxlines: int =22) -> str:
    return only22(part, maxlines=maxlines)
def oi22(part: str, maxlines: int = 22) -> str:
    return only22(part, indent="  ", maxlines=maxlines)
def only22(part: str, indent: str = "", maxlines: int = 22) -> str:
    if isinstance(part, string_types):
        if "\n" in part.strip():
            lines = part.strip().split("\n")
            if len(lines) <= maxlines:
                return indent+part.replace("\n", "\n"+indent)
            skipped = len(lines) - maxlines + 3
            lastlines = maxlines - 5 - 3
            real = lines[:5] + ["...", F"... ({skipped} lines skipped)", "..."] + lines[-lastlines:]
            text = indent
            newline = "\n" + indent
            text += newline.join(real)
            if part.endswith("\n"):
                text += "\n"
            return text
    if isinstance(part, string_types):
        if len(part) <= maxlines:
            return part
        return part[:5] + "..." + part[-14:]
    if isinstance(part, list):
        if len(part) <= maxlines:
            return part
        skipped = len(part) - maxlines + 3
        lastlines = maxlines - 5 - 3
        return part[:5] + ["...", F"... ({skipped} lines skipped)", "..."] + part[-lastlines:]
    return part

def get_USER_ID(root: bool = False) -> int:
    ID = 0
    if root: return ID
    return os.geteuid()
def get_USER(root: bool = False) -> str:
    if root: return "root"
    uid = os.geteuid()
    import pwd
    return pwd.getpwuid(uid).pw_name
def get_GROUP_ID(root: bool = False) -> int:
    ID = 0
    if root: return ID
    return os.getegid()
def get_GROUP(root: bool = False) -> str:
    if root: return "root"
    import grp
    gid = os.getegid()
    return grp.getgrgid(gid).gr_name
def get_LASTGROUP_ID(root: bool = False) -> int:
    if root: return 0 # only there is
    current = os.getegid()
    lastgid = current
    for gid in os.getgroups():
        if gid != current:
            lastgid = gid
    return lastgid
def get_LASTGROUP(root: bool = False) -> str:
    if root: return "root" # only there is
    gid = get_LASTGROUP_ID(root)
    import grp
    return grp.getgrgid(gid).gr_name

def beep() -> None:
    if os.name == "nt":
        import winsound # type: ignore[import-error] # pylint: disable=import-error
        frequency = 2500
        duration = 1000
        winsound.Beep(frequency, duration)  # type: ignore[attr-defined]
    else:
        # using 'sox' on Linux as "\a" is usually disabled
        # sx___("play -n synth 0.1 tri  1000.0")
        sx____("play -V1 -q -n -c1 synth 0.1 sine 500")

def get_proc_started(pid: int) -> float:
    """ get time process started after boot in clock ticks"""
    proc = F"/proc/{pid}/stat"
    return path_proc_started(proc)
def path_proc_started(proc: str) -> float:
    """ get time process started after boot in clock ticks"""
    if not os.path.exists(proc):
        logg.error("no such file %s", proc)
        return 0
    else:
        with open(proc, "rb") as f:
            data = f.readline()
        stat_data = data.split()
        started_ticks = stat_data[21]
        # man proc(5): "(22) starttime = The time the process started after system boot."
        #    ".. the value is expressed in clock ticks (divide by sysconf(_SC_CLK_TCK))."
        # NOTE: for containers the start time is related to the boot time of host system.

        clkTickInt = os.sysconf_names['SC_CLK_TCK']
        clockTicksPerSec = os.sysconf(clkTickInt)
        started_secs = float(started_ticks) / clockTicksPerSec
        logg.debug("Proc started time: %.3f (%s)", started_secs, proc)
        # this value is the start time from the host system

        # Variant 1:
        system_uptime = "/proc/uptime"
        with open(system_uptime, "rb") as f:
            data = f.readline()
        uptime_data = decodes(data).split()
        uptime_secs = float(uptime_data[0])
        logg.debug("System uptime secs: %.3f (%s)", uptime_secs, system_uptime)

        # get time now
        now = time.time()
        started_time = now - (uptime_secs - started_secs)
        logg.debug("Proc has been running since: %s", datetime.datetime.fromtimestamp(started_time))

        # Variant 2:
        system_stat = "/proc/stat"
        system_btime = 0.
        with open(system_stat, "rb") as f:
            for line in f:
                if line.startswith(b"btime"):
                    system_btime = float(decodes(line).split()[1])
        f.closed
        logg.debug("System btime secs: %.3f (%s)", system_btime, system_stat)

        started_btime = system_btime + started_secs
        logg.debug("Proc has been running since: %s", datetime.datetime.fromtimestamp(started_btime))

        # return started_time
        return started_btime

def download(base_url: str, filename: str, into: str) -> None:
    if not os.path.isdir(into):
        os.makedirs(into)
    if not os.path.exists(os.path.join(into, filename)):
        sh____(F"cd {into} && wget {base_url}/{filename}")
def text_file(filename: str, content: str) -> None:
    filedir = os.path.dirname(filename)
    if not os.path.isdir(filedir):
        os.makedirs(filedir)
    f = open(filename, "w")
    if content.startswith("\n"):
        x = re.match("(?s)\n( *)", content)
        assert x is not None
        indent = x.group(1)
        for line in content[1:].split("\n"):
            if line.startswith(indent):
                line = line[len(indent):]
            f.write(line+"\n")
    else:
        f.write(content)
    f.close()
    logg.info("::: made %s", filename)
def shell_file(filename: str, content: str) -> None:
    text_file(filename, content)
    os.chmod(filename, 0o775)
def copy_file(filename: str, target: str) -> None:
    targetdir = os.path.dirname(target)
    if not os.path.isdir(targetdir):
        os.makedirs(targetdir)
    shutil.copyfile(filename, target)
def copy_tool(filename: str, target: str) -> None:
    copy_file(filename, target)
    os.chmod(target, 0o755)
def get_caller_name() -> str:
    currentframe = inspect.currentframe()
    if not currentframe: return "global"
    frame = currentframe.f_back.f_back  # type: ignore[union-attr]
    return frame.f_code.co_name  # type: ignore[union-attr]
def get_caller_caller_name() -> str:
    currentframe = inspect.currentframe()
    if not currentframe: return "global"
    frame = currentframe.f_back.f_back.f_back # type: ignore[union-attr]
    return frame.f_code.co_name  # type: ignore[union-attr]
# def os_path(root: Optional[str], path: Optional[str]) -> Optional[str]:
def os_path(root: Optional[str], path: str) -> str:
    if not root:
        return path
    if not path:
        return path
    while path.startswith(os.path.sep):
        path = path[1:]
    return os.path.join(root, path)
def os_getlogin() -> str:
    """ NOT using os.getlogin() """
    import pwd
    return pwd.getpwuid(os.geteuid()).pw_name
def os_remove(path: str) -> None:
    if os.path.exists(path):
        os.remove(path)
def get_runtime_dir() -> str:
    explicit = os.environ.get("XDG_RUNTIME_DIR", "")
    if explicit: return explicit
    user = os_getlogin()
    return "/tmp/run-"+user
def docname(path: str) -> str:
    return os.path.splitext(os.path.basename(path))[0]

SYSTEMCTL_DEBUG_LOG = "{LOG}/systemctl.debug.log"
SYSTEMCTL_EXTRA_LOG = "{LOG}/systemctl.log"

def get_home() -> str:
    return os.path.expanduser("~")              # password directory. << from docs(os.path.expanduser)
def get_HOME(root: bool = False) -> str:
    if root: return "/root"
    return get_home()
def get_RUNTIME_DIR(root: bool = False) -> str:
    RUN = "/run"
    if root: return RUN
    return os.environ.get("XDG_RUNTIME_DIR", get_runtime_dir())
def get_CONFIG_HOME(root: bool = False) -> str:
    CONFIG = "/etc"
    if root: return CONFIG
    HOME = get_HOME(root)
    return os.environ.get("XDG_CONFIG_HOME", HOME + "/.config")
def get_LOG_DIR(root: bool = False) -> str:
    LOGDIR = "/var/log"
    if root: return LOGDIR
    CONFIG = get_CONFIG_HOME(root)
    return os.path.join(CONFIG, "log")
def expand_path(path: str, root: bool = True) -> str:
    # pylint: disable=possibly-unused-variable
    LOG = get_LOG_DIR(root)
    XDG_CONFIG_HOME=get_CONFIG_HOME(root)
    XDG_RUNTIME_DIR=get_RUNTIME_DIR(root)
    return os.path.expanduser(path.replace("${", "{").format(**locals()))

def inside_container() -> bool:
    return not os.path.exists("/dev/rtc")

############ the real testsuite ##############

class DockerSystemctlReplacementTest(unittest.TestCase):
    """ testcases for systemctl.py """
    def caller_testname(self) -> str:
        name = get_caller_caller_name()
        x1 = name.find("_")
        if x1 < 0: return name
        x2 = name.find("_", x1+1)
        if x2 < 0: return name
        return name[:x2]
    def testname(self, suffix: Optional[str] = None) -> str:
        name = self.caller_testname()
        if suffix:
            return name + "_" + suffix
        return name
    def testport(self) -> int:
        testname = self.caller_testname()
        m = re.match("test_([0123456789]+)", testname)
        if m:
            port = int(m.group(1))
            if 4000 <= port and port <= 9999:
                return port
        seconds = int(str(int(time.time()))[-4:])
        return 6000 + (seconds % 2000)
    def testdir(self, testname: Optional[str] = None, keep: bool = False) -> str:
        testname = testname or self.caller_testname()
        newdir = "tmp/tmp."+testname
        if os.path.isdir(newdir) and not keep:
            shutil.rmtree(newdir)
        if not os.path.isdir(newdir):
            os.makedirs(newdir)
        return newdir
    def rm_testdir(self, testname: Optional[str] = None) -> str:
        testname = testname or self.caller_testname()
        newdir = "tmp/tmp."+testname
        if os.path.isdir(newdir):
            if not KEEP:
                shutil.rmtree(newdir)
        return newdir
    def killall(self, what: str, wait: Optional[int] = None, sig: Optional[int] = None, kill: Optional[int] = None, but: Optional[List[str]] = None) -> None:
        # logg.info("killall %s (but %s)", what, but)
        killed = 0
        if True:
            sig = sig if sig is not None else signal.SIGINT
            for nextpid in os.listdir("/proc"):
                try: pid = int(nextpid)
                except: continue
                cmdline = F"/proc/{pid}/cmdline"
                try:
                    cmd = open(cmdline).read().replace("\0", " ")
                    if fnmatch(cmd, what):
                        found = [name for name in (but or []) if name in cmd]
                        if found: continue
                        logg.info(" %s", F"kill -{sig} {pid} # {cmd}")
                        os.kill(pid, sig)
                        killed += 1
                except IOError as e:
                    if e.errno != errno.ENOENT:
                        logg.info(" killing %s", e)
                except Exception as e:
                    logg.info(" killing %s", e)
        for checking in range(int(wait or KILLWAIT)):
            remaining = []
            for nextpid in os.listdir("/proc"):
                try: pid = int(nextpid)
                except: continue
                cmdline = F"/proc/{pid}/cmdline"
                try:
                    cmd = open(cmdline).read().replace("\0", " ")
                    if fnmatch(cmd, what):
                        found = [name for name in (but or []) if name in cmd]
                        if found: continue
                        remaining += [pid]
                except IOError as e:
                    if e.errno != errno.ENOENT:
                        logg.info(" killing %s", e)
                except Exception as e:
                    logg.info(" killing %s", e)
            if not remaining:
                return
            if checking % 2 == 0:
                logg.info("[%02is] %ix remaining %s", checking, len(remaining), remaining)
            time.sleep(1)
        if True:
            kill = kill if kill is not None else signal.SIGKILL
            for nextpid in os.listdir("/proc"):
                try: pid = int(nextpid)
                except: continue
                cmdline = F"/proc/{pid}/cmdline"
                try:
                    cmd = open(cmdline).read().replace("\0", " ")
                    if fnmatch(cmd, what):
                        found = [name for name in (but or []) if name in cmd]
                        if found: continue
                        logg.info(" %s", F"kill -{kill} {pid} # {cmd}")
                        os.kill(pid, kill)
                        killed += 1
                except IOError as e:
                    if e.errno != errno.ENOENT:
                        logg.info(" killing %s", e)
                except Exception as e:
                    logg.info(" killing %s", e)
    def rm_killall(self, testname: Optional[str] = None) -> None:
        self.killall("*systemctl*.py *", 10, but = ["edit ", "localtests2.py ", "dockertests3.py "])
        testname = testname or self.caller_testname()
        self.killall(F"*/{testname}_*")
    def kill(self, pid: Union[str, int], wait: Optional[int] = None, sig: Optional[int] = None) -> bool:
        pid = int(pid)
        cmdline = F"/proc/{pid}/cmdline"
        if True:
            try:
                if os.path.exists(cmdline):
                    cmd = open(cmdline).read().replace("\0", " ").strip()
                    logg.info(" %s", F"kill {pid} # {cmd}")
                    os.kill(pid, sig or signal.SIGINT)
            except IOError as e:
                if e.errno != errno.ENOENT:
                    logg.info(" killing %s", e)
            except Exception as e:
                logg.info(" killing %s", e)
        status = F"/proc/{pid}/status"
        for checking in range(int(wait or KILLWAIT)):
            if not os.path.exists(cmdline):
                return True
            try:
                if os.path.exists(status):
                    for line in open(status):
                        if line.startswith("State:"):
                            if "(zombie)" in line:
                                return True
                            if checking % 2 == 0:
                                logg.info("[%02is] wait %s - %s", checking, pid, line.strip())
            except IOError as e:
                if e.errno != errno.ENOENT:
                    logg.info(" killing %s", e)
            except Exception as e:
                logg.info(" killing %s", e)
            time.sleep(1)
        logg.warning("not killed %s", pid)
        return False
    def makedirs(self, path: str) -> None:
        if not os.path.isdir(path):
            os.makedirs(path)
    def real_folders(self) -> Generator[str, None, None]:
        yield "/etc/systemd/system"
        yield "/var/run/systemd/system"
        yield "/usr/lib/systemd/system"
        yield "/lib/systemd/system"
        yield "/etc/init.d"
        yield "/var/run/init.d"
        yield "/var/run"
        yield "/etc/sysconfig"
        yield "/etc/systemd/system/multi-user.target.wants"
        yield "/usr/bin"
        yield "/bin"
    def rm_zzfiles(self, root: Optional[str]) -> None:
        for folder in self.real_folders():
            for item in glob(os_path(root, folder + "/zz*")):
                if os.path.islink(item):
                    logg.info("rmlink %s", item)
                    os.unlink(item)
                elif os.path.isdir(item):
                    logg.info("rmtree %s", item)
                    shutil.rmtree(item)
                else:
                    logg.info("rm %s", item)
                    os.remove(item)
            for item in glob(os_path(root, folder + "/test_*")):
                if os.path.islink(item):
                    logg.info("rmlink %s", item)
                    os.unlink(item)
                elif os.path.isdir(item):
                    logg.info("rmtree %s", item)
                    shutil.rmtree(item)
                else:
                    logg.info("rm %s", item)
                    os.remove(item)
    def coverage(self, testname: Optional[str] = None) -> None:
        if not COVERAGE:
            return
        testname = testname or self.caller_testname()
        newcoverage = ".coverage."+testname
        if os.path.isfile(".coverage"):
            time.sleep(1) # some background process may want to write data
            # shutil.copy(".coverage", newcoverage)
            with open(".coverage", "rb") as inp:
                text = inp.read()
            text2 = re.sub(rb"(\]\}\})[^{}]*(\]\}\})$", rb"\1", text)
            with open(newcoverage, "wb") as out:
                out.write(text2)
    def root(self, testdir: str, real: bool = False) -> str:
        if real: return "/"
        root_folder = os.path.join(testdir, "root")
        if not os.path.isdir(root_folder):
            os.makedirs(root_folder)
        return os.path.abspath(root_folder)
    def socat(self) -> str:
        if False and os.path.exists("/usr/bin/socat"):
            return "/usr/bin/socat"
        else:
            return reply_tool()
    def newpassword(self) -> str:
        out = "Password."
        out += random.choice(string.ascii_uppercase)
        out += random.choice(string.ascii_lowercase)
        out += random.choice(string.ascii_lowercase)
        out += random.choice(string.ascii_lowercase)
        out += random.choice(string.ascii_lowercase)
        out += random.choice(",.-+")
        out += random.choice("0123456789")
        out += random.choice("0123456789")
        return out
    def user(self) -> str:
        return os_getlogin()
    def begin(self) -> str:
        self._started = time.monotonic() # pylint: disable=attribute-defined-outside-init
        logg.info("[[%s]]", datetime.datetime.fromtimestamp(self._started).strftime("%H:%M:%S"))
        return "-vv"
    def end(self, maximum: int = 99) -> None:
        runtime = time.monotonic() - self._started
        self.assertLess(runtime, maximum * LONGER)
    #
    # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
    #
    def test_21001_systemctl_testfile(self) -> None:
        """ the systemctl.py file to be tested does exist """
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        logg.info("...")
        logg.info("testname %s", testname)
        logg.info(" testdir %s", testdir)
        logg.info("and root %s", root)
        target = "/usr/bin/systemctl"
        target_folder = os_path(root, os.path.dirname(target))
        os.makedirs(target_folder)
        target_systemctl = os_path(root, target)
        shutil.copy(_systemctl_py, target_systemctl)
        self.assertTrue(os.path.isfile(target_systemctl))
        self.rm_testdir()
        self.coverage()
    def test_21002_systemctl_version(self) -> None:
        systemctl = cover() + _systemctl_py
        cmd = F"{systemctl} --version"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, "systemd 219"))
        self.assertTrue(greps(out, "via systemctl.py"))
        self.assertTrue(greps(out, "[+]SYSVINIT"))
        self.coverage()
    def real_21002_systemctl_version(self) -> None:
        cmd = F"systemctl --version"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"systemd [234]\d\d"))
        self.assertFalse(greps(out, "via systemctl.py"))
        self.assertTrue(greps(out, "[+]SYSVINIT"))
    def test_21003_systemctl_help(self) -> None:
        """ the '--help' option and 'help' command do work """
        systemctl = cover() + _systemctl_py
        cmd = F"{systemctl} --help"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, "--root=PATH"))
        self.assertTrue(greps(out, "--verbose"))
        self.assertTrue(greps(out, "--init"))
        self.assertTrue(greps(out, "for more information"))
        self.assertFalse(greps(out, "reload-or-try-restart"))
        cmd = F"{systemctl} help"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertFalse(greps(out, "--verbose"))
        self.assertTrue(greps(out, "reload-or-try-restart"))
        self.coverage()
    def test_21005_systemctl_help_command(self) -> None:
        """ for any command, 'help command' shows the documentation """
        systemctl = cover() + _systemctl_py
        cmd = F"{systemctl} help list-unit-files"
        out, end = output2(cmd)
        logg.info("%s\n%s", cmd, out)
        self.assertEqual(end, 0)
        self.assertFalse(greps(out, "for more information"))
        self.assertTrue(greps(out, "--type=service"))
        self.coverage()
    def test_21006_systemctl_help_command_other(self) -> None:
        """ for a non-existant command, 'help command' just shows the list """
        systemctl = cover() + _systemctl_py
        cmd = F"{systemctl} help list-foo"
        out, end = output2(cmd)
        logg.info("%s\n%s", cmd, out)
        self.assertEqual(end, 1)
        self.assertFalse(greps(out, "for more information"))
        self.assertFalse(greps(out, "reload-or-try-restart"))
        self.assertTrue(greps(out, "no such command"))
        self.coverage()
    def test_21009_systemctl_help_command_for_internal(self) -> None:
        """ for a command without doc, 'help command' is empty """
        systemctl = cover() + _systemctl_py
        cmd = F"{systemctl} help __test_float"
        out, err, end = output3(cmd)
        logg.info("%s\n%s\n%s", cmd, out, err)
        self.assertEqual(end, 0)
        self.assertEqual(err.strip(), "")
        self.assertTrue(greps(out, "__test_float = "))
        self.coverage()
    def test_21010_systemctl_daemon_reload(self) -> None:
        """ daemon-reload always succeeds (does nothing) """
        systemctl = cover() + _systemctl_py
        cmd = F"{systemctl} daemon-reload"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(lines4(out), [])
        self.assertEqual(end, 0)
        self.coverage()
    def real_21011_systemctl_daemon_reload_root_ignored(self) -> None:
        self.test_21011_systemctl_daemon_reload_root_ignored(True)
    def test_21011_systemctl_daemon_reload_root_ignored(self, real: bool = False) -> None:
        """ daemon-reload always succeeds (does nothing) """
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: systemctl = "/usr/bin/systemctl"
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            ExecStart=/bin/sleep 3
        """)
        #
        cmd = F"{systemctl} daemon-reload"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(lines4(out), [])
        self.assertEqual(end, 0)
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
    def test_21020_systemctl_with_systemctl_log(self) -> None:
        """ when /var/log/systemctl.log exists then print INFO messages into it"""
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/systemctl.log")
        text_file(logfile, "")
        #
        cmd = F"{systemctl} daemon-reload"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        log = reads(logfile)
        logg.info("systemctl.log>>\n%s", log)
        self.assertEqual(end, 0)
        self.assertEqual(len(greps(log, " INFO ")), 1)
        self.assertEqual(len(greps(log, " DEBUG ")), 0)
        self.rm_testdir()
        self.coverage()
    def test_21021_systemctl_with_systemctl_debug_log(self) -> None:
        """ when /var/log/systemctl.debug.log exists then print DEBUG messages into it"""
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/systemctl.debug.log")
        text_file(logfile, "")
        #
        cmd = F"{systemctl} daemon-reload"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        log = reads(logfile)
        logg.info("systemctl.log>>\n%s", log)
        self.assertEqual(end, 0)
        self.assertEqual(len(greps(log, " INFO ")), 1)
        self.assertEqual(len(greps(log, " DEBUG ")), 3)
        self.rm_testdir()
        self.coverage()
    def test_21022_systemctl_with_systemctl_debug_level(self) -> None:
        """ when /var/log/systemctl.debug.log exists then print DEBUG messages into it"""
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        systemctl += " -vvvv"
        logfile = os_path(root, "/var/log/systemctl.log")
        text_file(logfile, "")
        #
        cmd = F"{systemctl} daemon-reload"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        log = lines4(open(logfile))
        logg.info("LOG=>\n %s", "\n ".join(log))
        self.assertEqual(len(greps(open(logfile), " INFO ")), 1)
        self.assertEqual(len(greps(open(logfile), " DEBUG ")), 3)
        self.rm_testdir()
        self.coverage()
    def test_21030_systemctl_force_ipv4(self) -> None:
        """ we can force --ipv4 for /etc/hosts """
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/hosts"), """
            127.0.0.1 localhost localhost4
            ::1 localhost localhost6""")
        hosts = reads(os_path(root, "/etc/hosts"))
        self.assertEqual(len(lines4(hosts)), 2)
        self.assertTrue(greps(hosts, "127.0.0.1.*localhost4"))
        self.assertTrue(greps(hosts, "::1.*localhost6"))
        self.assertTrue(greps(hosts, "127.0.0.1.*localhost "))
        self.assertTrue(greps(hosts, "::1.*localhost "))
        #
        cmd = F"{systemctl} --ipv4 daemon-reload"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(lines4(out), [])
        self.assertEqual(end, 0)
        hosts = reads(os_path(root, "/etc/hosts"))
        self.assertEqual(len(lines4(hosts)), 2)
        self.assertTrue(greps(hosts, "127.0.0.1.*localhost4"))
        self.assertTrue(greps(hosts, "::1.*localhost6"))
        self.assertTrue(greps(hosts, "127.0.0.1.*localhost "))
        self.assertFalse(greps(hosts, "::1.*localhost "))
        self.rm_testdir()
        self.coverage()
    def test_21031_systemctl_force_ipv6(self) -> None:
        """ we can force --ipv6 for /etc/hosts """
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/hosts"), """
            127.0.0.1 localhost localhost4
            ::1 localhost localhost6""")
        hosts = reads(os_path(root, "/etc/hosts"))
        self.assertEqual(len(lines4(hosts)), 2)
        self.assertTrue(greps(hosts, "127.0.0.1.*localhost4"))
        self.assertTrue(greps(hosts, "::1.*localhost6"))
        self.assertTrue(greps(hosts, "127.0.0.1.*localhost "))
        self.assertTrue(greps(hosts, "::1.*localhost "))
        #
        cmd = F"{systemctl} --ipv6 daemon-reload"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(lines4(out), [])
        self.assertEqual(end, 0)
        hosts = reads(os_path(root, "/etc/hosts"))
        self.assertEqual(len(lines4(hosts)), 2)
        self.assertTrue(greps(hosts, "127.0.0.1.*localhost4"))
        self.assertTrue(greps(hosts, "::1.*localhost6"))
        self.assertFalse(greps(hosts, "127.0.0.1.*localhost "))
        self.assertTrue(greps(hosts, "::1.*localhost "))
        self.rm_testdir()
        self.coverage()
    def test_21040_systemctl_override_str_config(self) -> None:
        """ we can use -c name=something to override internals """
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            ExecStart=/bin/sleep 3
        """)
        #
        cmd = F"{systemctl} daemon-reload -c SYSINIT_TARGET=network.target -vvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertEqual(lines4(out), [])
        self.assertEqual(end, 0)
        self.assertEqual(len(greps(err, "SYSINIT_TARGET=network.target")), 2)
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
    def test_21041_systemctl_override_int_config(self) -> None:
        """ we can use -c name=something to override internals """
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            ExecStart=/bin/sleep 3
        """)
        #
        cmd = F"{systemctl} daemon-reload -c INITLOOPSLEEP=1 -vvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertEqual(lines4(out), [])
        self.assertEqual(end, 0)
        self.assertEqual(len(greps(err, "INITLOOPSLEEP=1")), 2)
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
    def test_21042_systemctl_override_num_config(self) -> None:
        """ we can use -c name=something to override internals """
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            ExecStart=/bin/sleep 3
        """)
        #
        cmd = F"{systemctl} daemon-reload -c YIELD=0.7 -vvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertEqual(lines4(out), [])
        self.assertEqual(end, 0)
        self.assertEqual(len(greps(err, "YIELD=0.7")), 2)
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
    def test_21043_systemctl_override_true_config(self) -> None:
        """ we can use -c name=something to override internals """
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            ExecStart=/bin/sleep 3
        """)
        #
        cmd = F"{systemctl} daemon-reload -c DO_FULL=True -vvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertEqual(lines4(out), [])
        self.assertEqual(end, 0)
        self.assertEqual(len(greps(err, "DO_FULL=True")), 2)
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
    def test_21044_systemctl_override_list_config(self) -> None:
        """ we can use -c name=something to override internals """
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            ExecStart=/bin/sleep 3
        """)
        #
        cmd = F"{systemctl} daemon-reload -c EXTRA_VARS=1,2 -vvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertEqual(lines4(out), [])
        self.assertEqual(end, 0)
        self.assertEqual(len(greps(err, "EXTRA_VARS=.'1', '2'.")), 1)
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
    def test_21045_systemctl_override_fail_unknown_config(self) -> None:
        """ we can use -c name=something to override internals """
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            ExecStart=/bin/sleep 3
        """)
        #
        cmd = F"{systemctl} daemon-reload -c FooBar=1 -vvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertEqual(lines4(out), [])
        self.assertEqual(end, 0)
        self.assertTrue(greps(err, "unknown target config -c 'FooBar'"))
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
    def test_21046_systemctl_override_fail_unknown_type(self) -> None:
        """ we can use -c name=something to override internals """
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            ExecStart=/bin/sleep 3
        """)
        #
        cmd = F"{systemctl} daemon-reload -c SYSD_TARGET_REQUIRES=1 -vvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertEqual(lines4(out), [])
        self.assertEqual(end, 0)
        self.assertTrue(greps(err, "unknown target type -c 'SYSD_TARGET_REQUIRES'.*'dict'>"))
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
    def test_21047_systemctl_override_fail_unknown_setting(self) -> None:
        """ we can use -c name=something to override internals """
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            ExecStart=/bin/sleep 3
        """)
        #
        cmd = F"{systemctl} daemon-reload -c SomeNonsenseHere -vvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertEqual(lines4(out), [])
        self.assertEqual(end, 0)
        self.assertTrue(greps(err, "unknown target config -c 'SomeNonsenseHere'"))
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
    def test_21048_systemctl_init_sets_loop_sleep(self) -> None:
        """ we can use -c name=something to override internals """
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            ExecStart=/bin/sleep 3
        """)
        #
        cmd = F"{systemctl} daemon-reload -1 -vvv --now"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertEqual(lines4(out), [])
        self.assertEqual(end, 0)
        self.assertTrue(greps(err, "loop_sleep=5"))
        cmd = F"{systemctl} daemon-reload -11 -vvv --now"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertEqual(lines4(out), [])
        self.assertEqual(end, 0)
        self.assertTrue(greps(err, "loop_sleep=2"))
        cmd = F"{systemctl} daemon-reload -111 -vvv --now"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertEqual(lines4(out), [])
        self.assertEqual(end, 0)
        self.assertTrue(greps(err, "loop_sleep=1"))
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
    def test_21050_can_create_a_test_service(self) -> None:
        """ check that a unit file can be created for testing """
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A""")
        textA = reads(os_path(root, "/etc/systemd/system/zza.service"))
        self.assertTrue(greps(textA, "Testing A"))
        self.assertIn("\nDescription", textA)
        self.rm_testdir()
        self.coverage()
    def test_21051_can_parse_the_service_file(self) -> None:
        """ check that a unit file can be parsed atleast for a description """
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A""")
        textA = reads(os_path(root, "/etc/systemd/system/zza.service"))
        self.assertTrue(greps(textA, "Testing A"))
        cmd = F"{systemctl} __get_description zza.service"
        out, end = output2(cmd)
        logg.info("%s => \n%s", cmd, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, "Testing A"))
        self.rm_testdir()
        self.coverage()
    def test_21052_can_describe_a_pid_file(self) -> None:
        """ check that a unit file can have a specific pdi file """
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            PIDFile=/var/run/foo.pid
            """)
        textA = reads(os_path(root, "/etc/systemd/system/zza.service"))
        self.assertTrue(greps(textA, "Testing A"))
        self.assertTrue(greps(textA, "PIDFile="))
        cmd = F"{systemctl} __get_pid_file zza.service"
        out, end = output2(cmd)
        logg.info("%s => \n%s", cmd, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, "/run/foo.pid"))
        self.rm_testdir()
        self.coverage()
    def test_21053_can_have_default_pid_file_for_simple_service(self) -> None:
        """ check that a unit file has a default pid file for simple services """
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            """)
        textA = reads(os_path(root, "/etc/systemd/system/zza.service"))
        self.assertTrue(greps(textA, "Testing A"))
        self.assertFalse(greps(textA, "PIDFile="))
        cmd = F"{systemctl} __get_pid_file zza.service"
        out, end = output2(cmd)
        logg.info("%s => \n%s", cmd, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, "/run/zza.service.status"))
        self.rm_testdir()
        self.coverage()
    def test_21055_other_services_use_a_status_file(self) -> None:
        """ check that other unit files may have a default status file """
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=oneshot
            """)
        textA = reads(os_path(root, "/etc/systemd/system/zza.service"))
        self.assertTrue(greps(textA, "Testing A"))
        self.assertFalse(greps(textA, "PIDFile="))
        cmd = F"{systemctl} __get_status_file zza.service"
        out, end = output2(cmd)
        logg.info("%s => \n%s", cmd, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, "/run/zza.service.status"))
        self.rm_testdir()
        self.coverage()
    def test_21060_can_have_shell_like_commments(self) -> None:
        """ check that a unit file can have comment lines with '#' """
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            #PIDFile=/var/run/zzfoo.pid
            """)
        textA = reads(os_path(root, "/etc/systemd/system/zza.service"))
        self.assertTrue(greps(textA, "Testing A"))
        self.assertTrue(greps(textA, "PIDFile="))
        cmd = F"{systemctl} __get_pid_file zza.service"
        out, end = output2(cmd)
        logg.info("%s => \n%s", cmd, out)
        self.assertEqual(end, 0)
        self.assertFalse(greps(out, "/run/zzfoo.pid"))
        self.assertTrue(greps(out, "/run/zza.service.status"))
        self.rm_testdir()
        self.coverage()
    def test_21061_can_have_winini_like_commments(self) -> None:
        """ check that a unit file can have comment lines with ';' """
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            ;PIDFile=/var/run/zzfoo.pid
            """)
        textA = reads(os_path(root, "/etc/systemd/system/zza.service"))
        self.assertTrue(greps(textA, "Testing A"))
        self.assertTrue(greps(textA, "PIDFile="))
        cmd = F"{systemctl} __get_pid_file zza.service"
        out, end = output2(cmd)
        logg.info("%s => \n%s", cmd, out)
        self.assertEqual(end, 0)
        self.assertFalse(greps(out, "/run/zzfoo.pid"))
        self.assertTrue(greps(out, "/run/zza.service.status"))
        self.rm_testdir()
        self.coverage()
    def test_21062_can_have_multi_line_settings_with_linebreak_mark(self) -> None:
        """ check that a unit file can have settings with '\\' at the line end """
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A \
                which is quite special
            [Service]
            PIDFile=/var/run/zzfoo.pid
            ExecStart=sleep \\
                2 \\

            """)
        textA = reads(os_path(root, "/etc/systemd/system/zza.service"))
        self.assertTrue(greps(textA, "Testing A"))
        self.assertTrue(greps(textA, "quite special"))
        self.assertTrue(greps(textA, "PIDFile="))
        self.assertTrue(greps(textA, "ExecStart="))
        cmd = F"{systemctl} __get_description zza.service"
        out, end = output2(cmd)
        logg.info("%s => \n%s", cmd, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, "Testing A"))
        self.assertTrue(greps(out, "quite special"))
        cmd = F"{systemctl} command zza.service"
        out, end = output2(cmd)
        logg.info("%s => \n%s", cmd, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(lines4(out)), 3)
        self.assertTrue(greps(out, "sleep \\\\"))
        cmd = F"{systemctl} __get_pid_file zza.service"
        out, end = output2(cmd)
        logg.info("%s => \n%s", cmd, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, "/run/zzfoo.pid"))
        self.rm_testdir()
        self.coverage()
    def test_21063_but_a_missing_linebreak_is_a_syntax_error(self) -> None:
        """ check that a unit file can have 'bad ini' lines throwing an exception """
        # the original systemd daemon would ignore services with syntax errors
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
                which is quite special
            [Service]
            PIDFile=/var/run/zzfoo.pid
            """)
        textA = reads(os_path(root, "/etc/systemd/system/zza.service"))
        self.assertTrue(greps(textA, "Testing A"))
        self.assertTrue(greps(textA, "quite special"))
        self.assertTrue(greps(textA, "PIDFile="))
        cmd = F"{systemctl} __get_description zza.service"
        out, end = output2(cmd)
        logg.info("%s => \n%s", cmd, out)
        self.assertEqual(end, 0)
        self.assertFalse(greps(out, "Testing A"))
        self.assertFalse(greps(out, "quite special"))
        cmd = F"{systemctl} __get_pid_file zza.service"
        out, end = output2(cmd)
        logg.info("%s => \n%s", cmd, out)
        self.assertEqual(end, 0)
        self.assertFalse(greps(out, "/run/zzfoo.pid"))
        self.rm_testdir()
        self.coverage()
    def test_21070_external_env_files_can_be_parsed(self) -> None:
        """ check that a unit file can have a valid EnvironmentFile for settings """
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
                which is quite special
            [Service]
            EnvironmentFile=/etc/sysconfig/zza.conf
            """)
        text_file(os_path(root, "/etc/sysconfig/zza.conf"), """
            CONF1=a1
            CONF2="b2"
            CONF3='c3'
            #CONF4=b4
            """)
        cmd = F"{systemctl} __read_env_file /etc/sysconfig/zza.conf -vv"
        out, end = output2(cmd)
        logg.info("%s => \n%s", cmd, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, "CONF1"))
        self.assertTrue(greps(out, "CONF2"))
        self.assertTrue(greps(out, "CONF3"))
        self.assertFalse(greps(out, "CONF4"))
        self.assertTrue(greps(out, "a1"))
        self.assertTrue(greps(out, "b2"))
        self.assertTrue(greps(out, "c3"))
        self.assertFalse(greps(out, '"b2"'))
        self.assertFalse(greps(out, "'c3'"))
        self.rm_testdir()
        self.coverage()
    def test_21080_preset_files_can_be_parsed(self) -> None:
        """ check that preset files do work internally"""
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzc.service"), """
            [Unit]
            Description=Testing C
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system-preset/our.preset"), """
            enable zzb.service
            disable zzc.service""")
        #
        cmd = F"{systemctl} __load_preset_files"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"^our.preset"))
        self.assertEqual(len(lines4(out)), 1)
        #
        cmd = F"{systemctl} get-preset zza.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        # self.assertTrue(greps(out, r"^our.preset"))
        self.assertEqual(len(lines4(out)), 0)
        #
        cmd = F"{systemctl} get-preset zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"^enable"))
        self.assertEqual(len(lines4(out)), 1)
        #
        cmd = F"{systemctl} get-preset zzc.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"^disable"))
        self.assertEqual(len(lines4(out)), 1)
        self.rm_testdir()
        self.coverage()
    def test_21090_check_syntax_errors_are_shown_on_daemon_reload(self) -> None:
        """ check that syntax errors are shown"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=foo
            ExecStart=runA
            ExecReload=runB
            ExecStop=runC
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzc.service"), """
            [Unit]
            Description=Testing C
            [Service]
            Type=simple
            ExecReload=/bin/kill -SIGHUP $MAINPID
            ExecStop=/bin/kill $MAINPID
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzd.service"), """
            [Unit]
            Description=Testing D
            [Service]
            Type=forking
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzg.service"), """
            [Unit]
            Description=Testing G
            [Service]
            Type=foo
            ExecStart=runA
            ExecStart=runA2
            ExecReload=runB
            ExecReload=runB2
            ExecStop=runC
            ExecStop=runC2
            [Install]
            WantedBy=multi-user.target""")
        #
        cmd = F"{systemctl} daemon-reload -vv 2>&1"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"a.service:.* file without .Service. section"))
        self.assertTrue(greps(out, r"Failed to parse service type, ignoring: foo"))
        self.assertTrue(greps(out, r"b.service:.* Executable path is not absolute"))
        self.assertTrue(greps(out, r"c.service: Service has no ExecStart"))
        self.assertTrue(greps(out, r"d.service: Service lacks both ExecStart and ExecStop"))
        self.assertTrue(greps(out, r"g.service: there may be only one Service ExecStart statement"))
        self.assertTrue(greps(out, r"c.service: the use of /bin/kill is not recommended"))
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_21090_syntax_errors_are_shown_in_journal_after_try_start(self) -> None:
        """ check the real syntax errors"""
        testname = self.testname()
        root = ""
        systemctl = "/usr/bin/systemctl"
        sx____("rm /etc/systemd/system/zz*")
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=foo
            ExecStart=runA
            ExecReload=runB
            ExecStop=runC
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzc.service"), """
            [Unit]
            Description=Testing C
            [Service]
            Type=simple
            ExecReload=/bin/kill -SIGHUP $MAINPID
            ExecStop=/bin/kill $MAINPID
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzd.service"), """
            [Unit]
            Description=Testing D
            [Service]
            Type=forking
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzg.service"), """
            [Unit]
            Description=Testing G
            [Service]
            Type=foo
            ExecStart=runA
            ExecStart=runA2
            ExecReload=runB
            ExecReload=runB2
            ExecStop=runC
            ExecStop=runC2
            [Install]
            WantedBy=multi-user.target""")
        #
        cmd = F"{systemctl} daemon-reload 2>&1"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        # there is not direct output
        self.assertFalse(greps(out, r"a.service:.* file without .Service. section"))
        self.assertFalse(greps(out, r"b.service:.* Executable path is not absolute"))
        self.assertFalse(greps(out, r"c.service:.* Service has no ExecStart"))
        self.assertFalse(greps(out, r"d.service:.* Service lacks both ExecStart and ExecStop"))
        self.assertFalse(greps(out, r"g.service:.* there may be only one ExecStart statement"))
        self.assertFalse(greps(out, r"g.service:.* there may be only one ExecStop statement"))
        self.assertFalse(greps(out, r"g.service:.* there may be only one ExecReload statement"))
        self.assertFalse(greps(out, r"c.service:.* the use of /bin/kill is not recommended"))
        # but let's try to start the services
        #
        cmd = F"{systemctl} start zza zzb zzc zzd zzg 2>&1"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertNotEqual(end, 0) # fails to start
        self.assertTrue(greps(out, r"failed to load: Invalid argument. See system logs and 'systemctl status zz\w.service' for details."))
        cmd = F"journalctl -xe --lines=50 2>&1"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertFalse(greps(out, r"a.service:.* file without .Service. section")) # systemctl.py special
        self.assertTrue(greps(out, r"Failed to parse service type, ignoring: foo"))
        self.assertTrue(greps(out, r"b.service:.* Executable path is not absolute"))
        self.assertTrue(greps(out, r"c.service:.* Service has no ExecStart"))
        self.assertTrue(greps(out, r"d.service:.* Service lacks both ExecStart= and ExecStop="))
        self.assertFalse(greps(out, r"g.service:.* there may be only one Service ExecStart statement")) # systemctl.py special
        self.assertFalse(greps(out, r"g.service:.* there may be only one Service ExecStop statement")) # systemctl.py special
        self.assertFalse(greps(out, r"g.service:.* there may be only one Service ExecReload statement")) # systemctl.py special
        self.assertFalse(greps(out, r"c.service:.* the use of /bin/kill is not recommended")) # systemctl.py special
        sh____("rm /etc/systemd/system/zz*")
    def test_21091_check_syntax_errors_on_start_service(self) -> None:
        """ check that checks are done before a start of a service"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=foo
            ExecStart=runA
            ExecReload=runB
            ExecStop=runC
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzc.service"), """
            [Unit]
            Description=Testing C
            [Service]
            Type=simple
            ExecReload=/bin/kill -SIGHUP $MAINPID
            ExecStop=/bin/kill $MAINPID
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzd.service"), """
            [Unit]
            Description=Testing D
            [Service]
            Type=forking
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzg.service"), """
            [Unit]
            Description=Testing G
            [Service]
            Type=foo
            ExecStart=runA
            ExecStart=runA2
            ExecReload=runB
            ExecReload=runB2
            ExecStop=runC
            ExecStop=runC2
            [Install]
            WantedBy=multi-user.target""")
        #
        cmd = F"{systemctl} daemon-reload -vv 2>&1"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"a.service:.* file without .Service. section"))
        self.assertTrue(greps(out, r"Failed to parse service type, ignoring: foo"))
        self.assertTrue(greps(out, r"b.service:.* Executable path is not absolute"))
        self.assertTrue(greps(out, r"c.service: Service has no ExecStart"))
        self.assertTrue(greps(out, r"d.service: Service lacks both ExecStart and ExecStop"))
        self.assertTrue(greps(out, r"g.service: there may be only one Service ExecStart statement"))
        self.assertTrue(greps(out, r"c.service: the use of /bin/kill is not recommended"))
        #
        cmd = F"{systemctl} start --no-reload zza zzb zzc zzd zzg -vv 2>&1"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(out, r"a.service:.* file without .Service. section"))
        self.assertTrue(greps(out, r"Failed to parse service type, ignoring: foo"))
        self.assertTrue(greps(out, r"b.service:.* Executable path is not absolute"))
        self.assertTrue(greps(out, r"c.service: Service has no ExecStart"))
        self.assertTrue(greps(out, r"d.service: Service lacks both ExecStart and ExecStop"))
        self.assertTrue(greps(out, r"g.service: there may be only one Service ExecStart statement"))
        self.assertTrue(greps(out, r"c.service: the use of /bin/kill is not recommended"))
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_21092_check_exec_errors_on_start_service(self) -> None:
        """ check that executable checks are done before a start of a service"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=foo
            ExecStart=/usr/bin/zza
            ExecReload=/usr/bin/zzb""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=foo
            ExecStart=-/usr/bin/zza
            ExecReload=-/usr/bin/zzb
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzc.service"), """
            [Unit]
            Description=Testing C
            [Service]
            Type=simple
            ExecStart=/usr/bin/zza
            ExecReload=/usr/bin/zzb
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzd.service"), """
            [Unit]
            Description=Testing D
            [Service]
            Type=simple
            ExecStartPre=/usr/bin/zza
            ExecStart=/usr/bin/false
            ExecStopPost=/usr/bin/zza
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzg.socket"), """
            [Unit]
            Description=Testing G
            [Socket]
            ExecStartPre=/usr/bin/zza
            ExecStopPost=/usr/bin/zzb
            Service=zzd.service
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzp.service"), """
            [Unit]
            Description=Testing P
            [Service]
            ExecStart=/usr/bin/false
            ExecStartPre=foo
            PrivateTmp=yes
            RuntimeDirectory=foo
            [Install]
            WantedBy=multi-user.target""")
        #
        cmd = F"{systemctl} daemon-reload -vv 2>&1"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"Failed to parse service type, ignoring: foo"))
        #
        logg.info("========================= zza ========")
        cmd = F"{systemctl} start --no-reload zza -vv 2>&1"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(out, r"Failed to parse service type, ignoring: foo"))
        self.assertTrue(greps(out, r"a.service: Exec command does not exist.*ExecStart"))
        self.assertTrue(greps(out, r"a.service: Exec command does not exist.*ExecReload"))
        self.assertTrue(greps(out, r"Oops"))
        #
        logg.info("========================= zzb ========")
        cmd = F"{systemctl} start --no-reload zzb -vv 2>&1"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(out, r"Failed to parse service type, ignoring: foo"))
        self.assertTrue(greps(out, r"b.service: Exec command does not exist.*ExecStart"))
        self.assertTrue(greps(out, r"b.service: Exec command does not exist.*ExecReload"))
        self.assertFalse(greps(out, r"Oops"))
        #
        logg.info("========================= zzc ========")
        cmd = F"{systemctl} start --no-reload zzc -vv 2>&1"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        self.assertFalse(greps(out, r"Failed to parse service type, ignoring: foo"))
        self.assertTrue(greps(out, r"c.service: Exec command does not exist.*ExecStart"))
        self.assertTrue(greps(out, r"c.service: Exec command does not exist.*ExecReload"))
        self.assertTrue(greps(out, r"Oops"))
        #
        logg.info("========================= zzd ========")
        cmd = F"{systemctl} start --no-reload zzd -vv 2>&1"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        self.assertFalse(greps(out, r"Failed to parse service type, ignoring: foo"))
        self.assertTrue(greps(out, r"d.service: Exec command does not exist.*ExecStartPre"))
        self.assertTrue(greps(out, r"d.service: Exec command does not exist.*ExecStopPost"))
        self.assertTrue(greps(out, r"Oops"))
        #
        logg.info("========================= zzg ========")
        cmd = F"{systemctl} start --no-reload zzg.socket -vv 2>&1"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        self.assertFalse(greps(out, r"Failed to parse service type, ignoring: foo"))
        self.assertTrue(greps(out, r"g.socket: Exec command does not exist.*ExecStartPre"))
        self.assertTrue(greps(out, r"g.socket: Exec command does not exist.*ExecStopPost"))
        self.assertTrue(greps(out, r"Oops"))
        #
        logg.info("========================= zzp ========")
        cmd = F"{systemctl} start --no-reload zzp.service -vv 2>&1"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        self.assertFalse(greps(out, r"zzp.service: Service directory path not implemented: RuntimeDirectory=foo"))
        self.assertTrue(greps(out, r"zzp.service: Service private directory option is ignored: PrivateTmp=yes"))
        self.assertFalse(greps(out, r"unsupported directory settings"))
        self.assertTrue(greps(out, r"Note, 1 private directory settings"))
        #
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_21093_check_user_group_errors_on_start_service(self) -> None:
        """ check that user and groups are checks are done before a start of a service"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=foo
            ExecStart=/usr/bin/false
            User=god""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=foo
            ExecStart=-/usr/bin/false
            User=god
            Group=bar
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzc.service"), """
            [Unit]
            Description=Testing C
            [Service]
            Type=foo
            ExecStart=/usr/bin/false
            Group=bar
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzd.service"), """
            [Unit]
            Description=Testing D
            [Service]
            Type=foo
            ExecStart=/usr/bin/false
            User=god
            Group=bar
            SupplementaryGroups=zap
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzg.socket"), """
            [Unit]
            Description=Testing G
            [Socket]
            Service=zzd.service
            SocketUser=devil
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzf.socket"), """
            [Unit]
            Description=Testing F
            [Socket]
            Service=zzd.service
            SocketUser=devil
            SocketGroup=hell
            [Install]
            WantedBy=multi-user.target""")
        #
        cmd = F"{systemctl} daemon-reload -vv 2>&1"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"Failed to parse service type, ignoring: foo"))
        #
        logg.info("========================= zza ========")
        cmd = F"{systemctl} start --no-reload zza -vv 2>&1"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(out, r"Failed to parse service type, ignoring: foo"))
        self.assertTrue(greps(out, r"a.service: User does not exist: god"))
        self.assertFalse(greps(out, r"b.service: Group does not exist: bar"))
        self.assertTrue(greps(out, r"Oops"))
        #
        logg.info("========================= zzb ========")
        cmd = F"{systemctl} start --no-reload zzb -vv 2>&1"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(out, r"Failed to parse service type, ignoring: foo"))
        self.assertTrue(greps(out, r"b.service: User does not exist: god"))
        self.assertTrue(greps(out, r"b.service: Group does not exist: bar"))
        self.assertTrue(greps(out, r"Oops"))
        #
        logg.info("========================= zzc ========")
        cmd = F"{systemctl} start --no-reload zzc -vv 2>&1"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(out, r"Failed to parse service type, ignoring: foo"))
        self.assertFalse(greps(out, r"c.service: User does not exist: god"))
        self.assertTrue(greps(out, r"c.service: Group does not exist: bar"))
        self.assertTrue(greps(out, r"Oops"))
        #
        logg.info("========================= zzd ========")
        cmd = F"{systemctl} start --no-reload zzd -vv 2>&1"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(out, r"Failed to parse service type, ignoring: foo"))
        self.assertTrue(greps(out, r"d.service: User does not exist: god"))
        self.assertTrue(greps(out, r"d.service: Group does not exist: bar"))
        self.assertTrue(greps(out, r"Oops"))
        #
        logg.info("========================= zzg ========")
        cmd = F"{systemctl} start --no-reload zzg.socket -vv 2>&1"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        self.assertFalse(greps(out, r"Failed to parse service type, ignoring: foo"))
        self.assertTrue(greps(out, r"g.socket: User does not exist: devil"))
        self.assertFalse(greps(out, r"g.socket: Group does not exist: hell"))
        self.assertTrue(greps(out, r"Oops"))
        #
        logg.info("========================= zzf ========")
        cmd = F"{systemctl} start --no-reload zzf.socket -vv 2>&1"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        self.assertFalse(greps(out, r"Failed to parse service type, ignoring: foo"))
        self.assertTrue(greps(out, r"f.socket: User does not exist: devil"))
        self.assertTrue(greps(out, r"f.socket: Group does not exist: hell"))
        self.assertTrue(greps(out, r"Oops"))
        #
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_21099_errors_message_on_dot_include(self) -> None:
        """ check that '.include' is accepted but marked deprecated"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            .include /etc/systemd/system/zzb.service
            [Unit]
            Description=Testing A""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=foo
            ExecStart=runA
            ExecReload=runB
            ExecStop=runC
            [Install]
            WantedBy=multi-user.target""")
        cmd = F"{systemctl} status zza.service"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        # self.assertEqual(end, 0)
        self.assertTrue(greps(err, r"deprecated"))
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_21101_get_bad_command(self) -> None:
        self.test_21101_bad_command(True)
    def test_21101_bad_command(self, real: bool = False) -> None:
        """ check that unknown commands work"""
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        self.rm_zzfiles(root)
        #
        cmd = F"{systemctl} incorrect"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertTrue(greps(err, "Unknown operation incorrect"))
        self.assertFalse(greps(out, "units listed."))
        self.assertEqual(end, 1)
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
    def real_21111_default_command(self) -> None:
        self.test_21111_default_command(True)
    def test_21111_default_command(self, real: bool = False) -> None:
        """ check that default commands work"""
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        self.rm_zzfiles(root)
        #
        cmd = F"{systemctl}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertTrue(greps(out, "units listed."))
        self.assertTrue(greps(out, "To show all installed unit files use 'systemctl list-unit-files'."))
        self.assertEqual(end, 0)
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
    def real_21201_get_default(self) -> None:
        self.test_21201_get_default(True)
    def test_21201_get_default(self, real: bool = False) -> None:
        """ check that get-default works"""
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        self.rm_zzfiles(root)
        #
        cmd = F"{systemctl} get-default"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        if real: self.assertTrue(greps(out, "graphical.target"))
        else: self.assertTrue(greps(out, "multi-user.target"))
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
    def real_21211_set_default(self) -> None:
        self.test_21211_set_default(True)
    def test_21211_set_default(self, real: bool = False) -> None:
        """ check that set-default works"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        self.rm_zzfiles(root)
        if not real:
            text_file(os_path(root, "/etc/systemd/system/basic.target"), """
            [Unit]
            Description=Basic Runlevel
            Requires=sockets.target""")
            text_file(os_path(root, "/etc/systemd/system/multi-user.target"), """
            [Unit]
            Description=Basic Runlevel
            Requires=basic.target""")
            text_file(os_path(root, "/etc/systemd/system/graphical.target"), """
            [Unit]
            Description=Basic Runlevel
            Requires=multi-user.target""")
        #
        cmd = F"{systemctl} get-default"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        old = out.strip()
        self.assertIn(old, ["graphical.target", "multi-user.target"])
        runlevel = "basic.target"
        cmd = F"{systemctl} set-default {runlevel}"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} get-default"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, runlevel)) # <<<<<<<<<<
        cmd = F"{systemctl} set-default {old}"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} get-default"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(out.strip(), old)
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
    def test_21218_set_default_empty(self, real: bool = False) -> None:
        """ check that set-default works with no runleven given"""
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        self.rm_zzfiles(root)
        #
        cmd = F"{systemctl} set-default "
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(out.strip(), "Too few arguments")
        self.assertEqual(end, 1)
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
    def test_21219_set_default_bad(self, real: bool = False) -> None:
        """ check that set-default works with a bad runlevel"""
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        self.rm_zzfiles(root)
        #
        cmd = F"{systemctl} set-default wrong"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(out.strip(), "No such runlevel wrong")
        self.assertEqual(end, 3)
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
    def real_21500_condition(self) -> None:
        self.test_21500_condition(True)
    def test_21500_condition(self, real: bool = False) -> None:
        """ check that file ConditionPathExistsGlob work"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        self.rm_zzfiles(root)
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            AssertPathExistsGlob=/etc/sysconfig/zz*
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            ConditionPathExistsGlob=/etc/sysconfig/zzx*
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        cmd = F"{systemctl} daemon-reload"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} status zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertTrue(greps(out, "Loaded: loaded"))
        cmd = F"{systemctl} status zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertTrue(greps(out, "Loaded: loaded"))
        #
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertTrue(greps(err, "Assertion failed on job for zza.service"))
        if not real:
            self.assertTrue(greps(err, "AssertPathExistsGlob - no files found"))
        self.assertEqual(end, EXIT_FAILURE)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job for zza.service"))
        if not real:
            self.assertTrue(greps(err, "ConditionPathExistsGlob - no files found"))
        self.assertEqual(end, EXIT_SUCCESS)
        #
        text_file(os_path(root, "/etc/sysconfig/zza"), """allow=true""")
        text_file(os_path(root, "/etc/sysconfig/zzb"), """allow=true""")
       #
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job for zza.service"))
        if not real:
            self.assertFalse(greps(err, "AssertPathExistsGlob - "))
        self.assertEqual(end, EXIT_SUCCESS)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job"))
        if not real:
            self.assertTrue(greps(err, "ConditionPathExistsGlob - no files found"))
        self.assertEqual(end, EXIT_SUCCESS)
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
    def real_21501_condition(self) -> None:
        self.test_21501_condition(True)
    def test_21501_condition(self, real: bool = False) -> None:
        """ check that file ConditionPathExists work"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        self.rm_zzfiles(root)
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            AssertPathExists=/etc/sysconfig/zza
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            ConditionPathExists=/etc/sysconfig/zzb
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        cmd = F"{systemctl} daemon-reload"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} status zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertTrue(greps(out, "Loaded: loaded"))
        cmd = F"{systemctl} status zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertTrue(greps(out, "Loaded: loaded"))
        #
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertTrue(greps(err, "Assertion failed on job for zza.service"))
        if not real:
            self.assertTrue(greps(err, "AssertPathExists - path not found"))
        self.assertEqual(end, EXIT_FAILURE)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job"))
        if not real:
            self.assertTrue(greps(err, "ConditionPathExists - path not found"))
        self.assertEqual(end, EXIT_SUCCESS)
        #
        text_file(os_path(root, "/etc/sysconfig/zza"), """allow=true""")
        text_file(os_path(root, "/etc/sysconfig/zzb"), """allow=true""")
       #
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job"))
        if not real:
            self.assertFalse(greps(err, "AssertPathExists - "))
        self.assertEqual(end, EXIT_SUCCESS)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job"))
        if not real:
            self.assertFalse(greps(err, "ConditionPathExists - "))
        self.assertEqual(end, EXIT_SUCCESS)
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
    def real_21502_condition(self) -> None:
        self.test_21502_condition(True)
    def test_21502_condition(self, real: bool = False) -> None:
        """ check that file ConditionFileNotEmpty work"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        self.rm_zzfiles(root)
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            AssertFileNotEmpty=/etc/sysconfig/zza
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            ConditionFileNotEmpty=/etc/sysconfig/zzb
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        cmd = F"{systemctl} daemon-reload"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} status zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertTrue(greps(out, "Loaded: loaded"))
        cmd = F"{systemctl} status zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertTrue(greps(out, "Loaded: loaded"))
        #
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertTrue(greps(err, "Assertion failed on job for zza.service"))
        if not real:
            self.assertTrue(greps(err, "AssertFileNotEmpty - path not found"))
        self.assertEqual(end, EXIT_FAILURE)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job"))
        if not real:
            self.assertTrue(greps(err, "ConditionFileNotEmpty - path not found"))
        self.assertEqual(end, EXIT_SUCCESS)
        #
        text_file(os_path(root, "/etc/sysconfig/zza"), """allow=true""")
        text_file(os_path(root, "/etc/sysconfig/zzb"), """allow=true""")
        #
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job"))
        if not real:
            self.assertFalse(greps(err, "AssertFileNotEmpty -"))
        self.assertEqual(end, EXIT_SUCCESS)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job"))
        if not real:
            self.assertFalse(greps(err, "ConditionFileNotEmpty - "))
        self.assertEqual(end, EXIT_SUCCESS)
        #
        text_file(os_path(root, "/etc/sysconfig/zza"), "")
        text_file(os_path(root, "/etc/sysconfig/zzb"), "")
        #
        cmd = F"{systemctl} stop zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertTrue(greps(err, "Assertion failed on job for zza.service"))
        if not real:
            self.assertTrue(greps(err, "AssertFileNotEmpty - file is empty"))
        self.assertEqual(end, EXIT_FAILURE)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job"))
        if not real:
            self.assertTrue(greps(err, "ConditionFileNotEmpty - file is empty"))
        self.assertEqual(end, EXIT_SUCCESS)
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
    def real_21503_condition(self) -> None:
        self.test_21503_condition(True)
    def test_21503_condition(self, real: bool = False) -> None:
        """ check that file ConditionPathIsReadWrite work"""
        if inside_container():
            self.skipTest("does not work in container")
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        self.rm_zzfiles(root)
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            AssertPathIsReadWrite=/etc/sysconfig/zza
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            ConditionPathIsReadWrite=/etc/sysconfig/zzb
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        cmd = F"{systemctl} daemon-reload"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} status zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertTrue(greps(out, "Loaded: loaded"))
        cmd = F"{systemctl} status zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertTrue(greps(out, "Loaded: loaded"))
        #
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertTrue(greps(err, "Assertion failed on job for zza.service"))
        if not real:
            self.assertTrue(greps(err, "AssertPathIsReadWrite - path not found"))
        self.assertEqual(end, EXIT_FAILURE)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        if not real:
            self.assertTrue(greps(err, "ConditionPathIsReadWrite - path not found"))
        self.assertEqual(end, EXIT_SUCCESS)
        #
        text_file(os_path(root, "/etc/sysconfig/zza"), """allow=true""")
        text_file(os_path(root, "/etc/sysconfig/zzb"), """allow=true""")
        #
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job"))
        if real:
            self.assertFalse(greps(err, "AssertPathIsReadWrite - "))
        self.assertEqual(end, EXIT_SUCCESS)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        if not real:
            self.assertFalse(greps(err, "ConditionPathIsReadWrite -"))
        self.assertEqual(end, EXIT_SUCCESS)
        #
        os.chmod(os_path(root, "/etc/sysconfig/zza"), 0o400)
        os.chmod(os_path(root, "/etc/sysconfig/zzb"), 0o400)
        #
        cmd = F"{systemctl} stop zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        if not real: # TODO
            self.assertTrue(greps(err, "Assertion failed on job for zza.service"))
            self.assertTrue(greps(err, "AssertPathIsReadWrite - not writable"))
            self.assertEqual(end, EXIT_FAILURE)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        if not real:
            self.assertTrue(greps(err, "ConditionPathIsReadWrite - not writable"))
        self.assertEqual(end, EXIT_SUCCESS)
        #
        os.chmod(os_path(root, "/etc/sysconfig/zza"), 0o200)
        os.chmod(os_path(root, "/etc/sysconfig/zzb"), 0o200)
        #
        cmd = F"{systemctl} stop zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        if not real: # TODO
            self.assertTrue(greps(err, "Assertion failed on job for zza.service"))
            self.assertTrue(greps(err, "AssertPathIsReadWrite - not readable"))
            self.assertEqual(end, EXIT_FAILURE)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        if not real:
            self.assertTrue(greps(err, "ConditionPathIsReadWrite - not readable"))
        self.assertEqual(end, EXIT_SUCCESS)
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
    def real_21504_condition(self) -> None:
        self.test_21504_condition(True)
    def test_21504_condition(self, real: bool = False) -> None:
        """ check that file ConditionFileIsExecutable work"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        self.rm_zzfiles(root)
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            AssertFileIsExecutable=/etc/sysconfig/zza
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            ConditionFileIsExecutable=/etc/sysconfig/zzb
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        cmd = F"{systemctl} daemon-reload"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} status zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertTrue(greps(out, "Loaded: loaded"))
        cmd = F"{systemctl} status zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertTrue(greps(out, "Loaded: loaded"))
        #
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertTrue(greps(err, "Assertion failed on job for zza.service"))
        if not real:
            self.assertTrue(greps(err, "AssertFileIsExecutable - path not found"))
        self.assertEqual(end, EXIT_FAILURE)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        if not real:
            self.assertTrue(greps(err, "ConditionFileIsExecutable - path not found"))
        self.assertEqual(end, EXIT_SUCCESS)
        #
        text_file(os_path(root, "/etc/sysconfig/zza"), """#! /usr/bin/true""")
        text_file(os_path(root, "/etc/sysconfig/zzb"), """#! /usr/bin/true""")
        #
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertTrue(greps(err, "Assertion failed on job for zza.service"))
        if not real:
            self.assertTrue(greps(err, "AssertFileIsExecutable - not executable"))
        self.assertEqual(end, EXIT_FAILURE)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        if not real:
            self.assertTrue(greps(err, "ConditionFileIsExecutable - not executable"))
        self.assertEqual(end, EXIT_SUCCESS)
        #
        os.chmod(os_path(root, "/etc/sysconfig/zza"), 0o200)
        os.chmod(os_path(root, "/etc/sysconfig/zzb"), 0o200)
        #
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertTrue(greps(err, "Assertion failed on job for zza.service"))
        if not real:
            self.assertTrue(greps(err, "AssertFileIsExecutable - not executable"))
        self.assertEqual(end, EXIT_FAILURE)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        if not real:
            self.assertTrue(greps(err, "ConditionFileIsExecutable - not executable"))
        self.assertEqual(end, EXIT_SUCCESS)
        #
        os.chmod(os_path(root, "/etc/sysconfig/zza"), 0o400)
        os.chmod(os_path(root, "/etc/sysconfig/zzb"), 0o400)
        #
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertTrue(greps(err, "Assertion failed on job for zza.service"))
        if not real:
            self.assertTrue(greps(err, "AssertFileIsExecutable - not executable"))
        self.assertEqual(end, EXIT_FAILURE)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        if not real:
            self.assertTrue(greps(err, "ConditionFileIsExecutable - not executable"))
        self.assertEqual(end, EXIT_SUCCESS)
        #
        os.chmod(os_path(root, "/etc/sysconfig/zza"), 0o700)
        os.chmod(os_path(root, "/etc/sysconfig/zzb"), 0o700)
        #
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job"))
        if not real:
            self.assertFalse(greps(err, "AssertFileIsExecutable -"))
        self.assertEqual(end, EXIT_SUCCESS)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        if not real:
            self.assertFalse(greps(err, "ConditionFileIsExecutable - "))
        self.assertEqual(end, EXIT_SUCCESS)
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
    def real_21509_condition(self) -> None:
        self.test_21509_condition(True)
    def test_21509_condition(self, real: bool = False) -> None:
        """ check that file IsMountPoint work"""
        if inside_container():
            self.skipTest("does not work in container")
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        self.rm_zzfiles(root)
        text_file(os_path(root, "/etc/systemd/system/zza.service"), F"""
            [Unit]
            Description=Testing A
            AssertPathIsMountPoint=/etc/sysconfig/zza
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), F"""
            [Unit]
            Description=Testing B
            ConditionPathIsMountPoint=/etc/sysconfig/zza
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        cmd = F"{systemctl} daemon-reload"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} status zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertTrue(greps(out, "Loaded: loaded"))
        cmd = F"{systemctl} status zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertTrue(greps(out, "Loaded: loaded"))
        #
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertTrue(greps(err, "Assertion failed on job for zza.service"))
        if not real:
            self.assertTrue(greps(err, "AssertPathIsMountPoint - path not found"))
        self.assertEqual(end, EXIT_FAILURE)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job"))
        if not real:
            self.assertTrue(greps(err, "ConditionPathIsMountPoint - path not found"))
        self.assertEqual(end, EXIT_SUCCESS)
        #
        text_file(os_path(root, "/etc/sysconfig/zza"), """allow=true""")
        text_file(os_path(root, "/etc/sysconfig/zzb"), """allow=true""")
        #
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertTrue(greps(err, "Assertion failed on job for zza.service"))
        if not real:
            self.assertTrue(greps(err, "AssertPathIsMountPoint - not a mount point"))
        self.assertEqual(end, EXIT_FAILURE)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job"))
        if not real:
            self.assertTrue(greps(err, "ConditionPathIsMountPoint - not a mount point"))
        self.assertEqual(end, EXIT_SUCCESS)
        #
        text_file(os_path(root, "/etc/systemd/system/zza.service"), F"""
            [Unit]
            Description=Testing A
            AssertPathIsMountPoint=//run
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), F"""
            [Unit]
            Description=Testing B
            ConditionPathIsMountPoint=//run
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        #
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job"))
        if not real:
            self.assertFalse(greps(err, "AssertPathIsMountPoint - "))
        self.assertEqual(end, EXIT_SUCCESS)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job"))
        if not real:
            self.assertFalse(greps(err, "ConditionPathIsMountPoint - "))
        self.assertEqual(end, EXIT_SUCCESS)
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()

    def real_21511_condition(self) -> None:
        self.test_21511_condition(True)
    def test_21511_condition(self, real: bool = False) -> None:
        """ check that file ConditionPathIsSymbolicLink work"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        self.rm_zzfiles(root)
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            AssertPathIsSymbolicLink=/etc/sysconfig/zza
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            ConditionPathIsSymbolicLink=/etc/sysconfig/zzb
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        cmd = F"{systemctl} daemon-reload"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} status zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertTrue(greps(out, "Loaded: loaded"))
        cmd = F"{systemctl} status zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertTrue(greps(out, "Loaded: loaded"))
        #
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertTrue(greps(err, "Assertion failed on job for zza.service"))
        if not real:
            self.assertTrue(greps(err, "AssertPathIsSymbolicLink - path not found"))
        self.assertEqual(end, EXIT_FAILURE)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        if not real:
            self.assertTrue(greps(err, "ConditionPathIsSymbolicLink - path not found"))
        self.assertEqual(end, EXIT_SUCCESS)
        #
        text_file(os_path(root, "/etc/sysconfig/zza"), """#! /usr/bin/true""")
        text_file(os_path(root, "/etc/sysconfig/zzb"), """#! /usr/bin/true""")
        #
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertTrue(greps(err, "Assertion failed on job for zza.service"))
        if not real:
            self.assertTrue(greps(err, "AssertPathIsSymbolicLink - not a symbolic link"))
        self.assertEqual(end, EXIT_FAILURE)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        if not real:
            self.assertTrue(greps(err, "ConditionPathIsSymbolicLink - not a symbolic link"))
        self.assertEqual(end, EXIT_SUCCESS)
        #
        os.unlink(os_path(root, "/etc/sysconfig/zza"))
        os.unlink(os_path(root, "/etc/sysconfig/zzb"))
        text_file(os_path(root, "/etc/sysconfig/zzax"), """#! /usr/bin/true""")
        text_file(os_path(root, "/etc/sysconfig/zzbx"), """#! /usr/bin/true""")
        os.symlink(os_path(root, "/etc/sysconfig/zzbx"), os_path(root, "/etc/sysconfig/zza"))
        os.symlink(os_path(root, "/etc/sysconfig/zzbx"), os_path(root, "/etc/sysconfig/zzb"))
        #
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job"))
        if not real:
            self.assertFalse(greps(err, "AssertPathIsSymbolicLink - "))
        self.assertEqual(end, EXIT_SUCCESS)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        if not real:
            self.assertFalse(greps(err, "ConditionPathIsSymbolicLink - "))
        self.assertEqual(end, EXIT_SUCCESS)
        #
        os.unlink(os_path(root, "/etc/sysconfig/zzax"))
        os.unlink(os_path(root, "/etc/sysconfig/zzbx"))
        #
        cmd = F"{systemctl} stop zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        if not real:
            self.assertTrue(greps(err, "Assertion failed on job for zza.service"))
            self.assertTrue(greps(err, "AssertPathIsSymbolicLink - path not found"))
            self.assertEqual(end, EXIT_FAILURE)
        else:
            self.assertEqual(end, EXIT_SUCCESS) # TODO
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        if not real:
            self.assertTrue(greps(err, "ConditionPathIsSymbolicLink - path not found"))
        self.assertEqual(end, EXIT_SUCCESS)
        #
        os.mkdir(os_path(root, "/etc/sysconfig/zzax"))
        os.mkdir(os_path(root, "/etc/sysconfig/zzbx"))
        #
        cmd = F"{systemctl} stop zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job"))
        if not real:
            self.assertFalse(greps(err, "AssertPathIsSymbolicLink - "))
        self.assertEqual(end, EXIT_SUCCESS)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        if not real:
            self.assertFalse(greps(err, "ConditionPathIsSymbolicLink - "))
        self.assertEqual(end, EXIT_SUCCESS)
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
    def real_21512_condition(self) -> None:
        self.test_21512_condition(True)
    def test_21512_condition(self, real: bool = False) -> None:
        """ check that file conditions work"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        self.rm_zzfiles(root)
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            AssertPathIsDirectory=/etc/sysconfig/zza
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            ConditionPathIsDirectory=/etc/sysconfig/zzb
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        cmd = F"{systemctl} daemon-reload"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} status zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertTrue(greps(out, "Loaded: loaded"))
        cmd = F"{systemctl} status zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertTrue(greps(out, "Loaded: loaded"))
        #
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertTrue(greps(err, "Assertion failed on job for zza.service"))
        if not real:
            self.assertTrue(greps(err, "AssertPathIsDirectory - path not found"))
        self.assertEqual(end, EXIT_FAILURE)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        if not real:
            self.assertTrue(greps(err, "ConditionPathIsDirectory - path not found"))
        self.assertEqual(end, EXIT_SUCCESS)
        #
        text_file(os_path(root, "/etc/sysconfig/zza"), """#! /usr/bin/true""")
        text_file(os_path(root, "/etc/sysconfig/zzb"), """#! /usr/bin/true""")
        #
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertTrue(greps(err, "Assertion failed on job for zza.service"))
        if not real:
            self.assertTrue(greps(err, "AssertPathIsDirectory - not a directory"))
        self.assertEqual(end, EXIT_FAILURE)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        if not real:
            self.assertTrue(greps(err, "ConditionPathIsDirectory - not a directory"))
        self.assertEqual(end, EXIT_SUCCESS)
        #
        os.unlink(os_path(root, "/etc/sysconfig/zza"))
        os.unlink(os_path(root, "/etc/sysconfig/zzb"))
        text_file(os_path(root, "/etc/sysconfig/zzax"), """#! /usr/bin/true""")
        text_file(os_path(root, "/etc/sysconfig/zzbx"), """#! /usr/bin/true""")
        os.symlink(os_path(root, "/etc/sysconfig/zzbx"), os_path(root, "/etc/sysconfig/zza"))
        os.symlink(os_path(root, "/etc/sysconfig/zzbx"), os_path(root, "/etc/sysconfig/zzb"))
        #
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertTrue(greps(err, "Assertion failed on job for zza.service"))
        if not real:
            self.assertTrue(greps(err, "AssertPathIsDirectory - not a directory"))
        self.assertEqual(end, EXIT_FAILURE)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        if not real:
            self.assertTrue(greps(err, "ConditionPathIsDirectory - not a directory"))
        self.assertEqual(end, EXIT_SUCCESS)
        #
        os.unlink(os_path(root, "/etc/sysconfig/zzax"))
        os.unlink(os_path(root, "/etc/sysconfig/zzbx"))
        os.mkdir(os_path(root, "/etc/sysconfig/zzax"))
        os.mkdir(os_path(root, "/etc/sysconfig/zzbx"))
        #
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job"))
        if not real:
            self.assertFalse(greps(err, "AssertPathIsDirectory - "))
        self.assertEqual(end, EXIT_SUCCESS)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        if not real:
            self.assertFalse(greps(err, "ConditionPathIsDirectory - "))
        self.assertEqual(end, EXIT_SUCCESS)
        #
        os.unlink(os_path(root, "/etc/sysconfig/zza"))
        os.unlink(os_path(root, "/etc/sysconfig/zzb"))
        os.mkdir(os_path(root, "/etc/sysconfig/zza"))
        os.mkdir(os_path(root, "/etc/sysconfig/zzb"))
        #
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job"))
        if not real:
            self.assertFalse(greps(err, "AssertPathIsDirectory - "))
        self.assertEqual(end, EXIT_SUCCESS)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        if not real:
            self.assertFalse(greps(err, "ConditionPathIsDirectory - "))
        self.assertEqual(end, EXIT_SUCCESS)
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
    def real_21513_condition(self) -> None:
        self.test_21513_condition(True)
    def test_21513_condition(self, real: bool = False) -> None:
        """ check that file ConditionDirectoryNotEmpty work"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        self.rm_zzfiles(root)
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            AssertDirectoryNotEmpty=/etc/sysconfig/zza
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            ConditionDirectoryNotEmpty=/etc/sysconfig/zzb
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        cmd = F"{systemctl} daemon-reload"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} status zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertTrue(greps(out, "Loaded: loaded"))
        cmd = F"{systemctl} status zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertTrue(greps(out, "Loaded: loaded"))
        #
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertTrue(greps(err, "Assertion failed on job for zza.service"))
        if not real:
            self.assertTrue(greps(err, "AssertDirectoryNotEmpty - path not found"))
        self.assertEqual(end, EXIT_FAILURE)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        if not real:
            self.assertTrue(greps(err, "ConditionDirectoryNotEmpty - path not found"))
        self.assertEqual(end, EXIT_SUCCESS)
        #
        text_file(os_path(root, "/etc/sysconfig/zza"), """#! /usr/bin/true""")
        text_file(os_path(root, "/etc/sysconfig/zzb"), """#! /usr/bin/true""")
        #
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertTrue(greps(err, "Assertion failed on job for zza.service"))
        if not real:
            self.assertTrue(greps(err, "AssertDirectoryNotEmpty - not a directory"))
        self.assertEqual(end, EXIT_FAILURE)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        if not real:
            self.assertTrue(greps(err, "ConditionDirectoryNotEmpty - not a directory"))
        self.assertEqual(end, EXIT_SUCCESS)
        #
        os.unlink(os_path(root, "/etc/sysconfig/zza"))
        os.unlink(os_path(root, "/etc/sysconfig/zzb"))
        text_file(os_path(root, "/etc/sysconfig/zzax"), """#! /usr/bin/true""")
        text_file(os_path(root, "/etc/sysconfig/zzbx"), """#! /usr/bin/true""")
        os.symlink(os_path(root, "/etc/sysconfig/zzbx"), os_path(root, "/etc/sysconfig/zza"))
        os.symlink(os_path(root, "/etc/sysconfig/zzbx"), os_path(root, "/etc/sysconfig/zzb"))
        #
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertTrue(greps(err, "Assertion failed on job for zza.service"))
        if not real:
            self.assertTrue(greps(err, "AssertDirectoryNotEmpty - not a directory"))
        self.assertEqual(end, EXIT_FAILURE)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        if not real:
            self.assertTrue(greps(err, "ConditionDirectoryNotEmpty - not a directory"))
        self.assertEqual(end, EXIT_SUCCESS)
        #
        os.unlink(os_path(root, "/etc/sysconfig/zzax"))
        os.unlink(os_path(root, "/etc/sysconfig/zzbx"))
        os.mkdir(os_path(root, "/etc/sysconfig/zzax"))
        os.mkdir(os_path(root, "/etc/sysconfig/zzbx"))
        #
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertTrue(greps(err, "Assertion failed on job for zza.service"))
        if not real:
            self.assertTrue(greps(err, "AssertDirectoryNotEmpty - directory is empty"))
        self.assertEqual(end, EXIT_FAILURE)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        if not real:
            self.assertTrue(greps(err, "ConditionDirectoryNotEmpty - directory is empty"))
        self.assertEqual(end, EXIT_SUCCESS)
        #
        text_file(os_path(root, "/etc/sysconfig/zzax/zz1"), """#! /usr/bin/true""")
        text_file(os_path(root, "/etc/sysconfig/zzbx/zz1"), """#! /usr/bin/true""")
        #
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job"))
        if not real:
            self.assertFalse(greps(err, "AssertDirectoryNotEmpty - "))
        self.assertEqual(end, EXIT_SUCCESS)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        if not real:
            self.assertFalse(greps(err, "ConditionDirectoryNotEmpty - "))
        self.assertEqual(end, EXIT_SUCCESS)
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
    def real_21521_condition(self) -> None:
        self.test_21521_condition(True)
    def test_21521_condition(self, real: bool = False) -> None:
        """ check that file ConditionArchitecture work"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        self.rm_zzfiles(root)
        import platform
        existing = platform.machine().replace("_", "-")
        unwanted = "mechanical-turk"
        text_file(os_path(root, "/etc/systemd/system/zza.service"), F"""
            [Unit]
            Description=Testing A
            AssertArchitecture={unwanted}
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), F"""
            [Unit]
            Description=Testing B
            ConditionArchitecture={unwanted}
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        cmd = F"{systemctl} daemon-reload"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} status zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertTrue(greps(out, "Loaded: loaded"))
        cmd = F"{systemctl} status zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertTrue(greps(out, "Loaded: loaded"))
        #
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertTrue(greps(err, "Assertion failed on job for zza.service"))
        if not real:
            self.assertTrue(greps(err, F"AssertArchitecture - want {unwanted} - have {existing}"))
        self.assertEqual(end, EXIT_FAILURE)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job"))
        if not real:
            self.assertTrue(greps(err, F"ConditionArchitecture - want {unwanted} - have {existing}"))
        self.assertEqual(end, EXIT_SUCCESS)
        #
        text_file(os_path(root, "/etc/systemd/system/zza.service"), F"""
            [Unit]
            Description=Testing A
            AssertArchitecture={existing}
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), F"""
            [Unit]
            Description=Testing B
            ConditionArchitecture={existing}
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        cmd = F"{systemctl} daemon-reload"
        out, end = output2(cmd)
       #
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job"))
        if not real:
            self.assertFalse(greps(err, "AssertArchitecture - "))
        self.assertEqual(end, EXIT_SUCCESS)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job"))
        if not real:
            self.assertFalse(greps(err, "ConditionArchitecture - "))
        self.assertEqual(end, EXIT_SUCCESS)
        self.rm_zzfiles(root)
        self.rm_testdir()
    def real_21522_condition(self) -> None:
        self.test_21522_condition(True)
    def test_21522_condition(self, real: bool = False) -> None:
        """ check that file ConditionHost work"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        self.rm_zzfiles(root)
        import platform
        existing = platform.node()
        unwanted = "test1.example.com"
        text_file(os_path(root, "/etc/systemd/system/zza.service"), F"""
            [Unit]
            Description=Testing A
            AssertHost={unwanted}
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), F"""
            [Unit]
            Description=Testing B
            ConditionHost={unwanted}
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        cmd = F"{systemctl} daemon-reload"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} status zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertTrue(greps(out, "Loaded: loaded"))
        cmd = F"{systemctl} status zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertTrue(greps(out, "Loaded: loaded"))
        #
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertTrue(greps(err, "Assertion failed on job for zza.service"))
        if not real:
            self.assertTrue(greps(err, F"AssertHost - want {unwanted} - have {existing}"))
        self.assertEqual(end, EXIT_FAILURE)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job"))
        if not real:
            self.assertTrue(greps(err, F"ConditionHost - want {unwanted} - have {existing}"))
        self.assertEqual(end, EXIT_SUCCESS)
        #
        text_file(os_path(root, "/etc/systemd/system/zza.service"), F"""
            [Unit]
            Description=Testing A
            AssertHost={existing}
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), F"""
            [Unit]
            Description=Testing B
            ConditionHost={existing}
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        cmd = F"{systemctl} daemon-reload"
        out, end = output2(cmd)
       #
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job"))
        if not real:
            self.assertFalse(greps(err, "AssertHost - "))
        self.assertEqual(end, EXIT_SUCCESS)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job"))
        if not real:
            self.assertFalse(greps(err, "ConditionHost - "))
        self.assertEqual(end, EXIT_SUCCESS)
        self.rm_zzfiles(root)
        self.rm_testdir()
    def real_21531_condition(self) -> None:
        self.test_21531_condition(True)
    def test_21531_condition(self, real: bool = False) -> None:
        """ check that file ConditionEnvironment work"""
        if inside_container():
            self.skipTest("does not work in container")
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        self.rm_zzfiles(root)
        enabled = "LANG"
        blocked = "BLOCKED"
        text_file(os_path(root, "/etc/systemd/system/zza.service"), F"""
            [Unit]
            Description=Testing A
            AssertEnvironment={blocked}
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), F"""
            [Unit]
            Description=Testing B
            ConditionEnvironment={blocked}
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        cmd = F"{systemctl} daemon-reload"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} status zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertTrue(greps(out, "Loaded: loaded"))
        cmd = F"{systemctl} status zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertTrue(greps(out, "Loaded: loaded"))
        #
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertTrue(greps(err, "Assertion failed on job for zza.service"))
        if not real:
            self.assertTrue(greps(err, F"AssertEnvironment - \\${blocked} not found"))
        self.assertEqual(end, EXIT_FAILURE)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job"))
        if not real:
            self.assertTrue(greps(err, F"ConditionEnvironment - \\${blocked} not found"))
        self.assertEqual(end, EXIT_SUCCESS)
        #
        text_file(os_path(root, "/etc/systemd/system/zza.service"), F"""
            [Unit]
            Description=Testing A
            AssertEnvironment={enabled}
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), F"""
            [Unit]
            Description=Testing B
            ConditionEnvironment={enabled}
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        cmd = F"{systemctl} daemon-reload"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        #
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job"))
        if not real:
            self.assertFalse(greps(err, "AssertEnvironment - "))
        self.assertEqual(end, EXIT_SUCCESS)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job"))
        if not real:
            self.assertFalse(greps(err, "ConditionEnvironment - "))
        self.assertEqual(end, EXIT_SUCCESS)
        #
        cmd = F"{systemctl} stop zza.service zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.rm_zzfiles(root)
        self.rm_testdir()
    def real_21532_condition(self) -> None:
        self.test_21532_condition(True)
    def test_21532_condition(self, real: bool = False) -> None:
        """ check that file ConditionEnvironment work"""
        if inside_container():
            self.skipTest("does not work in container")
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        self.rm_zzfiles(root)
        enabled = "LANG"
        blocked = "BLOCKED"
        text_file(os_path(root, "/etc/systemd/system/zza.service"), F"""
            [Unit]
            Description=Testing A
            AssertEnvironment={blocked}=ok
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), F"""
            [Unit]
            Description=Testing B
            ConditionEnvironment={blocked}=ok
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        cmd = F"{systemctl} daemon-reload"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} status zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertTrue(greps(out, "Loaded: loaded"))
        cmd = F"{systemctl} status zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertTrue(greps(out, "Loaded: loaded"))
        #
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertTrue(greps(err, "Assertion failed on job for zza.service"))
        if not real:
            self.assertTrue(greps(err, F"AssertEnvironment - \\${blocked} not found"))
        self.assertEqual(end, EXIT_FAILURE)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job"))
        if not real:
            self.assertTrue(greps(err, F"ConditionEnvironment - \\${blocked} not found"))
        self.assertEqual(end, EXIT_SUCCESS)
        #
        text_file(os_path(root, "/etc/systemd/system/zza.service"), F"""
            [Unit]
            Description=Testing A
            AssertEnvironment={enabled}=ok
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), F"""
            [Unit]
            Description=Testing B
            ConditionEnvironment={enabled}=ok
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        cmd = F"{systemctl} daemon-reload"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        #
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        ## self.assertTrue(greps(err, "Assertion failed on job for zza.service"))
        if not real:
            self.assertTrue(greps(err, F"AssertEnvironment - \\${enabled} wrong value - want 'ok'"))
        self.assertEqual(end, EXIT_FAILURE)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job"))
        if not real:
            self.assertTrue(greps(err, F"ConditionEnvironment - \\${enabled} wrong value - want 'ok'"))
        self.assertEqual(end, EXIT_SUCCESS)
        #
        cmd = F"{systemctl} show-environment {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        correct="no"
        for line in out.splitlines():
            logg.info("     env %s", line.rstrip())
            if line.startswith(F"{enabled}="):
                correct = line.split("=", 1)[1].rstrip()
                break
        if correct in ['C']:
            if not TODO:
                logg.warning("LANG was found to be '%s' - but that's not being evaluated later", correct)
                correct=os.environ.get("LANG", os.environ.get("LANGUAGE", os.environ.get('LC_TYPE')))  # type: ignore[arg-type]
        text_file(os_path(root, "/etc/systemd/system/zza.service"), F"""
            [Unit]
            Description=Testing A
            AssertEnvironment={enabled}={correct}
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), F"""
            [Unit]
            Description=Testing B
            ConditionEnvironment={enabled}={correct}
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        cmd = F"{systemctl} daemon-reload"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        #
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job"))
        if not real:
            self.assertFalse(greps(err, "AssertEnvironment - "))
        self.assertEqual(end, EXIT_SUCCESS)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job"))
        if not real:
            self.assertFalse(greps(err, "ConditionEnvironment - "))
        self.assertEqual(end, EXIT_SUCCESS)
        #
        cmd = F"{systemctl} stop zza.service zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.rm_zzfiles(root)
        self.rm_testdir()
    def real_21550_condition(self) -> None:
        self.test_21550_condition(True)
    def test_21550_condition(self, real: bool = False) -> None:
        """ check that file ConditionPathExistsGlob work"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        self.rm_zzfiles(root)
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            AssertPathExistsGlob=!/etc/sysconfig/zz*
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            ConditionPathExistsGlob=!/etc/sysconfig/zz*
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        cmd = F"{systemctl} daemon-reload"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} status zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertTrue(greps(out, "Loaded: loaded"))
        cmd = F"{systemctl} status zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertTrue(greps(out, "Loaded: loaded"))
        #
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job for zza.service"))
        if not real:
            self.assertFalse(greps(err, "AssertPathExistsGlob - "))
        self.assertEqual(end, EXIT_SUCCESS)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job"))
        if not real:
            self.assertFalse(greps(err, "ConditionPathExistsGlob - "))
        self.assertEqual(end, EXIT_SUCCESS)
        #
        text_file(os_path(root, "/etc/sysconfig/zza"), """allow=true""")
        text_file(os_path(root, "/etc/sysconfig/zzb"), """allow=true""")
        #
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        if not real and not TODO:
            self.assertTrue(greps(err, "Assertion failed on job for zza.service"))
        if not real:
            self.assertTrue(greps(err, "AssertPathExistsGlob - found 2 files"))
        if not real and not TODO:
            self.assertEqual(end, EXIT_FAILURE)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job"))
        if not real:
            self.assertTrue(greps(err, "ConditionPathExistsGlob - found 2 files"))
        self.assertEqual(end, EXIT_SUCCESS)
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
    def real_21551_condition(self) -> None:
        self.test_21511_condition(True)
    def test_21551_condition(self, real: bool = False) -> None:
        """ check that file ConditionPathExists work"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        self.rm_zzfiles(root)
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            AssertPathExists=!/etc/sysconfig/zza
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            ConditionPathExists=!/etc/sysconfig/zzb
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        cmd = F"{systemctl} daemon-reload"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} status zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertTrue(greps(out, "Loaded: loaded"))
        cmd = F"{systemctl} status zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertTrue(greps(out, "Loaded: loaded"))
        #
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job"))
        if not real:
            self.assertFalse(greps(err, "AssertPathExists - "))
        self.assertEqual(end, EXIT_SUCCESS)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job"))
        if not real:
            self.assertFalse(greps(err, "ConditionPathExists - "))
        self.assertEqual(end, EXIT_SUCCESS)
        #
        text_file(os_path(root, "/etc/sysconfig/zza"), """allow=true""")
        text_file(os_path(root, "/etc/sysconfig/zzb"), """allow=true""")
        #
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertTrue(greps(err, "Assertion failed on job for zza.service"))
        if not real:
            self.assertTrue(greps(err, "AssertPathExists - must not exist"))
        self.assertEqual(end, EXIT_FAILURE)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job"))
        if not real:
            self.assertTrue(greps(err, "ConditionPathExists - must not exist"))
        self.assertEqual(end, EXIT_SUCCESS)
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
    def real_21552_condition(self) -> None:
        self.test_21552_condition(True)
    def test_21552_condition(self, real: bool = False) -> None:
        """ check that file ConditionFileNotEmpty work"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        self.rm_zzfiles(root)
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            AssertFileNotEmpty=!/etc/sysconfig/zza
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            ConditionFileNotEmpty=!/etc/sysconfig/zzb
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        cmd = F"{systemctl} daemon-reload"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} status zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertTrue(greps(out, "Loaded: loaded"))
        cmd = F"{systemctl} status zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertTrue(greps(out, "Loaded: loaded"))
        #
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job"))
        if not real:
            self.assertFalse(greps(err, "AssertFileNotEmpty -"))
        self.assertEqual(end, EXIT_SUCCESS)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job"))
        if not real:
            self.assertFalse(greps(err, "ConditionFileNotEmpty - "))
        self.assertEqual(end, EXIT_SUCCESS)
        #
        text_file(os_path(root, "/etc/sysconfig/zza"), """allow=true""")
        text_file(os_path(root, "/etc/sysconfig/zzb"), """allow=true""")
        #
        cmd = F"{systemctl} stop zza.service zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertTrue(greps(err, "Assertion failed on job for zza.service"))
        if not real:
            self.assertTrue(greps(err, "AssertFileNotEmpty - file is not empty"))
        self.assertEqual(end, EXIT_FAILURE)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job"))
        if not real:
            self.assertTrue(greps(err, "ConditionFileNotEmpty - file is not empty"))
        self.assertEqual(end, EXIT_SUCCESS)
        #
        text_file(os_path(root, "/etc/sysconfig/zza"), "")
        text_file(os_path(root, "/etc/sysconfig/zzb"), "")
        #
        cmd = F"{systemctl} stop zza.service zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        if TODO:
            self.assertTrue(greps(err, "Assertion failed on job for zza.service"))
            if not real:
                self.assertTrue(greps(err, "AssertFileNotEmpty - path not found"))
            self.assertEqual(end, EXIT_FAILURE)
        else:
            self.assertEqual(end, EXIT_SUCCESS)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job"))
        if not real and TODO:
            self.assertTrue(greps(err, "ConditionFileNotEmpty - path not found"))
        self.assertEqual(end, EXIT_SUCCESS)
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
    def real_21553_condition(self) -> None:
        self.test_21553_condition(True)
    def test_21553_condition(self, real: bool = False) -> None:
        """ check that file ConditionPathIsReadWrite work"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        self.rm_zzfiles(root)
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            AssertPathIsReadWrite=!/etc/sysconfig/zza
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            ConditionPathIsReadWrite=!/etc/sysconfig/zzb
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        cmd = F"{systemctl} daemon-reload"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} status zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertTrue(greps(out, "Loaded: loaded"))
        cmd = F"{systemctl} status zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertTrue(greps(out, "Loaded: loaded"))
        #
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job"))
        if real:
            self.assertFalse(greps(err, "AssertPathIsReadWrite - "))
        self.assertEqual(end, EXIT_SUCCESS)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        if not real:
            self.assertFalse(greps(err, "ConditionPathIsReadWrite -"))
        self.assertEqual(end, EXIT_SUCCESS)
        #
        text_file(os_path(root, "/etc/sysconfig/zza"), """allow=true""")
        text_file(os_path(root, "/etc/sysconfig/zzb"), """allow=true""")
        #
        cmd = F"{systemctl} stop zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertTrue(greps(err, "Assertion failed on job for zza.service"))
        if not real:
            self.assertTrue(greps(err, "AssertPathIsReadWrite - is readwrite"))
        self.assertEqual(end, EXIT_FAILURE)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        if not real:
            self.assertTrue(greps(err, "ConditionPathIsReadWrite - is readwrite"))
        self.assertEqual(end, EXIT_SUCCESS)
        #
        os.chmod(os_path(root, "/etc/sysconfig/zza"), 0o400)
        os.chmod(os_path(root, "/etc/sysconfig/zzb"), 0o400)
        #
        cmd = F"{systemctl} stop zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        if real or TODO:
            self.assertTrue(greps(err, "Assertion failed on job for zza.service"))
        if not real and TODO:
            self.assertTrue(greps(err, "AssertPathIsReadWrite - not readable"))
        if real or TODO:
            self.assertEqual(end, EXIT_FAILURE)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        if not real and TODO:
            self.assertTrue(greps(err, "ConditionPathIsReadWrite - not readable"))
        self.assertEqual(end, EXIT_SUCCESS)
        #
        os.chmod(os_path(root, "/etc/sysconfig/zza"), 0o200)
        os.chmod(os_path(root, "/etc/sysconfig/zzb"), 0o200)
        #
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        if real or TODO:
            self.assertTrue(greps(err, "Assertion failed on job for zza.service"))
        if not real and TODO:
            self.assertTrue(greps(err, "AssertPathIsReadWrite - path not found"))
        if real or TODO:
            self.assertEqual(end, EXIT_FAILURE)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        if not real and TODO:
            self.assertTrue(greps(err, "ConditionPathIsReadWrite - path not found"))
        self.assertEqual(end, EXIT_SUCCESS)
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
    def real_21554_condition(self) -> None:
        self.test_21554_condition(True)
    def test_21554_condition(self, real: bool = False) -> None:
        """ check that file ConditionFileIsExecutable work"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        self.rm_zzfiles(root)
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            AssertFileIsExecutable=!/etc/sysconfig/zza
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            ConditionFileIsExecutable=!/etc/sysconfig/zzb
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        cmd = F"{systemctl} daemon-reload"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} status zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertTrue(greps(out, "Loaded: loaded"))
        cmd = F"{systemctl} status zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertTrue(greps(out, "Loaded: loaded"))
        #
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job"))
        if not real:
            self.assertFalse(greps(err, "AssertFileIsExecutable - "))
        self.assertEqual(end, EXIT_SUCCESS)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        if not real:
            self.assertFalse(greps(err, "ConditionFileIsExecutable - "))
        self.assertEqual(end, EXIT_SUCCESS)
        #
        text_file(os_path(root, "/etc/sysconfig/zza"), """#! /usr/bin/true""")
        text_file(os_path(root, "/etc/sysconfig/zzb"), """#! /usr/bin/true""")
        #
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job"))
        if not real:
            self.assertFalse(greps(err, "AssertFileIsExecutable - "))
        self.assertEqual(end, EXIT_SUCCESS)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        if not real:
            self.assertFalse(greps(err, "ConditionFileIsExecutable - "))
        self.assertEqual(end, EXIT_SUCCESS)
        #
        os.chmod(os_path(root, "/etc/sysconfig/zza"), 0o200)
        os.chmod(os_path(root, "/etc/sysconfig/zzb"), 0o200)
        #
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job"))
        if not real:
            self.assertFalse(greps(err, "AssertFileIsExecutable - "))
        self.assertEqual(end, EXIT_SUCCESS)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        if not real:
            self.assertFalse(greps(err, "ConditionFileIsExecutable - "))
        self.assertEqual(end, EXIT_SUCCESS)
        #
        os.chmod(os_path(root, "/etc/sysconfig/zza"), 0o400)
        os.chmod(os_path(root, "/etc/sysconfig/zzb"), 0o400)
        #
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job"))
        if not real:
            self.assertFalse(greps(err, "AssertFileIsExecutable - "))
        self.assertEqual(end, EXIT_SUCCESS)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        if not real:
            self.assertFalse(greps(err, "ConditionFileIsExecutable - "))
        self.assertEqual(end, EXIT_SUCCESS)
        #
        os.chmod(os_path(root, "/etc/sysconfig/zza"), 0o700)
        os.chmod(os_path(root, "/etc/sysconfig/zzb"), 0o700)
        #
        cmd = F"{systemctl} stop zza.service zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertTrue(greps(err, "Assertion failed on job for zza.service"))
        if not real:
            self.assertTrue(greps(err, "AssertFileIsExecutable - is executable"))
        self.assertEqual(end, EXIT_FAILURE)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        if not real:
            self.assertTrue(greps(err, "ConditionFileIsExecutable - is executable"))
        self.assertEqual(end, EXIT_SUCCESS)
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
    def real_21559_condition(self) -> None:
        self.test_21559_condition(True)
    def test_21559_condition(self, real: bool = False) -> None:
        """ check that file IsMountPoint work"""
        if inside_container():
            self.skipTest("does not work in container")
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        self.rm_zzfiles(root)
        text_file(os_path(root, "/etc/systemd/system/zza.service"), F"""
            [Unit]
            Description=Testing A
            AssertPathIsMountPoint=!/etc/sysconfig/zza
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), F"""
            [Unit]
            Description=Testing B
            ConditionPathIsMountPoint=!/etc/sysconfig/zza
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        cmd = F"{systemctl} daemon-reload"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} status zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertTrue(greps(out, "Loaded: loaded"))
        cmd = F"{systemctl} status zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertTrue(greps(out, "Loaded: loaded"))
        #
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job"))
        if not real:
            self.assertFalse(greps(err, "AssertPathIsMountPoint - "))
        self.assertEqual(end, EXIT_SUCCESS)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job"))
        if not real:
            self.assertFalse(greps(err, "ConditionPathIsMountPoint - "))
        self.assertEqual(end, EXIT_SUCCESS)
        #
        text_file(os_path(root, "/etc/sysconfig/zza"), """allow=true""")
        text_file(os_path(root, "/etc/sysconfig/zzb"), """allow=true""")
        #
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job f"))
        if not real:
            self.assertFalse(greps(err, "AssertPathIsMountPoint - "))
        self.assertEqual(end, EXIT_SUCCESS)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job"))
        if not real:
            self.assertFalse(greps(err, "ConditionPathIsMountPoint - "))
        self.assertEqual(end, EXIT_SUCCESS)
        #
        text_file(os_path(root, "/etc/systemd/system/zza.service"), F"""
            [Unit]
            Description=Testing A
            AssertPathIsMountPoint=!//run
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), F"""
            [Unit]
            Description=Testing B
            ConditionPathIsMountPoint=!//run
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        #
        cmd = F"{systemctl} daemon-reload"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} stop zza.service zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertTrue(greps(err, "Assertion failed on job for zza.service"))
        if not real:
            self.assertTrue(greps(err, "AssertPathIsMountPoint - is a mount point"))
        self.assertEqual(end, EXIT_FAILURE)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job"))
        if not real:
            self.assertTrue(greps(err, "ConditionPathIsMountPoint - is a mount point"))
        self.assertEqual(end, EXIT_SUCCESS)
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
    def real_21561_condition(self) -> None:
        self.test_21561_condition(True)
    def test_21561_condition(self, real: bool = False) -> None:
        """ check that file ConditionPathIsSymbolicLink work"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        self.rm_zzfiles(root)
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            AssertPathIsSymbolicLink=!/etc/sysconfig/zza
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            ConditionPathIsSymbolicLink=!/etc/sysconfig/zzb
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        cmd = F"{systemctl} daemon-reload"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} status zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertTrue(greps(out, "Loaded: loaded"))
        cmd = F"{systemctl} status zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertTrue(greps(out, "Loaded: loaded"))
        #
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job"))
        if not real:
            self.assertFalse(greps(err, "AssertPathIsSymbolicLink - "))
        self.assertEqual(end, EXIT_SUCCESS)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        if not real:
            self.assertFalse(greps(err, "ConditionPathIsSymbolicLink - "))
        self.assertEqual(end, EXIT_SUCCESS)
        #
        text_file(os_path(root, "/etc/sysconfig/zza"), """#! /usr/bin/true""")
        text_file(os_path(root, "/etc/sysconfig/zzb"), """#! /usr/bin/true""")
        #
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job "))
        if not real:
            self.assertFalse(greps(err, "AssertPathIsSymbolicLink - "))
        self.assertEqual(end, EXIT_SUCCESS)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        if not real:
            self.assertFalse(greps(err, "ConditionPathIsSymbolicLink - "))
        self.assertEqual(end, EXIT_SUCCESS)
        #
        os.unlink(os_path(root, "/etc/sysconfig/zza"))
        os.unlink(os_path(root, "/etc/sysconfig/zzb"))
        text_file(os_path(root, "/etc/sysconfig/zzax"), """#! /usr/bin/true""")
        text_file(os_path(root, "/etc/sysconfig/zzbx"), """#! /usr/bin/true""")
        os.symlink(os_path(root, "/etc/sysconfig/zzbx"), os_path(root, "/etc/sysconfig/zza"))
        os.symlink(os_path(root, "/etc/sysconfig/zzbx"), os_path(root, "/etc/sysconfig/zzb"))
        #
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        if real or TODO:
            self.assertFalse(greps(err, "Assertion failed on job"))
        if not real:
            self.assertTrue(greps(err, "AssertPathIsSymbolicLink - not a symbolic link"))
        if real or TODO:
            self.assertEqual(end, EXIT_SUCCESS)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        if not real:
            self.assertTrue(greps(err, "ConditionPathIsSymbolicLink - not a symbolic link"))
        self.assertEqual(end, EXIT_SUCCESS)
        #
        os.unlink(os_path(root, "/etc/sysconfig/zzax"))
        os.unlink(os_path(root, "/etc/sysconfig/zzbx"))
        #
        cmd = F"{systemctl} stop zza.service zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        if real or TODO:
            self.assertTrue(greps(err, "Assertion failed on job for zza.service"))
        if not real:
            self.assertFalse(greps(err, "AssertPathIsSymbolicLink - "))
        if real or TODO:
            self.assertEqual(end, EXIT_FAILURE)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        if not real:
            self.assertFalse(greps(err, "ConditionPathIsSymbolicLink - "))
        self.assertEqual(end, EXIT_SUCCESS)
        #
        os.mkdir(os_path(root, "/etc/sysconfig/zzax"))
        os.mkdir(os_path(root, "/etc/sysconfig/zzbx"))
        #
        cmd = F"{systemctl} stop zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertTrue(greps(err, "Assertion failed on job for zza.service"))
        if not real:
            self.assertTrue(greps(err, "AssertPathIsSymbolicLink - not a symbolic link"))
        self.assertEqual(end, EXIT_FAILURE)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        if not real:
            self.assertTrue(greps(err, "ConditionPathIsSymbolicLink - not a symbolic link"))
        self.assertEqual(end, EXIT_SUCCESS)
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
    def real_21562_condition(self) -> None:
        self.test_21562_condition(True)
    def test_21562_condition(self, real: bool = False) -> None:
        """ check that file conditions work"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        self.rm_zzfiles(root)
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            AssertPathIsDirectory=!/etc/sysconfig/zza
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            ConditionPathIsDirectory=!/etc/sysconfig/zzb
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        cmd = F"{systemctl} daemon-reload"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} status zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertTrue(greps(out, "Loaded: loaded"))
        cmd = F"{systemctl} status zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertTrue(greps(out, "Loaded: loaded"))
        #
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job"))
        if not real:
            self.assertFalse(greps(err, "AssertPathIsDirectory - "))
        self.assertEqual(end, EXIT_SUCCESS)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        if not real:
            self.assertFalse(greps(err, "ConditionPathIsDirectory - "))
        self.assertEqual(end, EXIT_SUCCESS)
        #
        text_file(os_path(root, "/etc/sysconfig/zza"), """#! /usr/bin/true""")
        text_file(os_path(root, "/etc/sysconfig/zzb"), """#! /usr/bin/true""")
        #
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job"))
        if not real:
            self.assertFalse(greps(err, "AssertPathIsDirectory - "))
        self.assertEqual(end, EXIT_SUCCESS)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        if not real:
            self.assertFalse(greps(err, "ConditionPathIsDirectory - "))
        self.assertEqual(end, EXIT_SUCCESS)
        #
        os.unlink(os_path(root, "/etc/sysconfig/zza"))
        os.unlink(os_path(root, "/etc/sysconfig/zzb"))
        text_file(os_path(root, "/etc/sysconfig/zzax"), """#! /usr/bin/true""")
        text_file(os_path(root, "/etc/sysconfig/zzbx"), """#! /usr/bin/true""")
        os.symlink(os_path(root, "/etc/sysconfig/zzbx"), os_path(root, "/etc/sysconfig/zza"))
        os.symlink(os_path(root, "/etc/sysconfig/zzbx"), os_path(root, "/etc/sysconfig/zzb"))
        #
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job"))
        if not real:
            self.assertFalse(greps(err, "AssertPathIsDirectory - "))
        self.assertEqual(end, EXIT_SUCCESS)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        if not real:
            self.assertFalse(greps(err, "ConditionPathIsDirectory - "))
        self.assertEqual(end, EXIT_SUCCESS)
        #
        os.unlink(os_path(root, "/etc/sysconfig/zzax"))
        os.unlink(os_path(root, "/etc/sysconfig/zzbx"))
        os.mkdir(os_path(root, "/etc/sysconfig/zzax"))
        os.mkdir(os_path(root, "/etc/sysconfig/zzbx"))
        #
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertTrue(greps(err, "Assertion failed on job for zza.service"))
        if not real:
            self.assertTrue(greps(err, "AssertPathIsDirectory - is a directory"))
        self.assertEqual(end, EXIT_FAILURE)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        if not real:
            self.assertTrue(greps(err, "ConditionPathIsDirectory - is a directory"))
        self.assertEqual(end, EXIT_SUCCESS)
        #
        os.unlink(os_path(root, "/etc/sysconfig/zza"))
        os.unlink(os_path(root, "/etc/sysconfig/zzb"))
        os.mkdir(os_path(root, "/etc/sysconfig/zza"))
        os.mkdir(os_path(root, "/etc/sysconfig/zzb"))
        #
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertTrue(greps(err, "Assertion failed on job for zza.service"))
        if not real:
            self.assertTrue(greps(err, "AssertPathIsDirectory - is a directory"))
        self.assertEqual(end, EXIT_FAILURE)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        if not real:
            self.assertTrue(greps(err, "ConditionPathIsDirectory - is a directory"))
        self.assertEqual(end, EXIT_SUCCESS)
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
    def real_21563_condition(self) -> None:
        self.test_21563_condition(True)
    def test_21563_condition(self, real: bool = False) -> None:
        """ check that file ConditionDirectoryNotEmpty work"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        self.rm_zzfiles(root)
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            AssertDirectoryNotEmpty=!/etc/sysconfig/zza
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            ConditionDirectoryNotEmpty=!/etc/sysconfig/zzb
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        cmd = F"{systemctl} daemon-reload"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} status zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertTrue(greps(out, "Loaded: loaded"))
        cmd = F"{systemctl} status zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertTrue(greps(out, "Loaded: loaded"))
        #
        cmd = F"{systemctl} stop zza.service zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job"))
        if not real:
            self.assertFalse(greps(err, "AssertDirectoryNotEmpty - "))
        self.assertEqual(end, EXIT_SUCCESS)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        if not real:
            self.assertFalse(greps(err, "ConditionDirectoryNotEmpty -"))
        self.assertEqual(end, EXIT_SUCCESS)
        #
        text_file(os_path(root, "/etc/sysconfig/zza"), """#! /usr/bin/true""")
        text_file(os_path(root, "/etc/sysconfig/zzb"), """#! /usr/bin/true""")
        #
        cmd = F"{systemctl} stop zza.service zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job"))
        if not real:
            self.assertFalse(greps(err, "AssertDirectoryNotEmpty - "))
        self.assertEqual(end, EXIT_SUCCESS)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        if not real:
            self.assertFalse(greps(err, "ConditionDirectoryNotEmpty - "))
        self.assertEqual(end, EXIT_SUCCESS)
        #
        os.unlink(os_path(root, "/etc/sysconfig/zza"))
        os.unlink(os_path(root, "/etc/sysconfig/zzb"))
        text_file(os_path(root, "/etc/sysconfig/zzax"), """#! /usr/bin/true""")
        text_file(os_path(root, "/etc/sysconfig/zzbx"), """#! /usr/bin/true""")
        os.symlink(os_path(root, "/etc/sysconfig/zzbx"), os_path(root, "/etc/sysconfig/zza"))
        os.symlink(os_path(root, "/etc/sysconfig/zzbx"), os_path(root, "/etc/sysconfig/zzb"))
        #
        cmd = F"{systemctl} stop zza.service zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job"))
        if not real:
            self.assertFalse(greps(err, "AssertDirectoryNotEmpty - "))
        self.assertEqual(end, EXIT_SUCCESS)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        if not real:
            self.assertFalse(greps(err, "ConditionDirectoryNotEmpty - "))
        self.assertEqual(end, EXIT_SUCCESS)
        #
        os.unlink(os_path(root, "/etc/sysconfig/zzax"))
        os.unlink(os_path(root, "/etc/sysconfig/zzbx"))
        os.mkdir(os_path(root, "/etc/sysconfig/zzax"))
        os.mkdir(os_path(root, "/etc/sysconfig/zzbx"))
        #
        cmd = F"{systemctl} stop zza.service zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job"))
        if not real:
            self.assertFalse(greps(err, "AssertDirectoryNotEmpty - "))
        self.assertEqual(end, EXIT_SUCCESS)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        if not real:
            self.assertFalse(greps(err, "ConditionDirectoryNotEmpty - "))
        self.assertEqual(end, EXIT_SUCCESS)
        #
        text_file(os_path(root, "/etc/sysconfig/zzax/zz1"), """#! /usr/bin/true""")
        text_file(os_path(root, "/etc/sysconfig/zzbx/zz1"), """#! /usr/bin/true""")
        #
        cmd = F"{systemctl} stop zza.service zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertTrue(greps(err, "Assertion failed on job for zza.service"))
        if not real:
            self.assertTrue(greps(err, "AssertDirectoryNotEmpty - directory is not empty"))
        self.assertEqual(end, EXIT_FAILURE)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        if not real:
            self.assertTrue(greps(err, "ConditionDirectoryNotEmpty - directory is not empty"))
        self.assertEqual(end, EXIT_SUCCESS)
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
    def real_21571_condition(self) -> None:
        self.test_21571_condition(True)
    def test_21571_condition(self, real: bool = False) -> None:
        """ check that file ConditionArchitecture work"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        self.rm_zzfiles(root)
        import platform
        existing = platform.machine().replace("_", "-")
        unwanted = "mechanical-turk"
        text_file(os_path(root, "/etc/systemd/system/zza.service"), F"""
            [Unit]
            Description=Testing A
            AssertArchitecture=!{unwanted}
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), F"""
            [Unit]
            Description=Testing B
            ConditionArchitecture=!{unwanted}
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        cmd = F"{systemctl} daemon-reload"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} status zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertTrue(greps(out, "Loaded: loaded"))
        cmd = F"{systemctl} status zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertTrue(greps(out, "Loaded: loaded"))
        #
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job"))
        if not real:
            self.assertFalse(greps(err, F"AssertArchitecture - "))
        self.assertEqual(end, EXIT_SUCCESS)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job"))
        if not real:
            self.assertFalse(greps(err, F"ConditionArchitecture - "))
        self.assertEqual(end, EXIT_SUCCESS)
        #
        text_file(os_path(root, "/etc/systemd/system/zza.service"), F"""
            [Unit]
            Description=Testing A
            AssertArchitecture=!{existing}
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), F"""
            [Unit]
            Description=Testing B
            ConditionArchitecture=!{existing}
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        cmd = F"{systemctl} daemon-reload"
        out, end = output2(cmd)
        #
        cmd = F"{systemctl} start zza.service zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertTrue(greps(err, "Assertion failed on job for zza.service"))
        if not real:
            self.assertTrue(greps(err, F"AssertArchitecture - avoid {existing} - have {existing}"))
        self.assertEqual(end, EXIT_FAILURE)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job"))
        if not real:
            self.assertTrue(greps(err, F"ConditionArchitecture - avoid {existing} - have {existing}"))
        self.assertEqual(end, EXIT_SUCCESS)
        self.rm_zzfiles(root)
        self.rm_testdir()
    def real_21572_condition(self) -> None:
        self.test_21572_condition(True)
    def test_21572_condition(self, real: bool = False) -> None:
        """ check that file ConditionHost work"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        self.rm_zzfiles(root)
        import platform
        existing = platform.node()
        unwanted = "test1.example.com"
        text_file(os_path(root, "/etc/systemd/system/zza.service"), F"""
            [Unit]
            Description=Testing A
            AssertHost=!{unwanted}
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), F"""
            [Unit]
            Description=Testing B
            ConditionHost=!{unwanted}
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        cmd = F"{systemctl} daemon-reload"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} status zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertTrue(greps(out, "Loaded: loaded"))
        cmd = F"{systemctl} status zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertTrue(greps(out, "Loaded: loaded"))
        #
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job"))
        if not real:
            self.assertFalse(greps(err, "AssertHost - "))
        self.assertEqual(end, EXIT_SUCCESS)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job"))
        if not real:
            self.assertFalse(greps(err, F"ConditionHost - "))
        self.assertEqual(end, EXIT_SUCCESS)
        #
        text_file(os_path(root, "/etc/systemd/system/zza.service"), F"""
            [Unit]
            Description=Testing A
            AssertHost=!{existing}
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), F"""
            [Unit]
            Description=Testing B
            ConditionHost=!{existing}
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        cmd = F"{systemctl} daemon-reload"
        out, end = output2(cmd)
       #
        cmd = F"{systemctl} stop zza.service zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertTrue(greps(err, "Assertion failed on job for zza.service"))
        if not real:
            self.assertTrue(greps(err, F"AssertHost - avoid {existing} - have {existing}"))
        self.assertEqual(end, EXIT_FAILURE)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job"))
        if not real:
            self.assertTrue(greps(err, F"ConditionHost - avoid {existing} - have {existing}"))
        self.assertEqual(end, EXIT_SUCCESS)
        self.rm_zzfiles(root)
        self.rm_testdir()
    def real_21581_condition(self) -> None:
        self.test_21581_condition(True)
    def test_21581_condition(self, real: bool = False) -> None:
        """ check that file ConditionEnvironment work"""
        if inside_container():
            self.skipTest("does not work in container")
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        self.rm_zzfiles(root)
        enabled = "LANG"
        blocked = "BLOCKED"
        text_file(os_path(root, "/etc/systemd/system/zza.service"), F"""
            [Unit]
            Description=Testing A
            AssertEnvironment=!{blocked}
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), F"""
            [Unit]
            Description=Testing B
            ConditionEnvironment=!{blocked}
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        cmd = F"{systemctl} daemon-reload"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} status zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertTrue(greps(out, "Loaded: loaded"))
        cmd = F"{systemctl} status zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertTrue(greps(out, "Loaded: loaded"))
        #
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        self.assertFalse(greps(err, "Assertion failed on job"))
        if not real:
            self.assertFalse(greps(err, "AssertEnvironment - "))
        self.assertEqual(end, EXIT_SUCCESS)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job"))
        if not real:
            self.assertFalse(greps(err, F"ConditionEnvironment - "))
        self.assertEqual(end, EXIT_SUCCESS)
        #
        text_file(os_path(root, "/etc/systemd/system/zza.service"), F"""
            [Unit]
            Description=Testing A
            AssertEnvironment=!{enabled}
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), F"""
            [Unit]
            Description=Testing B
            ConditionEnvironment=!{enabled}
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        cmd = F"{systemctl} daemon-reload"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        #
        cmd = F"{systemctl} stop zza.service zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertTrue(greps(err, "Assertion failed on job for zza.service"))
        if not real:
            self.assertTrue(greps(err, F"AssertEnvironment - \\${enabled} was found"))
        self.assertEqual(end, EXIT_FAILURE)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job"))
        if not real:
            self.assertTrue(greps(err, F"ConditionEnvironment - \\${enabled} was found"))
        self.assertEqual(end, EXIT_SUCCESS)
        #
        cmd = F"{systemctl} stop zza.service zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.rm_zzfiles(root)
        self.rm_testdir()
    def real_21582_condition(self) -> None:
        self.test_21582_condition(True)
    def test_21582_condition(self, real: bool = False) -> None:
        """ check that file ConditionEnvironment work"""
        if inside_container():
            self.skipTest("does not work in container")
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        self.rm_zzfiles(root)
        enabled = "LANG"
        blocked = "BLOCKED"
        text_file(os_path(root, "/etc/systemd/system/zza.service"), F"""
            [Unit]
            Description=Testing A
            AssertEnvironment=!{blocked}=ok
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), F"""
            [Unit]
            Description=Testing B
            ConditionEnvironment=!{blocked}=ok
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        cmd = F"{systemctl} daemon-reload"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} status zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertTrue(greps(out, "Loaded: loaded"))
        cmd = F"{systemctl} status zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertTrue(greps(out, "Loaded: loaded"))
        #
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job"))
        if not real:
            self.assertFalse(greps(err, "AssertEnvironment - "))
        self.assertEqual(end, EXIT_SUCCESS)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job"))
        if not real:
            self.assertFalse(greps(err, F"ConditionEnvironment - "))
        self.assertEqual(end, EXIT_SUCCESS)
        #
        text_file(os_path(root, "/etc/systemd/system/zza.service"), F"""
            [Unit]
            Description=Testing A
            AssertEnvironment=!{enabled}=ok
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), F"""
            [Unit]
            Description=Testing B
            ConditionEnvironment=!{enabled}=ok
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        cmd = F"{systemctl} daemon-reload"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        #
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job"))
        if not real:
            self.assertFalse(greps(err, F"AssertEnvironment - "))
        self.assertEqual(end, EXIT_SUCCESS)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job"))
        if not real:
            self.assertFalse(greps(err, F"ConditionEnvironment - "))
        self.assertEqual(end, EXIT_SUCCESS)
        #
        cmd = F"{systemctl} show-environment {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        correct="no"
        for line in out.splitlines():
            logg.info("     env %s", line.rstrip())
            if line.startswith(F"{enabled}="):
                correct = line.split("=", 1)[1].rstrip()
                break
        if correct in ['C']:
            if not TODO:
                logg.warning("LANG was found to be '%s' - but that's not being evaluated later", correct)
                correct=os.environ.get("LANG", os.environ.get("LANGUAGE", os.environ.get('LC_TYPE')))  # type: ignore[arg-type]
        text_file(os_path(root, "/etc/systemd/system/zza.service"), F"""
            [Unit]
            Description=Testing A
            AssertEnvironment=!{enabled}={correct}
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), F"""
            [Unit]
            Description=Testing B
            ConditionEnvironment=!{enabled}={correct}
            [Service]
            Type=simple
            ExecStart=/usr/bin/sleep 1
            [Install]
            WantedBy=multi-user.target""")
        cmd = F"{systemctl} daemon-reload"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        #
        cmd = F"{systemctl} stop zza.service zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertTrue(greps(err, "Assertion failed on job for zza.service"))
        if not real:
            self.assertTrue(greps(err, F"AssertEnvironment - \\${enabled} wrong value - avoid '{correct}'"))
        self.assertEqual(end, EXIT_FAILURE)
        cmd = F"{systemctl} start zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertFalse(greps(err, "Assertion failed on job"))
        if not real:
            self.assertTrue(greps(err, F"ConditionEnvironment - \\${enabled} wrong value - avoid '{correct}'"))
        self.assertEqual(end, EXIT_SUCCESS)
        #
        cmd = F"{systemctl} stop zza.service zzb.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.rm_zzfiles(root)
        self.rm_testdir()

    #
    #
    def test_22001_can_create_test_services(self) -> None:
        """ check that two unit files can be created for testing """
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B""")
        textA = reads(os_path(root, "/etc/systemd/system/zza.service"))
        textB = reads(os_path(root, "/etc/systemd/system/zzb.service"))
        self.assertTrue(greps(textA, "Testing A"))
        self.assertTrue(greps(textB, "Testing B"))
        self.assertIn("\nDescription", textA)
        self.assertIn("\nDescription", textB)
        self.rm_testdir()
        self.coverage()
    def test_22002_list_units(self) -> None:
        """ check that two unit files can be found for 'list-units' """
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B""")
        cmd = F"{systemctl} list-units"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"zza.service\s+loaded inactive dead\s+.*Testing A"))
        self.assertTrue(greps(out, r"zzb.service\s+loaded inactive dead\s+.*Testing B"))
        self.assertIn("loaded units listed.", out)
        self.assertIn("To show all installed unit files use", out)
        self.assertEqual(len(lines4(out)), 5)
        cmd = F"{systemctl} --no-legend list-units"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"zza.service\s+loaded inactive dead\s+.*Testing A"))
        self.assertTrue(greps(out, r"zzb.service\s+loaded inactive dead\s+.*Testing B"))
        self.assertNotIn("loaded units listed.", out)
        self.assertNotIn("To show all installed unit files use", out)
        self.assertEqual(len(lines4(out)), 2)
        self.rm_testdir()
        self.coverage()
    def test_22003_list_unit_files(self) -> None:
        """ check that two unit service files can be found for 'list-unit-files' """
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B""")
        cmd = F"{systemctl} --type=service list-unit-files"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"zza.service\s+static"))
        self.assertTrue(greps(out, r"zzb.service\s+static"))
        self.assertIn("unit files listed.", out)
        self.assertEqual(len(lines4(out)), 5)
        cmd = F"{systemctl} --no-legend --type=service list-unit-files"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"zza.service\s+static"))
        self.assertTrue(greps(out, r"zzb.service\s+static"))
        self.assertNotIn("unit files listed.", out)
        self.assertEqual(len(lines4(out)), 2)
        self.rm_testdir()
        self.coverage()
    def test_22004_list_unit_files_wanted(self) -> None:
        """ check that two unit files can be found for 'list-unit-files'
            with an enabled status """
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Install]
            WantedBy=multi-user.target""")
        cmd = F"{systemctl} --type=service list-unit-files"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"zza.service\s+static"))
        self.assertTrue(greps(out, r"zzb.service\s+disabled"))
        self.assertIn("unit files listed.", out)
        self.assertEqual(len(lines4(out)), 5)
        cmd = F"{systemctl} --no-legend --type=service list-unit-files"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"zza.service\s+static"))
        self.assertTrue(greps(out, r"zzb.service\s+disabled"))
        self.assertNotIn("unit files listed.", out)
        self.assertEqual(len(lines4(out)), 2)
        self.rm_testdir()
        self.coverage()
    def test_22006_list_unit_files_wanted_and_unknown_type(self) -> None:
        """ check that two unit files can be found for 'list-unit-files'
            with an enabled status plus handling unkonwn services"""
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Install]
            WantedBy=multi-user.target""")
        cmd = F"{systemctl} --type=foo list-unit-files"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertIn("0 unit files listed.", out)
        self.assertEqual(len(lines4(out)), 3)
        self.rm_testdir()
        self.coverage()
    def test_22008_list_unit_files_locations(self) -> None:
        """ check that unit files can be found for 'list-unit-files'
            in different standard locations on disk. """
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/usr/lib/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/lib/systemd/system/zzc.service"), """
            [Unit]
            Description=Testing C
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/var/run/systemd/system/zzd.service"), """
            [Unit]
            Description=Testing D
            [Install]
            WantedBy=multi-user.target""")
        cmd = F"{systemctl} --type=service list-unit-files"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"zza.service\s+disabled"))
        self.assertTrue(greps(out, r"zzb.service\s+disabled"))
        self.assertTrue(greps(out, r"zzc.service\s+disabled"))
        self.assertTrue(greps(out, r"zzd.service\s+disabled"))
        self.assertIn("4 unit files listed.", out)
        self.assertEqual(len(lines4(out)), 7)
        #
        cmd = F"{systemctl} enable zza.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} enable zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} enable zzc.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} enable zzd.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} --type=service list-unit-files"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"zza.service\s+enabled"))
        self.assertTrue(greps(out, r"zzb.service\s+enabled"))
        self.assertTrue(greps(out, r"zzc.service\s+enabled"))
        self.assertTrue(greps(out, r"zzd.service\s+enabled"))
        self.assertIn("4 unit files listed.", out)
        self.assertEqual(len(lines4(out)), 7)
        #
        self.rm_testdir()
        self.coverage()
    def test_22010_list_unit_files_locations_user_mode(self) -> None:
        """ check that unit files can be found for 'list-unit-files'
            in different standard locations on disk for --user mode """
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/usr/lib/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/lib/systemd/system/zzc.service"), """
            [Unit]
            Description=Testing C
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/var/run/systemd/system/zzd.service"), """
            [Unit]
            Description=Testing D
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/user/zzu.service"), """
            [Unit]
            Description=Testing U
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/usr/lib/systemd/user/zzv.service"), """
            [Unit]
            Description=Testing V
            [Install]
            WantedBy=multi-user.target""")
        cmd = F"{systemctl} --type=service list-unit-files --user"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertFalse(greps(out, r"zza.service\s+disabled"))
        self.assertFalse(greps(out, r"zzb.service\s+disabled"))
        self.assertFalse(greps(out, r"zzc.service\s+disabled"))
        self.assertFalse(greps(out, r"zzd.service\s+disabled"))
        self.assertTrue(greps(out, r"zzu.service\s+disabled"))
        self.assertTrue(greps(out, r"zzv.service\s+disabled"))
        self.assertIn("2 unit files listed.", out)
        self.assertEqual(len(lines4(out)), 5)
        #
        cmd = F"{systemctl} enable zza.service --user -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        cmd = F"{systemctl} enable zzb.service --user -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        cmd = F"{systemctl} enable zzu.service --user"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} enable zzv.service --user"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} --type=service list-unit-files --user"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"zzu.service\s+enabled"))
        self.assertTrue(greps(out, r"zzv.service\s+enabled"))
        self.assertIn("2 unit files listed.", out)
        self.assertEqual(len(lines4(out)), 5)
        #
        self.rm_testdir()
        self.coverage()
    def test_22014_list_unit_files_locations_user_extra(self) -> None:
        """ check that unit files can be found for 'list-unit-files'
            in different standard locations on disk for --user mode
            with some system files to be pinned on our user. """
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        user = self.user()
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            User={user}
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/usr/lib/systemd/system/zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Sevice]
            User={user}
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/lib/systemd/system/zzc.service"), F"""
            [Unit]
            Description=Testing C
            [Sevice]
            User={user}
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/var/run/systemd/system/zzd.service"), F"""
            [Unit]
            Description=Testing D
            [Sevice]
            User={user}
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/user/zzu.service"), """
            [Unit]
            Description=Testing U
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/usr/lib/systemd/user/zzv.service"), """
            [Unit]
            Description=Testing V
            [Install]
            WantedBy=multi-user.target""")
        cmd = F"{systemctl} --type=service list-unit-files --user"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"zza.service\s+disabled"))
        self.assertFalse(greps(out, r"zzb.service\s+disabled"))
        self.assertFalse(greps(out, r"zzc.service\s+disabled"))
        self.assertFalse(greps(out, r"zzd.service\s+disabled"))
        self.assertTrue(greps(out, r"zzu.service\s+disabled"))
        self.assertTrue(greps(out, r"zzv.service\s+disabled"))
        self.assertIn("3 unit files listed.", out)
        self.assertEqual(len(lines4(out)), 6)
        #
        cmd = F"{systemctl} enable zza.service --user -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} enable zzb.service --user -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        cmd = F"{systemctl} enable zzu.service --user"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} enable zzv.service --user"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} --type=service list-unit-files --user"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"zza.service\s+enabled"))
        self.assertTrue(greps(out, r"zzu.service\s+enabled"))
        self.assertTrue(greps(out, r"zzv.service\s+enabled"))
        self.assertIn("3 unit files listed.", out)
        self.assertEqual(len(lines4(out)), 6)
        #
        logg.info("enabled services for User=%s", user)
        self.rm_testdir()
        self.coverage()
    def test_22043_list_unit_files_common_targets(self) -> None:
        """ check that some unit target files can be found for 'list-unit-files' """
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B""")
        cmd = F"{systemctl} --no-legend --type=service list-unit-files"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"zza.service\s+static"))
        self.assertTrue(greps(out, r"zzb.service\s+static"))
        self.assertFalse(greps(out, r"multi-user.target\s+enabled"))
        self.assertEqual(len(lines4(out)), 2)
        cmd = F"{systemctl} --no-legend --type=target list-unit-files"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertFalse(greps(out, r"zza.service\s+static"))
        self.assertFalse(greps(out, r"zzb.service\s+static"))
        self.assertTrue(greps(out, r"multi-user.target\s+enabled"))
        self.assertGreater(len(lines4(out)), 10)
        num_targets = len(lines4(out))
        cmd = F"{systemctl} --no-legend list-unit-files"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"zza.service\s+static"))
        self.assertTrue(greps(out, r"zzb.service\s+static"))
        self.assertTrue(greps(out, r"multi-user.target\s+enabled"))
        self.assertEqual(len(lines4(out)), num_targets + 2)
        self.rm_testdir()
        self.coverage()
    def test_22044_list_unit_files_now(self) -> None:
        """ check that 'list-unit-files --now' presents a special debug list """
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B""")
        cmd = F"{systemctl} --no-legend --now list-unit-files"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"zza.service\s+SysD\s+.*systemd/system/zza.service"))
        self.assertTrue(greps(out, r"zzb.service\s+SysD\s+.*systemd/system/zzb.service"))
        self.assertFalse(greps(out, r"multi-user.target"))
        self.assertFalse(greps(out, r"enabled"))
        self.assertEqual(len(lines4(out)), 2)
        self.rm_testdir()
        self.coverage()
    def test_22140_show_environment_from_parts(self) -> None:
        """ check that the result of 'environment UNIT' can
            list the settings from different locations."""
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/sysconfig/zzb.conf"), """
            DEF1='def1'
            DEF2="def2"
            DEF3=def3
            """)
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            EnvironmentFile=/etc/sysconfig/zzb.conf
            Environment=DEF5=def5
            Environment=DEF6=def6
            ExecStart=/usr/bin/printf $DEF1 $DEF2 \
                                $DEF3 $DEF4 $DEF5
            [Install]
            WantedBy=multi-user.target""")
        cmd = F"{systemctl} environment zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"^DEF1=def1"))
        self.assertTrue(greps(out, r"^DEF2=def2"))
        self.assertTrue(greps(out, r"^DEF3=def3"))
        self.assertFalse(greps(out, r"^DEF4=def4"))
        self.assertTrue(greps(out, r"^DEF5=def5"))
        self.assertTrue(greps(out, r"^DEF6=def6"))
        self.assertFalse(greps(out, r"^DEF7=def7"))
        a_lines = len(lines4(out))
        #
        self.rm_testdir()
        self.coverage()
    def real_22147_show_environment_from_some_parts(self) -> None:
        self.test_22147_show_environment_from_some_parts(True)
    def test_22147_show_environment_from_some_parts(self, real: bool = False) -> None:
        """ check that the result of 'environment UNIT' can
            list the settings from different locations."""
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: systemctl = "/usr/bin/systemctl"
        text_file(os_path(root, "/etc/sysconfig/zzb.conf"), """
            DEF1='def1'
            DEF2="def2"
            DEF3=def3
            """)
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            EnvironmentFile=/etc/sysconfig/zzb.conf
            EnvironmentFile=-/etc/sysconfig/zz-not-existant.conf
            Environment=DEF5=def5
            Environment=DEF6=def6
            ExecStart=/usr/bin/printf $DEF1 $DEF2 \
                                $DEF3 $DEF4 $DEF5
            [Install]
            WantedBy=multi-user.target""")
        cmd = F"{systemctl} environment zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"^DEF1=def1"))
        self.assertTrue(greps(out, r"^DEF2=def2"))
        self.assertTrue(greps(out, r"^DEF3=def3"))
        self.assertFalse(greps(out, r"^DEF4=def4"))
        self.assertTrue(greps(out, r"^DEF5=def5"))
        self.assertTrue(greps(out, r"^DEF6=def6"))
        self.assertFalse(greps(out, r"^DEF7=def7"))
        a_lines = len(lines4(out))
        #
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
    def real_22148_show_environment_from_some_bad_parts(self) -> None:
        self.test_22148_show_environment_from_some_bad_parts(True)
    def test_22148_show_environment_from_some_bad_parts(self, real: bool = False) -> None:
        """ check that the result of 'environment UNIT' can
            list the settings from different locations."""
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: systemctl = "/usr/bin/systemctl"
        text_file(os_path(root, "/etc/sysconfig/zzb.conf"), """
            DEF1='def1'
            DEF2="def2"
            DEF3=def3
            """)
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            EnvironmentFile=/etc/sysconfig/zzb.conf
            EnvironmentFile=/etc/sysconfig/zz-not-existant.conf
            Environment=DEF5=def5
            Environment=DEF6=def6
            ExecStart=/usr/bin/printf $DEF1 $DEF2 \
                                $DEF3 $DEF4 $DEF5
            [Install]
            WantedBy=multi-user.target""")
        cmd = F"{systemctl} environment zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"^DEF1=def1"))
        self.assertTrue(greps(out, r"^DEF2=def2"))
        self.assertTrue(greps(out, r"^DEF3=def3"))
        self.assertFalse(greps(out, r"^DEF4=def4"))
        self.assertTrue(greps(out, r"^DEF5=def5"))
        self.assertTrue(greps(out, r"^DEF6=def6"))
        self.assertFalse(greps(out, r"^DEF7=def7"))
        a_lines = len(lines4(out))
        #
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
    def test_22150_have_environment_with_multiple_parts(self) -> None:
        """ check that the result of 'environment UNIT' can
            list the assignements that are crammed into one line."""
        # https://www.freedesktop.org/software/systemd/man/systemd.exec.html#Environment=
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/sysconfig/zzb.conf"), """
            DEF1='def1'
            DEF2="def2"
            DEF3=def3
            """)
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            EnvironmentFile=/etc/sysconfig/zzb.conf
            Environment="VAR1=word1 word2" VAR2=word3 "VAR3=$word 5 6"
            ExecStart=/usr/bin/printf $DEF1 $DEF2 \
                                $VAR1 $VAR2 $VAR3
            [Install]
            WantedBy=multi-user.target""")
        cmd = F"{systemctl} environment zzb.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"^DEF1=def1"))
        self.assertTrue(greps(out, r"^DEF2=def2"))
        self.assertTrue(greps(out, r"^DEF3=def3"))
        self.assertTrue(greps(out, r"^VAR1=word1 word2"))
        self.assertTrue(greps(out, r"^VAR2=word3"))
        self.assertTrue(greps(out, r"^VAR3=\$word 5 6"))
        a_lines = len(lines4(out))
        #
        self.rm_testdir()
        self.coverage()
    def test_22220_show_unit_is_parseable(self) -> None:
        """ check that 'show UNIT' is machine-readable """
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A""")
        cmd = F"{systemctl} show zza.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"^Id="))
        self.assertTrue(greps(out, r"^Names="))
        self.assertTrue(greps(out, r"^Description="))
        self.assertFalse(greps(out, r"^MainPID="))
        self.assertTrue(greps(out, r"^LoadState="))
        self.assertTrue(greps(out, r"^ActiveState="))
        self.assertTrue(greps(out, r"^SubState="))
        self.assertTrue(greps(out, r"^UnitFileState="))
        num_lines = len(lines4(out))
        #
        cmd = F"{systemctl} --all show zza.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"^Id="))
        self.assertTrue(greps(out, r"^Names="))
        self.assertTrue(greps(out, r"^Description="))
        self.assertTrue(greps(out, r"^MainPID="))
        self.assertTrue(greps(out, r"^LoadState="))
        self.assertTrue(greps(out, r"^ActiveState="))
        self.assertTrue(greps(out, r"^SubState="))
        self.assertTrue(greps(out, r"^UnitFileState="))
        self.assertTrue(greps(out, r"^PIDFile="))
        self.assertGreater(len(lines4(out)), num_lines)
        #
        for line in lines4(out):
            m = re.match(r"^\w+=", line)
            if not m:
                # found non-machine readable property line
                self.assertEqual("word=value", line)
        self.rm_testdir()
        self.coverage()
    def test_22221_show_unit_can_be_restricted_to_one_property(self) -> None:
        """ check that 'show UNIT' may return just one value if asked for"""
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A""")
        cmd = F"{systemctl} show zza.service --property=Description"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"^Description="))
        self.assertEqual(len(lines4(out)), 1)
        #
        cmd = F"{systemctl} show zza.service --property=Description --all"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"^Description="))
        self.assertEqual(len(lines4(out)), 1)
        #
        cmd = F"{systemctl} show zza.service --property=PIDFile"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"^PIDFile="))
        self.assertEqual(len(lines4(out)), 1)
        #
        cmd = F"{systemctl} show zza.service --property=PIDFile --all"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"^PIDFile="))
        self.assertEqual(len(lines4(out)), 1)
        #
        self.assertEqual(lines4(out), ["PIDFile="])
        self.rm_testdir()
        self.coverage()
    def test_22225_show_unit_for_multiple_matches(self) -> None:
        """ check that the result of 'show UNIT' for multiple services is
            concatenated but still machine readable. """
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Install]
            WantedBy=multi-user.target""")
        cmd = F"{systemctl} show zza.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"^Id="))
        self.assertTrue(greps(out, r"^Names="))
        self.assertTrue(greps(out, r"^Description="))
        self.assertFalse(greps(out, r"^MainPID="))
        self.assertTrue(greps(out, r"^LoadState="))
        self.assertTrue(greps(out, r"^ActiveState="))
        self.assertTrue(greps(out, r"^SubState="))
        self.assertTrue(greps(out, r"^UnitFileState="))
        a_lines = len(lines4(out))
        #
        cmd = F"{systemctl} show zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"^Id="))
        self.assertTrue(greps(out, r"^Names="))
        self.assertTrue(greps(out, r"^Description="))
        self.assertFalse(greps(out, r"^MainPID="))
        self.assertTrue(greps(out, r"^LoadState="))
        self.assertTrue(greps(out, r"^ActiveState="))
        self.assertTrue(greps(out, r"^SubState="))
        self.assertTrue(greps(out, r"^UnitFileState="))
        b_lines = len(lines4(out))
        #
        cmd = F"{systemctl} show zza.service zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"^Id="))
        self.assertTrue(greps(out, r"^Names="))
        self.assertTrue(greps(out, r"^Description="))
        self.assertFalse(greps(out, r"^MainPID="))
        self.assertTrue(greps(out, r"^LoadState="))
        self.assertTrue(greps(out, r"^ActiveState="))
        self.assertTrue(greps(out, r"^SubState="))
        self.assertTrue(greps(out, r"^UnitFileState="))
        all_lines = len(lines4(out))
        #
        self.assertGreater(all_lines, a_lines + b_lines)
        #
        for line in lines4(out):
            if not line.strip():
                # empty lines are okay now
                continue
            m = re.match(r"^\w+=", line)
            if not m:
                # found non-machine readable property line
                self.assertEqual("word=value", line)
        self.rm_testdir()
        self.coverage()
    def test_22227_show_unit_for_oneshot_service(self) -> None:
        """ check that 'show UNIT' is machine-readable """
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=oneshot
            ExecStart=/bin/echo foo
            ExecStop=/bin/echo bar
            """)
        cmd = F"{systemctl} show zza.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"^Id="))
        self.assertTrue(greps(out, r"^Names="))
        self.assertTrue(greps(out, r"^Description="))
        self.assertFalse(greps(out, r"^MainPID="))
        self.assertTrue(greps(out, r"^LoadState="))
        self.assertTrue(greps(out, r"^ActiveState="))
        self.assertTrue(greps(out, r"^SubState="))
        self.assertTrue(greps(out, r"^UnitFileState="))
        num_lines = len(lines4(out))
        #
        cmd = F"{systemctl} --all show zza.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"^Id="))
        self.assertTrue(greps(out, r"^Names="))
        self.assertTrue(greps(out, r"^Description="))
        self.assertTrue(greps(out, r"^MainPID="))
        self.assertTrue(greps(out, r"^LoadState="))
        self.assertTrue(greps(out, r"^ActiveState="))
        self.assertTrue(greps(out, r"^SubState="))
        self.assertTrue(greps(out, r"^UnitFileState=static"))
        self.assertTrue(greps(out, r"^PIDFile="))
        self.assertGreater(len(lines4(out)), num_lines)
        #
        for line in lines4(out):
            m = re.match(r"^\w+=", line)
            if not m:
                # found non-machine readable property line
                self.assertEqual("word=value", line)
        self.rm_testdir()
        self.coverage()
    def test_22230_show_unit_display_parsed_timeouts(self) -> None:
        """ check that 'show UNIT' show parsed timeoutss """
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            TimeoutStartSec=29
            TimeoutStopSec=60
            """)
        cmd = F"{systemctl} show zza.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        rep = lines4(out)
        self.assertIn("TimeoutStartUSec=29s", rep)
        self.assertIn("TimeoutStopUSec=1min", rep)
        ##
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing A
            [Service]
            TimeoutStartSec=1m
            TimeoutStopSec=2min
            """)
        cmd = F"{systemctl} show zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        rep = lines4(out)
        self.assertIn("TimeoutStartUSec=1min", rep)
        self.assertIn("TimeoutStopUSec=2min", rep)
        ##
        text_file(os_path(root, "/etc/systemd/system/zzc.service"), """
            [Unit]
            Description=Testing C
            [Service]
            TimeoutStartSec=1s
            TimeoutStopSec=2000ms
            """)
        cmd = F"{systemctl} show zzc.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        rep = lines4(out)
        self.assertIn("TimeoutStartUSec=1s", rep)
        self.assertIn("TimeoutStopUSec=2s", rep)
        #
        self.rm_testdir()
        self.coverage()
        ##
        text_file(os_path(root, "/etc/systemd/system/zzd.service"), """
            [Unit]
            Description=Testing D
            [Service]
            TimeoutStartSec=90s
            TimeoutStopSec=2250ms
            """)
        cmd = F"{systemctl} show zzd.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        rep = lines4(out)
        self.assertIn("TimeoutStartUSec=1min 30s", rep)
        self.assertIn("TimeoutStopUSec=2s 250ms", rep)
        ##
        text_file(os_path(root, "/etc/systemd/system/zze.service"), """
            [Unit]
            Description=Testing E
            [Service]
            TimeoutStartSec=90s 250ms
            TimeoutStopSec=3m 25ms
            """)
        cmd = F"{systemctl} show zze.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        rep = lines4(out)
        self.assertIn("TimeoutStartUSec=1min 30s 250ms", rep)
        self.assertIn("TimeoutStopUSec=3min 25ms", rep)
        ##
        text_file(os_path(root, "/etc/systemd/system/zzf.service"), """
            [Unit]
            Description=Testing F
            [Service]
            TimeoutStartSec=180
            TimeoutStopSec=182
            """)
        cmd = F"{systemctl} show zzf.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        rep = lines4(out)
        self.assertIn("TimeoutStartUSec=3min", rep)
        self.assertIn("TimeoutStopUSec=3min 2s", rep)
        #
        self.rm_testdir()
        self.coverage()
    def real_22240_show_environment_from_parts(self) -> None:
        self.test_22240_show_environment_from_parts(True)
    def test_22240_show_environment_from_parts(self, real: bool = False) -> None:
        """ check that the result of 'show -p Environment UNIT' can
            list the settings from different locations."""
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: systemctl = "/usr/bin/systemctl"
        text_file(os_path(root, "/etc/sysconfig/zzb.conf"), """
            DEF1='def1'
            DEF2="def2"
            DEF3=def3
            """)
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            EnvironmentFile=/etc/sysconfig/zzb.conf
            Environment=DEF5=def5
            Environment=DEF6=def6
            ExecStart=/usr/bin/printf $DEF1 $DEF2 \
                                $DEF3 $DEF4 $DEF5
            [Install]
            WantedBy=multi-user.target""")
        cmd = F"{systemctl} show -p Environment zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertFalse(greps(out, r"DEF1=def1"))
        self.assertFalse(greps(out, r"DEF2=def2"))
        self.assertFalse(greps(out, r"DEF3=def3"))
        self.assertFalse(greps(out, r"DEF4=def4"))
        self.assertTrue(greps(out, r"DEF5=def5"))
        self.assertTrue(greps(out, r"DEF6=def6"))
        self.assertFalse(greps(out, r"DEF7=def7"))
        a_lines = len(lines4(out))
        #
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
    def real_22250_show_environment_max_depth(self) -> None:
        self.test_22250_show_environment_max_depth(True)
    def test_22250_show_environment_max_depth(self, real: bool = False) -> None:
        """ check that the result of 'show -p Environment UNIT' can
            list the settings from different locations."""
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: systemctl = "/usr/bin/systemctl"
        text_file(os_path(root, "/etc/sysconfig/zzb.conf"), """
            DEF1='def1'
            DEF2="def2"
            DEF3=def3
            """)
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            EnvironmentFile=/etc/sysconfig/zzb.conf
            Environment=DEF5=def5
            Environment=DEF6=$DEF5
            ExecStart=/usr/bin/printf x.$DEF1.$DEF2.$DEF3.$DEF4.$DEF5
            [Install]
            WantedBy=multi-user.target""")
        cmd = F"{systemctl} daemon-reload"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} show -p Environment zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertFalse(greps(out, r"DEF1=def1"))
        self.assertFalse(greps(out, r"DEF2=def2"))
        self.assertFalse(greps(out, r"DEF3=def3"))
        self.assertFalse(greps(out, r"DEF4=def4"))
        self.assertTrue(greps(out, r"DEF5=def5"))
        self.assertTrue(greps(out, r"DEF6=[$]DEF5"))
        self.assertFalse(greps(out, r"DEF7=def7"))
        a_lines = len(lines4(out))
        cmd = F"{systemctl} show -p EnvironmentFile zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} stop zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} start zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} stop zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} status zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        #
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()

    def real_22300_override_environment_extras(self) -> None:
        self.test_22300_override_environment_extras(True)
    def test_22300_override_environment_extras(self, real: bool = False) -> None:
        """ check that the result of 'show -p Environment UNIT' can
            list the settings when using override file extras"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        text_file(os_path(root, "/etc/sysconfig/zzb.conf"), """
            DEF1='def1'
            DEF2="def2"
            DEF3=def3
            """)
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            EnvironmentFile=/etc/sysconfig/zzb.conf
            Environment=DEF5=def5
            Environment=DEF6=$DEF5
            ExecStart=/usr/bin/printf x.$DEF1.$DEF2.$DEF3.$DEF4.$DEF5
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service.d/extra.conf"), """
            [Service]
            Environment=DEF7=def7
            Environment=DEF8=$DEF5
            ExecStartPre=/usr/bin/printf y.$DEF7.$DEF8
            """)
        cmd = F"{systemctl} daemon-reload"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} show -p Environment zzb.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertFalse(greps(out, r"DEF1=def1"))
        self.assertFalse(greps(out, r"DEF2=def2"))
        self.assertFalse(greps(out, r"DEF3=def3"))
        self.assertFalse(greps(out, r"DEF4=def4"))
        self.assertTrue(greps(out, r"DEF5=def5"))
        self.assertTrue(greps(out, r"DEF6=[$]DEF5"))
        self.assertTrue(greps(out, r"DEF7=def7"))
        self.assertTrue(greps(out, r"DEF8=[$]DEF5"))
        self.assertFalse(greps(out, r"DEF9=def9"))
        a_lines = len(lines4(out))
        cmd = F"{systemctl} show -p EnvironmentFile zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} stop zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} start zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} stop zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} status zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        #
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
    def real_22310_override_environment_by_extras(self) -> None:
        self.test_22310_override_environment_by_extras(True)
    def test_22310_override_environment_by_extras(self, real: bool = False) -> None:
        """ check that the result of 'show -p Environment UNIT' can
            list the settings when using override file extras"""
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: systemctl = "/usr/bin/systemctl"
        text_file(os_path(root, "/etc/sysconfig/zzb.conf"), """
            DEF1='def1'
            DEF2="def2"
            DEF3=def3
            """)
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            EnvironmentFile=/etc/sysconfig/zzb.conf
            Environment=DEF5=def5
            Environment=DEF6=$DEF5
            ExecStart=/usr/bin/printf x.$DEF1.$DEF2.$DEF3.$DEF4.$DEF5
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service.d/extra.conf"), """
            [Service]
            Environment=DEF5=def7
            """)
        cmd = F"{systemctl} daemon-reload"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} show -p Environment zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertFalse(greps(out, r"DEF1=def1"))
        self.assertFalse(greps(out, r"DEF2=def2"))
        self.assertFalse(greps(out, r"DEF3=def3"))
        self.assertFalse(greps(out, r"DEF4=def4"))
        self.assertTrue(greps(out, r"DEF5=def7"))
        self.assertTrue(greps(out, r"DEF6=[$]DEF5"))
        self.assertFalse(greps(out, r"DEF7=def7"))
        a_lines = len(lines4(out))
        cmd = F"{systemctl} show -p EnvironmentFile zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} stop zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} start zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} stop zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} status zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        #
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
    def real_22320_override_environment_by_usrlib_extras(self) -> None:
        self.test_22320_override_environment_by_usrlib_extras(True)
    def test_22320_override_environment_by_usrlib_extras(self, real: bool = False) -> None:
        """ check that the result of 'show -p Environment UNIT' can
            list the settings when using override file extras"""
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: systemctl = "/usr/bin/systemctl"
        text_file(os_path(root, "/etc/sysconfig/zzb.conf"), """
            DEF1='def1'
            DEF2="def2"
            DEF3=def3
            """)
        text_file(os_path(root, "/usr/lib/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            EnvironmentFile=/etc/sysconfig/zzb.conf
            Environment=DEF5=def5
            Environment=DEF6=$DEF5
            ExecStart=/usr/bin/printf x.$DEF1.$DEF2.$DEF3.$DEF4.$DEF5
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/usr/lib/systemd/system/zzb.service.d/extra.conf"), """
            [Service]
            Environment=DEF5=def7
            """)
        cmd = F"{systemctl} daemon-reload"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} show -p Environment zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertFalse(greps(out, r"DEF1=def1"))
        self.assertFalse(greps(out, r"DEF2=def2"))
        self.assertFalse(greps(out, r"DEF3=def3"))
        self.assertFalse(greps(out, r"DEF4=def4"))
        self.assertTrue(greps(out, r"DEF5=def7"))
        self.assertTrue(greps(out, r"DEF6=[$]DEF5"))
        self.assertFalse(greps(out, r"DEF7=def7"))
        a_lines = len(lines4(out))
        cmd = F"{systemctl} show -p EnvironmentFile zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} stop zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} start zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} stop zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} status zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        #
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
    def real_22330_override_environment_by_usrlib_etc_extras(self) -> None:
        self.test_22330_override_environment_by_usrlib_etc_extras(True)
    def test_22330_override_environment_by_usrlib_etc_extras(self, real: bool = False) -> None:
        """ check that the result of 'show -p Environment UNIT' can
            list the settings when using override file extras"""
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: systemctl = "/usr/bin/systemctl"
        text_file(os_path(root, "/etc/sysconfig/zzb.conf"), """
            DEF1='def1'
            DEF2="def2"
            DEF3=def3
            """)
        text_file(os_path(root, "/usr/lib/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            EnvironmentFile=/etc/sysconfig/zzb.conf
            Environment=DEF5=def5
            Environment=DEF6=$DEF5
            ExecStart=/usr/bin/printf x.$DEF1.$DEF2.$DEF3.$DEF4.$DEF5
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service.d/extra.conf"), """
            [Service]
            Environment=DEF5=def7
            """)
        cmd = F"{systemctl} daemon-reload"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} show -p Environment zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertFalse(greps(out, r"DEF1=def1"))
        self.assertFalse(greps(out, r"DEF2=def2"))
        self.assertFalse(greps(out, r"DEF3=def3"))
        self.assertFalse(greps(out, r"DEF4=def4"))
        self.assertTrue(greps(out, r"DEF5=def7"))
        self.assertTrue(greps(out, r"DEF6=[$]DEF5"))
        self.assertFalse(greps(out, r"DEF7=def7"))
        a_lines = len(lines4(out))
        cmd = F"{systemctl} show -p EnvironmentFile zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} stop zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} start zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} stop zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} status zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        #
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
    def real_22340_override_environment_by_multiple_extras(self) -> None:
        self.test_22340_override_environment_by_multiple_extras(True)
    def test_22340_override_environment_by_multiple_extras(self, real: bool = False) -> None:
        """ check that the result of 'show -p Environment UNIT' can
            list the settings when using override file extras"""
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: systemctl = "/usr/bin/systemctl"
        text_file(os_path(root, "/etc/sysconfig/zzb.conf"), """
            DEF1='def1'
            DEF2="def2"
            DEF3=def3
            """)
        text_file(os_path(root, "/usr/lib/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            EnvironmentFile=/etc/sysconfig/zzb.conf
            Environment=DEF5=def5
            Environment=DEF6=$DEF5
            ExecStart=/usr/bin/printf x.$DEF1.$DEF2.$DEF3.$DEF4.$DEF5
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/usr/lib/systemd/system/zzb.service.d/base.conf"), """
            [Service]
            Environment=DEF5=def6
            Environment=DEF7=def6
            """)
        text_file(os_path(root, "/etc/systemd/system/zzb.service.d/extra.conf"), """
            [Service]
            Environment=DEF5=def7
            """)
        cmd = F"{systemctl} daemon-reload"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} show -p Environment zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertFalse(greps(out, r"DEF1=def1"))
        self.assertFalse(greps(out, r"DEF2=def2"))
        self.assertFalse(greps(out, r"DEF3=def3"))
        self.assertFalse(greps(out, r"DEF4=def4"))
        self.assertTrue(greps(out, r"DEF5=def7"))
        self.assertTrue(greps(out, r"DEF6=[$]DEF5"))
        self.assertTrue(greps(out, r"DEF7=def"))
        a_lines = len(lines4(out))
        cmd = F"{systemctl} show -p EnvironmentFile zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} stop zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} start zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} stop zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} status zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        #
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
    def real_22350_override_environment_by_multiple_same_extras(self) -> None:
        self.test_22350_override_environment_by_multiple_same_extras(True)
    def test_22350_override_environment_by_multiple_same_extras(self, real: bool = False) -> None:
        """ check that the result of 'show -p Environment UNIT' can
            list the settings when using override file extras"""
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: systemctl = "/usr/bin/systemctl"
        text_file(os_path(root, "/etc/sysconfig/zzb.conf"), """
            DEF1='def1'
            DEF2="def2"
            DEF3=def3
            """)
        text_file(os_path(root, "/usr/lib/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            EnvironmentFile=/etc/sysconfig/zzb.conf
            Environment=DEF5=def5
            Environment=DEF6=$DEF5
            ExecStart=/usr/bin/printf x.$DEF1.$DEF2.$DEF3.$DEF4.$DEF5
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/usr/lib/systemd/system/zzb.service.d/extra.conf"), """
            [Service]
            Environment=DEF5=def6
            Environment=DEF7=def6
            """)
        text_file(os_path(root, "/etc/systemd/system/zzb.service.d/extra.conf"), """
            [Service]
            Environment=DEF5=def7
            """)
        cmd = F"{systemctl} daemon-reload"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} show -p Environment zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertFalse(greps(out, r"DEF1=def1"))
        self.assertFalse(greps(out, r"DEF2=def2"))
        self.assertFalse(greps(out, r"DEF3=def3"))
        self.assertFalse(greps(out, r"DEF4=def4"))
        self.assertTrue(greps(out, r"DEF5=def7"))
        self.assertTrue(greps(out, r"DEF6=[$]DEF5"))
        self.assertFalse(greps(out, r"DEF7=def")) # <<< difference to previous!!
        a_lines = len(lines4(out))
        cmd = F"{systemctl} show -p EnvironmentFile zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} stop zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} start zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} stop zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} status zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        #
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
    def real_22360_override_environment_by_multiple_same_extras(self) -> None:
        self.test_22360_override_environment_by_multiple_same_extras(True)
    def test_22360_override_environment_by_multiple_same_extras(self, real: bool = False) -> None:
        """ check that the result of 'show -p Environment UNIT' can
            list the settings when using override file extras"""
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: systemctl = "/usr/bin/systemctl"
        text_file(os_path(root, "/etc/sysconfig/zzb.conf"), """
            DEF1='def1'
            DEF2="def2"
            DEF3=def3
            """)
        text_file(os_path(root, "/usr/lib/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            EnvironmentFile=/etc/sysconfig/zzb.conf
            Environment=DEF5=def5
            Environment=DEF6=$DEF5
            ExecStart=/usr/bin/printf x.$DEF1.$DEF2.$DEF3.$DEF4.$DEF5
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/usr/lib/systemd/system/zzb.service.d/extra.conf"), """
            [Service]
            Environment=DEF5=def6
            Environment=DEF7=def6
            """)
        text_file(os_path(root, "/etc/systemd/system/zzb.service.d/base.conf"), """
            [Service]
            Environment=DEF5=def7
            """)
        cmd = F"{systemctl} daemon-reload"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} show -p Environment zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertFalse(greps(out, r"DEF1=def1"))
        self.assertFalse(greps(out, r"DEF2=def2"))
        self.assertFalse(greps(out, r"DEF3=def3"))
        self.assertFalse(greps(out, r"DEF4=def4"))
        self.assertTrue(greps(out, r"DEF5=def6")) # <<< difference to (pre)previous
        self.assertTrue(greps(out, r"DEF6=[$]DEF5"))
        self.assertTrue(greps(out, r"DEF7=def"))
        a_lines = len(lines4(out))
        cmd = F"{systemctl} show -p EnvironmentFile zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} stop zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} start zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} stop zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} status zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        #
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
    def real_22390_override_environment_with_zero_out_extras(self) -> None:
        self.test_22390_override_environment_with_zero_out_extras(True)
    def test_22390_override_environment_with_zero_out_extras(self, real: bool = False) -> None:
        """ check that the result of 'show -p Environment UNIT' can
            list the settings when using override file extras"""
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: systemctl = "/usr/bin/systemctl"
        text_file(os_path(root, "/etc/sysconfig/zzb.conf"), """
            DEF1='def1'
            DEF2="def2"
            DEF3=def3
            """)
        text_file(os_path(root, "/usr/lib/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            EnvironmentFile=/etc/sysconfig/zzb.conf
            Environment=DEF5=def5
            Environment=DEF6=$DEF5
            ExecStart=/usr/bin/printf x.$DEF1.$DEF2.$DEF3.$DEF4.$DEF5
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/usr/lib/systemd/system/zzb.service.d/extra.conf"), """
            [Service]
            Environment=
            Environment=DEF5=def6
            Environment=DEF7=def6
            """)
        text_file(os_path(root, "/etc/systemd/system/zzb.service.d/base.conf"), """
            [Service]
            Environment=DEF5=def7
            Environment=DEF8=def8
            """)
        cmd = F"{systemctl} daemon-reload"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} show -p Environment zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertFalse(greps(out, r"DEF1=def1"))
        self.assertFalse(greps(out, r"DEF2=def2"))
        self.assertFalse(greps(out, r"DEF3=def3"))
        self.assertFalse(greps(out, r"DEF4=def4"))
        self.assertTrue(greps(out, r"DEF5=def6"))
        self.assertFalse(greps(out, r"DEF6=")) # <<< zero-out
        self.assertTrue(greps(out, r"DEF7=def"))
        self.assertFalse(greps(out, r"DEF8=")) # <<< zero-out
        a_lines = len(lines4(out))
        cmd = F"{systemctl} show -p EnvironmentFile zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} stop zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} start zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} stop zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} status zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        #
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
    def test_22610_show_unit_not_found(self) -> None:
        """ check when 'show UNIT' not found  """
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            TimeoutStartSec=29
            TimeoutStopSec=60
            """)
        cmd = F"{systemctl} show zz-not-existing.service"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        rep = lines4(out)
        self.assertIn("LoadState=not-found", rep)
        self.assertIn("ActiveState=inactive", rep)
        self.assertIn("SubState=dead", rep)
        self.assertIn("Id=zz-not-existing.service", rep)
        self.rm_testdir()
        self.coverage()
        ##
    def real_22612_show_unit_property_not_found(self) -> None:
        self.test_22612_show_unit_property_not_found(True)
    def test_22612_show_unit_property_not_found(self, real: bool = False) -> None:
        """ check when 'show UNIT' not found  """
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: systemctl = "/usr/bin/systemctl"
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            TimeoutStartSec=29
            TimeoutStopSec=60
            """)
        cmd = F"{systemctl} daemon-reload"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} show -p WeirdOption zza.service"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
        ##
    def real_22614_show_multiple_unit_property(self) -> None:
        self.test_22614_show_multiple_unit_property(True)
    def test_22614_show_multiple_unit_property(self, real: bool = False) -> None:
        """ check when 'show UNIT' with multiple -p (as used by Chef) """
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: systemctl = "/usr/bin/systemctl"
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            TimeoutStartSec=29
            TimeoutStopSec=60
            """)
        cmd = F"{systemctl} daemon-reload"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} show -p TimeoutStartUSec -p TimeoutStopUSec zza.service"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        rep = lines4(out)
        self.assertEqual(len(rep), 2)
        self.assertIn("TimeoutStartUSec=29s", rep)
        self.assertIn("TimeoutStopUSec=1min", rep)
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
        ##
    def test_22701_create_runtime(self) -> None:
        """ check when create and clean RuntimeDirectory  """
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        bindir=os_path(root, F"/bin")
        testsleep = self.testname("sleep")
        copy_tool(_bin_sleep, F"{bindir}/{testsleep}")
        text_file(os_path(root, "/etc/systemd/system/zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            TimeoutStartSec=29
            TimeoutStopSec=60
            RuntimeDirectory=foo/bar aaa
            ExecStart={bindir}/{testsleep} 3
            """)
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            TimeoutStartSec=29
            TimeoutStopSec=60
            RuntimeDirectory=foo/bar bbb
            RuntimeDirectoryPreserve=yes
            ExecStart={bindir}/{testsleep} 3
            """)
        path1 = os_path(root, "/run/foo/bar")
        path2 = os_path(root, "/run/aaa")
        self.assertFalse(os.path.isdir(path1))
        self.assertFalse(os.path.isdir(path2))
        cmd = F"{systemctl} start zza.service -vvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = F"{systemctl} stop zza.service -vvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertFalse(os.path.isdir(path1))
        self.assertFalse(os.path.isdir(path2))
        #
        path1 = os_path(root, "/run/foo/bar")
        path2 = os_path(root, "/run/bbb")
        self.assertFalse(os.path.isdir(path1))
        self.assertFalse(os.path.isdir(path2))
        cmd = F"{systemctl} start zzb.service -vvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = F"{systemctl} stop zzb.service -vvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = F"{systemctl} clean zzb.service -vvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertFalse(os.path.isdir(path1))
        self.assertFalse(os.path.isdir(path2))
        #
        path1 = os_path(root, "/run/foo/bar")
        path2 = os_path(root, "/run/bbb")
        self.assertFalse(os.path.isdir(path1))
        self.assertFalse(os.path.isdir(path2))
        cmd = F"{systemctl} start zzb.service -vvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = F"{systemctl} clean zzb.service -vvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = F"{systemctl} stop zzb.service -vvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = F"{systemctl} clean zzb.service --what=state -vvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = F"{systemctl} clean zzb.service --what=runtime -vvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertFalse(os.path.isdir(path1))
        self.assertFalse(os.path.isdir(path2))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        ##
    def test_22702_create_state(self) -> None:
        """ check when create and clean StateDirectory  """
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        bindir=os_path(root, F"/bin")
        testsleep = self.testname("sleep")
        copy_tool(_bin_sleep, F"{bindir}/{testsleep}")
        text_file(os_path(root, "/etc/systemd/system/zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            TimeoutStartSec=29
            TimeoutStopSec=60
            StateDirectory=foo/bar aaa
            ExecStart={bindir}/{testsleep} 3
            """)
        path1 = os_path(root, "/var/lib/foo/bar")
        path2 = os_path(root, "/var/lib/aaa")
        self.assertFalse(os.path.isdir(path1))
        self.assertFalse(os.path.isdir(path2))
        #
        cmd = F"{systemctl} start zza.service -vvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = F"{systemctl} stop zza.service -vvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = F"{systemctl} clean zza.service --what=all -vvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertFalse(os.path.isdir(path1))
        self.assertFalse(os.path.isdir(path2))
        #
        cmd = F"{systemctl} start zza.service -vvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = F"{systemctl} clean zza.service -vvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = F"{systemctl} stop zza.service -vvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = F"{systemctl} clean zza.service --what=runtime -vvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = F"{systemctl} clean zza.service --what=state -vvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertFalse(os.path.isdir(path1))
        self.assertFalse(os.path.isdir(path2))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        ##
    def test_22703_create_cache(self) -> None:
        """ check when create and clean CacheDirectory  """
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        bindir=os_path(root, F"/bin")
        testsleep = self.testname("sleep")
        copy_tool(_bin_sleep, F"{bindir}/{testsleep}")
        text_file(os_path(root, "/etc/systemd/system/zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            TimeoutStartSec=29
            TimeoutStopSec=60
            CacheDirectory=foo/bar aaa
            ExecStart={bindir}/{testsleep} 3
            """)
        path1 = os_path(root, "/var/cache/foo/bar")
        path2 = os_path(root, "/var/cache/aaa")
        self.assertFalse(os.path.isdir(path1))
        self.assertFalse(os.path.isdir(path2))
        cmd = F"{systemctl} start zza.service -vvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = F"{systemctl} stop zza.service -vvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = F"{systemctl} clean zza.service --what=all -vvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertFalse(os.path.isdir(path1))
        self.assertFalse(os.path.isdir(path2))
        #
        cmd = F"{systemctl} start zza.service -vvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = F"{systemctl} clean zza.service -vvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = F"{systemctl} stop zza.service -vvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = F"{systemctl} clean zza.service --what=state -vvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = F"{systemctl} clean zza.service --what=cache -vvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertFalse(os.path.isdir(path1))
        self.assertFalse(os.path.isdir(path2))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
    def test_22704_create_logs(self) -> None:
        """ check when create and clean LogsDirectory  """
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        bindir=os_path(root, F"/bin")
        testsleep = self.testname("sleep")
        copy_tool(_bin_sleep, F"{bindir}/{testsleep}")
        text_file(os_path(root, "/etc/systemd/system/zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            TimeoutStartSec=29
            TimeoutStopSec=60
            LogsDirectory=foo/bar aaa
            ExecStart={bindir}/{testsleep} 3
            """)
        path1 = os_path(root, "/var/log/foo/bar")
        path2 = os_path(root, "/var/log/aaa")
        self.assertFalse(os.path.isdir(path1))
        self.assertFalse(os.path.isdir(path2))
        #
        cmd = F"{systemctl} start zza.service -vvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = F"{systemctl} stop zza.service -vvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = F"{systemctl} clean zza.service --what=all -vvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertFalse(os.path.isdir(path1))
        self.assertFalse(os.path.isdir(path2))
        #
        cmd = F"{systemctl} start zza.service -vvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = F"{systemctl} clean zza.service -vvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = F"{systemctl} stop zza.service -vvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = F"{systemctl} clean zza.service --what=runtime -vvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = F"{systemctl} clean zza.service --what=logs -vvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertFalse(os.path.isdir(path1))
        self.assertFalse(os.path.isdir(path2))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        ##
    def test_22705_create_configuraiton(self) -> None:
        """ check when create and clean ConfigurationDirectory  """
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        bindir=os_path(root, F"/bin")
        testsleep = self.testname("sleep")
        copy_tool(_bin_sleep, F"{bindir}/{testsleep}")
        text_file(os_path(root, "/etc/systemd/system/zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            TimeoutStartSec=29
            TimeoutStopSec=60
            ConfigurationDirectory=foo/bar aaa
            ExecStart={bindir}/{testsleep} 3
            """)
        path1 = os_path(root, "/etc/foo/bar")
        path2 = os_path(root, "/etc/aaa")
        self.assertFalse(os.path.isdir(path1))
        self.assertFalse(os.path.isdir(path2))
        #
        cmd = F"{systemctl} start zza.service -vvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = F"{systemctl} stop zza.service -vvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = F"{systemctl} clean zza.service --what=all -vvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertFalse(os.path.isdir(path1))
        self.assertFalse(os.path.isdir(path2))
        #
        cmd = F"{systemctl} start zza.service -vvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = F"{systemctl} clean zza.service -vvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = F"{systemctl} stop zza.service -vvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = F"{systemctl} clean zza.service --what=runtime -vvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = F"{systemctl} clean zza.service --what=configuration -vvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertFalse(os.path.isdir(path1))
        self.assertFalse(os.path.isdir(path2))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        ##
    def test_22715_create_mode_configuration(self) -> None:
        """ check when create and clean ConfigurationDirectory with Mode settings """
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        bindir=os_path(root, F"/bin")
        testsleep = self.testname("sleepA")
        copy_tool(_bin_sleep, F"{bindir}/{testsleep}")
        text_file(os_path(root, "/etc/systemd/system/zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            TimeoutStartSec=29
            TimeoutStopSec=60
            ConfigurationDirectory=foo/bar aaa
            ExecStart={bindir}/{testsleep} 3
            """)
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            TimeoutStartSec=29
            TimeoutStopSec=60
            ConfigurationDirectory=foo/bar aaa
            ConfigurationDirectoryMode=0700
            ExecStart={bindir}/{testsleep} 3
            """)
        path1 = os_path(root, "/etc/foo/bar")
        path2 = os_path(root, "/etc/aaa")
        self.assertFalse(os.path.isdir(path1))
        self.assertFalse(os.path.isdir(path2))
        #
        cmd = F"{systemctl} start zza.service -vvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = F"ls -ld {path1}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertIn("drwxr-x", out)
        out_a = out
        #
        cmd = F"{systemctl} stop zza.service -vvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = F"{systemctl} clean zza.service --what=all -vvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertFalse(os.path.isdir(path1))
        self.assertFalse(os.path.isdir(path2))
        #
        cmd = F"{systemctl} start zzb.service -vvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = F"ls -ld {path1}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertIn("drwx---", out)
        out_b = out
        #
        cmd = F"{systemctl} stop zzb.service -vvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = F"{systemctl} clean zzb.service --what=all -vvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertFalse(os.path.isdir(path1))
        self.assertFalse(os.path.isdir(path2))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        ##
    def test_22716_create_same_user_state(self) -> None:
        """ check when create and clean StateDirectory with User= settings """
        # actually it should not try to change any uid/gid bits on the file
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        bindir=os_path(root, F"/bin")
        testsleep = self.testname("sleepA")
        copy_tool(_bin_sleep, F"{bindir}/{testsleep}")
        this_user = get_USER()
        this_group = get_GROUP()
        text_file(os_path(root, "/etc/systemd/system/zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            TimeoutStartSec=29
            TimeoutStopSec=60
            StateDirectory=foo/bar aaa
            User={this_user}
            ExecStart={bindir}/{testsleep} 3
            """)
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            TimeoutStartSec=29
            TimeoutStopSec=60
            StateDirectory=foo/bar aaa
            Group={this_group}
            ExecStart={bindir}/{testsleep} 3
            """)
        path1 = os_path(root, "/var/lib/foo/bar")
        path2 = os_path(root, "/var/lib/aaa")
        self.assertFalse(os.path.isdir(path1))
        self.assertFalse(os.path.isdir(path2))
        #
        cmd = F"{systemctl} start zza.service -vvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = F"ls -ld {path1}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        out_a = out
        #
        cmd = F"{systemctl} stop zza.service -vvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = F"{systemctl} clean zza.service --what=all -vvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertFalse(os.path.isdir(path1))
        self.assertFalse(os.path.isdir(path2))
        #
        cmd = F"{systemctl} start zzb.service -vvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = F"ls -ld {path1}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        out_b = out
        #
        cmd = F"{systemctl} stop zzb.service -vvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = F"{systemctl} clean zzb.service --what=all -vvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertFalse(os.path.isdir(path1))
        self.assertFalse(os.path.isdir(path2))
        #
        A = re.sub("\\d+:\\d*", "XX:XX", out_a.strip())
        B = re.sub("\\d+:\\d*", "XX:XX", out_b.strip())
        logg.info("A = %s", A)
        logg.info("B = %s", B)
        self.assertEqual(A, B)
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        ##
    def test_22717_create_other_group_state(self) -> None:
        """ check when create and clean StateDirectory with Group= settings """
        # if not running as 'root' then it may actually change the directory group
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        bindir=os_path(root, F"/bin")
        testsleep = self.testname("sleep")
        copy_tool(_bin_sleep, F"{bindir}/{testsleep}")
        this_group = get_GROUP()
        last_group = get_LASTGROUP()
        text_file(os_path(root, "/etc/systemd/system/zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            StateDirectory=foo/bar aaa
            Group={this_group}
            ExecStart={bindir}/{testsleep} 3
            """)
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            StateDirectory=foo/bar aaa
            Group={last_group}
            ExecStart={bindir}/{testsleep} 4
            """)
        path1 = os_path(root, "/var/lib/foo/bar")
        path2 = os_path(root, "/var/lib/aaa")
        self.assertFalse(os.path.isdir(path1))
        self.assertFalse(os.path.isdir(path2))
        #
        cmd = F"{systemctl} start zza.service -vvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = F"ls -ld {path1}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        out_a = out
        #
        cmd = F"{systemctl} stop zza.service -vvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = F"{systemctl} clean zza.service --what=all -vvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertFalse(os.path.isdir(path1))
        self.assertFalse(os.path.isdir(path2))
        #
        cmd = F"{systemctl} start zzb.service -vvvvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        # mayfail# self.assertEqual(end, 0)
        # mayfail# self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = F"ls -ld {path1}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        out_b = out
        #
        cmd = F"{systemctl} stop zzb.service -vvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = F"{systemctl} clean zzb.service --what=all -vvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertFalse(os.path.isdir(path1))
        self.assertFalse(os.path.isdir(path2))
        #
        logg.info("this group '%s' vs '%s' last group", this_group, last_group)
        A = re.sub("\\d+:\\d*", "XX:XX", out_a.strip())
        B = re.sub("\\d+:\\d*", "XX:XX", out_b.strip())
        logg.info("A = %s", A)
        logg.info("B = %s", B)
        if os.geteuid():
            self.assertNotEqual(A, B)
        else:
            self.assertEqual(A, B) # when "root"
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        ##
    def test_22718_create_other_group_configuration(self) -> None:
        """ check when create and clean ConfigurationDirectory with Group= settings """
        # if not running as 'root' then it may actually change the directory group
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        bindir=os_path(root, F"/bin")
        testsleep = self.testname("sleep")
        copy_tool(_bin_sleep, F"{bindir}/{testsleep}")
        this_group = get_GROUP()
        last_group = get_LASTGROUP()
        text_file(os_path(root, "/etc/systemd/system/zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            ConfigurationDirectory=foo/bar aaa
            Group={this_group}
            ExecStart={bindir}/{testsleep} 3
            """)
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            ConfigurationDirectory=foo/bar aaa
            Group={last_group}
            ExecStart={bindir}/{testsleep} 4
            """)
        path1 = os_path(root, "/etc/foo/bar")
        path2 = os_path(root, "/etc/aaa")
        self.assertFalse(os.path.isdir(path1))
        self.assertFalse(os.path.isdir(path2))
        #
        cmd = F"{systemctl} start zza.service -vvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = F"ls -ld {path1}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        out_a = out
        #
        cmd = F"{systemctl} stop zza.service -vvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = F"{systemctl} clean zza.service --what=all -vvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertFalse(os.path.isdir(path1))
        self.assertFalse(os.path.isdir(path2))
        #
        cmd = F"{systemctl} start zzb.service -vvvvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        # mayfail# self.assertEqual(end, 0)
        # mayfail# self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = F"ls -ld {path1}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        out_b = out
        #
        cmd = F"{systemctl} stop zzb.service -vvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = F"{systemctl} clean zzb.service --what=all -vvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertFalse(os.path.isdir(path1))
        self.assertFalse(os.path.isdir(path2))
        #
        logg.info("this group '%s' vs '%s' last group", this_group, last_group)
        A = re.sub("\\d+:\\d*", "XX:XX", out_a.strip())
        B = re.sub("\\d+:\\d*", "XX:XX", out_b.strip())
        logg.info("A = %s", A)
        logg.info("B = %s", B)
        self.assertEqual(A, B) # no chown if directory did exist
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        ##
    def test_22900_class_UnitConfParser(self) -> None:
        """ using systemctl.py as a helper library for
            the UnitConfParser functions."""
        python_exe = _python
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl_py_dir = os.path.dirname(realpath(_systemctl_py))
        unitconfparser_py = os_path(root, "/usr/bin/unitconfparser.py")
        service_file = os_path(root, "/etc/systemd/system/zzb.service")
        defaults = {"a1": "default1"}
        systemctl = os.path.splitext(os.path.basename(_systemctl_py))[0]
        shell_file(unitconfparser_py, F"""
            #! {python_exe}
            from __future__ import print_function
            import sys
            sys.path += [ "{systemctl_py_dir}" ]
            import {systemctl}
            data = {systemctl}.UnitConfParser({defaults})
            conf = {systemctl}.SystemctlConf(data)
            print("DEFAULTS", conf.data.defaults())
            print("FILENAME", conf.filename())
            data.read(sys.argv[1])
            print("filename=", conf.filename())
            print("sections=", conf.data.sections())
            print("has.Foo.Bar=", conf.data.has_option("Foo", "Bar"))
            print("has.Unit.Foo=", conf.data.has_option("Unit", "Foo"))
            try:
               conf.data.get("Foo", "Bar")
            except Exception as e:
               print("get.Foo.Bar:", str(e))
            try:
               conf.data.get("Unit", "Foo")
            except Exception as e:
               print("get.Unit.Foo:", str(e))
            try:
               conf.data.getlist("Foo", "Bar")
            except Exception as e:
               print("getlist.Foo.Bar:", str(e))
            try:
               conf.data.getlist("Unit", "Foo")
            except Exception as e:
               print("getlist.Unit.Foo:", str(e))
            print("get.none.Foo.Bar=", conf.data.get("Foo", "Bar", allow_no_value = True))
            print("get.none.Unit.Foo=", conf.data.get("Unit", "Foo", allow_no_value = True))
            print("getlist.none.Foo.Bar=", conf.data.getlist("Foo", "Bar", allow_no_value = True))
            print("getlist.none.Unit.Foo=", conf.data.getlist("Unit", "Foo", allow_no_value = True))
            print("get.defs.Foo.Bar=", conf.data.get("Foo", "Bar", "def1"))
            print("get.defs.Unit.Foo=", conf.data.get("Unit", "Foo", "def2"))
            print("getlist.defs.Foo.Bar=", conf.data.getlist("Foo", "Bar", ["def3"]))
            print("getlist.defs.Unit.Foo=", conf.data.getlist("Unit", "Foo", ["def4"]))
            data.set("Unit", "After", "network.target")
            print("getlist.unit.after1=", conf.data.getlist("Unit", "After"))
            print("getitem.unit.after1=", conf.data.get("Unit", "After"))
            data.set("Unit", "After", "postgres.service")
            print("getlist.unit.after2=", conf.data.getlist("Unit", "After"))
            print("getitem.unit.after2=", conf.data.get("Unit", "After"))
            data.set("Unit", "After", None)
            print("getlist.unit.after0=", conf.data.getlist("Unit", "After"))
            print("getitem.unit.after0=", conf.data.get("Unit", "After", allow_no_value = True))
            print("getlist.environment=", conf.data.getlist("Service", "Environment"))
            print("get.environment=", conf.data.get("Service", "Environment"))
            print("get.execstart=", conf.data.get("Service", "ExecStart"))
            """)
        text_file(service_file, F"""
            [Unit]
            Description=Testing B
            [Service]
            EnvironmentFile=/etc/sysconfig/zzb.conf
            Environment=DEF5=def5
            Environment=DEF6=def6
            ExecStart=/usr/bin/printf $DEF1 $DEF2 \\
                                $DEF3 $DEF4 $DEF5 \\
                                $DEF6 $DEF7
            [Install]
            WantedBy=multi-user.target""")
        testrun = cover() + unitconfparser_py
        cmd = F"{testrun} {service_file}"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, "DEFAULTS {'a1': 'default1'}"))
        self.assertTrue(greps(out, "FILENAME None"))
        self.assertTrue(greps(out, "filename= .*"+service_file))
        self.assertTrue(greps(out, "sections= \\['Unit', 'Service', 'Install'\\]"))
        self.assertTrue(greps(out, "has.Foo.Bar= False"))
        self.assertTrue(greps(out, "has.Unit.Foo= False"))
        self.assertTrue(greps(out, "get.Foo.Bar: section Foo does not exist"))
        self.assertTrue(greps(out, "get.Unit.Foo: option Foo in Unit does not exist"))
        self.assertTrue(greps(out, "getlist.Foo.Bar: section Foo does not exist"))
        self.assertTrue(greps(out, "getlist.Unit.Foo: option Foo in Unit does not exist"))
        self.assertTrue(greps(out, "get.none.Foo.Bar= None"))
        self.assertTrue(greps(out, "get.none.Unit.Foo= None"))
        self.assertTrue(greps(out, "getlist.none.Foo.Bar= \\[\\]"))
        self.assertTrue(greps(out, "getlist.none.Unit.Foo= \\[\\]"))
        self.assertTrue(greps(out, "get.defs.Foo.Bar= def1"))
        self.assertTrue(greps(out, "get.defs.Unit.Foo= def2"))
        self.assertTrue(greps(out, "getlist.defs.Foo.Bar= \\['def3'\\]"))
        self.assertTrue(greps(out, "getlist.defs.Unit.Foo= \\['def4'\\]"))
        self.assertTrue(greps(out, "getlist.unit.after1= \\['network.target'\\]"))
        self.assertTrue(greps(out, "getlist.unit.after2= \\['network.target', 'postgres.service'\\]"))
        self.assertTrue(greps(out, "getlist.unit.after0= \\[\\]"))
        self.assertTrue(greps(out, "getitem.unit.after1= network.target"))
        self.assertTrue(greps(out, "getitem.unit.after2= network.target"))
        self.assertTrue(greps(out, "getitem.unit.after0= None"))
        self.assertTrue(greps(out, "getlist.environment= \\['DEF5=def5', 'DEF6=def6'\\]"))
        self.assertTrue(greps(out, "get.environment= DEF5=def5"))
        self.assertTrue(greps(out, "get.execstart= /usr/bin/printf \\$DEF1 \\$DEF2 \\\\$"))
        self.assertTrue(greps(out, "      \\$DEF3 \\$DEF4 \\$DEF5"))
        self.assertTrue(greps(out, "      \\$DEF6 \\$DEF7"))
        #
        self.rm_testdir()
        self.coverage()
    def real_23002_enable_service_creates_a_symlink(self) -> None:
        self.test_23002_enable_service_creates_a_symlink(True)
    def test_23002_enable_service_creates_a_symlink(self, real: bool = False) -> None:
        """ check that a service can be enabled """
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        self.rm_zzfiles(root)
        bindir =os_path(root, F"/bin")
        sleep = self.testname("sleep")
        copy_tool(_bin_sleep, F"{bindir}/{sleep}")
        #
        text_file(os_path(root, "/etc/systemd/system/zza.service"), F"""
            [Unit]
            Description=Testing A""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            ExecStart={bindir}/{sleep} 2
            [Install]
            WantedBy=multi-user.target""")
        cmd = F"{systemctl} daemon-reload"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} enable zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        enabled_file = os_path(root, "/etc/systemd/system/multi-user.target.wants/zzb.service")
        self.assertTrue(os.path.islink(enabled_file))
        textB = reads(enabled_file)
        self.assertTrue(greps(textB, "Testing B"))
        self.assertIn("\nDescription", textB)
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_23003_disable_service_removes_the_symlink(self) -> None:
        self.test_23003_disable_service_removes_the_symlink(True)
    def test_23003_disable_service_removes_the_symlink(self, real: bool = False) -> None:
        """ check that a service can be enabled and disabled """
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        self.rm_zzfiles(root)
        bindir =os_path(root, F"/bin")
        sleep = self.testname("sleep")
        copy_tool(_bin_sleep, F"{bindir}/{sleep}")
        #
        text_file(os_path(root, "/etc/systemd/system/zza.service"), F"""
            [Unit]
            Description=Testing A""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            ExecStart={bindir}/{sleep} 2
            [Install]
            WantedBy=multi-user.target""")
        cmd = F"{systemctl} daemon-reload"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} enable zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        enabled_file = os_path(root, "/etc/systemd/system/multi-user.target.wants/zzb.service")
        self.assertTrue(os.path.islink(enabled_file))
        textB = reads(enabled_file)
        self.assertTrue(greps(textB, "Testing B"))
        self.assertIn("\nDescription", textB)
        #
        cmd = F"{systemctl} enable zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        enabled_file = os_path(root, "/etc/systemd/system/multi-user.target.wants/zzb.service")
        self.assertTrue(os.path.islink(enabled_file))
        #
        cmd = F"{systemctl} enable zz-other.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertNotEqual(end, 0)
        enabled_file = os_path(root, "/etc/systemd/system/multi-user.target.wants/zz-other.service")
        self.assertFalse(os.path.islink(enabled_file))
        #
        cmd = F"{systemctl} disable zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        enabled_file = os_path(root, "/etc/systemd/system/multi-user.target.wants/zzb.service")
        self.assertFalse(os.path.exists(enabled_file))
        #
        cmd = F"{systemctl} disable zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        enabled_file = os_path(root, "/etc/systemd/system/multi-user.target.wants/zzb.service")
        self.assertFalse(os.path.exists(enabled_file))
        #
        cmd = F"{systemctl} disable zz-other.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertNotEqual(end, 0)
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_23004_list_unit_files_when_enabled(self) -> None:
        self.test_23004_list_unit_files_when_enabled(True)
    def test_23004_list_unit_files_when_enabled(self, real: bool = False) -> None:
        """ check that two unit files can be found for 'list-unit-files'
            with an enabled status """
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        self.rm_zzfiles(root)
        bindir =os_path(root, F"/bin")
        sleep = self.testname("sleep")
        copy_tool(_bin_sleep, F"{bindir}/{sleep}")
        #
        text_file(os_path(root, "/etc/systemd/system/zza.service"), F"""
            [Unit]
            Description=Testing A""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            ExecStart={bindir}/{sleep} 2
            [Install]
            WantedBy=multi-user.target""")
        cmd = F"{systemctl} daemon-reload"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} --no-legend --type=service list-unit-files"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"zza.service\s+static"))
        self.assertTrue(greps(out, r"zzb.service\s+disabled"))
        self.assertEqual(len(greps(out, "^zz")), 2)
        #
        cmd = F"{systemctl} --no-legend enable zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        enabled_file = os_path(root, "/etc/systemd/system/multi-user.target.wants/zzb.service")
        self.assertTrue(os.path.islink(enabled_file))
        #
        cmd = F"{systemctl} --no-legend --type=service list-unit-files"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"zza.service\s+static"))
        self.assertTrue(greps(out, r"zzb.service\s+enabled"))
        self.assertEqual(len(greps(out, "^zz")), 2)
        #
        cmd = F"{systemctl} --no-legend disable zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        enabled_file = os_path(root, "/etc/systemd/system/multi-user.target.wants/zzb.service")
        self.assertFalse(os.path.exists(enabled_file))
        #
        cmd = F"{systemctl} --no-legend --type=service list-unit-files"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"zza.service\s+static"))
        self.assertTrue(greps(out, r"zzb.service\s+disabled"))
        self.assertEqual(len(greps(out, "^zz")), 2)
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_23005_is_enabled_result_when_enabled(self) -> None:
        self.test_23005_is_enabled_result_when_enabled(True)
    def test_23005_is_enabled_result_when_enabled(self, real: bool = False) -> None:
        """ check that 'is-enabled' reports correctly for enabled/disabled """
        self.begin()
        vv = "-vv"
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logg.info("systemctl = %s", systemctl)
        logg.info("cover(%s) = %s", COVERAGE, cover())
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        self.rm_zzfiles(root)
        bindir =os_path(root, F"/bin")
        sleep = self.testname("sleep")
        copy_tool(_bin_sleep, F"{bindir}/{sleep}")
        #
        text_file(os_path(root, "/etc/systemd/system/zza.service"), F"""
            [Unit]
            Description=Testing A""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            ExecStart={bindir}/{sleep} 2
            [Install]
            WantedBy=multi-user.target""")
        #
        cmd = F"{systemctl} daemon-reload"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} is-enabled zza.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"^static"))
        self.assertEqual(len(lines4(out)), 1)
        cmd = F"{systemctl} is-enabled zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(out, r"^disabled"))
        self.assertEqual(len(lines4(out)), 1)
        #
        cmd = F"{systemctl} --no-legend enable zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} is-enabled zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"^enabled"))
        self.assertEqual(len(lines4(out)), 1)
        #
        cmd = F"{systemctl} --no-legend disable zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} is-enabled zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^disabled"))
        self.assertEqual(len(lines4(out)), 1)
        self.assertEqual(end, 1)
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23006_is_enabled_is_true_when_any_is_enabled(self) -> None:
        """ check that 'is-enabled' reports correctly for enabled/disabled """
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        bindir =os_path(root, F"/bin")
        sleep = self.testname("sleep")
        copy_tool(_bin_sleep, F"{bindir}/{sleep}")
        text_file(os_path(root, "/etc/systemd/system/zza.service"), F"""
            [Unit]
            Description=Testing A""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            ExecStart={bindir}/{sleep} 2
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzc.service"), F"""
            [Unit]
            Description=Testing C
            [Service]
            ExecStart={bindir}/{sleep} 2
            [Install]
            WantedBy=multi-user.target""")
        #
        cmd = F"{systemctl} is-enabled zza.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"^static"))
        self.assertEqual(len(lines4(out)), 1)
        cmd = F"{systemctl} is-enabled zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(out, r"^disabled"))
        self.assertEqual(len(lines4(out)), 1)
        cmd = F"{systemctl} is-enabled zzc.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(out, r"^disabled"))
        self.assertEqual(len(lines4(out)), 1)
        cmd = F"{systemctl} is-enabled zzb.service zzc.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(out, r"^disabled"))
        self.assertFalse(greps(out, r"^enabled"))
        self.assertEqual(len(lines4(out)), 2)
        cmd = F"{systemctl} is-enabled zza.service zzb.service zzc.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"^disabled"))
        self.assertFalse(greps(out, r"^enabled"))
        self.assertEqual(len(lines4(out)), 3)
        #
        cmd = F"{systemctl} --no-legend enable zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} is-enabled zzb.service zzc.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"^disabled"))
        self.assertTrue(greps(out, r"^enabled"))
        self.assertEqual(len(lines4(out)), 2)
        #
        cmd = F"{systemctl} is-enabled zzb.service zza.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"^static"))
        self.assertTrue(greps(out, r"^enabled"))
        self.assertEqual(len(lines4(out)), 2)
        #
        cmd = F"{systemctl} is-enabled zzc.service zza.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"^static"))
        self.assertTrue(greps(out, r"^disabled"))
        self.assertEqual(len(lines4(out)), 2)
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23008_is_enabled_for_nonexistant_service(self) -> None:
        """ check that 'is-enabled' reports correctly for non-existant services """
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        bindir =os_path(root, F"/bin")
        sleep = self.testname("sleep")
        copy_tool(_bin_sleep, F"{bindir}/{sleep}")
        text_file(os_path(root, "/etc/systemd/system/zzc.service"), F"""
            [Unit]
            Description=Testing C
            [Service]
            ExecStart={bindir}/{sleep} 2
            [Install]
            WantedBy=multi-user.target""")
        #
        cmd = F"{systemctl} is-enabled zz-not-existing.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        self.assertFalse(greps(out, r"^static"))
        self.assertEqual(len(lines4(out)), 0)
        cmd = F"{systemctl} is-enabled zz-not-existing-service.service zzc.service"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(out, r"^disabled"))
        self.assertFalse(greps(out, r"^enabled"))
        self.assertEqual(len(lines4(out)), 1)
        self.assertTrue(greps(err, "Unit zz-not-existing-service.service not found."))
        #
        cmd = F"{systemctl} --no-legend enable zz-not-existing-service.service"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zz-not-existing-service.service not found."))
        #
        cmd = F"{systemctl} --no-legend disable zz-not-existing-service.service"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zz-not-existing-service.service not found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23009_sysv_service_enable(self) -> None:
        """ check that we manage SysV services in a root env
            with basic enable/disable commands, also being
            able to check its status."""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        logfile = os_path(root, "/var/log/"+testsleep+".log")
        bindir = os_path(root, "/usr/bin")
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        os.makedirs(os_path(root, "/var/run"))
        text_file(logfile, "created\n")
        begin = "{"
        ends = "}"
        shell_file(os_path(testdir, "xxx.init"), F"""
            #! /bin/bash
            ### BEGIN INIT INFO
            # Required-Start: $local_fs $remote_fs $syslog $network
            # Required-Stop:  $local_fs $remote_fs $syslog $network
            # Default-Start:  3 5
            # Default-Stop:   0 1 2 6
            # Short-Description: Testing Z
            # Description:    Allows for SysV testing
            ### END INIT INFO
        """)
        shell_file(os_path(testdir, "zzz.init"), F"""
            #! /bin/bash
            ### BEGIN INIT INFO
            # Required-Start: $local_fs $remote_fs $syslog $network
            # Required-Stop:  $local_fs $remote_fs $syslog $network
            # Default-Start:  3 5
            # Default-Stop:   0 1 2 6
            # Short-Description: Testing Z
            # Description:    Allows for SysV testing
            ### END INIT INFO
            logfile={logfile}
            sleeptime=111
            start() {begin}
               [ -d /var/run ] || mkdir -p /var/run
               ({bindir}/{testsleep} $sleeptime 0<&- &>/dev/null &
                echo $! > {root}/var/run/zzz.init.pid
               ) &
               wait %1
               # ps -o pid,ppid,args
               cat "RUNNING `cat {root}/var/run/zzz.init.pid`"
            {ends}
            stop() {begin}
               killall {testsleep}
            {ends}
            case "$1" in start)
               date "+START.%T" >> $logfile
               start >> $logfile 2>&1
               date "+start.%T" >> $logfile
            ;; stop)
               date "+STOP.%T" >> $logfile
               stop >> $logfile 2>&1
               date "+stop.%T" >> $logfile
            ;; restart)
               date "+RESTART.%T" >> $logfile
               stop >> $logfile 2>&1
               start >> $logfile 2>&1
               date "+.%T" >> $logfile
            ;; reload)
               date "+RELOAD.%T" >> $logfile
               echo "...." >> $logfile 2>&1
               date "+reload.%T" >> $logfile
            ;; esac
            echo "done$1" >&2
            exit 0
            """)
        copy_tool(os_path(testdir, "xxx.init"), os_path(root, "/etc/init.d/xxx"))
        copy_tool(os_path(testdir, "zzz.init"), os_path(root, "/etc/init.d/zzz"))
        #
        cmd = F"{systemctl} is-enabled zzz.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^disabled"))
        self.assertEqual(len(lines4(out)), 1)
        self.assertEqual(end, 1)
        #
        cmd = F"{systemctl} enable xxx.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} enable xxx.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} --no-legend enable zzz.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} is-enabled zzz.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"^enabled"))
        self.assertEqual(len(lines4(out)), 1)
        #
        cmd = F"{systemctl} default-services"
        out, end = output2(cmd)
        self.assertEqual(end, 0)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines4(out)), 2)
        #
        cmd = F"{systemctl} --no-legend disable zzz.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} is-enabled zzz.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(out, r"^disabled"))
        self.assertEqual(len(lines4(out)), 1)
        #
        cmd = F"{systemctl} disable xxx.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} disable xxx.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} default-services"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(lines4(out)), 0)
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23010_check_preset_all(self) -> None:
        """ check that 'is-enabled' reports correctly after 'preset-all' """
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        bindir =os_path(root, F"/bin")
        sleep = self.testname("sleep")
        copy_tool(_bin_sleep, F"{bindir}/{sleep}")
        text_file(os_path(root, "/etc/systemd/system/zza.service"), F"""
            [Unit]
            Description=Testing A""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            ExecStart={bindir}/{sleep} 2
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzc.service"), F"""
            [Unit]
            Description=Testing C
            [Service]
            ExecStart={bindir}/{sleep} 2
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system-preset/our.preset"), """
            enable zzb.service
            disable zzc.service""")
        #
        cmd = F"{systemctl} is-enabled zza.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^static"))
        self.assertEqual(len(lines4(out)), 1)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} is-enabled zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^disabled"))
        self.assertEqual(len(lines4(out)), 1)
        self.assertEqual(end, 1)
        cmd = F"{systemctl} is-enabled zzc.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^disabled"))
        self.assertEqual(len(lines4(out)), 1)
        self.assertEqual(end, 1)
        #
        cmd = F"{systemctl} preset-all"
        logg.info(" %s", cmd)
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines4(out)), 0)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} is-enabled zza.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^static"))
        self.assertEqual(len(lines4(out)), 1)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} is-enabled zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^enabled"))
        self.assertEqual(len(lines4(out)), 1)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} is-enabled zzc.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^disabled"))
        self.assertEqual(len(lines4(out)), 1)
        self.assertEqual(end, 1)
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23011_check_preset_one(self) -> None:
        """ check that 'is-enabled' reports correctly after 'preset service' """
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        bindir =os_path(root, F"/bin")
        sleep = self.testname("sleep")
        copy_tool(_bin_sleep, F"{bindir}/{sleep}")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            ExecStart={bindir}/{sleep} 2
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzc.service"), """
            [Unit]
            Description=Testing C
            [Service]
            ExecStart={bindir}/{sleep} 2
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system-preset/our.preset"), """
            enable zzb.service
            disable zzc.service""")
        #
        cmd = F"{systemctl} is-enabled zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^disabled"))
        self.assertEqual(len(lines4(out)), 1)
        self.assertEqual(end, 1)
        cmd = F"{systemctl} is-enabled zzc.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^disabled"))
        self.assertEqual(len(lines4(out)), 1)
        self.assertEqual(end, 1)
        #
        cmd = F"{systemctl} preset zzc.service -vv"
        logg.info(" %s", cmd)
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines4(out)), 0)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} is-enabled zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^disabled"))
        self.assertEqual(len(lines4(out)), 1)
        self.assertEqual(end, 1)
        cmd = F"{systemctl} is-enabled zzc.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^disabled"))
        self.assertEqual(len(lines4(out)), 1)
        self.assertEqual(end, 1)
        #
        cmd = F"{systemctl} preset zzb.service"
        logg.info(" %s", cmd)
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines4(out)), 0)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} is-enabled zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^enabled"))
        self.assertEqual(len(lines4(out)), 1)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} is-enabled zzc.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^disabled"))
        self.assertEqual(len(lines4(out)), 1)
        self.assertEqual(end, 1)
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23012_check_preset_to_reset_one(self) -> None:
        """ check that 'enable' and 'preset service' are counterparts """
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        bindir =os_path(root, F"/bin")
        sleep = self.testname("sleep")
        copy_tool(_bin_sleep, F"{bindir}/{sleep}")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            ExecStart={bindir}/{sleep} 2
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzc.service"), F"""
            [Unit]
            Description=Testing C
            [Service]
            ExecStart={bindir}/{sleep} 2
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system-preset/our.preset"), """
            enable zzb.service
            disable zzc.service""")
        #
        cmd = F"{systemctl} is-enabled zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^disabled"))
        self.assertEqual(len(lines4(out)), 1)
        self.assertEqual(end, 1)
        cmd = F"{systemctl} is-enabled zzc.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^disabled"))
        self.assertEqual(len(lines4(out)), 1)
        self.assertEqual(end, 1)
        self.assertEqual(end, 1)
        #
        cmd = F"{systemctl} preset zzb.service"
        logg.info(" %s", cmd)
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines4(out)), 0)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} preset zzc.service"
        logg.info(" %s", cmd)
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines4(out)), 0)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} is-enabled zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^enabled"))
        self.assertEqual(len(lines4(out)), 1)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} is-enabled zzc.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^disabled"))
        self.assertEqual(len(lines4(out)), 1)
        self.assertEqual(end, 1)
        #
        cmd = F"{systemctl} disable zzb.service"
        logg.info(" %s", cmd)
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines4(out)), 0)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} enable zzc.service"
        logg.info(" %s", cmd)
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines4(out)), 0)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} is-enabled zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^disabled"))
        self.assertEqual(len(lines4(out)), 1)
        self.assertEqual(end, 1)
        cmd = F"{systemctl} is-enabled zzc.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^enabled"))
        self.assertEqual(len(lines4(out)), 1)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} preset zzb.service"
        logg.info(" %s", cmd)
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines4(out)), 0)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} preset zzc.service"
        logg.info(" %s", cmd)
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines4(out)), 0)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} is-enabled zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^enabled"))
        self.assertEqual(len(lines4(out)), 1)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} is-enabled zzc.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^disabled"))
        self.assertEqual(len(lines4(out)), 1)
        self.assertEqual(end, 1)
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23013_check_preset_to_reset_some(self) -> None:
        """ check that 'enable' and 'preset services..' are counterparts """
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        bindir =os_path(root, F"/bin")
        sleep = self.testname("sleep")
        copy_tool(_bin_sleep, F"{bindir}/{sleep}")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            ExecStart={bindir}/{sleep} 2
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzc.service"), F"""
            [Unit]
            Description=Testing C
            [Service]
            ExecStart={bindir}/{sleep} 2
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system-preset/our.preset"), """
            enable zzb.service
            disable zzc.service""")
        #
        cmd = F"{systemctl} is-enabled zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^disabled"))
        self.assertEqual(len(lines4(out)), 1)
        self.assertEqual(end, 1)
        cmd = F"{systemctl} is-enabled zzc.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^disabled"))
        self.assertEqual(len(lines4(out)), 1)
        self.assertEqual(end, 1)
        self.assertEqual(end, 1)
        #
        cmd = F"{systemctl} preset zzb.service zzc.service"
        logg.info(" %s", cmd)
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines4(out)), 0)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} is-enabled zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^enabled"))
        self.assertEqual(len(lines4(out)), 1)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} is-enabled zzc.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^disabled"))
        self.assertEqual(len(lines4(out)), 1)
        self.assertEqual(end, 1)
        #
        cmd = F"{systemctl} disable zzb.service"
        logg.info(" %s", cmd)
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines4(out)), 0)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} enable zzc.service"
        logg.info(" %s", cmd)
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines4(out)), 0)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} is-enabled zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^disabled"))
        self.assertEqual(len(lines4(out)), 1)
        self.assertEqual(end, 1)
        cmd = F"{systemctl} is-enabled zzc.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^enabled"))
        self.assertEqual(len(lines4(out)), 1)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} preset zzb.service zzc.service"
        logg.info(" %s", cmd)
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines4(out)), 0)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} is-enabled zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^enabled"))
        self.assertEqual(len(lines4(out)), 1)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} is-enabled zzc.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^disabled"))
        self.assertEqual(len(lines4(out)), 1)
        self.assertEqual(end, 1)
        #
        cmd = F"{systemctl} preset zzb.service zzc.service other.service"
        logg.info(" %s", cmd)
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines4(out)), 0)
        self.assertEqual(end, 1)
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23015_check_preset_all_only_enable(self) -> None:
        """ check that 'preset-all' works with --preset-mode=enable """
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        bindir =os_path(root, F"/bin")
        sleep = self.testname("sleep")
        copy_tool(_bin_sleep, F"{bindir}/{sleep}")
        text_file(os_path(root, "/etc/systemd/system/zza.service"), F"""
            [Unit]
            Description=Testing A""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            ExecStart={bindir}/{sleep} 2
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzc.service"), F"""
            [Unit]
            Description=Testing C
            [Service]
            ExecStart={bindir}/{sleep} 2
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system-preset/our.preset"), """
            enable zzb.service
            disable zzc.service""")
        #
        cmd = F"{systemctl} is-enabled zza.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^static"))
        self.assertEqual(len(lines4(out)), 1)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} is-enabled zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^disabled"))
        self.assertEqual(len(lines4(out)), 1)
        self.assertEqual(end, 1)
        cmd = F"{systemctl} is-enabled zzc.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^disabled"))
        self.assertEqual(len(lines4(out)), 1)
        self.assertEqual(end, 1)
        #
        cmd = F"{systemctl} disable zzb.service"
        logg.info(" %s", cmd)
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines4(out)), 0)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} enable zzc.service"
        logg.info(" %s", cmd)
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines4(out)), 0)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} is-enabled zza.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^static"))
        self.assertEqual(len(lines4(out)), 1)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} is-enabled zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^disabled"))
        self.assertEqual(len(lines4(out)), 1)
        self.assertEqual(end, 1)
        cmd = F"{systemctl} is-enabled zzc.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^enabled"))
        self.assertEqual(len(lines4(out)), 1)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} preset-all --preset-mode=enable"
        logg.info(" %s", cmd)
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines4(out)), 0)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} is-enabled zza.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^static"))
        self.assertEqual(len(lines4(out)), 1)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} is-enabled zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^enabled"))
        self.assertEqual(len(lines4(out)), 1)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} is-enabled zzc.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^enabled"))
        self.assertEqual(len(lines4(out)), 1)
        self.assertEqual(end, 0)
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23016_check_preset_all_only_disable(self) -> None:
        """ check that 'preset-all' works with --preset-mode=disable """
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        bindir =os_path(root, F"/bin")
        sleep = self.testname("sleep")
        copy_tool(_bin_sleep, F"{bindir}/{sleep}")
        text_file(os_path(root, "/etc/systemd/system/zza.service"), F"""
            [Unit]
            Description=Testing A""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            ExecStart={bindir}/{sleep} 2
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzc.service"), F"""
            [Unit]
            Description=Testing C
            [Service]
            ExecStart={bindir}/{sleep} 2
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system-preset/our.preset"), """
            enable zzb.service
            disable zzc.service""")
        #
        cmd = F"{systemctl} is-enabled zza.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^static"))
        self.assertEqual(len(lines4(out)), 1)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} is-enabled zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^disabled"))
        self.assertEqual(len(lines4(out)), 1)
        self.assertEqual(end, 1)
        cmd = F"{systemctl} is-enabled zzc.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^disabled"))
        self.assertEqual(len(lines4(out)), 1)
        self.assertEqual(end, 1)
        #
        cmd = F"{systemctl} disable zzb.service"
        logg.info(" %s", cmd)
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines4(out)), 0)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} enable zzc.service"
        logg.info(" %s", cmd)
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines4(out)), 0)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} is-enabled zza.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^static"))
        self.assertEqual(len(lines4(out)), 1)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} is-enabled zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^disabled"))
        self.assertEqual(len(lines4(out)), 1)
        self.assertEqual(end, 1)
        cmd = F"{systemctl} is-enabled zzc.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^enabled"))
        self.assertEqual(len(lines4(out)), 1)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} preset-all --preset-mode=disable"
        logg.info(" %s", cmd)
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines4(out)), 0)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} is-enabled zza.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^static"))
        self.assertEqual(len(lines4(out)), 1)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} is-enabled zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^disabled"))
        self.assertEqual(len(lines4(out)), 1)
        self.assertEqual(end, 1)
        cmd = F"{systemctl} is-enabled zzc.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^disabled"))
        self.assertEqual(len(lines4(out)), 1)
        self.assertEqual(end, 1)
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23020_default_services(self) -> None:
        """ check the 'default-services' to know the enabled services """
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        bindir =os_path(root, F"/bin")
        sleep = self.testname("sleep")
        copy_tool(_bin_sleep, F"{bindir}/{sleep}")
        text_file(os_path(root, "/etc/systemd/system/zza.service"), F"""
            [Unit]
            Description=Testing A""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            ExecStart={bindir}/{sleep} 2
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzc.service"), F"""
            [Unit]
            Description=Testing C
            [Service]
            ExecStart={bindir}/{sleep} 2
            [Install]
            WantedBy=multi-user.target""")
        #
        cmd = F"{systemctl} default-services"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines4(out)), 0)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} --no-legend enable zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} default-services"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines4(out)), 1)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} --no-legend enable zzc.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} default-services"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines4(out)), 2)
        self.assertEqual(end, 0)
        #
        self.assertFalse(greps(out, "a.service"))
        self.assertTrue(greps(out, "b.service"))
        self.assertTrue(greps(out, "c.service"))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23021_default_services(self) -> None:
        """ check that 'default-services' skips some known services """
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        bindir =os_path(root, F"/bin")
        sleep = self.testname("sleep")
        copy_tool(_bin_sleep, F"{bindir}/{sleep}")
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            ExecStart={bindir}/{sleep} 2
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzc.service"), F"""
            [Unit]
            Description=Testing C
            [Service]
            ExecStart={bindir}/{sleep} 2
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/mount-disks.service"), F"""
            [Unit]
            Description=Testing C
            [Service]
            ExecStart={bindir}/{sleep} 2
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/network.service"), F"""
            [Unit]
            Description=Testing C
            [Service]
            ExecStart={bindir}/{sleep} 2
            [Install]
            WantedBy=multi-user.target""")
        #
        cmd = F"{systemctl} default-services"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines4(out)), 0)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} --no-legend enable zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} --no-legend enable zzc.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} --no-legend enable mount-disks.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} --no-legend enable network.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} default-services"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines4(out)), 2)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} default-services --all"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines4(out)), 3)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} default-services --all --all"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines4(out)), 4)
        self.assertEqual(end, 0)
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_23022_default_services_with_force(self) -> None:
        self.test_23022_default_services_with_force(True)
    def test_23022_default_services_with_force(self, real: bool = False) -> None:
        """ check that 'enable' can force services and targets """
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real:
            vv, systemctl = "", "systemctl"
        bindir =os_path(root, F"/bin")
        sleep = self.testname("sleep")
        copy_tool(_bin_sleep, F"{bindir}/{sleep}")
        text_file(os_path(root, "/etc/systemd/system/zza.service"), F"""
            [Unit]
            Description=Testing A""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            ExecStart={bindir}/{sleep} 2
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzc.service"), F"""
            [Unit]
            Description=Testing C
            Requires=zzx.target
            [Service]
            ExecStart={bindir}/{sleep} 2
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzx.target"), """
            [Unit]
            Description=Testing X
            """)
        #
        cmd = F"{systemctl} default-services"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines4(out)), 0)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} --no-legend enable zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} --no-legend enable zzc.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} default-services"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines4(out)), 2)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} --no-legend enable zza.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        #
        cmd = F"{systemctl} default-services"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines4(out)), 2)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} --no-legend enable zzx.target"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        #
        cmd = F"{systemctl} default-services"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines4(out)), 2)
        self.assertEqual(end, 0)
        ####
        cmd = F"{systemctl} is-enabled zza.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(out.strip(), "static")
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} is-enabled zzx.target"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(out.strip(), "static")
        self.assertEqual(end, 0)
        ####
        #
        cmd = F"{systemctl} --no-legend enable zza.service --force"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} default-services"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines4(out)), 3)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} --no-legend enable zzx.target --force {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} default-services"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines4(out)), 4)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} is-enabled zza.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(out.strip(), "enabled")
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} is-enabled zzx.target"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(out.strip(), "enabled")
        self.assertEqual(end, 0)
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23025_default_user_services(self) -> None:
        """ check the 'default-services' to know the enabled services """
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        user = self.user()
        systemctl = cover() + _systemctl_py + " --root=" + root
        bindir =os_path(root, F"/bin")
        sleep = self.testname("sleep")
        copy_tool(_bin_sleep, F"{bindir}/{sleep}")
        text_file(os_path(root, "/etc/systemd/system/zza.service"), F"""
            [Unit]
            Description=Testing A""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            ExecStart={bindir}/{sleep} 2
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzc.service"), F"""
            [Unit]
            Description=Testing C
            [Service]
            ExecStart={bindir}/{sleep} 2
            User={user}
            [Install]
            WantedBy=multi-user.target""")
        configs = os.path.expanduser("~/.config")
        text_file(os_path(root, configs+"/systemd/user/zzd.service"), F"""
            [Unit]
            Description=Testing D
            [Service]
            ExecStart={bindir}/{sleep} 2
            [Install]
            WantedBy=multi-user.target""")
        #
        cmd = F"{systemctl} list-unit-files --user"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertGreater(len(lines4(out)), 4)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} default-services --user"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines4(out)), 0)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} --no-legend enable zzc.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} default-services --user"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines4(out)), 1)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} --no-legend enable zzd.service --user"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} default-services --user -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines4(out)), 2)
        self.assertEqual(end, 0)
        #
        self.assertFalse(greps(out, "a.service"))
        self.assertFalse(greps(out, "b.service"))
        self.assertTrue(greps(out, "c.service"))
        self.assertTrue(greps(out, "d.service"))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23026_default_services_for_different_target(self, real: bool = False) -> None:
        """ check that 'default-services' changes when modifing default-target """
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        bindir =os_path(root, F"/bin")
        sleep = self.testname("sleep")
        copy_tool(_bin_sleep, F"{bindir}/{sleep}")
        text_file(os_path(root, "/etc/systemd/system/zza.service"), F"""
            [Unit]
            Description=Testing A""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            ExecStart={bindir}/{sleep} 2
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzc.service"), F"""
            [Unit]
            Description=Testing C
            [Service]
            ExecStart={bindir}/{sleep} 2
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzd.service"), F"""
            [Unit]
            Description=Testing D
            [Service]
            ExecStart={bindir}/{sleep} 2
            [Install]
            WantedBy=graphical.target""")
        if not real:
            text_file(os_path(root, "/etc/systemd/system/basic.target"), """
            [Unit]
            Description=Basic Runlevel
            Requires=sockets.target""")
            text_file(os_path(root, "/etc/systemd/system/multi-user.target"), """
            [Unit]
            Description=Basic Runlevel
            Requires=basic.target""")
            text_file(os_path(root, "/etc/systemd/system/graphical.target"), """
            [Unit]
            Description=Basic Runlevel
            Requires=multi-user.target""")
        #
        cmd = F"{systemctl} default-services"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines4(out)), 0)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} --no-legend enable zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} --no-legend enable zzc.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} default-services"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines4(out)), 2)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} get-default"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(out.strip(), "multi-user.target")
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} set-default graphical.target"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} get-default"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(out.strip(), "graphical.target")
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} --no-legend enable zzd.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} default-services -vvvv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines4(out)), 3)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} set-default multi-user.target"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} default-services -vvvv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines4(out)), 2)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} set-default basic.target"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} default-services -vvvv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines4(out)), 0)
        self.assertEqual(end, 0)
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23027_default_services_for_invented_target(self, real: bool = False) -> None:
        """ check that 'default-services' changes when modifing default-target """
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        bindir =os_path(root, F"/bin")
        sleep = self.testname("sleep")
        copy_tool(_bin_sleep, F"{bindir}/{sleep}")
        text_file(os_path(root, "/etc/systemd/system/zza.service"), F"""
            [Unit]
            Description=Testing A""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            ExecStart={bindir}/{sleep} 2
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzc.service"), F"""
            [Unit]
            Description=Testing C
            [Service]
            ExecStart={bindir}/{sleep} 2
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzd.service"), F"""
            [Unit]
            Description=Testing D
            [Service]
            ExecStart={bindir}/{sleep} 2
            [Install]
            WantedBy=graphical.target""")
        text_file(os_path(root, "/etc/systemd/system/zze.service"), F"""
            [Unit]
            Description=Testing E
            [Service]
            ExecStart={bindir}/{sleep} 2
            [Install]
            WantedBy=zz-invented.target""")
        text_file(os_path(root, "/etc/systemd/system/zzi.service"), F"""
            [Unit]
            Description=Testing E
            [Service]
            ExecStart={bindir}/{sleep} 2
            [Install]
            WantedBy=zz-isolated.target""")
        text_file(os_path(root, "/etc/systemd/system/zz-invented.target"), """
            [Unit]
            Description=Invented Runlevel
            Requires=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zz-isolated.target"), """
            [Unit]
            Description=Isolated Runlevel""")
        if not real:
            text_file(os_path(root, "/etc/systemd/system/basic.target"), """
            [Unit]
            Description=Basic Runlevel
            Requires=sockets.target""")
            text_file(os_path(root, "/etc/systemd/system/multi-user.target"), """
            [Unit]
            Description=Basic Runlevel
            Requires=basic.target""")
            text_file(os_path(root, "/etc/systemd/system/graphical.target"), """
            [Unit]
            Description=Basic Runlevel
            Requires=multi-user.target""")
        #
        cmd = F"{systemctl} list-unit-files --type=target"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertGreater(len(lines4(out)), 6)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, "zz-invented.target"))
        #
        cmd = F"{systemctl} default-services"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines4(out)), 0)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} --no-legend enable zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} --no-legend enable zzc.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} default-services"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines4(out)), 2)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} get-default"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(out.strip(), "multi-user.target")
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} set-default graphical.target"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} get-default"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(out.strip(), "graphical.target")
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} --no-legend enable zzd.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} default-services -vvvv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines4(out)), 3)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} set-default multi-user.target"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} default-services -vvvv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines4(out)), 2)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} set-default zz-nonexistant.target"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertTrue(greps(out, "No such runlevel"))
        #
        cmd = F"{systemctl} set-default zz-invented.target"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} default-services -vvvv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines4(out)), 2)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} --no-legend enable zze.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} default-services -vvvv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines4(out)), 3)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} set-default zz-isolated.target"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} default-services -vvvv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines4(out)), 0)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} --no-legend enable zzi.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} default-services -vvvv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines4(out)), 1)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} set-default zz-invented.target"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} default-services -vvvv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines4(out)), 3)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} --no-legend disable zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} default-services -vvvv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines4(out)), 2)
        self.assertEqual(end, 0)
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23030_systemctl_py_start_simple(self) -> None:
        """ check that we can start simple services with root env"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zzz.service"), F"""
            [Unit]
            Description=Testing Z
            AssertFileIsExecutable=//usr/bin/killall
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleep} 111
            ExecStop=/usr/bin/killall {testsleep}
            [Install]
            WantedBy=multi-user.target
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        #
        cmd = F"{systemctl} enable zzz.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} --version"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} default-services -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, "zzz.service"))
        self.assertEqual(len(lines4(out)), 1)
        #
        cmd = F"{systemctl} start zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        #
        cmd = F"{systemctl} stop zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = F"{systemctl} __killall {testsleep}"
        sx____(cmd)
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23031_systemctl_py_start_extra_simple(self) -> None:
        """ check that we can start extra simple services with root env"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zzz.service"), F"""
            [Unit]
            Description=Testing Z
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleep} 111
            [Install]
            WantedBy=multi-user.target
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        #
        cmd = F"{systemctl} enable zzz.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} --version"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} default-services -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, "zzz.service"))
        self.assertEqual(len(lines4(out)), 1)
        #
        cmd = F"{systemctl} start zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        #
        cmd = F"{systemctl} stop zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = F"{systemctl} __killall {testsleep}"
        sx____(cmd)
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23032_systemctl_py_start_forking(self) -> None:
        """ check that we can start forking services with root env"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        os.makedirs(os_path(root, "/var/run"))
        shell_file(os_path(testdir, "zzz.init"), F"""
            #! /bin/bash
            case "$1" in start)
               [ -d /var/run ] || mkdir -p /var/run
               ({bindir}/{testsleep} 111 0<&- &>/dev/null &
                echo $! > {root}/var/run/zzz.init.pid
               ) &
               wait %1
               ps -o pid,ppid,args
            ;; stop)
               killall {testsleep}
            ;; esac
            echo "done$1" >&2
            exit 0
            """)
        text_file(os_path(testdir, "zzz.service"), F"""
            [Unit]
            Description=Testing Z
            [Service]
            Type=forking
            PIDFile={root}/var/run/zzz.init.pid
            ExecStart={root}/usr/bin/zzz.init start
            ExeeStop={root}/usr/bin/zzz.init stop
            [Install]
            WantedBy=multi-user.target
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_tool(os_path(testdir, "zzz.init"), os_path(root, "/usr/bin/zzz.init"))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        #
        cmd = F"{systemctl} enable zzz.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} --version"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} default-services -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, "zzz.service"))
        self.assertEqual(len(lines4(out)), 1)
        #
        cmd = F"{systemctl} start zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        #
        cmd = F"{systemctl} stop zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = F"{systemctl} __killall {testsleep}"
        sx____(cmd)
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23033_systemctl_py_start_forking_without_pid_file(self) -> None:
        """ check that we can start forking services with root env without PIDFile"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        os.makedirs(os_path(root, "/var/run"))
        shell_file(os_path(testdir, "zzz.init"), F"""
            #! /bin/bash
            case "$1" in start)
               ({bindir}/{testsleep} 111 0<&- &>/dev/null &) &
               wait %1
               # ps -o pid,ppid,args >&2
            ;; stop)
               killall {testsleep}
               echo killed all {testsleep} >&2
               sleep 1
            ;; esac
            echo "done$1" >&2
            exit 0
            """)
        text_file(os_path(testdir, "zzz.service"), F"""
            [Unit]
            Description=Testing Z
            [Service]
            Type=forking
            ExecStart={root}/usr/bin/zzz.init start
            ExecStop={root}/usr/bin/zzz.init stop
            [Install]
            WantedBy=multi-user.target
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_tool(os_path(testdir, "zzz.init"), os_path(root, "/usr/bin/zzz.init"))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        #
        cmd = F"{systemctl} enable zzz.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} --version"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} default-services -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, "zzz.service"))
        self.assertEqual(len(lines4(out)), 1)
        #
        cmd = F"{systemctl} start zzz.service -vvvv 2>&1"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        #
        cmd = F"{systemctl} stop zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = F"{systemctl} __killall {testsleep}"
        sx____(cmd)
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23040_systemctl_py_start_simple_bad_stop(self) -> None:
        """ check that we can start simple services with root env"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zzz.service"), F"""
            [Unit]
            Description=Testing Z
            AssertFileIsExecutable=//usr/bin/killall
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleep} 111
            ExecStop=/usr/bin/killall -q z-not-existing
            TimeoutStopSec=4
            [Install]
            WantedBy=multi-user.target
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        #
        cmd = F"{systemctl} enable zzz.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} --version"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} default-services -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, "zzz.service"))
        self.assertEqual(len(lines4(out)), 1)
        #
        cmd = F"{systemctl} start zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        #
        cmd = F"{systemctl} stop zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = F"{systemctl} __killall {testsleep}"
        sx____(cmd)
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23041_systemctl_py_start_extra_simple_bad_start(self) -> None:
        """ check that we can start extra simple services with root env"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zzz.service"), F"""
            [Unit]
            Description=Testing Z
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleep} foo
            [Install]
            WantedBy=multi-user.target
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        #
        cmd = F"{systemctl} enable zzz.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} --version"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} default-services -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, "zzz.service"))
        self.assertEqual(len(lines4(out)), 1)
        #
        cmd = F"{systemctl} start zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        #
        cmd = F"{systemctl} stop zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = F"{systemctl} __killall {testsleep}"
        sx____(cmd)
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23042_systemctl_py_start_forking_bad_stop(self) -> None:
        """ check that we can start forking services with root env"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        os.makedirs(os_path(root, "/var/run"))
        shell_file(os_path(testdir, "zzz.init"), F"""
            #! /bin/bash
            case "$1" in start)
               [ -d /var/run ] || mkdir -p /var/run
               ({bindir}/{testsleep} 111 0<&- &>/dev/null &
                echo $! > {root}/var/run/zzz.init.pid
               ) &
               wait %1
               ps -o pid,ppid,args
            ;; stop)
               killall {testsleep}
               exit 1
            ;; esac
            echo "done$1" >&2
            exit 0
            """)
        text_file(os_path(testdir, "zzz.service"), F"""
            [Unit]
            Description=Testing Z
            [Service]
            Type=forking
            PIDFile={root}/var/run/zzz.init.pid
            ExecStart={root}/usr/bin/zzz.init start
            ExeeStop={root}/usr/bin/zzz.init stop
            [Install]
            WantedBy=multi-user.target
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_tool(os_path(testdir, "zzz.init"), os_path(root, "/usr/bin/zzz.init"))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        #
        cmd = F"{systemctl} enable zzz.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} --version"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} default-services -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, "zzz.service"))
        self.assertEqual(len(lines4(out)), 1)
        #
        cmd = F"{systemctl} start zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        #
        cmd = F"{systemctl} stop zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = F"{systemctl} __killall {testsleep}"
        sx____(cmd)
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23043_systemctl_py_start_forking_bad_start(self) -> None:
        """ check that we can start forking services with root env without PIDFile"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        os.makedirs(os_path(root, "/var/run"))
        shell_file(os_path(testdir, "zzz.init"), F"""
            #! /bin/bash
            case "$1" in start)
               ({bindir}/{testsleep} 111 0<&- &>/dev/null &) &
               wait %1
               # ps -o pid,ppid,args >&2
            ;; stop)
               killall {testsleep}
               echo killed all {testsleep} >&2
               sleep 1
            ;; esac
            echo "done$1" >&2
            exit 1
            """)
        text_file(os_path(testdir, "zzz.service"), F"""
            [Unit]
            Description=Testing Z
            [Service]
            Type=forking
            ExecStart={root}/usr/bin/zzz.init start
            ExecStop={root}/usr/bin/zzz.init stop
            [Install]
            WantedBy=multi-user.target
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_tool(os_path(testdir, "zzz.init"), os_path(root, "/usr/bin/zzz.init"))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        #
        cmd = F"{systemctl} enable zzz.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} --version"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} default-services -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, "zzz.service"))
        self.assertEqual(len(lines4(out)), 1)
        #
        cmd = F"{systemctl} start zzz.service -vvvv 2>&1"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        #
        cmd = F"{systemctl} stop zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = F"{systemctl} __killall {testsleep}"
        sx____(cmd)
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23049_systemctl_py_run_default_services_in_testenv(self) -> None:
        """ check that we can enable services in a test env to be run as default-services"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A""")
        text_file(os_path(testdir, "zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleep} 99
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zzc.service"), F"""
            [Unit]
            Description=Testing C
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleep} 111
            [Install]
            WantedBy=multi-user.target
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        copy_file(os_path(testdir, "zzc.service"), os_path(root, "/etc/systemd/system/zzc.service"))
        #
        cmd = F"{systemctl} enable zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} enable zzc.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} --version"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} default-services -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, "zzb.service"))
        self.assertEqual(len(lines4(out)), 2)
        #
        cmd = F"{systemctl} default -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep+" 99"))
        self.assertTrue(greps(top, testsleep+" 111"))
        #
        cmd = F"{systemctl} halt -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        #
        cmd = F"{systemctl} __killall {testsleep}"
        sx____(cmd)
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_23050_systemctl_py_check_is_active(self) -> None:
        self.test_23050_systemctl_py_check_is_active(True)
    def test_23050_systemctl_py_check_is_active(self, real: bool = False) -> None:
        """ check is_active behaviour"""
        self.begin()
        vv = "-vv"
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A""")
        text_file(os_path(testdir, "zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleep} 99
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zzc.service"), F"""
            [Unit]
            Description=Testing C
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleep} 111
            [Install]
            WantedBy=multi-user.target
            """)
        sx____(_systemctl_py+F" __killall {testsleep}")
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        copy_file(os_path(testdir, "zzc.service"), os_path(root, "/etc/systemd/system/zzc.service"))
        sh____(F"{systemctl} daemon-reload")
        #
        enable_A = F"{systemctl} enable zza.service"
        enable_B = F"{systemctl} enable zzb.service"
        enable_C = F"{systemctl} enable zzc.service"
        enable_D = F"{systemctl} enable zzd.service"
        doneA, exitA = output2(enable_A)
        doneB, exitB = output2(enable_B)
        doneC, exitC = output2(enable_C)
        doneD, exitD = output2(enable_D)
        if TODO or real: self.assertEqual(exitA, 0)
        else: self.assertEqual(exitA, 1)
        self.assertEqual(exitB, 0)
        self.assertEqual(exitC, 0)
        self.assertEqual(exitD, 1)
        #
        is_active_A = F"{systemctl} is-active zza.service"
        is_active_B = F"{systemctl} is-active zzb.service"
        is_active_C = F"{systemctl} is-active zzc.service"
        is_active_D = F"{systemctl} is-active zzd.service"
        actA, exitA = output2(is_active_A)
        actB, exitB = output2(is_active_B)
        actC, exitC = output2(is_active_C)
        actD, exitD = output2(is_active_D)
        self.assertEqual(actA.strip(), "inactive")
        self.assertEqual(actB.strip(), "inactive")
        self.assertEqual(actC.strip(), "inactive")
        self.assertEqual(exitA, 3)
        self.assertEqual(exitB, 3)
        self.assertEqual(exitC, 3)
        self.assertEqual(exitD, 3)
        #
        cmd = F"{systemctl} start zzb.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        is_active_A = F"{systemctl} is-active zza.service"
        is_active_B = F"{systemctl} is-active zzb.service"
        is_active_C = F"{systemctl} is-active zzc.service"
        is_active_D = F"{systemctl} is-active zzd.service"
        actA, exitA = output2(is_active_A)
        actB, exitB = output2(is_active_B)
        actC, exitC = output2(is_active_C)
        actD, exitD = output2(is_active_D)
        self.assertEqual(actA.strip(), "inactive")
        self.assertEqual(actB.strip(), "active")
        self.assertEqual(actC.strip(), "inactive")
        self.assertEqual(actD.strip(), "inactive")
        self.assertNotEqual(exitA, 0)
        self.assertEqual(exitB, 0)
        self.assertNotEqual(exitC, 0)
        self.assertNotEqual(exitD, 0)
        #
        logg.info("== checking with --quiet")
        is_active_A = F"{systemctl} is-active zza.service --quiet"
        is_active_B = F"{systemctl} is-active zzb.service --quiet"
        actA, exitA = output2(is_active_A)
        actB, exitB = output2(is_active_B)
        self.assertEqual(actA, "")
        self.assertEqual(actB, "")
        self.assertNotEqual(exitA, 0)
        self.assertEqual(exitB, 0)
        #
        logg.info("== checking combinations of arguments")
        is_active_BC = F"{systemctl} is-active zzb.service zzc.service "
        is_active_CD = F"{systemctl} is-active zzc.service zzd.service"
        is_active_BD = F"{systemctl} is-active zzb.service zzd.service"
        is_active_BCD = F"{systemctl} is-active zzb.service zzc.service zzd.service"
        actBC, exitBC = output2(is_active_BC)
        actCD, exitCD = output2(is_active_CD)
        actBD, exitBD = output2(is_active_BD)
        actBCD, exitBCD = output2(is_active_BCD)
        self.assertEqual(actBC.split("\n"), ["active", "inactive", ""])
        self.assertEqual(actCD.split("\n"), ["inactive", "inactive", ""])
        self.assertEqual(actBD.split("\n"), ["active", "inactive", ""])
        self.assertEqual(actBCD.split("\n"), ["active", "inactive", "inactive", ""])
        if not real:
            self.assertNotEqual(exitBC, 0)  # TODO
            self.assertNotEqual(exitCD, 0)
            self.assertNotEqual(exitBD, 0)
            self.assertNotEqual(exitBCD, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep+" 99"))
        #
        cmd = F"{systemctl} start zzc.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        actBC, exitBC = output2(is_active_BC)
        self.assertEqual(actBC.split("\n"), ["active", "active", ""])
        self.assertEqual(exitBC, 0)
        #
        cmd = F"{systemctl} stop zzb.service zzc.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        actBC, exitBC = output2(is_active_BC)
        self.assertEqual(actBC.split("\n"), ["inactive", "inactive", ""])
        self.assertNotEqual(exitBC, 0)
        #
        cmd = F"{_systemctl_py} __killall {testsleep}"
        sx____(cmd)
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
        self.end()
    def real_23051_systemctl_py_check_is_failed(self) -> None:
        self.test_23051_systemctl_py_check_is_failed(True)
    def test_23051_systemctl_py_check_is_failed(self, real: bool = False) -> None:
        """ check is_failed behaviour"""
        self.begin()
        vv = "-vv"
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A""")
        text_file(os_path(testdir, "zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleep} 99
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zzc.service"), F"""
            [Unit]
            Description=Testing C
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleep} 111
            [Install]
            WantedBy=multi-user.target
            """)
        sx____(F"{_systemctl_py} __killall {testsleep}")
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        copy_file(os_path(testdir, "zzc.service"), os_path(root, "/etc/systemd/system/zzc.service"))
        sh____(F"{systemctl} daemon-reload")
        #
        enable_A = F"{systemctl} enable zza.service"
        enable_B = F"{systemctl} enable zzb.service"
        enable_C = F"{systemctl} enable zzc.service"
        enable_D = F"{systemctl} enable zzd.service"
        doneA, exitA = output2(enable_A)
        doneB, exitB = output2(enable_B)
        doneC, exitC = output2(enable_C)
        doneD, exitD = output2(enable_D)
        if TODO or real: self.assertEqual(exitA, 0)
        else: self.assertEqual(exitA, 1)
        self.assertEqual(exitB, 0)
        self.assertEqual(exitC, 0)
        self.assertEqual(exitD, 1)
        #
        is_active_A = F"{systemctl} is-failed zza.service"
        is_active_B = F"{systemctl} is-failed zzb.service"
        is_active_C = F"{systemctl} is-failed zzc.service"
        is_active_D = F"{systemctl} is-failed zzd.service"
        actA, exitA = output2(is_active_A)
        actB, exitB = output2(is_active_B)
        actC, exitC = output2(is_active_C)
        actD, exitD = output2(is_active_D)
        self.assertEqual(actA.strip(), "inactive")
        self.assertEqual(actB.strip(), "inactive")
        self.assertEqual(actC.strip(), "inactive")
        self.assertEqual(actD.strip(), "inactive")
        self.assertEqual(exitA, 1)
        self.assertEqual(exitB, 1)
        self.assertEqual(exitC, 1)
        self.assertEqual(exitD, 1)
        #
        cmd = F"{systemctl} start zzb.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        is_active_A = F"{systemctl} is-failed zza.service"
        is_active_B = F"{systemctl} is-failed zzb.service"
        is_active_C = F"{systemctl} is-failed zzc.service"
        is_active_D = F"{systemctl} is-failed zzd.service"
        actA, exitA = output2(is_active_A)
        actB, exitB = output2(is_active_B)
        actC, exitC = output2(is_active_C)
        actD, exitD = output2(is_active_D)
        self.assertEqual(actA.strip(), "inactive")
        self.assertEqual(actB.strip(), "active")
        self.assertEqual(actC.strip(), "inactive")
        self.assertEqual(actD.strip(), "inactive")
        self.assertEqual(exitA, 1)
        self.assertEqual(exitB, 1)
        self.assertEqual(exitC, 1)
        self.assertEqual(exitD, 1)
        #
        logg.info("== checking with --quiet")
        is_active_A = F"{systemctl} is-failed zza.service --quiet"
        is_active_B = F"{systemctl} is-failed zzb.service --quiet"
        actA, exitA = output2(is_active_A)
        actB, exitB = output2(is_active_B)
        self.assertEqual(actA, "")
        self.assertEqual(actB, "")
        self.assertEqual(exitA, 1)
        self.assertEqual(exitB, 1)
        #
        logg.info("== checking combinations of arguments")
        is_active_BC = F"{systemctl} is-failed zzb.service zzc.service {vv}"
        is_active_CD = F"{systemctl} is-failed zzc.service zzd.service {vv}"
        is_active_BD = F"{systemctl} is-failed zzb.service zzd.service {vv}"
        is_active_BCD = F"{systemctl} is-failed zzb.service zzc.service zzd.service {vv}"
        is_active_BCDX = F"{systemctl} is-failed zzb.service zzc.service zzd.service --quiet {vv}"
        actBC, exitBC = output2(is_active_BC)
        actCD, exitCD = output2(is_active_CD)
        actBD, exitBD = output2(is_active_BD)
        actBCD, exitBCD = output2(is_active_BCD)
        actBCDX, exitBCDX = output2(is_active_BCDX)
        self.assertEqual(actBC.split("\n"), ["active", "inactive", ""])
        self.assertEqual(actCD.split("\n"), ["inactive", "inactive", ""])
        self.assertEqual(actBD.split("\n"), ["active", "inactive", ""])
        self.assertEqual(actBCD.split("\n"), ["active", "inactive", "inactive", ""])
        self.assertEqual(actBCDX.split("\n"), [""])
        if not real:
            self.assertNotEqual(exitBC, 0)
            self.assertNotEqual(exitCD, 0)
            self.assertNotEqual(exitBD, 0)
            self.assertNotEqual(exitBCD, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep+" 99"))
        #
        cmd = F"{systemctl} start zzc.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        actBC, exitBC = output2(is_active_BC)
        self.assertEqual(actBC.split("\n"), ["active", "active", ""])
        self.assertNotEqual(exitBC, 0)
        #
        actBC, exitBC = output2(is_active_BC)
        self.assertEqual(actBC.split("\n"), ["active", "active", ""])
        self.assertNotEqual(exitBC, 0)
        #
        cmd = F"{systemctl} __killall {testsleep}"
        sx____(cmd)
        #
        actBC, exitBC = output2(is_active_BC)
        if real:
            self.assertEqual(exitBC, 1)
            self.assertEqual(actBC.split("\n"), ["active", "active", ""])
        else:
            self.assertEqual(exitBC, 0)
            self.assertEqual(actBC.split("\n"), ["failed", "failed", ""])
        #
        cmd = F"{systemctl} stop zzb.service zzc.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        actBC, exitBC = output2(is_active_BC)
        self.assertEqual(actBC.split("\n"), ["inactive", "inactive", ""])
        self.assertNotEqual(exitBC, 0)
        #
        cmd = F"{_systemctl_py} __killall {testsleep}"
        sx____(cmd)
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_23060_is_active_for_forking(self) -> None:
        self.test_23060_is_active_for_forking(True)
    def test_23060_is_active_for_forking(self, real: bool = False) -> None:
        """ check that we can start forking services and have them is-active"""
        self.begin()
        vv = "-vv"
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        bindir = os_path(root, "/usr/bin")
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        testsleep = self.testname("sleep")
        self.makedirs(os_path(root, "/var/run"))
        shell_file(os_path(testdir, "zzz.init"), F"""
            #! /bin/bash
            case "$1" in start)
               [ -d /var/run ] || mkdir -p /var/run
               ({bindir}/{testsleep} 111 0<&- &>/dev/null &
                echo $! > {root}/var/run/zzz.init.pid
               ) &
               wait %1
               ps -o pid,ppid,args
            ;; stop)
               killall {testsleep}
            ;; esac
            echo "done$1" >&2
            exit 0
            """)
        text_file(os_path(testdir, "zzz.service"), F"""
            [Unit]
            Description=Testing Z
            [Service]
            Type=forking
            PIDFile={root}/var/run/zzz.init.pid
            ExecStart={root}/usr/bin/zzz.init start
            ExecStop={root}/usr/bin/zzz.init stop
            [Install]
            WantedBy=multi-user.target
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_tool(os_path(testdir, "zzz.init"), os_path(root, "/usr/bin/zzz.init"))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        cmd = F"{systemctl} daemon-reload"
        sh____(cmd)
        #
        cmd = F"{systemctl} is-active zzz.service {vv}"
        actZX, exitZX = output2(cmd)
        self.assertEqual(actZX.split("\n"), ["inactive", ""])
        self.assertEqual(exitZX, 3)
        #
        cmd = F"{systemctl} enable zzz.service {vv}"
        sh____(cmd)
        cmd = F"{systemctl} is-active zzz.service {vv}"
        actZX, exitZX = output2(cmd)
        self.assertEqual(actZX.split("\n"), ["inactive", ""])
        self.assertEqual(exitZX, 3)
        #
        cmd = F"{systemctl} start zzz.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        #
        is_active_ZX = F"{systemctl} is-active zzz.service {vv}"
        actZX, exitZX = output2(is_active_ZX)
        self.assertEqual(actZX.split("\n"), ["active", ""])
        self.assertEqual(exitZX, 0)
        #
        cmd = F"{systemctl} stop zzz.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        #
        is_active_ZX = F"{systemctl} is-active zzz.service {vv}"
        actZX, exitZX = output2(is_active_ZX)
        self.assertEqual(actZX.split("\n"), ["inactive", ""])
        self.assertEqual(exitZX, 3)
        #
        cmd = F"{systemctl} __killall {testsleep}"
        sx____(cmd)
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
        self.end()
    def real_23061_is_failed_for_forking(self) -> None:
        self.test_23061_is_failed_for_forking(True)
    def test_23061_is_failed_for_forking(self, real: bool = False) -> None:
        """ check that we can start forking services and have them is-failed"""
        self.begin()
        vv = "-vv"
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        bindir = os_path(root, "/usr/bin")
        testsleep = self.testname("sleep")
        self.makedirs(os_path(root, "/var/run"))
        shell_file(os_path(testdir, "zzz.init"), F"""
            #! /bin/bash
            case "$1" in start)
               [ -d /var/run ] || mkdir -p /var/run
               ({bindir}/{testsleep} 111 0<&- &>/dev/null &
                echo $! > {root}/var/run/zzz.init.pid
               ) &
               wait %1
               ps -o pid,ppid,args
            ;; stop)
               killall {testsleep}
            ;; esac
            echo "done$1" >&2
            exit 0
            """)
        text_file(os_path(testdir, "zzz.service"), F"""
            [Unit]
            Description=Testing Z
            [Service]
            Type=forking
            PIDFile={root}/var/run/zzz.init.pid
            ExecStart={root}/usr/bin/zzz.init start
            ExecStop={root}/usr/bin/zzz.init stop
            [Install]
            WantedBy=multi-user.target
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_tool(os_path(testdir, "zzz.init"), os_path(root, "/usr/bin/zzz.init"))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        sh____(F"{systemctl} daemon-reload")
        #
        cmd = F"{systemctl} is-failed zzz.service {vv}"
        actZX, exitZX = output2(cmd)
        self.assertEqual(actZX.split("\n"), ["inactive", ""])
        self.assertEqual(exitZX, 1)
        #
        cmd = F"{systemctl} enable zzz.service"
        sh____(cmd)
        cmd = F"{systemctl} is-failed zzz.service {vv}"
        actZX, exitZX = output2(cmd)
        self.assertEqual(actZX.split("\n"), ["inactive", ""])
        self.assertEqual(exitZX, 1)
        #
        cmd = F"{systemctl} start zzz.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        #
        is_active_ZX = F"{systemctl} is-failed zzz.service {vv}"
        actZX, exitZX = output2(is_active_ZX)
        self.assertEqual(actZX.split("\n"), ["active", ""])
        self.assertEqual(exitZX, 1)
        #
        cmd = F"{systemctl} stop zzz.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        #
        is_active_ZX = F"{systemctl} is-failed zzz.service {vv}"
        actZX, exitZX = output2(is_active_ZX)
        self.assertEqual(actZX.split("\n"), ["inactive", ""])
        self.assertEqual(exitZX, 1)
        #
        cmd = F"{systemctl} __killall {testsleep}"
        sx____(cmd)
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
        self.end()
    def real_23063_is_active_for_forking_delayed(self) -> None:
        self.test_23063_is_active_for_forking_delayed(True)
    def test_23063_is_active_for_forking_delayed(self, real: bool = False) -> None:
        """ check that we can start forking services and have them is-active,
            even when the pid-file is created later because startup waits
            for its existance."""
        self.begin()
        vv = "-vv"
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        self.makedirs(os_path(root, "/var/run"))
        shell_file(os_path(testdir, "zzz.init"), F"""
            #! /bin/bash
            case "$1" in start)
               [ -d /var/run ] || mkdir -p /var/run
               ({bindir}/{testsleep} 111 0<&- &>/dev/null &
                sleep 4
                echo $! > {root}/var/run/zzz.init.pid
               ) &
               sleep 1
               ps -o pid,ppid,args
            ;; stop)
               killall {testsleep}
            ;; esac
            echo "done$1" >&2
            exit 0
            """)
        text_file(os_path(testdir, "zzz.service"), F"""
            [Unit]
            Description=Testing Z
            [Service]
            Type=forking
            PIDFile={root}/var/run/zzz.init.pid
            ExecStart={root}/usr/bin/zzz.init start
            ExecStop={root}/usr/bin/zzz.init stop
            [Install]
            WantedBy=multi-user.target
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_tool(os_path(testdir, "zzz.init"), os_path(root, "/usr/bin/zzz.init"))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        sh____(F"{systemctl} daemon-reload")
        #
        cmd = F"{systemctl} is-active zzz.service {vv}"
        actZX, exitZX = output2(cmd)
        self.assertEqual(actZX.split("\n"), ["inactive", ""])
        self.assertEqual(exitZX, 3)
        #
        cmd = F"{systemctl} enable zzz.service"
        sh____(cmd)
        cmd = F"{systemctl} is-active zzz.service {vv}"
        actZX, exitZX = output2(cmd)
        self.assertEqual(actZX.split("\n"), ["inactive", ""])
        self.assertEqual(exitZX, 3)
        #
        cmd = F"{systemctl} start zzz.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        #
        is_active_ZX = F"{systemctl} is-active zzz.service {vv}"
        actZX, exitZX = output2(is_active_ZX)
        self.assertEqual(actZX.split("\n"), ["active", ""])
        self.assertEqual(exitZX, 0)
        self.assertTrue(os.path.exists(os_path(root, "/var/run/zzz.init.pid")))
        time.sleep(4)
        self.assertTrue(os.path.exists(os_path(root, "/var/run/zzz.init.pid")))
        #
        cmd = F"{systemctl} stop zzz.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        #
        is_active_ZX = F"{systemctl} is-active zzz.service {vv}"
        actZX, exitZX = output2(is_active_ZX)
        self.assertEqual(actZX.split("\n"), ["inactive", ""])
        self.assertEqual(exitZX, 3)
        #
        cmd = F"{systemctl} __killall {testsleep}"
        sx____(cmd)
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
        self.end()
    def real_23070_check_prestart_is_activating(self) -> None:
        self.test_23070_check_prestart_is_activating(True)
    def test_23070_check_prestart_is_activating(self, real: bool = False) -> None:
        """ consider a situation where a 'systemctl start <service>' is
            taking a bit longer to start. Especially some pre-start
            must be blocking while being in state 'activating'"""
        self.begin()
        vv = "-vv"
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir, real)
        systemctl = cover() + realpath(_systemctl_py) + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        logfile = os.path.join(os.path.abspath(testdir), "zzz.log")
        self.makedirs(os_path(root, "/var/run"))
        shell_file(os_path(testdir, "zzz.init"), F"""
            #! /bin/bash
            case "$1" in start)
               [ -d /var/run ] || mkdir -p /var/run
               (
                mkdir -p {root}/var/log
                echo `date +%M:%S` starting pid >{logfile}
                {bindir}/{testsleep} 111 0<&- &>/dev/null &
                echo $! > {root}/var/run/zzz.init.pid
                echo `date +%M:%S` started pid >>{logfile}
                sleep 2
                echo `date +%M:%S` starting zza >>{logfile}
                {systemctl} start zza.service {vv} >>{logfile} 2>&1
                echo `date +%M:%S` started zza >>{logfile}
               ) &
               sleep 1
               ps -o pid,ppid,args
            ;; stop)
               killall {testsleep}
            ;; esac
            echo "done$1" >&2
            exit 0
            """)
        text_file(os_path(testdir, "zzz.service"), F"""
            [Unit]
            Description=Testing Z
            [Service]
            Type=forking
            PIDFile={root}/var/run/zzz.init.pid
            ExecStart={root}/usr/bin/zzz.init start
            ExecStop={root}/usr/bin/zzz.init stop
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStartPre={bindir}/{testsleep}pre 5
            ExecStart={bindir}/{testsleep}now 10
            [Install]
            WantedBy=multi-user.target
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_tool(_bin_sleep, os_path(bindir, testsleep+"pre"))
        copy_tool(_bin_sleep, os_path(bindir, testsleep+"now"))
        copy_tool(os_path(testdir, "zzz.init"), os_path(root, "/usr/bin/zzz.init"))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        sh____(F"{systemctl} daemon-reload")
        #
        cmd = F"{systemctl} enable zza.service zzz.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} start zzz.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        logg.info("===== [0] just started")
        top = greps(_recent(output(_top_list)), testsleep)
        logg.info("top>>>\n| %s", "\n| ".join(top))
        self.assertFalse(greps(top, testsleep+"pre"))
        self.assertFalse(greps(top, testsleep+"now"))
        log0 = lines4(open(logfile))
        logg.info("zzz.log>\n\t%s", "\n\t".join(log0))
        time.sleep(2)
        logg.info("===== [1] after start")
        cmd = F"{systemctl} is-active zza.service zzz.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        top = greps(_recent(output(_top_list)), testsleep)
        logg.info("top>>>\n| %s", "\n| ".join(top))
        self.assertTrue(greps(top, testsleep+"pre"))
        self.assertFalse(greps(top, testsleep+"now"))
        log1 = lines4(open(logfile))
        logg.info("zzz.log>\n\t%s", "\n\t".join(log1))
        time.sleep(2)
        #
        logg.info("===== [2] some later")
        cmd = F"{systemctl} is-active zza.service zzz.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        top = greps(_recent(output(_top_list)), testsleep)
        logg.info("top>>>\n| %s", "\n| ".join(top))
        self.assertTrue(greps(top, testsleep+"pre"))
        self.assertFalse(greps(top, testsleep+"now"))
        log2 = lines4(open(logfile))
        logg.info("zzz.log>\n\t%s", "\n\t".join(log2))
        time.sleep(2)
        #
        logg.info("===== [3] some more later")
        cmd = F"{systemctl} is-active zza.service zzz.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        top = greps(_recent(output(_top_list)), testsleep)
        logg.info("top>>>\n| %s", "\n| ".join(top))
        time.sleep(2)
        top = greps(_recent(output(_top_list)), testsleep)
        logg.info("top>>>\n| %s", "\n| ".join(top))
        self.assertFalse(greps(top, testsleep+"pre"))
        self.assertTrue(greps(top, testsleep+"now"))
        log3 = lines4(open(logfile))
        logg.info("zzz.log>\n\t%s", "\n\t".join(log3))
        time.sleep(3)
        logg.info("===== [4] even more later")
        cmd = F"{systemctl} is-active zza.service zzz.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        top = greps(_recent(output(_top_list)), testsleep)
        logg.info("top>>>\n| %s", "\n| ".join(top))
        self.assertFalse(greps(top, testsleep+"pre"))
        self.assertTrue(greps(top, testsleep+"now"))
        log4 = lines4(open(logfile))
        logg.info("zzz.log>\n\t%s", "\n\t".join(log4))
        #
        cmd = F"{systemctl} __killall {testsleep}"
        sx____(cmd)
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
        self.end()
    def real_23080_two_service_starts_in_parallel(self) -> None:
        self.test_23080_two_service_starts_in_parallel(True)
    def test_23080_two_service_starts_in_parallel(self, real: bool = False) -> None:
        """ consider a situation where a 'systemctl start <service>' is
            done from two programs at the same time. Ensure that there
            is a locking that disallow then to run in parallel."""
        self.begin()
        vv = "-vv"
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir, real)
        systemctl = cover() + realpath(_systemctl_py) + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        logfile = os.path.join(os.path.abspath(testdir), "zzz.log")
        self.makedirs(os_path(root, "/var/run"))
        shell_file(os_path(testdir, "zzz.init"), F"""
            #! /bin/bash
            case "$1" in start)
               [ -d /var/run ] || mkdir -p /var/run
               (
                mkdir -p {root}/var/log
                echo `date +%M:%S` starting pid >{logfile}
                {bindir}/{testsleep} 111 0<&- &>/dev/null &
                echo $! > {root}/var/run/zzz.init.pid
                echo `date +%M:%S` started pid >>{logfile}
                sleep 2
                echo `date +%M:%S` starting zza >>{logfile}
                {systemctl} start zza.service {vv} >>{logfile} 2>&1
                echo `date +%M:%S` started zza >>{logfile}
               ) &
               sleep 1
               ps -o pid,ppid,args
            ;; stop)
               killall {testsleep}
            ;; esac
            echo "done$1" >&2
            exit 0
            """)
        text_file(os_path(testdir, "zzz.service"), F"""
            [Unit]
            Description=Testing Z
            [Service]
            Type=forking
            PIDFile={root}/var/run/zzz.init.pid
            ExecStart={root}/usr/bin/zzz.init start
            ExecStop={root}/usr/bin/zzz.init stop
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStartPre={bindir}/{testsleep}pre 5
            ExecStart={bindir}/{testsleep}now 10
            [Install]
            WantedBy=multi-user.target
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_tool(_bin_sleep, os_path(bindir, testsleep+"pre"))
        copy_tool(_bin_sleep, os_path(bindir, testsleep+"now"))
        copy_tool(os_path(testdir, "zzz.init"), os_path(root, "/usr/bin/zzz.init"))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        sh____(F"{systemctl} daemon-reload")
        #
        cmd = F"{systemctl} enable zza.service zzz.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} start zzz.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        logg.info("===== [0] just started")
        top = greps(_recent(output(_top_list)), testsleep)
        logg.info("top>>>\n| %s", "\n| ".join(top))
        self.assertTrue(greps(top, testsleep))
        log1 = lines4(open(logfile))
        logg.info("zzz.log>\n\t%s", "\n\t".join(log1))
        time.sleep(3)
        logg.info("===== [1] after start")
        top = greps(_recent(output(_top_list)), testsleep)
        logg.info("top>>>\n| %s", "\n| ".join(top))
        self.assertTrue(greps(top, testsleep))
        log1 = lines4(open(logfile))
        logg.info("zzz.log>\n\t%s", "\n\t".join(log1))
        #
        logg.info("====== [2] start next")
        cmd = F"{systemctl} is-active zza.service zzz.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        cmd = F"{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertEqual(end, 0)
        top = greps(_recent(output(_top_list)), testsleep)
        logg.info("top>>>\n| %s", "\n| ".join(top))
        self.assertTrue(greps(top, testsleep))
        log1 = lines4(open(logfile))
        logg.info("zzz.log>\n\t%s", "\n\t".join(log1))
        #
        self.assertTrue(greps(err, "1. systemctl locked by"))
        self.assertTrue(greps(err, "the service is already running on PID")) # FIXME: may not be?
        #
        cmd = F"{systemctl} __killall {testsleep}"
        sx____(cmd)
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
        self.end()
    def test_23081_two_service_starts_in_parallel_with_lockfile_remove(self, real: bool = False) -> None:
        """ consider a situation where a 'systemctl start <service>' is
            done from two programs at the same time. Ensure that there
            is a locking that disallows them to run in parallel. In this
            scenario we test what happens if the lockfile is deleted in between."""
        self.begin()
        vv = "-vv"
        removelockfile="-c REMOVE_LOCK_FILE=True -c DEBUG_FLOCK=True"
        timeouts = "-c MinimumTimeoutStartSec=7 -c MinimumTimeoutStopSec=7"
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir, real)
        systemctl = cover() + realpath(_systemctl_py) + " --root=" + root
        if real: vv, removelockfile, systemctl = "", "", "/usr/bin/systemctl"
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        logfile = os.path.join(os.path.abspath(testdir), "zzz.log")
        self.makedirs(os_path(root, "/var/run"))
        if os.path.exists(logfile):
            os.remove(logfile)
        shell_file(os_path(testdir, "zzz.init"), F"""
            #! /bin/bash
            case "$1" in start)
               [ -d /var/run ] || mkdir -p /var/run
               (
                mkdir -p {root}/var/log
                echo zzz `date +%M:%S` "[$$]" starting pid >>{logfile}
                {bindir}/{testsleep} 111 0<&- &>/dev/null &
                echo $! > {root}/var/run/zzz.init.pid
                echo zzz `date +%M:%S` "[$$]" started pid >>{logfile}
                sleep 2
                echo zzz `date +%M:%S` "[$$]" starting zza >>{logfile}
                {systemctl} start zza.service {vv} {vv} {removelockfile} {timeouts} >>{logfile} 2>&1
                echo zzz `date +%M:%S` "[$$]" started zza >>{logfile}
               ) &
               sleep 1
               ps -o pid,ppid,args
            ;; stop)
               killall {testsleep}
            ;; esac
            echo "done$1" >&2
            exit 0
            """)
        text_file(os_path(testdir, "zzz.service"), F"""
            [Unit]
            Description=Testing Z
            [Service]
            Type=forking
            PIDFile={root}/var/run/zzz.init.pid
            ExecStart={root}/usr/bin/zzz.init start
            ExecStop={root}/usr/bin/zzz.init stop
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStartPre={bindir}/{testsleep}pre 5
            ExecStart={bindir}/{testsleep}now 10
            [Install]
            WantedBy=multi-user.target
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_tool(_bin_sleep, os_path(bindir, testsleep+"pre"))
        copy_tool(_bin_sleep, os_path(bindir, testsleep+"now"))
        copy_tool(os_path(testdir, "zzz.init"), os_path(root, "/usr/bin/zzz.init"))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        sh____(F"{systemctl} daemon-reload")
        #
        cmd = F"{systemctl} enable zza.service zzz.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} start zzz.service {vv} {removelockfile} {timeouts}"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        logg.info("===== [0] just started")
        top = greps(_recent(output(_top_list)), testsleep)
        logg.info("top>>>\n| %s", "\n| ".join(top))
        self.assertTrue(greps(top, testsleep))
        log1 = lines4(open(logfile))
        logg.info("zzz.log>\n\t%s", "\n\t".join(log1))
        time.sleep(2)
        logg.info("===== [1] after start")
        top = greps(_recent(output(_top_list)), testsleep)
        logg.info("top>>>\n| %s", "\n| ".join(top))
        self.assertTrue(greps(top, testsleep))
        log1 = lines4(open(logfile))
        logg.info("zzz.log>\n\t%s", "\n\t".join(log1))
        #
        logg.info("====== start next")
        # cmd = F"{systemctl} is-active zza.service zzz.service {vv}"
        # out, err, end = output3(cmd)
        # logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        cmd = F"{systemctl} start zza.service {vv} {vv} {removelockfile} {timeouts}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        top = greps(_recent(output(_top_list)), testsleep)
        logg.info("top>>>\n| %s", "\n| ".join(top))
        self.assertTrue(greps(top, testsleep))
        #
        self.assertTrue(greps(err, "1. systemctl locked by"))
        self.assertTrue(greps(err, "the service is already running on PID"))
        self.assertTrue(greps(err, "lock got deleted, trying again"))
        self.assertTrue(greps(err, "lock got deleted, trying again"))
        #
        log1 = lines4(open(logfile))
        logg.info("zzz.log>\n\t%s", "\n\t".join(log1))
        #
        cmd = F"{systemctl} __killall {testsleep}"
        sx____(cmd)
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
        self.end()
    def real_23100_mask_service_creates_empty_file(self) -> None:
        self.test_23100_mask_service_creates_empty_file(True)
    def test_23100_mask_service_creates_empty_file(self, real: bool = False) -> None:
        """ check that a service can be masked """
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        vv = "-vv"
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        self.rm_zzfiles(root)
        bindir =os_path(root, F"/bin")
        sleep = self.testname("sleep")
        copy_tool(_bin_sleep, F"{bindir}/{sleep}")
        #
        text_file(os_path(root, "/usr/lib/systemd/system/zza.service"), F"""
            [Unit]
            Description=Testing A""")
        text_file(os_path(root, "/usr/lib/systemd/system/zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            ExecStart={bindir}/{sleep} 2
            [Install]
            WantedBy=multi-user.target""")
        cmd = F"{systemctl} daemon-reload"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} enable zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        enabled_file = os_path(root, "/etc/systemd/system/multi-user.target.wants/zzb.service")
        self.assertTrue(os.path.islink(enabled_file))
        textB = reads(enabled_file)
        self.assertTrue(greps(textB, "Testing B"))
        self.assertIn("\nDescription", textB)
        cmd = F"{systemctl} status zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, "enabled"))
        self.assertFalse(greps(out, "masked"))
        # .........................................
        cmd = F"{systemctl} mask zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} status zzb.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertFalse(greps(out, "enabled"))
        self.assertTrue(greps(out, "masked"))
        if real: self.assertTrue(greps(out, "/dev/null"))
        else: self.assertTrue(greps(out, "None, "))
        mask_file = os_path(root, "/etc/systemd/system/zzb.service")
        self.assertTrue(os.path.islink(mask_file))
        target = os.readlink(mask_file)
        self.assertEqual(target, "/dev/null")
        cmd = F"{systemctl} show zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, oi22(out))
        self.assertTrue(greps(out, "LoadState=masked"))
        self.assertTrue(greps(out, "UnitFileState=masked"))
        self.assertTrue(greps(out, "Id=zzb.service"))
        self.assertTrue(greps(out, "Names=zzb.service"))
        cmd = F"{systemctl} is-active zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        if real: self.assertTrue(greps(out, "inactive"))
        cmd = F"{systemctl} is-enabled zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, "masked"))
        #
        # second mask
        #
        cmd = F"{systemctl} mask zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} status zzb.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertFalse(greps(out, "enabled"))
        self.assertTrue(greps(out, "masked"))
        self.assertEqual(end, 3)
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_23101_unmask_service_removes_empty_file(self) -> None:
        self.test_23101_unmask_service_removes_empty_file(True)
    def test_23101_unmask_service_removes_empty_file(self, real: bool = False) -> None:
        """ check that a service can be unmasked """
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        vv = "-vv"
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        self.rm_zzfiles(root)
        bindir =os_path(root, F"/bin")
        sleep = self.testname("sleep")
        copy_tool(_bin_sleep, F"{bindir}/{sleep}")
        #
        text_file(os_path(root, "/usr/lib/systemd/system/zza.service"), F"""
            [Unit]
            Description=Testing A""")
        text_file(os_path(root, "/usr/lib/systemd/system/zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            ExecStart={bindir}/{sleep} 2
            [Install]
            WantedBy=multi-user.target""")
        cmd = F"{systemctl} daemon-reload"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} enable zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        enabled_file = os_path(root, "/etc/systemd/system/multi-user.target.wants/zzb.service")
        self.assertTrue(os.path.islink(enabled_file))
        textB = reads(enabled_file)
        self.assertTrue(greps(textB, "Testing B"))
        self.assertIn("\nDescription", textB)
        cmd = F"{systemctl} status zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, "enabled"))
        self.assertFalse(greps(out, "masked"))
        # .........................................
        cmd = F"{systemctl} mask zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} status zzb.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertFalse(greps(out, "enabled"))
        self.assertTrue(greps(out, "masked"))
        if real: self.assertTrue(greps(out, "/dev/null"))
        else: self.assertTrue(greps(out, "None, "))
        mask_file = os_path(root, "/etc/systemd/system/zzb.service")
        self.assertTrue(os.path.islink(mask_file))
        target = os.readlink(mask_file)
        self.assertEqual(target, "/dev/null")
        cmd = F"{systemctl} show zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, oi22(out))
        self.assertTrue(greps(out, "LoadState=masked"))
        self.assertTrue(greps(out, "UnitFileState=masked"))
        self.assertTrue(greps(out, "Id=zzb.service"))
        self.assertTrue(greps(out, "Names=zzb.service"))
        # .................................................
        cmd = F"{systemctl} unmask zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} status zzb.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, "enabled"))
        self.assertFalse(greps(out, "masked"))
        mask_file = os_path(root, "/etc/systemd/system/zzb.service")
        self.assertFalse(os.path.exists(mask_file))
        cmd = F"{systemctl} show zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, oi22(out))
        self.assertTrue(greps(out, "LoadState=loaded"))
        self.assertTrue(greps(out, "Id=zzb.service"))
        self.assertTrue(greps(out, "Names=zzb.service"))
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_23102_testing_user_mask_unmask_service(self) -> None:
        self.test_23102_testing_user_mask_unmask_service(True)
    def test_23102_testing_user_mask_unmask_service(self, real: bool = False) -> None:
        """ check that a service can be unmasked """
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        vv = "-vv"
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        self.rm_zzfiles(root)
        bindir =os_path(root, F"/bin")
        sleep = self.testname("sleep")
        copy_tool(_bin_sleep, F"{bindir}/{sleep}")
        #
        text_file(os_path(root, "/usr/lib/systemd/user/zza.service"), F"""
            [Unit]
            Description=Testing A""")
        text_file(os_path(root, "/usr/lib/systemd/user/zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            ExecStart={bindir}/{sleep} 2
            [Install]
            WantedBy=multi-user.target""")
        cmd = F"{systemctl} daemon-reload"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} enable --user zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} status --user zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, "enabled"))
        self.assertFalse(greps(out, "masked"))
        # .........................................
        cmd = F"{systemctl} mask --user zzb.service {vv} {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} status --user zzb.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertFalse(greps(out, "enabled"))
        self.assertTrue(greps(out, "masked"))
        if real: self.assertTrue(greps(out, "/dev/null"))
        else: self.assertTrue(greps(out, "None, "))
        xdg_config = os.path.expanduser("~/.config")
        mask_file = os_path(root, xdg_config + "/systemd/user/zzb.service")
        self.assertTrue(os.path.islink(mask_file))
        target = os.readlink(mask_file)
        self.assertEqual(target, "/dev/null")
        cmd = F"{systemctl} show --user zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, oi22(out))
        self.assertTrue(greps(out, "LoadState=masked"))
        self.assertTrue(greps(out, "UnitFileState=masked"))
        self.assertTrue(greps(out, "Id=zzb.service"))
        self.assertTrue(greps(out, "Names=zzb.service"))
        # .................................................
        cmd = F"{systemctl} unmask --user zzb.service {vv} {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} status --user zzb.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, "enabled"))
        self.assertFalse(greps(out, "masked"))
        xdg_config = os.path.expanduser("~/.config")
        mask_file = os_path(root, xdg_config + "/systemd/system/zzb.service")
        self.assertFalse(os.path.exists(mask_file))
        cmd = F"{systemctl} show --user zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, oi22(out))
        self.assertTrue(greps(out, "LoadState=loaded"))
        self.assertTrue(greps(out, "Id=zzb.service"))
        self.assertTrue(greps(out, "Names=zzb.service"))
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23105_is_masked_for_nonexistant_service(self) -> None:
        """ check that mask/unmask reports correctly for non-existant services """
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        bindir =os_path(root, F"/bin")
        sleep = self.testname("sleep")
        copy_tool(_bin_sleep, F"{bindir}/{sleep}")
        text_file(os_path(root, "/etc/systemd/system/zzc.service"), F"""
            [Unit]
            Description=Testing C
            [Service]
            ExecStart={bindir}/{sleep} 2
            [Install]
            WantedBy=multi-user.target""")
        #
        cmd = F"{systemctl} is-enabled zz-not-existing.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        self.assertFalse(greps(out, r"^static"))
        self.assertEqual(len(lines4(out)), 0)
        cmd = F"{systemctl} is-enabled zz-not-existing-service.service zzc.service"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(out, r"^disabled"))
        self.assertFalse(greps(out, r"^enabled"))
        self.assertEqual(len(lines4(out)), 1)
        self.assertTrue(greps(err, "Unit zz-not-existing-service.service not found."))
        #
        cmd = F"{systemctl} --no-legend mask zz-not-existing-service.service"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 5)
        self.assertTrue(greps(err, "Unit zz-not-existing-service.service not found."))
        #
        cmd = F"{systemctl} --no-legend unmask zz-not-existing-service.service"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 5)
        self.assertTrue(greps(err, "Unit zz-not-existing-service.service not found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23106_can_not_mask_sysv_services(self) -> None:
        """ check that mask/unmask reports correctly for sysv services """
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/init.d/zzz"), """
            #! /bin/bash
            ### BEGIN INIT INFO
            # Required-Start: $local_fs $remote_fs $syslog $network
            # Required-Stop:  $local_fs $remote_fs $syslog $network
            # Default-Start:  3 5
            # Default-Stop:   0 1 2 6
            # Short-Description: Testing Z
            # Description:    Allows for SysV testing
            ### END INIT INFO
            echo OK
            """)
        #
        cmd = F"{systemctl} is-enabled zzz.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        self.assertFalse(greps(out, r"^static"))
        self.assertEqual(len(lines4(out)), 1)
        #
        cmd = F"{systemctl} --no-legend mask zzz"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Initscript zzz.service can not be masked"))
        #
        cmd = F"{systemctl} --no-legend unmask zzz.service -vv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Initscript zzz.service can not be un/masked"))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23107_unusual_operations_for__mask_folder(self) -> None:
        """ check that mask/unmask folder is working correctly """
        self.begin()
        real, vv = False, "-vv"
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        bindir =os_path(root, F"/bin")
        sleep = self.testname("sleep")
        copy_tool(_bin_sleep, F"{bindir}/{sleep}")
        text_file(os_path(root, "/usr/lib/systemd/system/zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            ExecStart={bindir}/{sleep} 2
            [Install]
            WantedBy=multi-user.target""")
        #
        cmd = F"{systemctl} is-enabled zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        self.assertEqual(out.strip(), "disabled")
        #
        # .........................................
        cmd = F"{systemctl} mask zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} status zzb.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertFalse(greps(out, "enabled"))
        self.assertTrue(greps(out, "masked"))
        if real: self.assertTrue(greps(out, "/dev/null"))
        else: self.assertTrue(greps(out, "None, "))
        mask_file = os_path(root, "/etc/systemd/system/zzb.service")
        self.assertTrue(os.path.islink(mask_file))
        target = os.readlink(mask_file)
        self.assertEqual(target, "/dev/null")
        # .........................................
        cmd = F"{systemctl} mask zzb.service {vv} {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertEqual(end, 0)
        self.assertTrue(greps(err, "mask symlink does already exist"))
        cmd = F"{systemctl} mask -f zzb.service {vv} {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertEqual(end, 0)
        self.assertFalse(greps(err, "mask symlink does already exist"))
        #
        cmd = F"{systemctl} unmask zzb.service {vv} {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} unmask zzb.service {vv} {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertEqual(end, 0)
        self.assertTrue(greps(err, "Symlink did not exist anymore"))
        #
        text_file(mask_file, "#")
        cmd = F"{systemctl} mask zzb.service {vv} {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "mask target does already exist"))
        cmd = F"{systemctl} unmask zzb.service {vv} {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertEqual(end, 0)
        self.assertTrue(greps(err, "target is not a symlink"))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23120_start_default_target(self, real: bool = False) -> None:
        """ check the 'default-services' to know the enabled services """
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            ExecStart={root}/bin/{testsleep} 2
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(root, "/etc/systemd/system/zzc.service"), F"""
            [Unit]
            Description=Testing C
            [Service]
            ExecStart={root}/bin/{testsleep} 2
            [Install]
            WantedBy=multi-user.target
            """)
        if not real:
            text_file(os_path(root, "/etc/systemd/system/basic.target"), """
            [Unit]
            Description=Basic Runlevel
            Requires=sockets.target""")
            text_file(os_path(root, "/etc/systemd/system/multi-user.target"), """
            [Unit]
            Description=Basic Runlevel
            Requires=basic.target""")
            text_file(os_path(root, "/etc/systemd/system/graphical.target"), """
            [Unit]
            Description=Basic Runlevel
            Requires=multi-user.target""")
        copy_tool(_bin_sleep, F"{root}/bin/{testsleep}")
        #
        cmd = F"{systemctl} default-services"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines4(out)), 0)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} --no-legend enable zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} default-services"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines4(out)), 1)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} --no-legend enable zzc.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} default-services"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines4(out)), 2)
        self.assertEqual(end, 0)
        #
        self.assertFalse(greps(out, "a.service"))
        self.assertTrue(greps(out, "b.service"))
        self.assertTrue(greps(out, "c.service"))
        #
        cmd = F"{systemctl} start multi-user.target"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        top = greps(_recent(output(_top_list)), testsleep)
        logg.info("top>>>\n| %s", "\n| ".join(top))
        self.assertEqual(len(greps(top, testsleep)), 2)
        #
        cmd = F"{systemctl} stop multi-user.target"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        top = greps(_recent(output(_top_list)), testsleep)
        logg.info("top>>>\n| %s", "\n| ".join(top))
        self.assertEqual(len(greps(top, testsleep)), 0)
        #
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23126_default_services_for_different_target(self, real: bool = False) -> None:
        """ check that 'default-services' changes when modifing default-target """
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep=self.testname("sleep")
        text_file(os_path(root, "/etc/systemd/system/zza.service"), F"""
            [Unit]
            Description=Testing A""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            ExecStart={root}/bin/{testsleep} 2
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(root, "/etc/systemd/system/zzc.service"), F"""
            [Unit]
            Description=Testing C
            [Service]
            ExecStart={root}/bin/{testsleep} 2
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(root, "/etc/systemd/system/zzd.service"), F"""
            [Unit]
            Description=Testing D
            [Service]
            ExecStart={root}/bin/{testsleep} 2
            [Install]
            WantedBy=graphical.target
            """)
        if not real:
            text_file(os_path(root, "/etc/systemd/system/basic.target"), """
            [Unit]
            Description=Basic Runlevel
            Requires=sockets.target""")
            text_file(os_path(root, "/etc/systemd/system/multi-user.target"), """
            [Unit]
            Description=Basic Runlevel
            Requires=basic.target""")
            text_file(os_path(root, "/etc/systemd/system/graphical.target"), """
            [Unit]
            Description=Basic Runlevel
            Requires=multi-user.target""")
        copy_tool(_bin_sleep, F"{root}/bin/{testsleep}")
        #
        cmd = F"{systemctl} default-services"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines4(out)), 0)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} --no-legend enable zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} --no-legend enable zzc.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} default-services"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines4(out)), 2)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} get-default"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(out.strip(), "multi-user.target")
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} set-default graphical.target"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} get-default"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(out.strip(), "graphical.target")
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} --no-legend enable zzd.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} default-services -vvvv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines4(out)), 3)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} set-default multi-user.target"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} default-services -vvvv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines4(out)), 2)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} set-default basic.target"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} default-services -vvvv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines4(out)), 0)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} default-services multi-user.target -vvvv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines4(out)), 2)
        self.assertEqual(end, 0)
        #
        ###############################################
        #
        cmd = F"{systemctl} start multi-user.target -vvvv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        top = greps(_recent(output(_top_list)), testsleep)
        logg.info("top>>>\n| %s", "\n| ".join(top))
        self.assertEqual(len(greps(top, testsleep)), 2)
        #
        cmd = F"{systemctl} stop multi-user.target"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        top = greps(_recent(output(_top_list)), testsleep)
        logg.info("top>>>\n| %s", "\n| ".join(top))
        self.assertEqual(len(greps(top, testsleep)), 0)
        #
        cmd = F"{systemctl} start graphical.target"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        top = greps(_recent(output(_top_list)), testsleep)
        logg.info("top>>>\n| %s", "\n| ".join(top))
        self.assertEqual(len(greps(top, testsleep)), 3)
        #
        cmd = F"{systemctl} stop graphical.target"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        top = greps(_recent(output(_top_list)), testsleep)
        logg.info("top>>>\n| %s", "\n| ".join(top))
        self.assertEqual(len(greps(top, testsleep)), 0)
        #
        cmd = F"{systemctl} start graphical.target"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        top = greps(_recent(output(_top_list)), testsleep)
        logg.info("top>>>\n| %s", "\n| ".join(top))
        self.assertEqual(len(greps(top, testsleep)), 3)
        #
        cmd = F"{systemctl} stop multi-user.target"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        top = greps(_recent(output(_top_list)), testsleep)
        logg.info("top>>>\n| %s", "\n| ".join(top))
        self.assertEqual(len(greps(top, testsleep)), 1)
        #
        cmd = F"{systemctl} stop graphical.target"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        top = greps(_recent(output(_top_list)), testsleep)
        logg.info("top>>>\n| %s", "\n| ".join(top))
        self.assertEqual(len(greps(top, testsleep)), 0)
        #
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23127_default_services_for_invented_target(self, real: bool = False) -> None:
        """ check that 'default-services' changes when modifing default-target """
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep=self.testname("sleep")
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            ExecStart={root}/bin/{testsleep} 4
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(root, "/etc/systemd/system/zzc.service"), F"""
            [Unit]
            Description=Testing C
            [Service]
            ExecStart={root}/bin/{testsleep} 4
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(root, "/etc/systemd/system/zzd.service"), F"""
            [Unit]
            Description=Testing D
            [Service]
            ExecStart={root}/bin/{testsleep} 4
            [Install]
            WantedBy=graphical.target
            """)
        text_file(os_path(root, "/etc/systemd/system/zze.service"), F"""
            [Unit]
            Description=Testing E
            [Service]
            ExecStart={root}/bin/{testsleep} 4
            [Install]
            WantedBy=invented.target
            """)
        text_file(os_path(root, "/etc/systemd/system/zzi.service"), F"""
            [Unit]
            Description=Testing E
            [Service]
            ExecStart={root}/bin/{testsleep} 4
            [Install]
            WantedBy=isolated.target""")
        text_file(os_path(root, "/etc/systemd/system/invented.target"), """
            [Unit]
            Description=Invented Runlevel
            Requires=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/isolated.target"), """
            [Unit]
            Description=Isolated Runlevel""")
        if not real:
            text_file(os_path(root, "/etc/systemd/system/basic.target"), """
            [Unit]
            Description=Basic Runlevel
            Requires=sockets.target""")
            text_file(os_path(root, "/etc/systemd/system/multi-user.target"), """
            [Unit]
            Description=Basic Runlevel
            Requires=basic.target""")
            text_file(os_path(root, "/etc/systemd/system/graphical.target"), """
            [Unit]
            Description=Basic Runlevel
            Requires=multi-user.target""")
        copy_tool(_bin_sleep, F"{root}/bin/{testsleep}")
        #
        cmd = F"{systemctl} list-unit-files --type=target"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertGreater(len(lines4(out)), 6)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, "invented.target"))
        #
        cmd = F"{systemctl} default-services"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines4(out)), 0)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} --no-legend enable zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} --no-legend enable zzc.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} default-services"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines4(out)), 2)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} get-default"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(out.strip(), "multi-user.target")
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} set-default graphical.target"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} get-default"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(out.strip(), "graphical.target")
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} --no-legend enable zzd.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} default-services -vvvv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines4(out)), 3)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} set-default multi-user.target"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} default-services -vvvv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines4(out)), 2)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} set-default nonexistant.target"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertTrue(greps(out, "No such runlevel"))
        #
        cmd = F"{systemctl} set-default invented.target"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} default-services -vvvv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines4(out)), 2)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} --no-legend enable zze.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} default-services -vvvv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines4(out)), 3)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} set-default isolated.target"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} default-services -vvvv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines4(out)), 0)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} --no-legend enable zzi.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} default-services -vvvv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines4(out)), 1)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} set-default invented.target"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} default-services -vvvv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines4(out)), 3)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} --no-legend disable zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} default-services -vvvv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines4(out)), 2)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} default-services multi-user.target -vvvv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines4(out)), 1)
        self.assertEqual(end, 0)
        #
        ###############################################
        #
        cmd = F"{systemctl} start multi-user.target"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        top = greps(_recent(output(_top_list)), testsleep)
        logg.info("top>>>\n| %s", "\n| ".join(top))
        self.assertEqual(len(greps(top, testsleep)), 1)
        #
        cmd = F"{systemctl} stop multi-user.target"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        top = greps(_recent(output(_top_list)), testsleep)
        logg.info("top>>>\n| %s", "\n| ".join(top))
        self.assertEqual(len(greps(top, testsleep)), 0)
        #
        cmd = F"{systemctl} start invented.target"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        top = greps(_recent(output(_top_list)), testsleep)
        logg.info("top>>>\n| %s", "\n| ".join(top))
        self.assertEqual(len(greps(top, testsleep)), 2)
        #
        cmd = F"{systemctl} stop invented.target"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        top = greps(_recent(output(_top_list)), testsleep)
        logg.info("top>>>\n| %s", "\n| ".join(top))
        self.assertEqual(len(greps(top, testsleep)), 0)
        #
        cmd = F"{systemctl} start isolated.target"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        top = greps(_recent(output(_top_list)), testsleep)
        logg.info("top>>>\n| %s", "\n| ".join(top))
        self.assertEqual(len(greps(top, testsleep)), 1)
        #
        cmd = F"{systemctl} reload isolated.target"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        top = greps(_recent(output(_top_list)), testsleep)
        logg.info("top>>>\n| %s", "\n| ".join(top))
        self.assertEqual(len(greps(top, testsleep)), 1)
        #
        cmd = F"{systemctl} restart isolated.target -vvvv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        time.sleep(1)
        #
        top = greps(_recent(output(_top_list)), testsleep)
        logg.info("top>>>\n| %s", "\n| ".join(top))
        self.assertEqual(len(greps(top, testsleep)), 1)
        #
        cmd = F"{systemctl} stop isolated.target"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        top = greps(_recent(output(_top_list)), testsleep)
        logg.info("top>>>\n| %s", "\n| ".join(top))
        self.assertEqual(len(greps(top, testsleep)), 0)
        #
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23201_missing_environment_file_makes_service_ignored(self) -> None:
        """ check that a missing EnvironmentFile spec makes the service to be ignored"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zzz.service"), F"""
            [Unit]
            Description=Testing Z
            [Service]
            Type=simple
            EnvironmentFile=/foo.conf
            ExecStart={bindir}/{testsleep} 111
            [Install]
            WantedBy=multi-user.target
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        #
        start_service = F"{systemctl} start zzz.service -vv"
        end = sx____(start_service)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        self.assertGreater(end, 0)
        #
        stop_service = F"{systemctl} stop zzz.service -vv"
        end = sx____(stop_service)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        self.assertGreater(end, 0)
        #
        cmd = F"{systemctl} __killall {testsleep}"
        sx____(cmd)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23211_environment_files_are_included(self) -> None:
        """ check that environment specs are read correctly"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        logfile = os_path(root, "/var/log/test.log")
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zzz.service"), F"""
            [Unit]
            Description=Testing Z
            AssertFileIsExecutable=//usr/bin/killall
            [Service]
            Type=simple
            EnvironmentFile=/etc/sysconfig/zzz.conf
            Environment=CONF4=dd4
            ExecStart={bindir}/zzz.sh
            ExecStop=/usr/bin/killall {testsleep}
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zzz.sh"), F"""
            #! /bin/sh
            echo "WITH CONF1=$CONF1" >> {logfile}
            echo "WITH CONF2=$CONF2" >> {logfile}
            echo "WITH CONF3=$CONF3" >> {logfile}
            echo "WITH CONF4=$CONF4" >> {logfile}
            {bindir}/{testsleep} 4
            """)
        text_file(os_path(testdir, "zzz.conf"), F"""
            CONF1=aa1
            CONF2="bb2"
            CONF3='cc3'
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_tool(os_path(testdir, "zzz.sh"), os_path(bindir, "zzz.sh"))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        copy_file(os_path(testdir, "zzz.conf"), os_path(root, "/etc/sysconfig/zzz.conf"))
        #
        start_service = F"{systemctl} start zzz.service -vv"
        end = sx____(start_service)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        self.assertEqual(end, 0)
        #
        log = lines4(open(logfile))
        logg.info("LOG \n| %s", "\n| ".join(log))
        self.assertTrue(greps(log, "WITH CONF1=aa1"))
        self.assertTrue(greps(log, "WITH CONF2=bb2"))
        self.assertTrue(greps(log, "WITH CONF3=cc3"))
        self.assertTrue(greps(log, "WITH CONF4=dd4"))
        os.remove(logfile)
        #
        stop_service = F"{systemctl} stop zzz.service -vv"
        end = sx____(stop_service)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        #
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23240_may_expand_environment_variables(self) -> None:
        """ check that different styles of environment
            variables get expanded."""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        print_sh = os_path(root, "/usr/bin/print.sh")
        logfile = os_path(root, "/var/log/print_sh.log")
        text_file(os_path(root, "/etc/sysconfig/b.conf"), """
            DEF1='def1'
            DEF2="def2 def3"
            DEF4="$DEF1 ${DEF2}"
            DEF5="$DEF1111 def5 ${DEF2222}"
            """)
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Environment=DEF2=foo
            EnvironmentFile=/etc/sysconfig/b.conf
            ExecStart=/bin/sleep 3
            ExecStartPost=%s A $DEF1 $DEF2
            ExecStartPost=%s B ${DEF1} ${DEF2}
            ExecStartPost=%s C $DEF1$DEF2
            ExecStartPost=%s D ${DEF1}${DEF2}
            ExecStartPost=%s E ${DEF4}
            ExecStartPost=%s F ${DEF5}
            [Install]
            WantedBy=multi-user.target"""
                  % (print_sh, print_sh, print_sh, print_sh,
                     print_sh, print_sh,))
        text_file(logfile, "")
        shell_file(print_sh, F"""
            #! /bin/sh
            logfile='{logfile}'
            echo "'$1' '$2' '$3' '$4' '$5'" >> "$logfile"
            """)
        cmd = F"{systemctl} environment zzb.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"^DEF1=def1"))
        self.assertTrue(greps(out, r"^DEF2=def2 def3"))
        #
        cmd = F"{systemctl} start zzb.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        log = lines4(open(logfile))
        logg.info("LOG \n%s", log)
        A="'A' 'def1' 'def2' 'def3' ''"   # A $DEF1 $DEF2
        B="'B' 'def1' 'def2 def3' '' ''"  # B ${DEF1} ${DEF2}
        C="'C' 'def1def2' 'def3' '' ''"   # C $DEF1$DEF2
        D="'D' 'def1def2 def3' '' '' ''"  # D ${DEF1}${DEF2} ??TODO??
        E="'E' 'def1 def2 def3' '' '' ''" # E ${DEF4}
        # F="'F' ' def5 ' '' '' ''"       # F ${DEF5}
        F="'F' '$DEF1111 def5 ${DEF2222}' '' '' ''"
        self.assertIn(A, log)
        self.assertIn(B, log)
        self.assertIn(C, log)
        self.assertIn(D, log)
        self.assertIn(E, log)
        self.assertIn(F, log)
        #
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_23250_nonlazy_expand_variables(self) -> None:
        self.test_23250_nonlazy_expand_variables(True)
    def test_23250_nonlazy_expand_variables(self, real: bool = False) -> None:
        """ check that variables can contain variables that get (not?) expanded."""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        print_sh = os_path(root, "/usr/bin/zz_print.sh")
        logfile = os_path(root, "/var/log/zz_print_sh.log")
        text_file(os_path(root, "/etc/sysconfig/zz_b.conf"), """
            DEF1='def1'
            DEF3="${DEF4}.${DEF5}"
            DEF4="${DEF1}.${DEF2}"
            DEF5="${DEF1111}.def5.${DEF2222}"
            DEF6="${DEF3}.${DEF3}"
            """)
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Environment=DEF2=def2.def3
            EnvironmentFile=/etc/sysconfig/zz_b.conf
            ExecStart=/bin/sleep 3
            ExecStartPost=%s A.${DEF1}
            ExecStartPost=%s B.${DEF2}
            ExecStartPost=%s C.${DEF3}
            ExecStartPost=%s D.${DEF4}
            ExecStartPost=%s E.${DEF5}
            ExecStartPost=%s F.${DEF6}
            [Install]
            WantedBy=multi-user.target"""
                  % (print_sh, print_sh, print_sh, print_sh,
                     print_sh, print_sh,))
        text_file(logfile, "")
        shell_file(print_sh, F"""
            #! /bin/sh
            logfile='{logfile}'
            echo "'$1'" >> "$logfile"
            """)
        #
        cmd = F"{systemctl} start zzb.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        log = lines4(open(logfile))
        logg.info("LOG \n%s", log)
        if real:
            A="'A.def1'"
            B="'B.def2.def3'"
            C="'C.${DEF4}.${DEF5}'"
            D="'D.${DEF1}.${DEF2}'"  # TODO
            E="'E.${DEF1111}.def5.${DEF2222}'"
            F="'F.${DEF3}.${DEF3}'"  # TODO
        else:
            A="'A.def1'"
            B="'B.def2.def3'"
            C="'C.${DEF4}.${DEF5}'"
            D="'D.def1.def2.def3'"
            E="'E.${DEF1111}.def5.${DEF2222}'"
            F="'F.def1.def2.def3.${DEF1111}.def5.${DEF2222}.def1.def2.def3.${DEF1111}.def5.${DEF2222}'"
        # so effectivly both systemctl.py and sysd-systemctl do no lazy expansion
        # here - but sysd-systemctl will keep the unkonwn value in the text.
        self.assertIn(A, log)
        self.assertIn(B, log)
        self.assertIn(C, log)
        self.assertIn(D, log)
        self.assertIn(E, log)
        self.assertIn(F, log)
        #
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23251_nonlazy_expand_variables_empty_vars(self, real: bool = False) -> None:
        """ check that variables can contain variables that get (not?) expanded.
            Here we show the oldstyle result (up to systemctl.py v1.4)"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        systemctl += " -c EXPAND_KEEP_VARS=no"
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        print_sh = os_path(root, "/usr/bin/zz_print.sh")
        logfile = os_path(root, "/var/log/zz_print_sh.log")
        text_file(os_path(root, "/etc/sysconfig/zz_b.conf"), """
            DEF1='def1'
            DEF3="${DEF4}.${DEF5}"
            DEF4="${DEF1}.${DEF2}"
            DEF5="${DEF1111}.def5.${DEF2222}"
            DEF6="${DEF3}.${DEF3}"
            """)
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Environment=DEF2=def2.def3
            EnvironmentFile=/etc/sysconfig/zz_b.conf
            ExecStart=/bin/sleep 3
            ExecStartPost=%s A.${DEF1}
            ExecStartPost=%s B.${DEF2}
            ExecStartPost=%s C.${DEF3}
            ExecStartPost=%s D.${DEF4}
            ExecStartPost=%s E.${DEF5}
            ExecStartPost=%s F.${DEF6}
            [Install]
            WantedBy=multi-user.target"""
                  % (print_sh, print_sh, print_sh, print_sh,
                     print_sh, print_sh,))
        text_file(logfile, "")
        shell_file(print_sh, F"""
            #! /bin/sh
            logfile='{logfile}'
            echo "'$1'" >> "$logfile"
            """)
        #
        cmd = F"{systemctl} start zzb.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        log = lines4(open(logfile))
        logg.info("LOG \n%s", log)
        if real:
            A="'A.def1'"
            B="'B.def2.def3'"
            C="'C.${DEF4}.${DEF5}'"
            D="'D.${DEF1}.${DEF2}'"
            E="'E.${DEF1111}.def5.${DEF2222}'"
            F="'F.${DEF3}.${DEF3}'"
        else:
            A="'A.def1'"
            B="'B.def2.def3'"
            C="'C..'"
            D="'D.def1.def2.def3'"
            E="'E..def5.'"
            F="'F....'"
        # so effectivly both systemctl.py and sysd-systemctl do no lazy expansion
        # here - but sysd-systemctl will keep the unkonwn value in the text.
        self.assertIn(A, log)
        self.assertIn(B, log)
        self.assertIn(C, log)
        self.assertIn(D, log)
        self.assertIn(E, log)
        self.assertIn(F, log)
        #
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_23260_recursive_expand_variables(self) -> None:
        self.test_23260_recursive_expand_variables(True)
    def test_23260_recursive_expand_variables(self, real: bool = False) -> None:
        """ check that variables can contain variables that get (not?) expanded."""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        systemctl += " -c EXPAND_VARS_MAXDEPTH=5"
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        print_sh = os_path(root, "/usr/bin/zz_print.sh")
        logfile = os_path(root, "/var/log/zz_print_sh.log")
        text_file(os_path(root, "/etc/sysconfig/zz_b.conf"), """
            DEF1='def1'
            DEF3="${DEF4}.def3"
            DEF4="${DEF1}.${${DEF2}}"
            DEF5="${DEF1}.${${DEF3}}"
            DEF6="${DEF3}.${DEF3}"
            """)
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Environment=DEF2=DEF3
            EnvironmentFile=/etc/sysconfig/zz_b.conf
            ExecStart=/bin/sleep 3
            ExecStartPost=%s A.${DEF1}
            ExecStartPost=%s B.${DEF2}
            ExecStartPost=%s C.${DEF3}
            ExecStartPost=%s D.${DEF4}
            ExecStartPost=%s E.${DEF5}
            ExecStartPost=%s F.${DEF6}
            [Install]
            WantedBy=multi-user.target"""
                  % (print_sh, print_sh, print_sh, print_sh,
                     print_sh, print_sh,))
        text_file(logfile, "")
        shell_file(print_sh, F"""
            #! /bin/sh
            logfile='{logfile}'
            echo "'$1'" >> "$logfile"
            """)
        #
        cmd = F"{systemctl} start zzb.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        log = lines4(open(logfile))
        logg.info("LOG \n%s", log)
        if real:
            A="'A.def1'"
            B="'B.DEF3'"
            C="'C.${DEF4}.def3'"
            D="'D.${DEF1}.${${DEF2}}'"  # todo?
            E="'E.${DEF1}.${${DEF3}}'"  # todo?
            F="'F.${DEF3}.${DEF3}'"     # todo?
        else:
            A="'A.def1'"
            B="'B.DEF3'"
            C="'C.${DEF4}.def3'"
            D="'D.def1.${DEF4}.def3'"
            E="'E.def1.${def1.def1.def1.def1.${DEF4}.def3.def3.def3.def3.def3}'"
            F="'F.def1.def1.def1.def1.${DEF4}.def3.def3.def3.def3.def3.def1.def1.def1.def1.${DEF4}.def3.def3.def3.def3.def3'"
        # so effectivly sysd-systemctl does not have a recursive expansion #TODO?
        self.assertIn(A, log)
        self.assertIn(B, log)
        self.assertIn(C, log)
        self.assertIn(D, log)
        self.assertIn(E, log)
        self.assertIn(F, log)
        #
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_23270_env_may_expand_special_variables(self) -> None:
        self.test_23270_env_may_expand_special_variables(True)
    def test_23270_env_may_expand_special_variables(self, real: bool = False) -> None:
        """ check that different flavours for special
            variables get expanded."""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        vv = "-vv"
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        print_sh = os_path(root, "/usr/bin/zzprint.sh")
        logfile = os_path(root, "/var/log/zzprint_sh.log")
        service_file = os_path(root, "/etc/systemd/system/zzb_zzc.service")
        text_file(service_file, """
            [Unit]
            Description=Testing B
            [Service]
            Environment=X=x1
            Environment="Y=y2 y3"
            ExecStart=/bin/sleep 3
            ExecStartPost=%s _N_ %%N $X ${Y}
            ExecStartPost=%s _n_ %%n $X ${Y}
            ExecStartPost=%s _f_ %%f $X ${Y}
            ExecStartPost=%s _t_ %%t $X ${Y}
            ExecStartPost=%s _P_ %%P $X ${Y}
            ExecStartPost=%s _p_ %%p $X ${Y}
            ExecStartPost=%s _I_ %%I $X ${Y}
            ExecStartPost=%s _i_ %%i $X ${Y} $FOO
            ExecStartPost=%s _T_ %%T $X ${Y}
            ExecStartPost=%s _V_ %%V $X ${Y}
            ExecStartPost=%s _Z_ %%Z $X ${Y} ${FOO}
            [Install]
            WantedBy=multi-user.target"""
                  % (print_sh, print_sh, print_sh, print_sh,
                     print_sh, print_sh, print_sh, print_sh,
                     print_sh, print_sh, print_sh))
        text_file(logfile, "")
        shell_file(print_sh, F"""
            #! /bin/sh
            logfile='{logfile}'
            echo "'$1' '$2' '$3' '$4' '$5'" >> "$logfile"
            """)
        #
        RUN = "/run" # for system-mode
        cmd = F"{systemctl} start 'zzb_zzc.service' {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        log = lines4(open(logfile))
        logg.info("LOG \n%s", log)
        _N_="'_N_' 'zzb_zzc' 'x1' 'y2 y3' ''"
        _n_="'_n_' 'zzb_zzc.service' 'x1' 'y2 y3' ''"
        _f_="'_f_' '/zzb_zzc' 'x1' 'y2 y3' ''"
        _t_="'_t_' '%s' 'x1' 'y2 y3' ''" % os_path(root, RUN)  # pylint: disable=consider-using-f-string
        _P_="'_P_' 'zzb_zzc' 'x1' 'y2 y3' ''"
        _p_="'_p_' 'zzb_zzc' 'x1' 'y2 y3' ''"
        _I_="'_I_' '' 'x1' 'y2 y3' ''"
        _i_="'_i_' '' 'x1' 'y2 y3' ''"
        _T_="'_T_' '%s' 'x1' 'y2 y3' ''" % os_path(root, "/tmp")  # pylint: disable=consider-using-f-string
        _V_="'_V_' '%s' 'x1' 'y2 y3' ''" % os_path(root, "/var/tmp")  # pylint: disable=consider-using-f-string
        _Z_="'_Z_' '' 'x1' 'y2 y3' ''"
        self.assertIn(_N_, log)
        self.assertIn(_n_, log)
        self.assertIn(_f_, log)
        self.assertIn(_t_, log)
        self.assertIn(_P_, log)
        self.assertIn(_p_, log)
        self.assertIn(_I_, log)
        self.assertIn(_i_, log)
        if not real:
            self.assertIn(_T_, log)
            self.assertIn(_V_, log)
            self.assertIn(_Z_, log)
        #
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
        self.end()
    def real_23275_env_may_expand_special_variables(self) -> None:
        self.test_23275_env_may_expand_special_variables(True)
    def test_23275_env_may_expand_special_variables(self, real: bool = False) -> None:
        """ check that different flavours for special
            variables get expanded."""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        vv = "-vv"
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        print_sh = os_path(root, "/usr/bin/zzprint.sh")
        logfile = os_path(root, "/var/log/zzprint_sh.log")
        service_file = os_path(root, "/etc/systemd/system/zzb\\x20zzc.service")
        text_file(service_file, """
            [Unit]
            Description=Testing B
            [Service]
            Environment=X=x1
            Environment="Y=y2 y3"
            ExecStart=/bin/sleep 3
            ExecStartPost=%s _N_ %%N $X ${Y}
            ExecStartPost=%s _n_ %%n $X ${Y}
            ExecStartPost=%s _f_ %%f $X ${Y}
            ExecStartPost=%s _t_ %%t $X ${Y}
            ExecStartPost=%s _P_ %%P $X ${Y}
            ExecStartPost=%s _p_ %%p $X ${Y}
            ExecStartPost=%s _I_ %%I $X ${Y}
            ExecStartPost=%s _i_ %%i $X ${Y} $FOO
            ExecStartPost=%s _T_ %%T $X ${Y}
            ExecStartPost=%s _V_ %%V $X ${Y}
            ExecStartPost=%s _Z_ %%Z $X ${Y} ${FOO}
            [Install]
            WantedBy=multi-user.target"""
                  % (print_sh, print_sh, print_sh, print_sh,
                     print_sh, print_sh, print_sh, print_sh,
                     print_sh, print_sh, print_sh))
        text_file(logfile, "")
        shell_file(print_sh, F"""
            #! /bin/sh
            logfile='{logfile}'
            echo "'$1' '$2' '$3' '$4' '$5'" >> "$logfile"
            """)
        #
        RUN = "/run" # for system-mode
        cmd = F"{systemctl} start 'zzb\\x20zzc.service' {vv}"
        if real: cmd = F"{systemctl} start 'zzb zzc.service' {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        log = lines4(open(logfile))
        logg.info("LOG \n%s", log)
        _N_="'_N_' 'zzb\\x20zzc' 'x1' 'y2 y3' ''"
        _n_="'_n_' 'zzb\\x20zzc.service' 'x1' 'y2 y3' ''"
        _f_="'_f_' '/zzb zzc' 'x1' 'y2 y3' ''"
        _t_="'_t_' '%s' 'x1' 'y2 y3' ''" % os_path(root, RUN)  # pylint: disable=consider-using-f-string
        _P_="'_P_' 'zzb zzc' 'x1' 'y2 y3' ''"
        _p_="'_p_' 'zzb\\x20zzc' 'x1' 'y2 y3' ''"
        _I_="'_I_' '' 'x1' 'y2 y3' ''"
        _i_="'_i_' '' 'x1' 'y2 y3' ''"
        _T_="'_T_' '%s' 'x1' 'y2 y3' ''" % os_path(root, "/tmp")  # pylint: disable=consider-using-f-string
        _V_="'_V_' '%s' 'x1' 'y2 y3' ''" % os_path(root, "/var/tmp")  # pylint: disable=consider-using-f-string
        _Z_="'_Z_' '' 'x1' 'y2 y3' ''"
        self.assertIn(_N_, log)
        self.assertIn(_n_, log)
        self.assertIn(_f_, log)
        self.assertIn(_t_, log)
        self.assertIn(_P_, log)
        self.assertIn(_p_, log)
        self.assertIn(_I_, log)
        self.assertIn(_i_, log)
        if not real:
            self.assertIn(_T_, log)
            self.assertIn(_V_, log)
            self.assertIn(_Z_, log)
        #
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
        self.end()
    def test_23280_user_mode_env_may_expand_special_variables(self, real: bool = False) -> None:
        """ check that different flavours for special
            variables get expanded. Differently in --user mode."""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        print_sh = os_path(root, "/usr/bin/print.sh")
        logfile = os_path(root, "/var/log/print_sh.log")
        service_file = os_path(root, "/etc/systemd/user/zzb zzc.service")
        text_file(service_file, """
            [Unit]
            Description=Testing B
            [Service]
            Environment=X=x1
            Environment="Y=y2 y3"
            ExecStart=/bin/sleep 3
            ExecStartPost=%s _N_ %%N $X ${Y}
            ExecStartPost=%s _n_ %%n $X ${Y}
            ExecStartPost=%s _f_ %%f $X ${Y}
            ExecStartPost=%s _t_ %%t $X ${Y}
            ExecStartPost=%s _P_ %%P $X ${Y}
            ExecStartPost=%s _p_ %%p $X ${Y}
            ExecStartPost=%s _I_ %%I $X ${Y}
            ExecStartPost=%s _i_ %%i $X ${Y} $FOO
            ExecStartPost=%s _T_ %%T $X ${Y}
            ExecStartPost=%s _V_ %%V $X ${Y}
            ExecStartPost=%s _Z_ %%Z $X ${Y} ${FOO}
            [Install]
            WantedBy=multi-user.target"""
                  % (print_sh, print_sh, print_sh, print_sh,
                     print_sh, print_sh, print_sh, print_sh,
                     print_sh, print_sh, print_sh))
        text_file(logfile, "")
        shell_file(print_sh, F"""
            #! /bin/sh
            logfile='{logfile}'
            echo "'$1' '$2' '$3' '$4' '$5'" >> "$logfile"
            """)
        #
        RUN = "/run" # for system-mode
        RUN = get_runtime_dir()
        cmd = F"{systemctl} --user start 'zzb zzc.service' -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        log = lines4(open(logfile))
        logg.info("LOG \n%s", log)
        _N_="'_N_' 'zzb zzc' 'x1' 'y2 y3' ''"
        _n_="'_n_' 'zzb zzc.service' 'x1' 'y2 y3' ''"
        _f_="'_f_' '/zzb zzc' 'x1' 'y2 y3' ''"
        _t_="'_t_' '%s' 'x1' 'y2 y3' ''" % os_path(root, RUN)  # pylint: disable=consider-using-f-string
        _P_="'_P_' 'zzb zzc' 'x1' 'y2 y3' ''"
        _p_="'_p_' 'zzb zzc' 'x1' 'y2 y3' ''"
        _I_="'_I_' '' 'x1' 'y2 y3' ''"
        _i_="'_i_' '' 'x1' 'y2 y3' ''"
        _T_="'_T_' '%s' 'x1' 'y2 y3' ''" % os_path(root, "/tmp")  # pylint: disable=consider-using-f-string
        _V_="'_V_' '%s' 'x1' 'y2 y3' ''" % os_path(root, "/var/tmp")  # pylint: disable=consider-using-f-string
        _Z_="'_Z_' '' 'x1' 'y2 y3' ''"
        self.assertIn(_N_, log)
        self.assertIn(_n_, log)
        self.assertIn(_f_, log)
        self.assertIn(_t_, log)
        self.assertIn(_P_, log)
        self.assertIn(_p_, log)
        self.assertIn(_I_, log)
        self.assertIn(_i_, log)
        if not real:
            self.assertIn(_T_, log)
            self.assertIn(_V_, log)
            self.assertIn(_Z_, log)
        #
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23290_may_override_environment_from_commandline(self) -> None:
        """ check that --extra-vars can be given on the commandline
            to override settings in Environment= and EnvironmentFile=."""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        print_sh = os_path(root, "/usr/bin/print.sh")
        logfile = os_path(root, "/var/log/print_sh.log")
        service_file = os_path(root, "/etc/systemd/system/zzb zzc.service")
        env_file = "/etc/sysconfig/my.conf"
        extra_vars_file = "/etc/sysconfig/extra.conf"
        env_text_file = os_path(root, env_file)
        extra_vars_text_file = os_path(root, extra_vars_file)
        text_file(env_text_file, """
            M="emm a"
            N='enn i'
        """)
        text_file(extra_vars_text_file, """
            R="rob o"
            Y='knew it'
        """)
        text_file(service_file, """
            [Unit]
            Description=Testing B
            [Service]
            Environment=X=x1
            Environment="Y=y2 y3"
            EnvironmentFile=%s
            ExecStart=/bin/sleep 3
            ExecStartPost=%s X: $X ${X}
            ExecStartPost=%s Y: $Y ${Y}
            ExecStartPost=%s M: $M ${M}
            ExecStartPost=%s N: $N ${N}
            ExecStartPost=%s R: $R ${R}
            ExecStartPost=%s S: $S ${S}
            ExecStartPost=%s T: $T ${T}
            [Install]
            WantedBy=multi-user.target"""
                  % (env_file, print_sh, print_sh, print_sh,
                     print_sh, print_sh, print_sh, print_sh, ))
        text_file(logfile, "")
        shell_file(print_sh, F"""
            #! /bin/sh
            logfile='{logfile}'
            echo "'$1' '$2' '$3' '$4' '$5'" >> "$logfile"
            """)
        #
        cmd = F"{systemctl} start 'zzb zzc.service' -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        log = lines4(open(logfile))
        logg.info("LOG \n%s", log)
        X="'X:' 'x1' 'x1' '' ''"  #
        Y="'Y:' 'y2' 'y3' 'y2 y3' ''"
        M="'M:' 'emm' 'a' 'emm a' ''"
        N="'N:' 'enn' 'i' 'enn i' ''"
        R="'R:' '' '' '' ''"
        S="'S:' '' '' '' ''"
        T="'T:' '' '' '' ''"
        self.assertIn(X, log)
        self.assertIn(Y, log)
        self.assertIn(M, log)
        self.assertIn(N, log)
        self.assertIn(R, log)
        self.assertIn(S, log)
        self.assertIn(T, log)
        #
        cmd = F"{systemctl} stop 'zzb zzc.service'"
        out, end = output2(cmd)
        time.sleep(1)
        cmd = F"{systemctl} start 'zzb zzc.service' -vv -e X=now --environment 'M=more N=from' --extra-vars @" + extra_vars_file
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        log = lines4(open(logfile))
        logg.info("LOG \n%s", log)
        X="'X:' 'now' 'now' '' ''"  #
        Y="'Y:' 'knew' 'it' 'knew it' ''"
        M="'M:' 'more' 'more' '' ''"
        N="'N:' 'from' 'from' '' ''"
        R="'R:' 'rob' 'o' 'rob o' ''"
        S="'S:' '' '' '' ''"
        T="'T:' '' '' '' ''"
        self.assertIn(X, log)
        self.assertIn(Y, log)
        self.assertIn(M, log)
        self.assertIn(N, log)
        self.assertIn(R, log)
        self.assertIn(S, log)
        self.assertIn(T, log)
        #
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23301_service_config_show(self) -> None:
        """ check that a named service config can show its properties"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        logfile = os_path(root, "/var/log/test.log")
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zzs.service"), F"""
            [Unit]
            Description=Testing S
            After=foo.service
            AssertFileIsExecutable=//usr/bin/killall
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleep} 99
            ExecStop=/usr/bin/killall {testsleep}
            [Install]
            WantedBy=multi-user.target
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzs.service"), os_path(root, "/etc/systemd/system/zzs.service"))
        #
        cmd = F"{systemctl} show zzs.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        data = lines4(out)
        self.assertTrue(greps(data, "Id=zzs.service"))
        self.assertTrue(greps(data, "Names=zzs.service"))
        self.assertTrue(greps(data, "Description=Testing"))
        self.assertFalse(greps(data, "MainPID=0"))
        self.assertTrue(greps(data, "SubState=dead"))
        self.assertTrue(greps(data, "ActiveState=inactive"))
        self.assertTrue(greps(data, "LoadState=loaded"))
        self.assertTrue(greps(data, "UnitFileState=disabled"))
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} enable zzs.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} show zzs.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        data = lines4(out)
        self.assertTrue(greps(data, "Id=zzs.service"))
        self.assertTrue(greps(data, "Names=zzs.service"))
        self.assertTrue(greps(data, "Description=Testing"))
        self.assertFalse(greps(data, "MainPID=0"))
        self.assertTrue(greps(data, "SubState=dead"))
        self.assertTrue(greps(data, "ActiveState=inactive"))
        self.assertTrue(greps(data, "LoadState=loaded"))
        self.assertTrue(greps(data, "UnitFileState=enabled")) # <<<
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} start zzs.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} show zzs.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        data = lines4(out)
        self.assertTrue(greps(data, "Id=zzs.service"))
        self.assertTrue(greps(data, "Names=zzs.service"))
        self.assertTrue(greps(data, "Description=Testing"))
        self.assertTrue(greps(data, "MainPID=[123456789][1234567890]*")) # <<<<
        self.assertTrue(greps(data, "SubState=running")) # <<<
        self.assertTrue(greps(data, "ActiveState=active")) # <<<<
        self.assertTrue(greps(data, "LoadState=loaded"))
        self.assertTrue(greps(data, "UnitFileState=enabled"))
        self.assertEqual(end, 0)
        #
        # cleanup
        kill_testsleep = F"{systemctl} __killall {testsleep}"
        sx____(kill_testsleep)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23302_service_config_show_single_properties(self) -> None:
        """ check that a named service config can show a single properties"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        logfile = os_path(root, "/var/log/test.log")
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zzs.service"), F"""
            [Unit]
            Description=Testing S
            After=foo.service
            AssertFileIsExecutable=//usr/bin/killall
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleep} 99
            ExecStop=/usr/bin/killall {testsleep}
            [Install]
            WantedBy=multi-user.target
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzs.service"), os_path(root, "/etc/systemd/system/zzs.service"))
        #
        cmd = F"{systemctl} show zzs.service -vv -p ActiveState"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        data = lines4(out)
        self.assertTrue(greps(data, "ActiveState=inactive"))
        self.assertEqual(len(data), 1)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} start zzs.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} show zzs.service -vv -p ActiveState"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        data = lines4(out)
        self.assertTrue(greps(data, "ActiveState=active"))
        self.assertEqual(len(data), 1)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} show zzs.service -vv -p 'MainPID'"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        data = lines4(out)
        self.assertTrue(greps(data, "MainPID=[123456789][1234567890]*")) # <<<<
        self.assertEqual(len(data), 1)
        self.assertEqual(end, 0)
        #
        # cleanup
        kill_testsleep = F"{systemctl} __killall {testsleep}"
        sx____(kill_testsleep)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23303_service_config_show_single_properties_plus_unknown(self) -> None:
        """ check that a named service config can show a single properties"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        logfile = os_path(root, "/var/log/test.log")
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zzs.service"), F"""
            [Unit]
            Description=Testing S
            After=foo.service
            AssertFileIsExecutable=//usr/bin/killall
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleep} 99
            ExecStop=/usr/bin/killall {testsleep}
            [Install]
            WantedBy=multi-user.target
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzs.service"), os_path(root, "/etc/systemd/system/zzs.service"))
        #
        cmd = F"{systemctl} show zzs.service -vv -p ActiveState"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        data = lines4(out)
        self.assertTrue(greps(data, "ActiveState=inactive"))
        self.assertEqual(len(data), 1)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} start zzs.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} show zzs.service other.service -vv -p ActiveState"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        data = lines4(out)
        self.assertTrue(greps(data, "ActiveState=active"))
        self.assertEqual(len(data), 3)
        #
        cmd = F"{systemctl} show zzs.service other.service -vv -p 'MainPID'"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        data = lines4(out)
        self.assertTrue(greps(data, "MainPID=[123456789][1234567890]*")) # <<<<
        self.assertEqual(len(data), 3)
        #
        # cleanup
        kill_testsleep = F"{systemctl} __killall {testsleep}"
        sx____(kill_testsleep)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23401_service_status_show(self) -> None:
        """ check that a named service config can show its status"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        logfile = os_path(root, "/var/log/test.log")
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zzs.service"), F"""
            [Unit]
            Description=Testing S
            After=foo.service
            AssertFileIsExecutable=//usr/bin/killall
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleep} 99
            ExecStop=/usr/bin/killall {testsleep}
            [Install]
            WantedBy=multi-user.target
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzs.service"), os_path(root, "/etc/systemd/system/zzs.service"))
        #
        cmd = F"{systemctl} status zzs.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertNotEqual(end, 0)
        data = lines4(out)
        self.assertTrue(greps(data, "zzs.service - Testing"))
        self.assertTrue(greps(data, "Loaded: loaded"))
        self.assertTrue(greps(data, "Active: inactive"))
        self.assertTrue(greps(data, "[(]dead[)]"))
        self.assertTrue(greps(data, "disabled[)]"))
        #
        cmd = F"{systemctl} enable zzs.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} start zzs.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} status zzs.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        data = lines4(out)
        self.assertTrue(greps(data, "zzs.service - Testing"))
        self.assertTrue(greps(data, "Loaded: loaded"))
        self.assertTrue(greps(data, "Active: active"))
        self.assertTrue(greps(data, "[(]running[)]"))
        self.assertTrue(greps(data, "enabled[)]"))
        #
        # cleanup
        kill_testsleep = F"{systemctl} __killall {testsleep}"
        sx____(kill_testsleep)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23403_service_status_show_plus_unknown(self) -> None:
        """ check that a named service config can show its status"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        logfile = os_path(root, "/var/log/test.log")
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zzs.service"), F"""
            [Unit]
            Description=Testing S
            After=foo.service
            AssertFileIsExecutable=//usr/bin/killall
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleep} 99
            ExecStop=/usr/bin/killall {testsleep}
            [Install]
            WantedBy=multi-user.target
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzs.service"), os_path(root, "/etc/systemd/system/zzs.service"))
        #
        cmd = F"{systemctl} status zzs.service other.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertNotEqual(end, 0)
        data = lines4(out)
        self.assertTrue(greps(data, "zzs.service - Testing"))
        self.assertTrue(greps(data, "Loaded: loaded"))
        self.assertTrue(greps(data, "Active: inactive"))
        self.assertTrue(greps(data, "[(]dead[)]"))
        self.assertTrue(greps(data, "disabled[)]"))
        #
        cmd = F"{systemctl} enable zzs.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} start zzs.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} status zzs.service other.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertNotEqual(end, 0)
        data = lines4(out)
        self.assertTrue(greps(data, "zzs.service - Testing"))
        self.assertTrue(greps(data, "Loaded: loaded"))
        self.assertTrue(greps(data, "Active: active"))
        self.assertTrue(greps(data, "[(]running[)]"))
        self.assertTrue(greps(data, "enabled[)]"))
        #
        # cleanup
        kill_testsleep = F"{systemctl} __killall {testsleep}"
        sx____(kill_testsleep)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23530_systemctl_py_default_workingdirectory_is_root(self) -> None:
        """ check that services without WorkingDirectory start in / """
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        logfile = os_path(root, "/var/log/test.log")
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zzz.service"), F"""
            [Unit]
            Description=Testing Z
            AssertFileIsExecutable=//usr/bin/killall
            [Service]
            Type=simple
            ExecStart={bindir}/zzz.sh
            ExecStop=/usr/bin/killall {testsleep}
            [Install]
            WantedBy=multi-user.target
            """)
        shell_file(os_path(testdir, "zzz.sh"), F"""
            #! /bin/sh
            log={logfile}
            date > "$log"
            pwd >> "$log"
            exec {bindir}/{testsleep} 111
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        copy_tool(os_path(testdir, "zzz.sh"), os_path(root, "/usr/bin/zzz.sh"))
        #
        cmd = F"{systemctl} start zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        #
        log = lines4(reads(logfile))
        logg.info("LOG %s\n| %s", logfile, "\n| ".join(log))
        self.assertIn(root, log) # <<<<<<<<<< CHECK
        #
        cmd = F"{systemctl} stop zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        kill_testsleep = F"{systemctl} __killall {testsleep}"
        sx____(kill_testsleep)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23531_systemctl_py_simple_in_workingdirectory(self) -> None:
        """ check that we can start simple services with a WorkingDirectory"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        logfile = os_path(root, "/var/log/test.log")
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        workingdir = "/var/testsleep"
        text_file(os_path(testdir, "zzz.service"), F"""
            [Unit]
            Description=Testing Z
            AssertFileIsExecutable=//usr/bin/killall
            [Service]
            Type=simple
            WorkingDirectory={workingdir}
            ExecStart={bindir}/zzz.sh
            ExecStop=/usr/bin/killall {testsleep}
            [Install]
            WantedBy=multi-user.target
            """)
        shell_file(os_path(testdir, "zzz.sh"), F"""
            #! /bin/sh
            log={logfile}
            date > "$log"
            pwd >> "$log"
            exec {bindir}/{testsleep} 111
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        copy_tool(os_path(testdir, "zzz.sh"), os_path(root, "/usr/bin/zzz.sh"))
        os.makedirs(os_path(root, workingdir))
        #
        cmd = F"{systemctl} start zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        #
        log = lines4(reads(logfile))
        logg.info("LOG %s\n| %s", logfile, "\n| ".join(log))
        self.assertIn(os_path(root, workingdir), log) # <<<<<<<<<< CHECK
        #
        cmd = F"{systemctl} stop zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        kill_testsleep = F"{systemctl} __killall {testsleep}"
        sx____(kill_testsleep)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23532_systemctl_py_with_bad_workingdirectory(self) -> None:
        """ check that we can start simple services with a bad WorkingDirectory"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        logfile = os_path(root, "/var/log/test.log")
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        workingdir = "/var/testsleep"
        text_file(os_path(testdir, "zzz.service"), F"""
            [Unit]
            Description=Testing Z
            AssertFileIsExecutable=//usr/bin/killall
            [Service]
            Type=simple
            WorkingDirectory={workingdir}
            ExecStart={bindir}/zzz.sh
            ExecStop=/usr/bin/killall {testsleep}
            [Install]
            WantedBy=multi-user.target
            """)
        shell_file(os_path(testdir, "zzz.sh"), F"""
            #! /bin/sh
            log={logfile}
            date > "$log"
            pwd >> "$log"
            exec {bindir}/{testsleep} 111
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        copy_tool(os_path(testdir, "zzz.sh"), os_path(root, "/usr/bin/zzz.sh"))
        # os.makedirs(os_path(root, workingdir)) <<<
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        text_file(debug_log, "")
        #
        cmd = F"{systemctl} start zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        #
        log = reads(debug_log)
        logg.info("systemctl.debug.log:\n%s", i2(log))
        self.assertTrue(greps(log, "ERROR chdir workingdir.*such file or directory"))
        self.assertTrue(greps(log, "bad workingdir"))
        #
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out, "failed\n")
        #
        kill_testsleep = F"{systemctl} __killall {testsleep}"
        sx____(kill_testsleep)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23533_systemctl_py_with_bad_workingdirectory(self) -> None:
        """ check that we can start simple services with a bad WorkingDirectory with '-'"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        logfile = os_path(root, "/var/log/test.log")
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        workingdir = "/var/testsleep"
        text_file(os_path(testdir, "zzz.service"), F"""
            [Unit]
            Description=Testing Z
            AssertFileIsExecutable=//usr/bin/killall
            [Service]
            Type=simple
            WorkingDirectory=-{workingdir}
            ExecStart={bindir}/zzz.sh
            ExecStop=/usr/bin/killall {testsleep}
            [Install]
            WantedBy=multi-user.target
            """)
        shell_file(os_path(testdir, "zzz.sh"), F"""
            #! /bin/sh
            log={logfile}
            date > "$log"
            pwd >> "$log"
            exec {bindir}/{testsleep} 111
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        copy_tool(os_path(testdir, "zzz.sh"), os_path(root, "/usr/bin/zzz.sh"))
        # os.makedirs(os_path(root, workingdir)) <<<
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        text_file(debug_log, "")
        if COVERAGE:
            systemctl += " -c EXEC_SPAWN=True"
        #
        cmd = F"{systemctl} start zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        #
        log = reads(debug_log)
        logg.info("systemctl.debug.log:\n%s", i2(log))
        self.assertTrue(greps(log, "DEBUG chdir workingdir.*such file or directory"))
        self.assertFalse(greps(log, "bad workingdir"))
        #
        log = reads(logfile)
        logg.info("LOG %s\n %s", logfile, i2(log))
        self.assertNotIn(os_path(root, workingdir), log) # <<<<<<<<<< CHECK
        self.assertIn(root, log)
        #
        cmd = F"{systemctl} stop zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        kill_testsleep = F"{systemctl} __killall {testsleep}"
        sx____(kill_testsleep)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23601_non_absolute_ExecStopPost(self) -> None:
        """ check that we get a strong warning when not using absolute paths in ExecCommands"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zzz.service"), F"""
            [Unit]
            Description=Testing Z
            AssertFileIsExecutable=//usr/bin/killall
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleep} 111
            ExecStop=/usr/bin/killall {testsleep}
            ExecStopPost=killall {testsleep}
            [Install]
            WantedBy=multi-user.target
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        #
        cmd = F"{systemctl} start zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} stop zzz.service -vv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertTrue(greps(err, "Exec is not an absolute"))
        #
        kill_testsleep = F"{systemctl} __killall {testsleep}"
        sx____(kill_testsleep)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23602_non_absolute_ExecStop(self) -> None:
        """ check that we get a strong warning when not using absolute paths in ExecCommands"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        quick = QUICK
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zzz.service"), F"""
            [Unit]
            Description=Testing Z
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleep} 111
            ExecStop=killall {testsleep}
            [Install]
            WantedBy=multi-user.target
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        #
        cmd = F"{systemctl} start zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} stop zzz.service -vv {quick}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertTrue(greps(err, "Exec is not an absolute"))
        #
        kill_testsleep = F"{systemctl} __killall {testsleep}"
        sx____(kill_testsleep)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23603_non_absolute_ExecReload(self) -> None:
        """ check that we get a strong warning when not using absolute paths in ExecCommands"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zzz.service"), F"""
            [Unit]
            Description=Testing Z
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleep} 111
            ExecReload=killall {testsleep}
            [Install]
            WantedBy=multi-user.target
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        #
        cmd = F"{systemctl} start zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} reload zzz.service -vv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertTrue(greps(err, "Exec is not an absolute"))
        #
        cmd = F"{systemctl} stop zzz.service -vv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        #
        kill_testsleep = F"{systemctl} __killall {testsleep}"
        sx____(kill_testsleep)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23604_non_absolute_ExecStartPost(self) -> None:
        """ check that we get a strong warning when not using absolute paths in ExecCommands"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zzz.service"), F"""
            [Unit]
            Description=Testing Z
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleep} 111
            ExecStartPost=echo OK
            [Install]
            WantedBy=multi-user.target
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        #
        cmd = F"{systemctl} start zzz.service -vv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(err, "Exec is not an absolute"))
        #
        cmd = F"{systemctl} stop zzz.service -vv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        #
        kill_testsleep = F"{systemctl} __killall {testsleep}"
        sx____(kill_testsleep)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23605_non_absolute_ExecStartPre(self) -> None:
        """ check that we get a strong warning when not using absolute paths in ExecCommands"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zzz.service"), F"""
            [Unit]
            Description=Testing Z
            [Service]
            Type=simple
            ExecStartPre=echo OK
            ExecStart={bindir}/{testsleep} 111
            [Install]
            WantedBy=multi-user.target
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        #
        cmd = F"{systemctl} start zzz.service -vv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Exec is not an absolute"))
        #
        cmd = F"{systemctl} stop zzz.service -vv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        #
        kill_testsleep = F"{systemctl} __killall {testsleep}"
        sx____(kill_testsleep)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23606_non_absolute_ExecStart(self) -> None:
        """ check that we get a strong warning when not using absolute paths in ExecCommands"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zzz.service"), F"""
            [Unit]
            Description=Testing Z
            [Service]
            Type=simple
            ExecStart=sleep 111
            TimeoutSec=10
            [Install]
            WantedBy=multi-user.target
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        #
        cmd = F"{systemctl} start zzz.service -vv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Exec is not an absolute"))
        #
        cmd = F"{systemctl} stop zzz.service -vv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        #
        kill_testsleep = F"{systemctl} __killall {testsleep}"
        sx____(kill_testsleep)
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_23609_exitcode_from_ExecReload(self) -> None:
        self.test_23609_exitcode_from_ExecReload(True)
    def test_23609_exitcode_from_ExecReload(self, real: bool = False) -> None:
        """ check that we get a warning when ExecReload has an error"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir, real)
        vv = "-vv"
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zzz.service"), F"""
            [Unit]
            Description=Testing Z
            AssertFileIsExecutable=//usr/bin/killall
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleep} 111
            ExecReload=/usr/bin/killall -q some-unknown-program
            [Install]
            WantedBy=multi-user.target
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        cmd = F"{systemctl} start zzz.service {vv}"
        sx____(F"{systemctl} daemon-reload")
        #
        cmd = F"{systemctl} start zzz.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} reload zzz.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertTrue(greps(err, "Job for zzz.service failed because the control process exited with error code."))
        #
        cmd = F"{systemctl} is-active zzz.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        #
        cmd = F"{systemctl} stop zzz.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        #
        kill_testsleep = F"{systemctl} __killall {testsleep}"
        sx____(kill_testsleep)
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
        self.end()
    def real_23660_start_timer_unit(self) -> None:
        self.test_23660_start_timer_unit(True)
    def test_23660_start_timer_unit(self, real: bool = False) -> None:
        """ check that we get a warning when a timer is started"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir, real)
        vv = "-vv"
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zzt.timer"), F"""
            [Unit]
            Description=Timer T
            [Timer]
            OnCalendar=daily
            AccuracySec=12h
            Persistent=true
            [Install]
            WantedBy=timers.target
            """)
        text_file(os_path(testdir, "zzt.service"), F"""
            [Unit]
            Description=Testing T
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleep} 11
            [Install]
            WantedBy=multi-user.target
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzt.timer"), os_path(root, "/etc/systemd/system/zzt.timer"))
        copy_file(os_path(testdir, "zzt.service"), os_path(root, "/etc/systemd/system/zzt.service"))
        sx____(F"{systemctl} daemon-reload")
        #
        cmd = F"{systemctl} enable zzt.timer {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(os.path.exists(os_path(root, "/etc/systemd/system/timers.target.wants/zzt.timer")))
        #
        cmd = F"{systemctl} start zzt.timer {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        if real:
            self.assertEqual(end, 0)
        else:
            self.assertEqual(end, 1)
            self.assertTrue(greps(err, "not implemented"))
        #
        cmd = F"{systemctl} reload zzt.timer {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertTrue(greps(err, "not implemented"))
        #
        cmd = F"{systemctl} is-active zzt.timer {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(out.strip(), "unknown")
        #
        cmd = F"{systemctl} stop zzt.timer {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertTrue(greps(err, "not implemented"))
        #
        cmd = F"{systemctl} restart zzt.timer {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertTrue(greps(err, "not implemented"))
        #
        cmd = F"{systemctl} listen zzt.timer {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertTrue(greps(err, "not implemented"))
        #
        kill_testsleep = F"{systemctl} __killall {testsleep}"
        sx____(kill_testsleep)
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
        self.end()
    def test_23700_systemctl_py_default_init_loop_in_testenv(self) -> None:
        """ check that we can enable services in a test env to be run by an init-loop.
            We expect here that the init-loop ends when all services are dead. """
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A""")
        text_file(os_path(testdir, "zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStartPre=/bin/echo starting B
            ExecStart={bindir}/{testsleep} 10
            ExecStartPost=/bin/echo running B
            ExecStopPost=/bin/echo stopping B
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zzc.service"), F"""
            [Unit]
            Description=Testing C
            [Service]
            Type=simple
            ExecStartPre=/bin/echo starting C
            ExecStart={bindir}/{testsleep} 15
            ExecStartPost=/bin/echo running C
            ExecStopPost=/bin/echo stopping C
            [Install]
            WantedBy=multi-user.target
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        copy_file(os_path(testdir, "zzc.service"), os_path(root, "/etc/systemd/system/zzc.service"))
        #
        cmd = F"{systemctl} enable zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} enable zzc.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} --version"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} default-services -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, "zzb.service"))
        self.assertEqual(len(lines4(out)), 2)
        #
        log_stdout = os.path.join(root, "systemctl.stdout.log")
        log_stderr = os.path.join(root, "systemctl.stderr.log")
        pid = os.fork()
        if not pid:
            new_stdout = os.open(log_stdout, os.O_WRONLY |os.O_CREAT |os.O_TRUNC)
            new_stderr = os.open(log_stderr, os.O_WRONLY |os.O_CREAT |os.O_TRUNC)
            os.dup2(new_stdout, 1)
            os.dup2(new_stderr, 2)
            systemctl_cmd = [_systemctl_py, "--root="+root, "-11", "--now", "default", "-vv"]
            env = os.environ.copy()
            os.execve(_systemctl_py, systemctl_cmd, env)
        time.sleep(2)
        logg.info("all services running [systemctl.py PID %s]", pid)
        txt_stdout = lines4(open(log_stdout))
        txt_stderr = lines4(open(log_stderr))
        logg.info("-- %s>\n\t%s", log_stdout, "\n\t".join(txt_stdout))
        logg.info("-- %s>\n\t%s", log_stderr, "\n\t".join(txt_stderr))
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzb.service zzc.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, "^active"))
        self.assertFalse(greps(out, "inactive"))
        self.assertFalse(greps(out, "failed"))
        for check in range(20):
            time.sleep(2)
            top = _recent(output(_top_list))
            logg.info("[%s] checking for testsleep procs: \n>>>\n%s",
                      check, greps(top, testsleep))
            if not greps(top, testsleep):
                break
        time.sleep(2)
        logg.info("all services dead [systemctl.py PID %s]", pid)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        ###
        txt_stdout = lines4(open(log_stdout))
        txt_stderr = lines4(open(log_stderr))
        logg.info("-- %s>\n\t%s", log_stdout, "\n\t".join(txt_stdout))
        logg.info("-- %s>\n\t%s", log_stderr, "\n\t".join(txt_stderr))
        ###
        cmd = F"{systemctl} is-active zzb.service zzc.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertFalse(greps(out, "^active"))
        self.assertTrue(greps(out, "inactive"))
        self.assertFalse(greps(out, "failed"))
        #
        os.kill(pid, 2) # SIGINT (clean up zombie?)
        txt_stdout = lines4(open(log_stdout))
        txt_stderr = lines4(open(log_stderr))
        logg.info("-- %s>\n\t%s", log_stdout, "\n\t".join(txt_stdout))
        logg.info("-- %s>\n\t%s", log_stderr, "\n\t".join(txt_stderr))
        self.assertTrue(greps(txt_stderr, "no more services - exit init-loop"))
        self.assertTrue(greps(txt_stderr, "system is down"))
        self.assertTrue(greps(txt_stdout, "starting B"))
        self.assertTrue(greps(txt_stdout, "starting C"))
        #
        kill_testsleep = F"{systemctl} __killall {testsleep}"
        sx____(kill_testsleep)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23710_systemctl_py_init_explicit_loop_in_testenv(self) -> None:
        """ check that we can init services in a test env to be run by an init-loop.
            We expect here that the init-loop ends when those services are dead. """
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A""")
        text_file(os_path(testdir, "zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStartPre=/bin/echo starting B
            ExecStart={bindir}/{testsleep} 10
            ExecStartPost=/bin/echo running B
            ExecStopPost=/bin/echo stopping B
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zzc.service"), F"""
            [Unit]
            Description=Testing C
            [Service]
            Type=simple
            ExecStartPre=/bin/echo starting C
            ExecStart={bindir}/{testsleep} 15
            ExecStartPost=/bin/echo running C
            ExecStopPost=/bin/echo stopping C
            [Install]
            WantedBy=multi-user.target
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        copy_file(os_path(testdir, "zzc.service"), os_path(root, "/etc/systemd/system/zzc.service"))
        #
        cmd = F"{systemctl} enable zzb.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} enable zzc.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} --version"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} default-services -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, "zzb.service"))
        self.assertEqual(len(lines4(out)), 2)
        #
        log_stdout = os.path.join(root, "systemctl.stdout.log")
        log_stderr = os.path.join(root, "systemctl.stderr.log")
        pid = os.fork()
        if not pid:
            new_stdout = os.open(log_stdout, os.O_WRONLY |os.O_CREAT |os.O_TRUNC)
            new_stderr = os.open(log_stderr, os.O_WRONLY |os.O_CREAT |os.O_TRUNC)
            os.dup2(new_stdout, 1)
            os.dup2(new_stderr, 2)
            systemctl_cmd = [_systemctl_py, "--root="+root, "start", "-11", "--now", "zzb.service", "zzc.service", "-vv"]
            env = os.environ.copy()
            os.execve(_systemctl_py, systemctl_cmd, env)
        time.sleep(3)
        logg.info("all services running [systemctl.py PID %s]", pid)
        txt_stdout = lines4(open(log_stdout))
        txt_stderr = lines4(open(log_stderr))
        logg.info("-- %s>\n\t%s", log_stdout, "\n\t".join(txt_stdout))
        logg.info("-- %s>\n\t%s", log_stderr, "\n\t".join(txt_stderr))
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzb.service zzc.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, "^active"))
        self.assertFalse(greps(out, "inactive"))
        self.assertFalse(greps(out, "failed"))
        for check in range(20):
            time.sleep(2)
            top = _recent(output(_top_list))
            logg.info("[%s] checking for testsleep procs: \n>>>\n%s",
                      check, greps(top, testsleep))
            if not greps(top, testsleep):
                break
        time.sleep(2)
        logg.info("all services dead [systemctl.py PID %s]", pid)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzb.service zzc.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertFalse(greps(out, "^active"))
        self.assertTrue(greps(out, "inactive"))
        self.assertFalse(greps(out, "failed"))
        #
        os.kill(pid, 2) # SIGINT (clean up zombie?)
        txt_stdout = lines4(open(log_stdout))
        txt_stderr = lines4(open(log_stderr))
        logg.info("-- %s>\n\t%s", log_stdout, "\n\t".join(txt_stdout))
        logg.info("-- %s>\n\t%s", log_stderr, "\n\t".join(txt_stderr))
        self.assertTrue(greps(txt_stderr, "no more services - exit init-loop"))
        self.assertTrue(greps(txt_stderr, "system is up"))
        self.assertTrue(greps(txt_stdout, "starting B"))
        self.assertTrue(greps(txt_stdout, "starting C"))
        #
        kill_testsleep = F"{systemctl} __killall {testsleep}"
        sx____(kill_testsleep)
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_23801_start_some_unknown(self) -> None:
        self.test_23801_start_some_unknown(True)
    def test_23801_start_some_unknown(self, real: bool = False) -> None:
        """ check start some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____(F"{systemctl} daemon-reload")
        cmd = F"{systemctl} start zz-unknown.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 5)
        self.assertTrue(greps(err, "Unit zz-unknown.service not found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_23802_stop_some_unknown(self) -> None:
        self.test_23802_stop_some_unknown(True)
    def test_23802_stop_some_unknown(self, real: bool = False) -> None:
        """ check stop some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____(F"{systemctl} daemon-reload")
        cmd = F"{systemctl} stop zz-unknown.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 5)
        if real: self.assertTrue(greps(err, "Unit zz-unknown.service not loaded."))
        else: self.assertTrue(greps(err, "Unit zz-unknown.service not found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_23803_restart_some_unknown(self) -> None:
        self. test_23803_restart_some_unknown(True)
    def test_23803_restart_some_unknown(self, real: bool = False) -> None:
        """ check restart some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____(F"{systemctl} daemon-reload")
        cmd = F"{systemctl} restart zz-unknown.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 5)
        self.assertTrue(greps(err, "Unit zz-unknown.service not found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_23804_reload_some_unknown(self) -> None:
        self. test_23804_reload_some_unknown(True)
    def test_23804_reload_some_unknown(self, real: bool = False) -> None:
        """ check reload some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____(F"{systemctl} daemon-reload")
        cmd = F"{systemctl} reload zz-unknown.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 5)
        self.assertTrue(greps(err, "Unit zz-unknown.service not found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_23805_reload_or_restart_some_unknown(self) -> None:
        self. test_23805_reload_or_restart_some_unknown(True)
    def test_23805_reload_or_restart_some_unknown(self, real: bool = False) -> None:
        """ check reload-or-restart some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____(F"{systemctl} daemon-reload")
        cmd = F"{systemctl} reload-or-restart zz-unknown.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 5)
        self.assertTrue(greps(err, "Unit zz-unknown.service not found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_23806_reload_or_try_restart_some_unknown(self) -> None:
        self. test_23806_reload_or_try_restart_some_unknown(True)
    def test_23806_reload_or_try_restart_some_unknown(self, real: bool = False) -> None:
        """ check reload-or-try-restart some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____(F"{systemctl} daemon-reload")
        cmd = F"{systemctl} reload-or-try-restart zz-unknown.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 5)
        self.assertTrue(greps(err, "Unit zz-unknown.service not found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_23807_try_restart_some_unknown(self) -> None:
        self. test_23807_try_restart_some_unknown(True)
    def test_23807_try_restart_some_unknown(self, real: bool = False) -> None:
        """ check try-restart some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____(F"{systemctl} daemon-reload")
        cmd = F"{systemctl} try-restart zz-unknown.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 5)
        self.assertTrue(greps(err, "Unit zz-unknown.service not found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_23808_kill_some_unknown(self) -> None:
        self. test_23808_kill_some_unknown(True)
    def test_23808_kill_some_unknown(self, real: bool = False) -> None:
        """ check kill some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____(F"{systemctl} daemon-reload")
        cmd = F"{systemctl} kill zz-unknown.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        if real:
            self.assertTrue(greps(err, "Unit zz-unknown.service is not loaded."))
        else:
            self.assertTrue(greps(err, "Unit zz-unknown.service not found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_23809_reset_failed_some_unknown(self) -> None:
        self. test_23809_reset_failed_some_unknown(True)
    def test_23809_reset_failed_some_unknown(self, real: bool = False) -> None:
        """ check reset_failed some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____(F"{systemctl} daemon-reload")
        cmd = F"{systemctl} reset-failed zz-unknown.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        if real:
            self.assertTrue(greps(err, "Unit zz-unknown.service not loaded."))
        else:
            self.assertTrue(greps(err, "Unit zz-unknown.service not found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_23811_mask_some_unknown(self) -> None:
        self. test_23811_mask_some_unknown(True)
    def test_23811_mask_some_unknown(self, real: bool = False) -> None:
        """ check mask some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____(F"{systemctl} daemon-reload")
        cmd = F"{systemctl} mask zz-unknown.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        if real:
            self.assertEqual(end, 0)
            self.assertTrue(greps(err, "Unit zz-unknown.service does not exist, proceeding anyway."))  # TODO
            self.assertTrue(greps(err, "Created symlink /etc/systemd/system/zz-unknown.service .* /dev/null"))
        else:
            self.assertEqual(end, 5)
            self.assertTrue(greps(err, "Unit zz-unknown.service not found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_23812_unmask_some_unknown(self) -> None:
        self. test_23812_unmask_some_unknown(True)
    def test_23812_unmask_some_unknown(self, real: bool = False) -> None:
        """ check unmask some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____(F"{systemctl} daemon-reload")
        cmd = F"{systemctl} unmask zz-unknown.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        if real:
            self.assertEqual(end, 0)
            self.assertTrue(greps(err, "Unit zz-unknown.service does not exist, proceeding anyway."))  # TODO
        else:
            self.assertEqual(end, 5)
            self.assertTrue(greps(err, "Unit zz-unknown.service not found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_23813_enable_some_unknown(self) -> None:
        self. test_23813_enable_some_unknown(True)
    def test_23813_enable_some_unknown(self, real: bool = False) -> None:
        """ check enable some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____(F"{systemctl} daemon-reload")
        cmd = F"{systemctl} enable zz-unknown.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        if real:
            self.assertTrue(greps(err, "Failed to enable unit: Unit file zz-unknown.service does not exist."))  # TODO
        else:
            self.assertTrue(greps(err, "Unit zz-unknown.service not found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_23814_disable_some_unknown(self) -> None:
        self. test_23814_disable_some_unknown(True)
    def test_23814_disable_some_unknown(self, real: bool = False) -> None:
        """ check disable some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____(F"{systemctl} daemon-reload")
        cmd = F"{systemctl} disable zz-unknown.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        if real:
            self.assertTrue(greps(err, "Failed to disable unit: Unit file zz-unknown.service does not exist."))  # TODO
        else:
            self.assertTrue(greps(err, "Unit zz-unknown.service not found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_23815_is_enabled_some_unknown(self) -> None:
        self. test_23815_is_enabled_some_unknown(True)
    def test_23815_is_enabled_some_unknown(self, real: bool = False) -> None:
        """ check is-enabled some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____(F"{systemctl} daemon-reload")
        cmd = F"{systemctl} is-enabled zz-unknown.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        if real:
            self.assertTrue(greps(err, "Failed to get unit file state for zz-unknown.service: No such file or directory"))  # TODO
        else:
            self.assertTrue(greps(err, "Unit zz-unknown.service not found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_23816_is_failed_some_unknown(self) -> None:
        self. test_23816_is_failed_some_unknown(True)
    def test_23816_is_failed_some_unknown(self, real: bool = False) -> None:
        """ check is-failed some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____(F"{systemctl} daemon-reload")
        cmd = F"{systemctl} is-failed zz-unknown.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertEqual(out, "inactive\n")
        if not real:
            self.assertTrue(greps(err, "Unit zz-unknown.service not found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_23817_is_active_some_unknown(self) -> None:
        self. test_23817_is_active_some_unknown(True)
    def test_23817_is_active_some_unknown(self, real: bool = False) -> None:
        """ check is-active some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____(F"{systemctl} daemon-reload")
        cmd = F"{systemctl} is-active zz-unknown.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 3)
        if not real:
            self.assertTrue(greps(err, "Unit zz-unknown.service not found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_23818_cat_some_unknown(self) -> None:
        self. test_23818_cat_some_unknown(True)
    def test_23818_cat_some_unknown(self, real: bool = False) -> None:
        """ check cat some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____(F"{systemctl} daemon-reload")
        cmd = F"{systemctl} cat zz-unknown.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        if real:
            self.assertTrue(greps(err, "No files found for zz-unknown.service."))
        else:
            self.assertTrue(greps(err, "Unit zz-unknown.service not found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_23819_status_some_unknown(self) -> None:
        self. test_23819_status_some_unknown(True)
    def test_23819_status_some_unknown(self, real: bool = False) -> None:
        """ check status some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____(F"{systemctl} daemon-reload")
        cmd = F"{systemctl} status zz-unknown.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 4)
        self.assertTrue(greps(err, "Unit zz-unknown.service not found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_23820_preset_some_unknown(self) -> None:
        self. test_23820_preset_some_unknown(True)
    def test_23820_preset_some_unknown(self, real: bool = False) -> None:
        """ check preset some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____(F"{systemctl} daemon-reload")
        cmd = F"{systemctl} preset zz-unknown.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        if real:
            self.assertTrue(greps(err, "Failed to preset unit: Unit file zz-unknown.service does not exist."))
        if not real:
            self.assertTrue(greps(err, "Unit zz-unknown.service not found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    # def real_23821_get_preset_some_unknown(self) -> None:
    #     self. test_23821_get_preset_some_unknown(True)
    def test_23821_get_preset_some_unknown(self, real: bool = False) -> None:
        """ check get-preset some unknown unit fails okay"""
        self.skipTest("get-preset currently not exported")
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____(F"{systemctl} daemon-reload")
        cmd = F"{systemctl} get-preset zz-unknown.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        if not real:
            self.assertTrue(greps(err, "Unit zz-unknown.service not found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_23822_show_some_unknown(self) -> None:
        self. test_23822_show_some_unknown(True)
    def test_23822_show_some_unknown(self, real: bool = False) -> None:
        """ check show some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____(F"{systemctl} daemon-reload")
        cmd = F"{systemctl} show zz-unknown.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        if not real:
            self.assertTrue(greps(err, "Unit zz-unknown.service not found."))
            self.assertTrue(greps(out, "Description=NOT-FOUND zz-unknown.service"))
            self.assertTrue(greps(out, "UnitFileState=static"))
        self.assertTrue(greps(out, "Id=zz-unknown.service"))
        self.assertTrue(greps(out, "Names=zz-unknown.service"))
        self.assertFalse(greps(out, "MainPID=0"))
        self.assertTrue(greps(out, "SubState=dead"))
        self.assertTrue(greps(out, "ActiveState=inactive"))
        self.assertTrue(greps(out, "LoadState=not-found"))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23824_show_environment_some_unknown(self, real: bool = False) -> None:
        """ check show-environment some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____(F"{systemctl} daemon-reload")
        cmd = F"{systemctl} environment zz-unknown.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 4)
        if not real:
            self.assertTrue(greps(err, "Unit zz-unknown.service not found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23829_preset_all_user_some_unknown(self, real: bool = False) -> None:
        """ check prset-all --user some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____(F"{systemctl} daemon-reload")
        cmd = F"{systemctl} preset-all --user {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(err, "preset-all makes no sense in --user mode"))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23831_API_start_some_unknown(self, real: bool = False) -> None:
        """ check API start some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____(F"{systemctl} daemon-reload")
        cmd = F"{systemctl} __start_unit zz-unknown.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zz-unknown.service not found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23832_API_stop_some_unknown(self, real: bool = False) -> None:
        """ check API stop some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____(F"{systemctl} daemon-reload")
        cmd = F"{systemctl} __stop_unit zz-unknown.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zz-unknown.service not found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23833_API_restart_some_unknown(self, real: bool = False) -> None:
        """ check API restart some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____(F"{systemctl} daemon-reload")
        cmd = F"{systemctl} __restart_unit zz-unknown.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zz-unknown.service not found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23834_API_reload_some_unknown(self, real: bool = False) -> None:
        """ check API reload some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____(F"{systemctl} daemon-reload")
        cmd = F"{systemctl} __reload_unit zz-unknown.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zz-unknown.service not found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23835_API_reload_or_restart_some_unknown(self, real: bool = False) -> None:
        """ check API reload_or_restart some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____(F"{systemctl} daemon-reload")
        cmd = F"{systemctl} __reload_or_restart_unit zz-unknown.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zz-unknown.service not found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23836_API_reload_or_try_restart_some_unknown(self, real: bool = False) -> None:
        """ check API reload_or_try_restart some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____(F"{systemctl} daemon-reload")
        cmd = F"{systemctl} __reload_or_try_restart_unit zz-unknown.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zz-unknown.service not found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23837_API_try_restart_some_unknown(self, real: bool = False) -> None:
        """ check API try_restart some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____(F"{systemctl} daemon-reload")
        cmd = F"{systemctl} __try_restart_unit zz-unknown.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zz-unknown.service not found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23838_API_kill_some_unknown(self, real: bool = False) -> None:
        """ check API kill some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____(F"{systemctl} daemon-reload")
        cmd = F"{systemctl} __kill_unit zz-unknown.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zz-unknown.service not found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23839_API_reset_failed_some_unknown(self, real: bool = False) -> None:
        """ check API reset_failed some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____(F"{systemctl} daemon-reload")
        cmd = F"{systemctl} __reset_failed_unit zz-unknown.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zz-unknown.service not found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23841_API_mask_some_unknown(self, real: bool = False) -> None:
        """ check API mask some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____(F"{systemctl} daemon-reload")
        cmd = F"{systemctl} __mask_unit zz-unknown.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zz-unknown.service not found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23842_API_unmask_some_unknown(self, real: bool = False) -> None:
        """ check API unmask some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____(F"{systemctl} daemon-reload")
        cmd = F"{systemctl} __unmask_unit zz-unknown.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zz-unknown.service not found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23843_API_enable_some_unknown(self, real: bool = False) -> None:
        """ check API enable some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____(F"{systemctl} daemon-reload")
        cmd = F"{systemctl} __enable_unit zz-unknown.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zz-unknown.service not found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23844_API_disable_some_unknown(self, real: bool = False) -> None:
        """ check API disable some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____(F"{systemctl} daemon-reload")
        cmd = F"{systemctl} __disable_unit zz-unknown.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zz-unknown.service not found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23845_API_is_enabled_some_unknown(self, real: bool = False) -> None:
        """ check API is_enabled some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____(F"{systemctl} daemon-reload")
        cmd = F"{systemctl} __is_enabled_unit zz-unknown.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zz-unknown.service not found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23847_API_get_active_some_unknown(self, real: bool = False) -> None:
        """ check API get_active some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____(F"{systemctl} daemon-reload")
        cmd = F"{systemctl} __get_active_unit zz-unknown.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        if not real:
            self.assertTrue(greps(err, "Unit zz-unknown.service not found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23848_API_cat_some_unknown(self, real: bool = False) -> None:
        """ check API cat some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____(F"{systemctl} daemon-reload")
        cmd = F"{systemctl} __cat_unit zz-unknown.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "No files found for zz-unknown.service"))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23850_API_preset_all_some_unknown(self, real: bool = False) -> None:
        """ check API preset_all some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____(F"{systemctl} daemon-reload")
        cmd = F"{systemctl} __system_preset_all zz-unknown.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        # self.assertTrue(greps(err, "Unit zz-unknown.service not found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23851_API_get_preset_some_unknown(self, real: bool = False) -> None:
        """ check API get_preset some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____(F"{systemctl} daemon-reload")
        cmd = F"{systemctl} __get_preset_of_unit zz-unknown.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        # self.assertTrue(greps(err, "Unit zz-unknown.service not found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23852_API_show_some_unknown(self, real: bool = False) -> None:
        """ check API show some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____(F"{systemctl} daemon-reload")
        cmd = F"{systemctl} __show_unit_items zz-unknown.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        # self.assertTrue(greps(err, "Unit zz-unknown.service not found."))
        self.assertTrue(greps(out, "Description.*NOT-FOUND zz-unknown.service"))
        self.assertTrue(greps(out, "UnitFileState.*static"))
        self.assertTrue(greps(out, "Id.*zz-unknown.service"))
        self.assertTrue(greps(out, "Names.*zz-unknown.service"))
        self.assertTrue(greps(out, "MainPID\\s*"))
        self.assertTrue(greps(out, "SubState.*dead"))
        self.assertTrue(greps(out, "ActiveState.*inactive"))
        self.assertTrue(greps(out, "LoadState.*not-found"))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23880_start_some_empty_file_problem(self, real: bool = False) -> None:
        """ check start some empty file unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        text_file(os_path(root, "/etc/systemd/system/zz-empty.service"), "")
        #
        sh____(F"{systemctl} daemon-reload")
        cmd = F"{systemctl} start zz-empty.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        # self.assertTrue(greps(err, "Unit zz-empty.service not found."))
        self.assertTrue(greps(err, "zz-empty.service: .* file without .Service. section"))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23881_start_some_syntax_problem(self, real: bool = False) -> None:
        """ check start some syntax problem unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        text_file(os_path(root, "/etc/systemd/system/zz-empty.service"), "()")
        #
        sh____(F"{systemctl} daemon-reload")
        cmd = F"{systemctl} start zz-empty.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zz-empty.service not found."))
        self.assertTrue(greps(err, "zz-empty.service not loaded.*bad ini line"))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23882_start_some_inaccessible(self, real: bool = False) -> None:
        """ check start some inaccessible unit fails okay"""
        if not get_USER_ID(real):
            self.skipTest("chmod does not make a file inaccessible for the root user")
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        text_file(os_path(root, "/etc/systemd/system/zz-empty.service"), "()")
        os.chmod(os_path(root, "/etc/systemd/system/zz-empty.service"), 111)
        #
        sh____(F"{systemctl} daemon-reload")
        cmd = F"{systemctl} start zz-empty.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zz-empty.service not found."))
        self.assertTrue(greps(err, "zz-empty.service not loaded.*Permission denied"))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()

    def test_23901_service_config_cat(self) -> None:
        """ check that a name service config can be printed as-is"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        logfile = os_path(root, "/var/log/test.log")
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zzs.service"), F"""
            [Unit]
            Description=Testing S
            After=foo.service
            AssertFileIsExecutable=//usr/bin/killall
            [Service]
            Type=simple
            ExecStart={bindir}{testsleep} 99
            ExecStop=/usr/bin/killall {testsleep}
            [Install]
            WantedBy=multi-user.target
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzs.service"), os_path(root, "/etc/systemd/system/zzs.service"))
        #
        cmd = F"{systemctl} cat zzs.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        orig = lines4(open(os_path(root, "/etc/systemd/system/zzs.service")))
        data = lines4(out)
        self.assertEqual(orig + [""], data)
        #
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_23903_service_config_cat_plus_unknown(self) -> None:
        """ check that a name service config can be printed as-is"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        logfile = os_path(root, "/var/log/test.log")
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zzs.service"), F"""
            [Unit]
            Description=Testing S
            After=foo.service
            AssertFileIsExecutable=//usr/bin/killall
            [Service]
            Type=simple
            ExecStart={bindir}{testsleep} 99
            ExecStop=/usr/bin/killall {testsleep}
            [Install]
            WantedBy=multi-user.target
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzs.service"), os_path(root, "/etc/systemd/system/zzs.service"))
        #
        cmd = F"{systemctl} cat zzs.service unknown.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 1)
        orig = lines4(open(os_path(root, "/etc/systemd/system/zzs.service")))
        data = lines4(out)
        self.assertEqual(orig + [""], data)
        #
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_23910_start_false_execpre(self) -> None:
        self.test_23910_start_false_execpre(True)
    def test_23910_start_false_execpre(self, real: bool = False) -> None:
        """ check that a failed execpre is handled"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir, real)
        logfile = os_path(root, "/var/log/test.log")
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        self.rm_testdir()
        self.rm_zzfiles(root)
        text_file(os_path(testdir, "zzz.service"), F"""
            [Unit]
            Description=Testing Z
            After=foo.service
            AssertFileIsExecutable=//usr/bin/killall
            [Service]
            Type=simple
            ExecStartPre="/bin/false"
            ExecStart={bindir}/{testsleep} 9
            ExecStop=/usr/bin/killall {testsleep}
            [Install]
            WantedBy=multi-user.target
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        sx____(F"{systemctl} reset-failed zzz.service")
        sh____(F"{systemctl} daemon-reload")
        #
        cmd = F"{systemctl} enable zzz.service {vv}"
        sh____(cmd)
        cmd = F"{systemctl} is-active zzz.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== try to 'start' the service  ")
        cmd = F"{systemctl} start zzz.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, i2(err))
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "control process exited with error code"))
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "failed")
        #
        cmd = F"{systemctl} reset-failed zzz.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} is-active zzz.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
        self.end()
    def real_23911_start_false_exec_simple(self) -> None:
        self.test_23911_start_false_exec_simple(True)
    def test_23911_start_false_exec_simple(self, real: bool = False) -> None:
        """ check that a failed exec is handled"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir, real)
        logfile = os_path(root, "/var/log/test.log")
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        self.rm_testdir()
        self.rm_zzfiles(root)
        text_file(os_path(testdir, "zzz.service"), F"""
            [Unit]
            Description=Testing Z
            After=foo.service
            AssertFileIsExecutable=//usr/bin/killall
            [Service]
            Type=simple
            ExecStart="/bin/false"
            ExecStop=/usr/bin/killall {testsleep}
            [Install]
            WantedBy=multi-user.target
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        sx____(F"{systemctl} reset-failed zzz.service")
        sh____(F"{systemctl} daemon-reload")
        #
        cmd = F"{systemctl} enable zzz.service {vv}"
        sh____(cmd)
        cmd = F"{systemctl} is-active zzz.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== try to 'start' the service  ")
        cmd = F"{systemctl} start zzz.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, i2(err))
        if real: self.assertEqual(end, 0)
        else: self.assertEqual(end, 1) # TODO: simple Exec should not wait_testpid!!
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "failed")
        #
        cmd = F"{systemctl} reset-failed zzz.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} is-active zzz.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
        self.end()
    def real_23912_start_false_exec_notify(self) -> None:
        self.test_23912_start_false_exec_notify(True)
    def test_23912_start_false_exec_notify(self, real: bool = False) -> None:
        """ check that a failed exec is handled"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir, real)
        logfile = os_path(root, "/var/log/test.log")
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        self.rm_testdir()
        self.rm_zzfiles(root)
        text_file(os_path(testdir, "zzz.service"), F"""
            [Unit]
            Description=Testing Z
            After=foo.service
            AssertFileIsExecutable=//usr/bin/killall
            [Service]
            Type=notify
            ExecStart="/bin/false"
            ExecStop=/usr/bin/killall {testsleep}
            [Install]
            WantedBy=multi-user.target
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        sx____(F"{systemctl} reset-failed zzz.service")
        sh____(F"{systemctl} daemon-reload")
        #
        cmd = F"{systemctl} enable zzz.service {vv}"
        sh____(cmd)
        cmd = F"{systemctl} is-active zzz.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== try to 'start' the service  ")
        cmd = F"{systemctl} start zzz.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, i2(err))
        self.assertEqual(end, 1)
        if real:
            self.assertTrue(greps(err, "because the control process exited with error code."))
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "failed")
        #
        cmd = F"{systemctl} reset-failed zzz.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} is-active zzz.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_23913_start_false_exec_oneshot(self) -> None:
        self.test_23913_start_false_exec_oneshot(True)
    def test_23913_start_false_exec_oneshot(self, real: bool = False) -> None:
        """ check that a failed exec is handled"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir, real)
        logfile = os_path(root, "/var/log/test.log")
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        self.rm_testdir()
        self.rm_zzfiles(root)
        text_file(os_path(testdir, "zzz.service"), F"""
            [Unit]
            Description=Testing Z
            After=foo.service
            AssertFileIsExecutable=//usr/bin/killall
            [Service]
            Type=oneshot
            ExecStart="/bin/false"
            ExecStop=/usr/bin/killall {testsleep}
            [Install]
            WantedBy=multi-user.target
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        sx____(F"{systemctl} reset-failed zzz.service")
        sh____(F"{systemctl} daemon-reload")
        #
        cmd = F"{systemctl} enable zzz.service {vv}"
        sh____(cmd)
        cmd = F"{systemctl} is-active zzz.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== try to 'start' the service  ")
        cmd = F"{systemctl} start zzz.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, i2(err))
        self.assertEqual(end, 1)
        if real:
            self.assertTrue(greps(err, "because the control process exited with error code."))
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "failed")
        #
        cmd = F"{systemctl} reset-failed zzz.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} is-active zzz.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
        self.end()
    def real_23914_start_false_exec_forking(self) -> None:
        self.test_23914_start_false_exec_forking(True)
    def test_23914_start_false_exec_forking(self, real: bool = False) -> None:
        """ check that a failed exec is handled"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir, real)
        logfile = os_path(root, "/var/log/test.log")
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        self.rm_testdir()
        self.rm_zzfiles(root)
        text_file(os_path(testdir, "zzz.service"), F"""
            [Unit]
            Description=Testing Z
            After=foo.service
            AssertFileIsExecutable=//usr/bin/killall
            [Service]
            Type=forking
            ExecStart="/bin/false"
            ExecStop=/usr/bin/killall {testsleep}
            [Install]
            WantedBy=multi-user.target
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        sx____(F"{systemctl} reset-failed zzz.service")
        sh____(F"{systemctl} daemon-reload")
        #
        cmd = F"{systemctl} enable zzz.service {vv}"
        sh____(cmd)
        cmd = F"{systemctl} is-active zzz.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== try to 'start' the service  ")
        cmd = F"{systemctl} start zzz.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, i2(err))
        self.assertEqual(end, 1)
        if real:
            self.assertTrue(greps(err, "because the control process exited with error code."))
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "failed")
        #
        cmd = F"{systemctl} reset-failed zzz.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} is-active zzz.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
        self.end()
    def real_23935_start_false_exec_notify(self) -> None:
        self.test_23935_start_false_exec_notify(True)
    def test_23935_start_false_exec_notify(self, real: bool = False) -> None:
        """ check that we manage notify services in a root env
            and false handling."""
        socat = self.socat()
        if not os.path.exists(socat):
            self.skipTest("missing "+socat)
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = testname+"_sleep"
        logfile = os_path(root, "/var/log/"+testsleep+".log")
        bindir = os_path(root, "/usr/bin")
        os.makedirs(os_path(root, "/var/run"))
        text_file(logfile, "created\n")
        shell_file(os_path(testdir, "zzz.init"), F"""
            #! /bin/bash
            case "$1" in start)
                ls -l  $NOTIFY_SOCKET
                {bindir}/{testsleep} 3 0<&- &>/dev/null &
                echo "MAINPID=$!" | {socat} -v -d - UNIX-CLIENT:$NOTIFY_SOCKET
                echo "READY=1" | {socat} -v -d - UNIX-CLIENT:$NOTIFY_SOCKET
                wait %1
                # ps -o pid,ppid,args
            ;; stop)
                killall {testsleep}
            ;; esac
            echo "done$1" >&2
            exit 0
            """)
        text_file(os_path(testdir, "zzz.service"), F"""
            [Unit]
            Description=Testing Z
            [Service]
            Type=notify
            # PIDFile={root}/var/run/zzz.init.pid
            ExecStart={root}/usr/bin/zzz.init start
            ExecStop={root}/usr/bin/zzz.init stop
            [Install]
            WantedBy=multi-user.target
            """)
        zzz_service = F"/etc/systemd/system/zzz.service"
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_tool(os_path(testdir, "zzz.init"), os_path(root, "/usr/bin/zzz.init"))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, zzz_service))
        #
        cmd = F"{systemctl} enable zzz.service -vv"
        sh____(cmd)
        #
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'start' shall start a service that is NOT is-active ")
        cmd = F"{systemctl} start zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        #
        time.sleep(4)
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "failed")
        #
        cmd = F"{systemctl} reset-failed zzz.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} is-active zzz.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("LOG\n%s", " "+reads(logfile).replace("\n", "\n "))
        self.rm_testdir()
        self.end()
    def real_23936_start_false_exec_notify(self) -> None:
        self.test_23936_start_false_exec_notify(True)
    def test_23936_start_false_exec_notify(self, real: bool = False) -> None:
        """ check that we manage notify services in a root env
            and false handling."""
        socat = self.socat()
        if not os.path.exists(socat):
            self.skipTest("missing "+socat)
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = testname+"_sleep"
        logfile = os_path(root, "/var/log/"+testsleep+".log")
        bindir = os_path(root, "/usr/bin")
        os.makedirs(os_path(root, "/var/run"))
        text_file(logfile, "created\n")
        shell_file(os_path(testdir, "zzz.init"), F"""
            #! /bin/bash
            case "$1" in start)
                ls -l  $NOTIFY_SOCKET
                {bindir}/{testsleep} 3 0<&- &>/dev/null &
                echo "$!" > {root}/var/run/zzz.init.pid
                echo "READY=1" | {socat} -v -d - UNIX-CLIENT:$NOTIFY_SOCKET
                wait %1
                # ps -o pid,ppid,args
            ;; stop)
                killall {testsleep}
            ;; esac
            echo "done$1" >&2
            exit 0
            """)
        text_file(os_path(testdir, "zzz.service"), F"""
            [Unit]
            Description=Testing Z
            [Service]
            Type=notify
            PIDFile={root}/var/run/zzz.init.pid
            ExecStart={root}/usr/bin/zzz.init start
            ExecStop={root}/usr/bin/zzz.init stop
            [Install]
            WantedBy=multi-user.target
            """)
        zzz_service = F"/etc/systemd/system/zzz.service"
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_tool(os_path(testdir, "zzz.init"), os_path(root, "/usr/bin/zzz.init"))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, zzz_service))
        #
        cmd = F"{systemctl} enable zzz.service -vv"
        sh____(cmd)
        #
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'start' shall start a service that is NOT is-active ")
        cmd = F"{systemctl} start zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        #
        time.sleep(4)
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "failed")
        #
        logg.info("LOG\n%s", " "+reads(logfile).replace("\n", "\n "))
        self.rm_testdir()
        self.end()
    def real_23937_start_false_exec_notify(self) -> None:
        self.test_23937_start_false_exec_notify(True)
    def test_23937_start_false_exec_notify(self, real: bool = False) -> None:
        """ check that we manage notify services in a root env
            and false handling."""
        socat = self.socat()
        if not os.path.exists(socat):
            self.skipTest("missing "+socat)
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = testname+"_sleep"
        logfile = os_path(root, "/var/log/"+testsleep+".log")
        bindir = os_path(root, "/usr/bin")
        os.makedirs(os_path(root, "/var/run"))
        text_file(logfile, "created\n")
        shell_file(os_path(testdir, "zzz.init"), F"""
            #! /bin/bash
            case "$1" in start)
                ls -l  $NOTIFY_SOCKET
                {bindir}/{testsleep} 3 0<&- &>/dev/null &
                echo "$!" > {root}/var/run/zzz.init.pid
                echo "READY=1" | {socat} -v -d - UNIX-CLIENT:$NOTIFY_SOCKET
                wait %1
                # ps -o pid,ppid,args
            ;; stop)
                killall {testsleep}
            ;; esac
            echo "done$1" >&2
            exit 0
            """)
        text_file(os_path(testdir, "zzz.service"), F"""
            [Unit]
            Description=Testing Z
            [Service]
            Type=notify
            PIDFile={root}/var/run/zzz.init.pid
            ExecStart={root}/usr/bin/zzz.init start
            ExecStop={root}/usr/bin/zzz.init stop
            [Install]
            WantedBy=multi-user.target
            """)
        zzz_service = F"/etc/systemd/system/zzz.service"
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_tool(os_path(testdir, "zzz.init"), os_path(root, "/usr/bin/zzz.init"))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, zzz_service))
        #
        cmd = F"{systemctl} enable zzz.service -vv"
        sh____(cmd)
        #
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'start' shall start a service that is NOT is-active ")
        cmd = F"{systemctl} start zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        #
        os.remove(os_path(root, "/var/run/zzz.init.pid"))
        time.sleep(4)
        #
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("LOG\n%s", " "+reads(logfile).replace("\n", "\n "))
        self.rm_testdir()
        self.end()
    def real_23938_start_slow_exec_notify(self) -> None:
        self.test_23938_start_slow_exec_notify(True)
    def test_23938_start_slow_exec_notify(self, real: bool = False) -> None:
        """ check that we manage notify services in a root env
            and slow handling."""
        socat = self.socat()
        if not os.path.exists(socat):
            self.skipTest("missing "+socat)
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = testname+"_sleep"
        logfile = os_path(root, "/var/log/"+testsleep+".log")
        bindir = os_path(root, "/usr/bin")
        os.makedirs(os_path(root, "/var/run"))
        text_file(logfile, "created\n")
        shell_file(os_path(testdir, "zzz.init"), F"""
            #! /bin/bash
            case "$1" in start)
                ls -l  $NOTIFY_SOCKET
                {bindir}/{testsleep} 13 0<&- &>/dev/null &
                PID="$!"
                sleep 1
                echo "" > {root}/var/run/zzz.init.pid
                sleep 1
                echo "$PID" > {root}/var/run/zzz.init.pid
                sleep 1
                echo "READY=1" | {socat} -v -d - UNIX-CLIENT:$NOTIFY_SOCKET
                wait %1
                # ps -o pid,ppid,args
            ;; stop)
                killall {testsleep}
            ;; esac
            echo "done$1" >&2
            exit 0
            """)
        text_file(os_path(testdir, "zzz.service"), F"""
            [Unit]
            Description=Testing Z
            [Service]
            Type=notify
            PIDFile={root}/var/run/zzz.init.pid
            ExecStart={root}/usr/bin/zzz.init start
            ExecStop={root}/usr/bin/zzz.init stop
            [Install]
            WantedBy=multi-user.target
            """)
        zzz_service = F"/etc/systemd/system/zzz.service"
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_tool(os_path(testdir, "zzz.init"), os_path(root, "/usr/bin/zzz.init"))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, zzz_service))
        #
        cmd = F"{systemctl} enable zzz.service {vv}"
        sh____(cmd)
        #
        cmd = F"{systemctl} is-active zzz.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'start' shall start a service that is NOT is-active ")
        cmd = F"{systemctl} start zzz.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        #
        os.remove(os_path(root, "/var/run/zzz.init.pid"))
        time.sleep(4)
        #
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("LOG\n%s", " "+reads(logfile).replace("\n", "\n "))
        self.rm_testdir()
        self.end()
    def real_23939_start_slowe_exec_forking(self) -> None:
        self.test_23939_start_slow_exec_forking(True)
    def test_23939_start_slow_exec_forking(self, real: bool = False) -> None:
        """ check that we manage forking services in a root env
            and slow handling."""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = testname+"_sleep"
        logfile = os_path(root, "/var/log/"+testsleep+".log")
        bindir = os_path(root, "/usr/bin")
        os.makedirs(os_path(root, "/var/run"))
        text_file(logfile, "created\n")
        shell_file(os_path(testdir, "zzz.init"), F"""
            #! /bin/bash
            case "$1" in start)
                ls -l  $NOTIFY_SOCKET
               ({bindir}/{testsleep} 11 0<&- &>/dev/null &
                PID="$!"
                sleep 1
                echo "" > {root}/var/run/zzz.init.pid
                sleep 1
                echo "$PID" > {root}/var/run/zzz.init.pid
                sleep 1
               ) &
                wait %1
                # ps -o pid,ppid,args
            ;; stop)
                killall {testsleep}
            ;; esac
            echo "done$1" >&2
            exit 0
            """)
        text_file(os_path(testdir, "zzz.service"), F"""
            [Unit]
            Description=Testing Z
            [Service]
            Type=forking
            PIDFile={root}/var/run/zzz.init.pid
            ExecStart={root}/usr/bin/zzz.init start
            ExecStop={root}/usr/bin/zzz.init stop
            StartTimeoutSec=5
            [Install]
            WantedBy=multi-user.target
            """)
        zzz_service = F"/etc/systemd/system/zzz.service"
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_tool(os_path(testdir, "zzz.init"), os_path(root, "/usr/bin/zzz.init"))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, zzz_service))
        #
        cmd = F"{systemctl} enable zzz.service {vv}"
        sh____(cmd)
        #
        cmd = F"{systemctl} is-active zzz.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'start' shall start a service that is NOT is-active ")
        cmd = F"{systemctl} start zzz.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        #
        time.sleep(1)
        #
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        #
        time.sleep(1)
        pid = reads(os_path(root, "/var/run/zzz.init.pid"))
        os.kill(int(pid), signal.SIGTERM)
        #
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "failed")
        #
        cmd = F"{systemctl} reset-failed zzz.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("LOG\n%s", " "+reads(logfile).replace("\n", "\n "))
        self.rm_testdir()
        self.end()
    def real_23941_stop_false_exec_simple(self) -> None:
        self.test_23941_stop_false_exec_simple(True)
    def test_23941_stop_false_exec_simple(self, real: bool = False) -> None:
        """ check that a failed exec is handled"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir, real)
        logfile = os_path(root, "/var/log/test.log")
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        self.rm_testdir()
        self.rm_zzfiles(root)
        text_file(os_path(testdir, "zzz.service"), F"""
            [Unit]
            Description=Testing Z
            After=foo.service
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleep} 3
            ExecStop="/bin/false"
            [Install]
            WantedBy=multi-user.target
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        sx____(F"{systemctl} reset-failed zzz.service")
        sh____(F"{systemctl} daemon-reload")
        #
        cmd = F"{systemctl} enable zzz.service {vv}"
        sh____(cmd)
        cmd = F"{systemctl} is-active zzz.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== try to 'start' the service  ")
        cmd = F"{systemctl} start zzz.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, i2(err))
        self.assertEqual(end, 0)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        #
        logg.info("== try to 'stop' the service  ")
        cmd = F"{systemctl} stop zzz.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, i2(err))
        self.assertEqual(end, 1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        sx____(F"{systemctl} reset-failed zzz.service")
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
        self.end()
    def real_23943_stop_false_exec_oneshot(self) -> None:
        self.test_23943_stop_false_exec_oneshot(True)
    def test_23943_stop_false_exec_oneshot(self, real: bool = False) -> None:
        """ check that a failed exec is handled"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir, real)
        logfile = os_path(root, "/var/log/test.log")
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        self.rm_testdir()
        self.rm_zzfiles(root)
        text_file(os_path(testdir, "zzz.service"), F"""
            [Unit]
            Description=Testing Z
            After=foo.service
            [Service]
            Type=oneshot
            ExecStart={bindir}/{testsleep} 3
            ExecStop="/bin/false"
            [Install]
            WantedBy=multi-user.target
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        sx____(F"{systemctl} reset-failed zzz.service")
        sh____(F"{systemctl} daemon-reload")
        #
        cmd = F"{systemctl} enable zzz.service {vv}"
        sh____(cmd)
        cmd = F"{systemctl} is-active zzz.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== try to 'start' the service  ")
        cmd = F"{systemctl} start zzz.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, i2(err))
        self.assertEqual(end, 0)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        #
        logg.info("== try to 'stop' the service  ")
        cmd = F"{systemctl} stop zzz.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, i2(err))
        self.assertEqual(end, 1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "failed")
        #
        sx____(F"{systemctl} reset-failed zzz.service")
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
        self.end()
    def real_23944_stop_false_exec_forking(self) -> None:
        self.test_23944_stop_false_exec_forking(True)
    def test_23944_stop_false_exec_forking(self, real: bool = False) -> None:
        """ check that a failed exec is handled"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir, real)
        logfile = os_path(root, "/var/log/test.log")
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        self.rm_testdir()
        self.rm_zzfiles(root)
        text_file(os_path(testdir, "zzz.service"), F"""
            [Unit]
            Description=Testing Z
            After=foo.service
            [Service]
            Type=forking
            ExecStart={bindir}/{testsleep} 3
            ExecStop="/bin/false"
            [Install]
            WantedBy=multi-user.target
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        sx____(F"{systemctl} reset-failed zzz.service")
        sh____(F"{systemctl} daemon-reload")
        #
        cmd = F"{systemctl} enable zzz.service {vv}"
        sh____(cmd)
        cmd = F"{systemctl} is-active zzz.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== try to 'start' the service  ")
        cmd = F"{systemctl} start zzz.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, i2(err))
        self.assertEqual(end, 0)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        #
        logg.info("== try to 'stop' the service  ")
        cmd = F"{systemctl} stop zzz.service {vv}"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, i2(err))
        self.assertEqual(end, 1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "failed")
        #
        sx____(F"{systemctl} reset-failed zzz.service")
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
        self.end()
    def real_25030_simple_service_functions_system(self) -> None:
        """ check that we manage simple services in a root env
            with commands like start, restart, stop, etc"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        self.simple_service_functions("system", testname, testdir)
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_25031_simple_service_functions_user(self) -> None:
        """ check that we manage simple services in a root env
            with commands like start, restart, stop, etc"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        self.simple_service_functions("user", testname, testdir)
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def simple_service_functions(self, system: str, testname: str, testdir: str) -> None:
        """ check that we manage simple services in a root env
            with commands like start, restart, stop, etc"""
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        systemctl += F" --{system}"
        testsleep = testname+"_testsleep"
        testscript = testname+"_testscript.sh"
        logfile = os_path(root, "/var/log/test.log")
        bindir = os_path(root, "/usr/bin")
        begin = "{"
        ends = "}"
        text_file(logfile, "")
        text_file(os_path(testdir, "zzz.service"), F"""
            [Unit]
            Description=Testing Z
            [Service]
            Type=simple
            ExecStartPre=/bin/echo %n
            ExecStart={bindir}/{testscript} 111
            ExecStartPost=/bin/echo started $MAINPID
            ExecStop=/bin/kill -3 $MAINPID
            ExecStopPost=/bin/echo stopped $MAINPID
            ExecStopPost=/bin/sleep 2
            ExecReload=/bin/kill -10 $MAINPID
            KillSignal=SIGQUIT
            [Install]
            WantedBy=multi-user.target
            """)
        shell_file(os_path(bindir, testscript), F"""
            #! /bin/sh
            date +%T,enter > {logfile}
            stops () {begin}
              date +%T,stopping >> {logfile}
              killall {testsleep}
              date +%T,stopped >> {logfile}
            {ends}
            reload () {begin}
              date +%T,reloading >> {logfile}
              date +%T,reloaded >> {logfile}
            {ends}
            trap "stops" 3   # SIGQUIT
            trap "reload" 10 # SIGUSR1
            date +%T,starting >> {logfile}
            {bindir}/{testsleep} $1 >> {logfile} 2>&1 &
            while kill -0 $!; do
               # use 'kill -0' to check the existance of the child
               date +%T,waiting >> {logfile}
               # use 'wait' for children AND external signals
               wait
            done
            date +%T,leaving >> {logfile}
            trap - 3 10 # SIGQUIT SIGUSR1
            date +%T,leave >> {logfile}
        """)
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        zzz_service = F"/etc/systemd/{system}/zzz.service"
        copy_file(os_path(testdir, "zzz.service"), os_path(root, zzz_service))
        #
        cmd = F"{systemctl} enable zzz.service -vv"
        sh____(cmd)
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'start' shall start a service that is NOT is-active ")
        cmd = F"{systemctl} start zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        #
        logg.info("== 'stop' shall stop a service that is-active")
        cmd = F"{systemctl} stop zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        # inspect the service's log
        log = lines4(open(logfile))
        logg.info("LOG\n %s", "\n ".join(log))
        self.assertTrue(greps(log, "enter"))
        self.assertTrue(greps(log, "leave"))
        self.assertTrue(greps(log, "starting"))
        self.assertTrue(greps(log, "stopped"))
        self.assertFalse(greps(log, "reload"))
        os.remove(logfile)
        #
        logg.info("== 'restart' shall start a service that NOT is-active")
        cmd = F"{systemctl} restart zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top1= top
        #
        # inspect the service's log
        log = lines4(open(logfile))
        logg.info("LOG\n %s", "\n ".join(log))
        self.assertTrue(greps(log, "enter"))
        self.assertFalse(greps(log, "leave"))
        self.assertTrue(greps(log, "starting"))
        self.assertFalse(greps(log, "stopped"))
        self.assertFalse(greps(log, "reload"))
        os.remove(logfile)
        #
        logg.info("== 'restart' shall restart a service that is-active")
        cmd = F"{systemctl} restart zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top2 = top
        #
        logg.info("-- and we check that there is a new PID for the service process")
        def find_pids(ps_output: Union[str, List[str]], command: str) -> List[str]:
            pids = []
            for line in _lines4(ps_output):
                if command not in line: continue
                m = re.match(r"\s*[\d:]*\s+(\S+)\s+(\S+)\s+(.*)", line)
                if not m: continue
                pid, ppid, args = m.groups()
                # logg.info("  %s | %s | %s", pid, ppid, args)
                pids.append(pid)
            return pids
        ps1 = find_pids(top1, testsleep)
        ps2 = find_pids(top2, testsleep)
        logg.info("found PIDs %s and %s", ps1, ps2)
        self.assertTrue(len(ps1), 1)
        self.assertTrue(len(ps2), 1)
        self.assertNotEqual(ps1[0], ps2[0])
        #
        # inspect the service's log
        log = lines4(open(logfile))
        logg.info("LOG\n %s", "\n ".join(log))
        self.assertTrue(greps(log, "enter"))
        self.assertTrue(greps(log, "starting"))
        self.assertFalse(greps(log, "reload"))
        os.remove(logfile)
        #
        #
        logg.info("== 'reload' will NOT restart a service that is-active")
        cmd = F"{systemctl} reload zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top3 = top
        #
        logg.info("-- and we check that there is NO new PID for the service process")
        ps3 = find_pids(top3, testsleep)
        logg.info("found PIDs %s and %s", ps2, ps3)
        self.assertTrue(len(ps2), 1)
        self.assertTrue(len(ps3), 1)
        self.assertEqual(ps2[0], ps3[0])
        #
        # inspect the service's log
        log = lines4(open(logfile))
        logg.info("LOG\n %s", "\n ".join(log))
        self.assertFalse(greps(log, "enter"))
        self.assertFalse(greps(log, "leave"))
        self.assertFalse(greps(log, "starting"))
        self.assertFalse(greps(log, "stopped"))
        self.assertTrue(greps(log, "reload"))
        os.remove(logfile)
        #
        logg.info("== 'reload-or-restart' will restart a service that is-active (if ExecReload)")
        cmd = F"{systemctl} reload-or-restart zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top4 = top
        #
        logg.info("-- and we check that there is NO new PID for the service process (if ExecReload)")
        ps4 = find_pids(top4, testsleep)
        logg.info("found PIDs %s and %s", ps3, ps4)
        self.assertTrue(len(ps3), 1)
        self.assertTrue(len(ps4), 1)
        self.assertEqual(ps3[0], ps4[0])
        #
        logg.info("== 'kill' will bring is-active non-active as well (when the PID is known)")
        cmd = F"{systemctl} kill zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'stop' will turn 'failed' to 'inactive' (when the PID is known)")
        cmd = F"{systemctl} stop zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertNotEqual(end, 0) # no PID known so 'kill $MAINPID' fails
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'reload-or-try-restart' will not start a not-active service")
        cmd = F"{systemctl} reload-or-try-restart zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'try-restart' will not start a not-active service")
        cmd = F"{systemctl} try-restart zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'reload-or-restart' will start a not-active service")
        cmd = F"{systemctl} reload-or-restart zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top5 = top
        #
        logg.info("== 'reload-or-try-restart' will NOT restart an is-active service (with ExecReload)")
        cmd = F"{systemctl} reload-or-try-restart zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top6 = top
        #
        logg.info("-- and we check that there is NO new PID for the service process (if ExecReload)")
        ps5 = find_pids(top5, testsleep)
        ps6 = find_pids(top6, testsleep)
        logg.info("found PIDs %s and %s", ps5, ps6)
        self.assertTrue(len(ps5), 1)
        self.assertTrue(len(ps6), 1)
        self.assertEqual(ps5[0], ps6[0])
        #
        logg.info("== 'try-restart' will restart an is-active service")
        cmd = F"{systemctl} try-restart zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top7 = top
        #
        logg.info("-- and we check that there is a new PID for the service process")
        ps7 = find_pids(top7, testsleep)
        logg.info("found PIDs %s and %s", ps6, ps7)
        self.assertTrue(len(ps6), 1)
        self.assertTrue(len(ps7), 1)
        self.assertNotEqual(ps6[0], ps7[0])

        #
        # cleanup
        kill_testsleep = F"{systemctl} __killall {testsleep}"
        sx____(kill_testsleep)
        time.sleep(1)
    def real_25032_forking_service_functions_system(self) -> None:
        """ check that we manage forking services in a root env
            with basic run-service commands: start, stop, restart,
            reload, try-restart, reload-or-restart, kill and
            reload-or-try-restart."""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        self.forking_service_functions("system", testname, testdir)
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_25033_forking_service_functions_user(self) -> None:
        """ check that we manage forking services in a root env
            with basic run-service commands: start, stop, restart,
            reload, try-restart, reload-or-restart, kill and
            reload-or-try-restart."""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        self.forking_service_functions("user", testname, testdir)
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def forking_service_functions(self, system: str, testname: str, testdir: str) -> None:
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        systemctl += F" --{system}"
        testsleep = testname+"_sleep"
        logfile = os_path(root, "/var/log/"+testsleep+".log")
        bindir = os_path(root, "/usr/bin")
        os.makedirs(os_path(root, "/var/run"))
        text_file(logfile, "created\n")
        begin = "{"
        ends = "}"
        shell_file(os_path(testdir, "zzz.init"), F"""
            #! /bin/bash
            logfile={logfile}
            start() {begin}
               [ -d /var/run ] || mkdir -p /var/run
               ({bindir}/{testsleep} 111 0<&- &>/dev/null &
                echo $! > {root}/var/run/zzz.init.pid
               ) &
               wait %1
               # ps -o pid,ppid,args
            {ends}
            stop() {begin}
               killall {testsleep}
            {ends}
            case "$1" in start)
               date "+START.%T" >> $logfile
               start >> $logfile 2>&1
               date "+start.%T" >> $logfile
            ;; stop)
               date "+STOP.%T" >> $logfile
               stop >> $logfile 2>&1
               date "+stop.%T" >> $logfile
            ;; restart)
               date "+RESTART.%T" >> $logfile
               stop >> $logfile 2>&1
               start >> $logfile 2>&1
               date "+.%T" >> $logfile
            ;; reload)
               date "+RELOAD.%T" >> $logfile
               echo "...." >> $logfile 2>&1
               date "+reload.%T" >> $logfile
            ;; esac
            echo "done$1" >&2
            exit 0
            """)
        text_file(os_path(testdir, "zzz.service"), F"""
            [Unit]
            Description=Testing Z
            [Service]
            Type=forking
            PIDFile={root}/var/run/zzz.init.pid
            ExecStart={root}/usr/bin/zzz.init start
            ExecStop={root}/usr/bin/zzz.init stop
            [Install]
            WantedBy=multi-user.target
            """)
        zzz_service = F"/etc/systemd/{system}/zzz.service"
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_tool(os_path(testdir, "zzz.init"), os_path(root, "/usr/bin/zzz.init"))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, zzz_service))
        #
        cmd = F"{systemctl} enable zzz.service -vv"
        sh____(cmd)
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'start' shall start a service that is NOT is-active ")
        cmd = F"{systemctl} start zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        #
        logg.info("== 'stop' shall stop a service that is-active")
        cmd = F"{systemctl} stop zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'restart' shall start a service that NOT is-active")
        cmd = F"{systemctl} restart zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top1= top
        #
        logg.info("== 'restart' shall restart a service that is-active")
        cmd = F"{systemctl} restart zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top2 = top
        #
        logg.info("-- and we check that there is a new PID for the service process")
        def find_pids(ps_output: Union[str, List[str]], command: str) -> List[str]:
            pids = []
            for line in _lines4(ps_output):
                if command not in line: continue
                m = re.match(r"\s*[\d:]*\s+(\S+)\s+(\S+)\s+(.*)", line)
                if not m: continue
                pid, ppid, args = m.groups()
                # logg.info("  %s | %s | %s", pid, ppid, args)
                pids.append(pid)
            return pids
        ps1 = find_pids(top1, testsleep)
        ps2 = find_pids(top2, testsleep)
        logg.info("found PIDs %s and %s", ps1, ps2)
        self.assertTrue(len(ps1), 1)
        self.assertTrue(len(ps2), 1)
        self.assertNotEqual(ps1[0], ps2[0])
        #
        logg.info("== 'reload' will NOT restart a service that is-active")
        cmd = F"{systemctl} reload zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top3 = top
        #
        logg.info("-- and we check that there is NO new PID for the service process")
        ps3 = find_pids(top3, testsleep)
        logg.info("found PIDs %s and %s", ps2, ps3)
        self.assertTrue(len(ps2), 1)
        self.assertTrue(len(ps3), 1)
        self.assertEqual(ps2[0], ps3[0])
        #
        logg.info("== 'reload-or-restart' will restart a service that is-active (if no ExecReload)")
        cmd = F"{systemctl} reload-or-restart zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top4 = top
        #
        logg.info("-- and we check that there is a new PID for the service process (if no ExecReload)")
        ps4 = find_pids(top4, testsleep)
        logg.info("found PIDs %s and %s", ps3, ps4)
        self.assertTrue(len(ps3), 1)
        self.assertTrue(len(ps4), 1)
        self.assertNotEqual(ps3[0], ps4[0])
        #
        logg.info("== 'kill' will bring is-active non-active as well (when the PID is known)")
        cmd = F"{systemctl} kill zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "failed")
        #
        logg.info("== 'stop' will turn 'failed' to 'inactive' (when the PID is known)")
        cmd = F"{systemctl} stop zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'reload-or-try-restart' will not start a not-active service")
        cmd = F"{systemctl} reload-or-try-restart zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'try-restart' will not start a not-active service")
        cmd = F"{systemctl} try-restart zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'reload-or-restart' will start a not-active service")
        cmd = F"{systemctl} reload-or-restart zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top5 = top
        #
        logg.info("== 'reload-or-try-restart' will restart an is-active service (with no ExecReload)")
        cmd = F"{systemctl} try-restart zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top6 = top
        #
        logg.info("-- and we check that there is a new PID for the service process (if no ExecReload)")
        ps5 = find_pids(top5, testsleep)
        ps6 = find_pids(top6, testsleep)
        logg.info("found PIDs %s and %s", ps5, ps6)
        self.assertTrue(len(ps5), 1)
        self.assertTrue(len(ps6), 1)
        self.assertNotEqual(ps5[0], ps6[0])
        #
        logg.info("== 'try-restart' will restart an is-active service")
        cmd = F"{systemctl} try-restart zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top7 = top
        #
        logg.info("-- and we check that there is a new PID for the service process")
        ps7 = find_pids(top7, testsleep)
        logg.info("found PIDs %s and %s", ps6, ps7)
        self.assertTrue(len(ps6), 1)
        self.assertTrue(len(ps7), 1)
        self.assertNotEqual(ps6[0], ps7[0])
        #
        logg.info("LOG\n%s", " "+reads(logfile).replace("\n", "\n "))
    def real_25034_notify_service_functions_system(self) -> None:
        """ check that we manage notify services in a root env
            with basic run-service commands: start, stop, restart,
            reload, try-restart, reload-or-restart, kill and
            reload-or-try-restart."""
        self.begin()
        socat = self.socat()
        if not os.path.exists(socat):
            self.skipTest("missing "+socat)
        testname = self.testname()
        testdir = self.testdir()
        self.notify_service_functions("system", testname, testdir)
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_25035_notify_service_functions_user(self) -> None:
        """ check that we manage notify services in a root env
            with basic run-service commands: start, stop, restart,
            reload, try-restart, reload-or-restart, kill and
            reload-or-try-restart."""
        self.begin()
        socat = self.socat()
        if not os.path.exists(socat):
            self.skipTest("missing "+socat)
        testname = self.testname()
        testdir = self.testdir()
        self.notify_service_functions("user", testname, testdir)
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def notify_service_functions(self, system: str, testname: str, testdir: str) -> None:
        socat = self.socat()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        systemctl += F" --{system}"
        testsleep = testname+"_sleep"
        logfile = os_path(root, "/var/log/"+testsleep+".log")
        bindir = os_path(root, "/usr/bin")
        os.makedirs(os_path(root, "/var/run"))
        text_file(logfile, "created\n")
        begin = "{"
        ends = "}"
        shell_file(os_path(testdir, "zzz.init"), F"""
            #! /bin/bash
            logfile={logfile}
            start() {begin}
                ls -l  $NOTIFY_SOCKET
                {bindir}/{testsleep} 111 0<&- &>/dev/null &
                echo "MAINPID=$!" | {socat} -v -d - UNIX-CLIENT:$NOTIFY_SOCKET
                echo "READY=1" | {socat} -v -d - UNIX-CLIENT:$NOTIFY_SOCKET
                wait %1
                # ps -o pid,ppid,args
            {ends}
            stop() {begin}
                killall {testsleep}
            {ends}
            case "$1" in start)
               date "+START.%T" >> $logfile
               start >> $logfile 2>&1
               date "+start.%T" >> $logfile
            ;; stop)
               date "+STOP.%T" >> $logfile
               stop >> $logfile 2>&1
               date "+stop.%T" >> $logfile
            ;; restart)
               date "+RESTART.%T" >> $logfile
               stop >> $logfile 2>&1
               start >> $logfile 2>&1
               date "+.%T" >> $logfile
            ;; reload)
               date "+RELOAD.%T" >> $logfile
               echo "...." >> $logfile 2>&1
               date "+reload.%T" >> $logfile
            ;; esac
            echo "done$1" >&2
            exit 0
            """)
        text_file(os_path(testdir, "zzz.service"), F"""
            [Unit]
            Description=Testing Z
            [Service]
            Type=notify
            # PIDFile={root}/var/run/zzz.init.pid
            ExecStart={root}/usr/bin/zzz.init start
            ExecStop={root}/usr/bin/zzz.init stop
            [Install]
            WantedBy=multi-user.target
            """)
        zzz_service = F"/etc/systemd/{system}/zzz.service"
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_tool(os_path(testdir, "zzz.init"), os_path(root, "/usr/bin/zzz.init"))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, zzz_service))
        #
        cmd = F"{systemctl} enable zzz.service -vv"
        sh____(cmd)
        #
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'start' shall start a service that is NOT is-active ")
        cmd = F"{systemctl} start zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        #
        logg.info("== 'stop' shall stop a service that is-active")
        cmd = F"{systemctl} stop zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'restart' shall start a service that NOT is-active")
        cmd = F"{systemctl} restart zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top1= top
        #
        logg.info("== 'restart' shall restart a service that is-active")
        cmd = F"{systemctl} restart zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top2 = top
        #
        logg.info("-- and we check that there is a new PID for the service process")
        def find_pids(ps_output: Union[str, List[str]], command: str) -> List[str]:
            pids = []
            for line in _lines4(ps_output):
                if command not in line: continue
                m = re.match(r"\s*[\d:]*\s+(\S+)\s+(\S+)\s+(.*)", line)
                if not m: continue
                pid, ppid, args = m.groups()
                # logg.info("  %s | %s | %s", pid, ppid, args)
                pids.append(pid)
            return pids
        ps1 = find_pids(top1, testsleep)
        ps2 = find_pids(top2, testsleep)
        logg.info("found PIDs %s and %s", ps1, ps2)
        self.assertTrue(len(ps1), 1)
        self.assertTrue(len(ps2), 1)
        self.assertNotEqual(ps1[0], ps2[0])
        #
        logg.info("== 'reload' will NOT restart a service that is-active")
        cmd = F"{systemctl} reload zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top3 = top
        #
        logg.info("-- and we check that there is NO new PID for the service process")
        ps3 = find_pids(top3, testsleep)
        logg.info("found PIDs %s and %s", ps2, ps3)
        self.assertTrue(len(ps2), 1)
        self.assertTrue(len(ps3), 1)
        self.assertEqual(ps2[0], ps3[0])
        #
        logg.info("== 'reload-or-restart' will restart a service that is-active (if no ExecReload)")
        cmd = F"{systemctl} reload-or-restart zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top4 = top
        #
        logg.info("-- and we check that there is a new PID for the service process (if no ExecReload)")
        ps4 = find_pids(top4, testsleep)
        logg.info("found PIDs %s and %s", ps3, ps4)
        self.assertTrue(len(ps3), 1)
        self.assertTrue(len(ps4), 1)
        self.assertNotEqual(ps3[0], ps4[0])
        #
        logg.info("== 'kill' will bring is-active non-active as well (when the PID is known)")
        cmd = F"{systemctl} kill zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'stop' will turn 'failed' to 'inactive' (when the PID is known)")
        cmd = F"{systemctl} stop zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'reload-or-try-restart' will not start a not-active service")
        cmd = F"{systemctl} reload-or-try-restart zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'try-restart' will not start a not-active service")
        cmd = F"{systemctl} try-restart zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'reload-or-restart' will start a not-active service")
        cmd = F"{systemctl} reload-or-restart zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top5 = top
        #
        logg.info("== 'reload-or-try-restart' will restart an is-active service (with no ExecReload)")
        cmd = F"{systemctl} try-restart zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top6 = top
        #
        logg.info("-- and we check that there is a new PID for the service process (if no ExecReload)")
        ps5 = find_pids(top5, testsleep)
        ps6 = find_pids(top6, testsleep)
        logg.info("found PIDs %s and %s", ps5, ps6)
        self.assertTrue(len(ps5), 1)
        self.assertTrue(len(ps6), 1)
        self.assertNotEqual(ps5[0], ps6[0])
        #
        logg.info("== 'try-restart' will restart an is-active service")
        cmd = F"{systemctl} try-restart zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top7 = top
        #
        logg.info("-- and we check that there is a new PID for the service process")
        ps7 = find_pids(top7, testsleep)
        logg.info("found PIDs %s and %s", ps6, ps7)
        self.assertTrue(len(ps6), 1)
        self.assertTrue(len(ps7), 1)
        self.assertNotEqual(ps6[0], ps7[0])
        #
        logg.info("LOG\n%s", " "+reads(logfile).replace("\n", "\n "))
    def real_25036_notify_service_functions_with_reload(self) -> None:
        """ check that we manage notify services in a root env
            with basic run-service commands: start, stop, restart,
            reload, try-restart, reload-or-restart, kill and
            reload-or-try-restart. (with ExecReload)"""
        self.begin()
        socat = self.socat()
        if not os.path.exists(socat):
            self.skipTest("missing "+socat)
        testname = self.testname()
        testdir = self.testdir()
        self.notify_service_functions_with_reload("system", testname, testdir)
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_25037_notify_service_functions_with_reload_user(self) -> None:
        """ check that we manage notify services in a root env
            with basic run-service commands: start, stop, restart,
            reload, try-restart, reload-or-restart, kill and
            reload-or-try-restart. (with ExecReload)"""
        # real_25037 is triggering len(socketfile) > 100 | "new notify socketfile"
        self.begin()
        socat = self.socat()
        if not os.path.exists(socat):
            self.skipTest("missing "+socat)
        testname = self.testname()
        testdir = self.testdir()
        self.notify_service_functions_with_reload("user", testname, testdir)
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def notify_service_functions_with_reload(self, system: str, testname: str, testdir: str) -> None:
        socat = self.socat()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        systemctl += F" --{system}"
        testsleep = self.testname("sleep")
        logfile = os_path(root, "/var/log/"+testsleep+".log")
        bindir = os_path(root, "/usr/bin")
        os.makedirs(os_path(root, "/var/run"))
        text_file(logfile, "created\n")
        begin = "{"
        ends = "}"
        shell_file(os_path(testdir, "zzz.init"), F"""
            #! /bin/bash
            logfile={logfile}
            start() {begin}
                ls -l  $NOTIFY_SOCKET
                {bindir}/{testsleep} 111 0<&- &>/dev/null &
                echo "MAINPID=$!" | {socat} -v -d - UNIX-CLIENT:$NOTIFY_SOCKET
                echo "READY=1" | {socat} -v -d - UNIX-CLIENT:$NOTIFY_SOCKET
                wait %1
                # ps -o pid,ppid,args
            {ends}
            stop() {begin}
                killall {testsleep}
            {ends}
            case "$1" in start)
               date "+START.%T" >> $logfile
               start >> $logfile 2>&1
               date "+start.%T" >> $logfile
            ;; stop)
               date "+STOP.%T" >> $logfile
               stop >> $logfile 2>&1
               date "+stop.%T" >> $logfile
            ;; restart)
               date "+RESTART.%T" >> $logfile
               stop >> $logfile 2>&1
               start >> $logfile 2>&1
               date "+.%T" >> $logfile
            ;; reload)
               date "+RELOAD.%T" >> $logfile
               echo "...." >> $logfile 2>&1
               date "+reload.%T" >> $logfile
            ;; esac
            echo "done$1" >&2
            exit 0
            """)
        text_file(os_path(testdir, "zzz.service"), F"""
            [Unit]
            Description=Testing Z
            [Service]
            Type=notify
            # PIDFile={root}/var/run/zzz.init.pid
            ExecStart={root}/usr/bin/zzz.init start
            ExecReload={root}/usr/bin/zzz.init reload
            ExecStop={root}/usr/bin/zzz.init stop
            TimeoutRestartSec=4
            TimeoutReloadSec=4
            [Install]
            WantedBy=multi-user.target
            """)
        zzz_service = F"/etc/systemd/{system}/zzz.service"
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_tool(os_path(testdir, "zzz.init"), os_path(root, "/usr/bin/zzz.init"))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, zzz_service))
        #
        cmd = F"{systemctl} enable zzz.service -vv"
        sh____(cmd)
        #
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'start' shall start a service that is NOT is-active ")
        cmd = F"{systemctl} start zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        #
        logg.info("== 'stop' shall stop a service that is-active")
        cmd = F"{systemctl} stop zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'restart' shall start a service that NOT is-active")
        cmd = F"{systemctl} restart zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top1= top
        #
        logg.info("== 'restart' shall restart a service that is-active")
        cmd = F"{systemctl} restart zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top2 = top
        #
        logg.info("-- and we check that there is a new PID for the service process")
        def find_pids(ps_output: Union[str, List[str]], command: str) -> List[str]:
            pids = []
            for line in _lines4(ps_output):
                if command not in line: continue
                m = re.match(r"\s*[\d:]*\s+(\S+)\s+(\S+)\s+(.*)", line)
                if not m: continue
                pid, ppid, args = m.groups()
                # logg.info("  %s | %s | %s", pid, ppid, args)
                pids.append(pid)
            return pids
        ps1 = find_pids(top1, testsleep)
        ps2 = find_pids(top2, testsleep)
        logg.info("found PIDs %s and %s", ps1, ps2)
        self.assertTrue(len(ps1), 1)
        self.assertTrue(len(ps2), 1)
        self.assertNotEqual(ps1[0], ps2[0])
        #
        logg.info("== 'reload' will NOT restart a service that is-active")
        cmd = F"{systemctl} reload zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top3 = top
        #
        logg.info("-- and we check that there is NO new PID for the service process")
        ps3 = find_pids(top3, testsleep)
        logg.info("found PIDs %s and %s", ps2, ps3)
        self.assertTrue(len(ps2), 1)
        self.assertTrue(len(ps3), 1)
        self.assertEqual(ps2[0], ps3[0])
        #
        logg.info("== 'reload-or-restart' will restart a service that is-active (if no ExecReload)")
        cmd = F"{systemctl} reload-or-restart zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top4 = top
        #
        logg.info("-- and we check that there is the same PID for the service process (if ExecReload)")
        ps4 = find_pids(top4, testsleep)
        logg.info("found PIDs %s and %s", ps3, ps4)
        self.assertTrue(len(ps3), 1)
        self.assertTrue(len(ps4), 1)
        self.assertEqual(ps3[0], ps4[0])
        #
        logg.info("== 'kill' will bring is-active non-active as well (when the PID is known)")
        cmd = F"{systemctl} kill zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'stop' will turn 'failed' to 'inactive' (when the PID is known)")  # TODO#
        cmd = F"{systemctl} stop zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'reload-or-try-restart' will not start a not-active service")
        cmd = F"{systemctl} reload-or-try-restart zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'try-restart' will not start a not-active service")
        cmd = F"{systemctl} try-restart zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'reload-or-restart' will start a not-active service")
        cmd = F"{systemctl} reload-or-restart zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top5 = top
        #
        logg.info("== 'reload-or-try-restart' will restart an is-active service (with no ExecReload)")
        cmd = F"{systemctl} try-restart zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top6 = top
        #
        logg.info("-- and we check that there is a new PID for the service process (if no ExecReload)")
        ps5 = find_pids(top5, testsleep)
        ps6 = find_pids(top6, testsleep)
        logg.info("found PIDs %s and %s", ps5, ps6)
        self.assertTrue(len(ps5), 1)
        self.assertTrue(len(ps6), 1)
        self.assertNotEqual(ps5[0], ps6[0])
        #
        logg.info("== 'try-restart' will restart an is-active service")
        cmd = F"{systemctl} try-restart zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top7 = top
        #
        logg.info("-- and we check that there is a new PID for the service process")
        ps7 = find_pids(top7, testsleep)
        logg.info("found PIDs %s and %s", ps6, ps7)
        self.assertTrue(len(ps6), 1)
        self.assertTrue(len(ps7), 1)
        self.assertNotEqual(ps6[0], ps7[0])
        #
        logg.info("LOG\n%s", " "+reads(logfile).replace("\n", "\n "))
    def real_25038_notify_service_functions_with_failed(self) -> None:
        """ check that we manage notify services in a root env
            with basic run-service commands: start, stop, restart,
            reload, try-restart, reload-or-restart, kill and
            reload-or-try-restart. (with ExecReload)"""
        self.begin()
        socat = self.socat()
        if not os.path.exists(socat):
            self.skipTest("missing "+socat)
        testname = self.testname()
        testdir = self.testdir()
        self.notify_service_functions_with_failed("system", testname, testdir)
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_25039_notify_service_functions_with_failed(self) -> None:
        """ check that we manage notify services in a root env
            with basic run-service commands: start, stop, restart,
            reload, try-restart, reload-or-restart, kill and
            reload-or-try-restart. (with ExecReload)"""
        # real_25037 is triggering len(socketfile) > 100 | "new notify socketfile"
        self.begin()
        socat = self.socat()
        if not os.path.exists(socat):
            self.skipTest("missing "+socat)
        testname = self.testname()
        testdir = self.testdir()
        self.notify_service_functions_with_failed("user", testname, testdir)
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def notify_service_functions_with_failed(self, system: str, testname: str, testdir: str) -> None:
        socat = self.socat()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        systemctl += F" --{system}"
        testsleep = self.testname("sleep")
        logfile = os_path(root, "/var/log/"+testsleep+".log")
        bindir = os_path(root, "/usr/bin")
        os.makedirs(os_path(root, "/var/run"))
        text_file(logfile, "created\n")
        begin = "{"
        ends = "}"
        shell_file(os_path(testdir, "zzz.init"), F"""
            #! /bin/bash
            logfile={logfile}
            start() {begin}
                ls -l  $NOTIFY_SOCKET
                {bindir}/{testsleep} 4 0<&- &>/dev/null &
                echo "MAINPID=$!" | {socat} -v -d - UNIX-CLIENT:$NOTIFY_SOCKET
                echo "READY=1" | {socat} -v -d - UNIX-CLIENT:$NOTIFY_SOCKET
                wait %1
                # ps -o pid,ppid,args
            {ends}
            stop() {begin}
                killall {testsleep}
            {ends}
            case "$1" in start)
               date "+START.%T" >> $logfile
               start >> $logfile 2>&1
               date "+start.%T" >> $logfile
            ;; stop)
               date "+STOP.%T" >> $logfile
               stop >> $logfile 2>&1
               date "+stop.%T" >> $logfile
            ;; restart)
               date "+RESTART.%T" >> $logfile
               stop >> $logfile 2>&1
               start >> $logfile 2>&1
               date "+.%T" >> $logfile
            ;; reload)
               date "+RELOAD.%T" >> $logfile
               echo "...." >> $logfile 2>&1
               date "+reload.%T" >> $logfile
            ;; esac
            echo "done$1" >&2
            exit 0
            """)
        text_file(os_path(testdir, "zzz.service"), F"""
            [Unit]
            Description=Testing Z
            [Service]
            Type=notify
            # PIDFile={root}/var/run/zzz.init.pid
            ExecStart={root}/usr/bin/zzz.init start
            ExecReload={root}/usr/bin/zzz.init reload
            ExecStop={root}/usr/bin/zzz.init stop
            TimeoutRestartSec=4
            TimeoutReloadSec=4
            [Install]
            WantedBy=multi-user.target
            """)
        zzz_service = F"/etc/systemd/{system}/zzz.service"
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_tool(os_path(testdir, "zzz.init"), os_path(root, "/usr/bin/zzz.init"))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, zzz_service))
        #
        cmd = F"{systemctl} enable zzz.service -vv"
        sh____(cmd)
        #
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'start' shall start a service that is NOT is-active ")
        cmd = F"{systemctl} start zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        #
        time.sleep(5) # -> "failed"
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "failed")
        #
        logg.info("== 'stop' shall stop a service that is-active")
        cmd = F"{systemctl} stop zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("LOG\n%s", " "+reads(logfile).replace("\n", "\n "))
    def real_25040_oneshot_service_functions(self) -> None:
        """ check that we manage oneshot services in a root env
            with basic run-service commands: start, stop, restart,
            reload, try-restart, reload-or-restart, kill and
            reload-or-try-restart."""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        self.oneshot_service_functions("system", testname, testdir)
        self.rm_killall()
        self.rm_testdir()
        self.end()
    def real_25041_oneshot_service_functions_user(self) -> None:
        """ check that we manage oneshot services in a root env
            with basic run-service commands: start, stop, restart,
            reload, try-restart, reload-or-restart, kill and
            reload-or-try-restart."""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        self.oneshot_service_functions("user", testname, testdir)
        self.rm_killall()
        self.rm_testdir()
        self.end()
    def oneshot_service_functions(self, system: str, testname: str, testdir: str) -> None:
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        systemctl += F" --{system}"
        testsleep = self.testname("sleep")
        logfile = os_path(root, "/var/log/"+testsleep+".log")
        bindir = os_path(root, "/usr/bin")
        os.makedirs(os_path(root, "/var/run"))
        text_file(logfile, "created\n")
        text_file(os_path(testdir, "zzz.service"), F"""
            [Unit]
            Description=Testing Z
            [Service]
            Type=oneshot
            ExecStartPre={bindir}/backup {root}/var/tmp/test.1 {root}/var/tmp/test.2
            ExecStart=/usr/bin/touch {root}/var/tmp/test.1
            ExecStop=/bin/rm {root}/var/tmp/test.1
            ExecStopPost=/bin/rm -f {root}/var/tmp/test.2
            [Install]
            WantedBy=multi-user.target
            """)
        shell_file(os_path(testdir, "backup"), """
           #! /bin/sh
           set -x
           test ! -f "$1" || mv -v "$1" "$2"
        """)
        zzz_service = F"/etc/systemd/{system}/zzz.service"
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, zzz_service))
        copy_tool(os_path(testdir, "backup"), os_path(root, "/usr/bin/backup"))
        text_file(os_path(root, "/var/tmp/test.0"), """..""")
        #
        cmd = F"{systemctl} enable zzz.service -vv"
        sh____(cmd)
        #
        is_active = F"{systemctl} is-active zzz.service -vv"
        act, end = output2(is_active)
        self.assertEqual(act.strip(), "inactive")
        self.assertEqual(end, 3)
        #
        logg.info("== 'start' shall start a service that is NOT is-active ")
        cmd = F"{systemctl} start zzz.service -vvvv"
        out, end = output2(cmd)
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active)
        self.assertEqual(act.strip(), "active")
        self.assertEqual(end, 0)
        self.assertTrue(os.path.exists(os_path(root, "/var/tmp/test.1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.2")))
        #
        logg.info("== 'stop' shall stop a service that is-active")
        cmd = F"{systemctl} stop zzz.service -vv"
        out, end = output2(cmd)
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active)
        self.assertEqual(act.strip(), "inactive")
        self.assertEqual(end, 3)
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.2")))
        #
        logg.info("== 'restart' shall start a service that NOT is-active")
        cmd = F"{systemctl} restart zzz.service -vv"
        out, end = output2(cmd)
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active)
        self.assertEqual(act.strip(), "active")
        self.assertEqual(end, 0)
        self.assertTrue(os.path.exists(os_path(root, "/var/tmp/test.1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.2")))
        #
        logg.info("== 'restart' shall restart a service that is-active")
        cmd = F"{systemctl} restart zzz.service -vv"
        out, end = output2(cmd)
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active)
        self.assertEqual(act.strip(), "active")
        self.assertEqual(end, 0)
        self.assertTrue(os.path.exists(os_path(root, "/var/tmp/test.1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.2")))
        #
        logg.info("== 'reload' will NOT restart a service that is-active")
        cmd = F"{systemctl} reload zzz.service -vv"
        out, end = output2(cmd)
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active)
        self.assertEqual(act.strip(), "active")
        self.assertEqual(end, 0)
        self.assertTrue(os.path.exists(os_path(root, "/var/tmp/test.1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.2")))
        #
        logg.info("== 'reload-or-restart' will restart a service that is-active")
        cmd = F"{systemctl} reload-or-restart zzz.service -vv"
        out, end = output2(cmd)
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active)
        self.assertEqual(act.strip(), "active")
        self.assertEqual(end, 0)
        #
        logg.info("== 'stop' will brings it back to 'inactive'")
        cmd = F"{systemctl} stop zzz.service -vv"
        out, end = output2(cmd)
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active)
        self.assertEqual(act.strip(), "inactive")
        self.assertEqual(end, 3)
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.2")))
        #
        logg.info("== 'reload-or-try-restart' will not start a not-active service")
        cmd = F"{systemctl} reload-or-try-restart zzz.service -vv"
        out, end = output2(cmd)
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active)
        self.assertEqual(act.strip(), "inactive")
        self.assertEqual(end, 3)
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.2")))
        #
        logg.info("== 'try-restart' will not start a not-active service")
        cmd = F"{systemctl} try-restart zzz.service -vv"
        out, end = output2(cmd)
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active)
        self.assertEqual(act.strip(), "inactive")
        self.assertEqual(end, 3)
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.2")))
        #
        logg.info("== 'reload-or-restart' will start a not-active service")
        cmd = F"{systemctl} reload-or-restart zzz.service -vv"
        out, end = output2(cmd)
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active)
        self.assertEqual(act.strip(), "active")
        self.assertEqual(end, 0)
        self.assertTrue(os.path.exists(os_path(root, "/var/tmp/test.1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.2")))
        #
        logg.info("== 'reload-or-try-restart' will restart an is-active service")
        cmd = F"{systemctl} reload-or-try-restart zzz.service -vv"
        out, end = output2(cmd)
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active)
        self.assertEqual(act.strip(), "active")
        self.assertEqual(end, 0)
        self.assertTrue(os.path.exists(os_path(root, "/var/tmp/test.1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.2")))
        #
        logg.info("== 'try-restart' will restart an is-active service")
        cmd = F"{systemctl} try-restart zzz.service -vv"
        out, end = output2(cmd)
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active)
        self.assertEqual(act.strip(), "active")
        self.assertEqual(end, 0)
        self.assertTrue(os.path.exists(os_path(root, "/var/tmp/test.1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.2")))
        #
        logg.info("== 'stop' will brings it back to 'inactive'")
        cmd = F"{systemctl} stop zzz.service -vv"
        out, end = output2(cmd)
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active)
        self.assertEqual(act.strip(), "inactive")
        self.assertEqual(end, 3)
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.2")))
        #
        logg.info("LOG\n%s", " "+reads(logfile).replace("\n", "\n "))
    def real_25042_oneshot_and_unknown_service_functions(self) -> None:
        """ check that we manage multiple services even when some
            services are not actually known. Along with oneshot serivce
            with basic run-service commands: start, stop, restart,
            reload, try-restart, reload-or-restart, kill and
            reload-or-try-restart / we have only different exit-code."""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        logfile = os_path(root, "/var/log/"+testsleep+".log")
        bindir = os_path(root, "/usr/bin")
        os.makedirs(os_path(root, "/var/run"))
        text_file(logfile, "created\n")
        text_file(os_path(testdir, "zzz.service"), F"""
            [Unit]
            Description=Testing Z
            [Service]
            Type=oneshot
            ExecStartPre={bindir}/backup {root}/var/tmp/test.1 {root}/var/tmp/test.2
            ExecStart=/usr/bin/touch {root}/var/tmp/test.1
            ExecStop=/bin/rm {root}/var/tmp/test.1
            ExecStopPost=/bin/rm -f {root}/var/tmp/test.2
            [Install]
            WantedBy=multi-user.target
            """)
        shell_file(os_path(testdir, "backup"), """
           #! /bin/sh
           set -x
           test ! -f "$1" || mv -v "$1" "$2"
        """)
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        copy_tool(os_path(testdir, "backup"), os_path(root, "/usr/bin/backup"))
        text_file(os_path(root, "/var/tmp/test.0"), """..""")
        #
        cmd = F"{systemctl} enable zzz.service -vv"
        sh____(cmd)
        is_active = F"{systemctl} is-active zzz.service other.service -vv"
        act, end = output2(is_active)
        self.assertEqual(act.strip(), "inactive\ninactive")
        self.assertEqual(end, 3)
        #
        logg.info("== 'start' shall start a service that is NOT is-active ")
        cmd = F"{systemctl} start zzz.service other.service -vv"
        out, end = output2(cmd)
        logg.info("%s =>\n%s", cmd, out)
        self.assertNotEqual(end, 0)
        is_active = F"{systemctl} is-active zzz.service other.service -vv"
        act, end = output2(is_active)
        self.assertEqual(act.strip(), "active\ninactive")
        self.assertEqual(end, 3)
        self.assertTrue(os.path.exists(os_path(root, "/var/tmp/test.1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.2")))
        #
        logg.info("== 'stop' shall stop a service that is-active")
        cmd = F"{systemctl} stop zzz.service other.service -vv"
        out, end = output2(cmd)
        logg.info("%s =>\n%s", cmd, out)
        self.assertNotEqual(end, 0)
        act, end = output2(is_active)
        self.assertEqual(act.strip(), "inactive\ninactive")
        self.assertEqual(end, 3)
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.2")))
        #
        logg.info("== 'restart' shall start a service that NOT is-active")
        cmd = F"{systemctl} restart zzz.service other.service -vv"
        out, end = output2(cmd)
        logg.info("%s =>\n%s", cmd, out)
        self.assertNotEqual(end, 0)
        act, end = output2(is_active)
        self.assertEqual(act.strip(), "active\ninactive")
        self.assertEqual(end, 3)
        self.assertTrue(os.path.exists(os_path(root, "/var/tmp/test.1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.2")))
        #
        logg.info("== 'restart' shall restart a service that is-active")
        cmd = F"{systemctl} restart zzz.service other.service -vv"
        out, end = output2(cmd)
        logg.info("%s =>\n%s", cmd, out)
        self.assertNotEqual(end, 0)
        act, end = output2(is_active)
        self.assertEqual(act.strip(), "active\ninactive")
        self.assertEqual(end, 3)
        self.assertTrue(os.path.exists(os_path(root, "/var/tmp/test.1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.2")))
        #
        logg.info("== 'reload' will NOT restart a service that is-active")
        cmd = F"{systemctl} reload zzz.service other.service -vv"
        out, end = output2(cmd)
        logg.info("%s =>\n%s", cmd, out)
        self.assertNotEqual(end, 0)
        act, end = output2(is_active)
        self.assertEqual(act.strip(), "active\ninactive")
        self.assertEqual(end, 3)
        self.assertTrue(os.path.exists(os_path(root, "/var/tmp/test.1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.2")))
        #
        logg.info("== 'reload-or-restart' will restart a service that is-active")
        cmd = F"{systemctl} reload-or-restart zzz.service other.service -vv"
        out, end = output2(cmd)
        logg.info("%s =>\n%s", cmd, out)
        self.assertNotEqual(end, 0)
        act, end = output2(is_active)
        self.assertEqual(act.strip(), "active\ninactive")
        self.assertEqual(end, 3)
        #
        logg.info("== 'stop' will brings it back to 'inactive'")
        cmd = F"{systemctl} stop zzz.service other.service -vv"
        out, end = output2(cmd)
        logg.info("%s =>\n%s", cmd, out)
        self.assertNotEqual(end, 0)
        act, end = output2(is_active)
        self.assertEqual(act.strip(), "inactive\ninactive")
        self.assertEqual(end, 3)
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.2")))
        #
        logg.info("== 'reload-or-try-restart' will not start a not-active service")
        cmd = F"{systemctl} reload-or-try-restart zzz.service other.service -vv"
        out, end = output2(cmd)
        logg.info("%s =>\n%s", cmd, out)
        self.assertNotEqual(end, 0)
        act, end = output2(is_active)
        self.assertEqual(act.strip(), "inactive\ninactive")
        self.assertEqual(end, 3)
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.2")))
        #
        logg.info("== 'try-restart' will not start a not-active service")
        cmd = F"{systemctl} try-restart zzz.service other.service -vv"
        out, end = output2(cmd)
        logg.info("%s =>\n%s", cmd, out)
        self.assertNotEqual(end, 0)
        act, end = output2(is_active)
        self.assertEqual(act.strip(), "inactive\ninactive")
        self.assertEqual(end, 3)
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.2")))
        #
        logg.info("== 'reload-or-restart' will start a not-active service")
        cmd = F"{systemctl} reload-or-restart zzz.service other.service -vv"
        out, end = output2(cmd)
        logg.info("%s =>\n%s", cmd, out)
        self.assertNotEqual(end, 0)
        act, end = output2(is_active)
        self.assertEqual(act.strip(), "active\ninactive")
        self.assertEqual(end, 3)
        self.assertTrue(os.path.exists(os_path(root, "/var/tmp/test.1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.2")))
        #
        logg.info("== 'reload-or-try-restart' will restart an is-active service")
        cmd = F"{systemctl} reload-or-try-restart zzz.service other.service -vv"
        out, end = output2(cmd)
        logg.info("%s =>\n%s", cmd, out)
        self.assertNotEqual(end, 0)
        act, end = output2(is_active)
        self.assertEqual(act.strip(), "active\ninactive")
        self.assertEqual(end, 3)
        self.assertTrue(os.path.exists(os_path(root, "/var/tmp/test.1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.2")))
        #
        logg.info("== 'try-restart' will restart an is-active service")
        cmd = F"{systemctl} try-restart zzz.service other.service -vv"
        out, end = output2(cmd)
        logg.info("%s =>\n%s", cmd, out)
        self.assertNotEqual(end, 0)
        act, end = output2(is_active)
        self.assertEqual(act.strip(), "active\ninactive")
        self.assertEqual(end, 3)
        self.assertTrue(os.path.exists(os_path(root, "/var/tmp/test.1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.2")))
        #
        logg.info("== 'stop' will brings it back to 'inactive'")
        cmd = F"{systemctl} stop zzz.service other.service -vv"
        out, end = output2(cmd)
        logg.info("%s =>\n%s", cmd, out)
        self.assertNotEqual(end, 0)
        act, end = output2(is_active)
        self.assertEqual(act.strip(), "inactive\ninactive")
        self.assertEqual(end, 3)
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.2")))
        #
        logg.info("LOG\n%s", " "+reads(logfile).replace("\n", "\n "))
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_25043_oneshot_template_service_functions(self) -> None:
        """ check that we manage oneshot template services in a root env
            with basic run-service commands: start, stop, restart,
            reload, try-restart, reload-or-restart, kill and
            reload-or-try-restart."""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        self.oneshot_template_service_functions("system", testname, testdir)
        self.rm_killall()
        self.rm_testdir()
        self.end()
    def real_25044_oneshot_template_service_functions_user(self) -> None:
        """ check that we manage oneshot template services in a root env
            with basic run-service commands: start, stop, restart,
            reload, try-restart, reload-or-restart, kill and
            reload-or-try-restart."""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        self.oneshot_template_service_functions("user", testname, testdir)
        self.rm_killall()
        self.rm_testdir()
        self.end()
    def oneshot_template_service_functions(self, system: str, testname: str, testdir: str) -> None:
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        systemctl += F" --{system}"
        testsleep = self.testname("sleep")
        logfile = os_path(root, "/var/log/"+testsleep+".log")
        bindir = os_path(root, "/usr/bin")
        os.makedirs(os_path(root, "/var/run"))
        text_file(logfile, "created\n")
        text_file(os_path(testdir, "zzz@.service"), F"""
            [Unit]
            Description=Testing Z.%i
            [Service]
            Type=oneshot
            ExecStartPre={bindir}/backup {root}/var/tmp/test.%i.1 {root}/var/tmp/test.%i.2
            ExecStart=/usr/bin/touch {root}/var/tmp/test.%i.1
            ExecStop=/bin/rm {root}/var/tmp/test.%i.1
            ExecStopPost=/bin/rm -f {root}/var/tmp/test.%i.2
            [Install]
            WantedBy=multi-user.target
            """)
        shell_file(os_path(testdir, "backup"), """
           #! /bin/sh
           set -x
           test ! -f "$1" || mv -v "$1" "$2"
        """)
        zzz_service = F"/etc/systemd/{system}/zzz@.service"
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzz@.service"), os_path(root, zzz_service))
        copy_tool(os_path(testdir, "backup"), os_path(root, "/usr/bin/backup"))
        text_file(os_path(root, "/var/tmp/test.0"), """..""")
        #
        cmd = F"{systemctl} enable zzz@rsa.service -vv"
        sh____(cmd)
        #
        is_active = F"{systemctl} is-active zzz@rsa.service -vv"
        act, end = output2(is_active)
        self.assertEqual(act.strip(), "inactive")
        self.assertEqual(end, 3)
        #
        logg.info("== 'start' shall start a service that is NOT is-active ")
        cmd = F"{systemctl} start zzz@rsa.service -vvvv"
        out, end = output2(cmd)
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active)
        self.assertEqual(act.strip(), "active")
        self.assertEqual(end, 0)
        self.assertTrue(os.path.exists(os_path(root, "/var/tmp/test.rsa.1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.rsa.2")))
        #
        logg.info("== 'stop' shall stop a service that is-active")
        cmd = F"{systemctl} stop zzz@rsa.service -vv"
        out, end = output2(cmd)
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active)
        self.assertEqual(act.strip(), "inactive")
        self.assertEqual(end, 3)
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.rsa.1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.rsa.2")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test..1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test..2")))
        #
        logg.info("== 'restart' shall start a service that NOT is-active")
        cmd = F"{systemctl} restart zzz@rsa.service -vv"
        out, end = output2(cmd)
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active)
        self.assertEqual(act.strip(), "active")
        self.assertEqual(end, 0)
        self.assertTrue(os.path.exists(os_path(root, "/var/tmp/test.rsa.1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.rsa.2")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test..1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test..2")))
        #
        logg.info("== 'restart' shall restart a service that is-active")
        cmd = F"{systemctl} restart zzz@rsa.service -vv"
        out, end = output2(cmd)
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active)
        self.assertEqual(act.strip(), "active")
        self.assertEqual(end, 0)
        self.assertTrue(os.path.exists(os_path(root, "/var/tmp/test.rsa.1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.rsa.2")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test..1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test..2")))
        #
        logg.info("== 'reload' will NOT restart a service that is-active")
        cmd = F"{systemctl} reload zzz@rsa.service -vv"
        out, end = output2(cmd)
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active)
        self.assertEqual(act.strip(), "active")
        self.assertEqual(end, 0)
        self.assertTrue(os.path.exists(os_path(root, "/var/tmp/test.rsa.1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.rsa.2")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test..1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test..2")))
        #
        logg.info("== 'reload-or-restart' will restart a service that is-active")
        cmd = F"{systemctl} reload-or-restart zzz@rsa.service -vv"
        out, end = output2(cmd)
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active)
        self.assertEqual(act.strip(), "active")
        self.assertEqual(end, 0)
        #
        logg.info("== 'stop' will brings it back to 'inactive'")
        cmd = F"{systemctl} stop zzz@rsa.service -vv"
        out, end = output2(cmd)
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active)
        self.assertEqual(act.strip(), "inactive")
        self.assertEqual(end, 3)
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.rsa.1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.rsa.2")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test..1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test..2")))
        #
        logg.info("== 'reload-or-try-restart' will not start a not-active service")
        cmd = F"{systemctl} reload-or-try-restart zzz@rsa.service -vv"
        out, end = output2(cmd)
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active)
        self.assertEqual(act.strip(), "inactive")
        self.assertEqual(end, 3)
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.rsa.1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.rsa.2")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test..1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test..2")))
        #
        logg.info("== 'try-restart' will not start a not-active service")
        cmd = F"{systemctl} try-restart zzz@rsa.service -vv"
        out, end = output2(cmd)
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active)
        self.assertEqual(act.strip(), "inactive")
        self.assertEqual(end, 3)
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.rsa.1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.rsa.2")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test..1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test..2")))
        #
        logg.info("== 'reload-or-restart' will start a not-active service")
        cmd = F"{systemctl} reload-or-restart zzz@rsa.service -vv"
        out, end = output2(cmd)
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active)
        self.assertEqual(act.strip(), "active")
        self.assertEqual(end, 0)
        self.assertTrue(os.path.exists(os_path(root, "/var/tmp/test.rsa.1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.rsa.2")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test..1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test..2")))
        #
        logg.info("== 'reload-or-try-restart' will restart an is-active service")
        cmd = F"{systemctl} reload-or-try-restart zzz@rsa.service -vv"
        out, end = output2(cmd)
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active)
        self.assertEqual(act.strip(), "active")
        self.assertEqual(end, 0)
        self.assertTrue(os.path.exists(os_path(root, "/var/tmp/test.rsa.1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.rsa.2")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test..1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test..2")))
        #
        logg.info("== 'try-restart' will restart an is-active service")
        cmd = F"{systemctl} try-restart zzz@rsa.service -vv"
        out, end = output2(cmd)
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active)
        self.assertEqual(act.strip(), "active")
        self.assertEqual(end, 0)
        self.assertTrue(os.path.exists(os_path(root, "/var/tmp/test.rsa.1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.rsa.2")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test..1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test..2")))
        #
        logg.info("== 'stop' will brings it back to 'inactive'")
        cmd = F"{systemctl} stop zzz@rsa.service -vv"
        out, end = output2(cmd)
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active)
        self.assertEqual(act.strip(), "inactive")
        self.assertEqual(end, 3)
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.rsa.1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.rsa.2")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test..1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test..2")))
        #
        logg.info("LOG\n%s", " "+reads(logfile).replace("\n", "\n "))
    def real_25045_sysv_service_functions(self) -> None:
        """ check that we manage SysV services in a root env
            with basic run-service commands: start, stop, restart,
            reload, try-restart, reload-or-restart, kill and
            reload-or-try-restart."""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        logfile = os_path(root, "/var/log/"+testsleep+".log")
        bindir = os_path(root, "/usr/bin")
        os.makedirs(os_path(root, "/var/run"))
        text_file(logfile, "created\n")
        begin = "{"
        ends = "}"
        shell_file(os_path(testdir, "zzz.init"), F"""
            #! /bin/bash
            ### BEGIN INIT INFO
            # Required-Start: $local_fs $remote_fs $syslog $network
            # Required-Stop:  $local_fs $remote_fs $syslog $network
            # Default-Start:  3 5
            # Default-Stop:   0 1 2 6
            # Short-Description: Testing Z
            # Description:    Allows for SysV testing
            ### END INIT INFO
            logfile={logfile}
            sleeptime=111
            start() {begin}
               [ -d /var/run ] || mkdir -p /var/run
               ({bindir}/{testsleep} $sleeptime 0<&- &>/dev/null &
                echo $! > {root}/var/run/zzz.init.pid
               ) &
               wait %1
               # ps -o pid,ppid,args
               cat "RUNNING `cat {root}/var/run/zzz.init.pid`"
            {ends}
            stop() {begin}
               killall {testsleep}
            {ends}
            case "$1" in start)
               date "+START.%T" >> $logfile
               start >> $logfile 2>&1
               date "+start.%T" >> $logfile
            ;; stop)
               date "+STOP.%T" >> $logfile
               stop >> $logfile 2>&1
               date "+stop.%T" >> $logfile
            ;; restart)
               date "+RESTART.%T" >> $logfile
               stop >> $logfile 2>&1
               start >> $logfile 2>&1
               date "+.%T" >> $logfile
            ;; reload)
               date "+RELOAD.%T" >> $logfile
               echo "...." >> $logfile 2>&1
               date "+reload.%T" >> $logfile
            ;; esac
            echo "done$1" >&2
            exit 0
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_tool(os_path(testdir, "zzz.init"), os_path(root, "/etc/init.d/zzz"))
        #
        cmd = F"{systemctl} enable zzz.service -vv"
        sh____(cmd)
        #
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'start' shall start a service that is NOT is-active ")
        cmd = F"{systemctl} start zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        #
        logg.info("== 'stop' shall stop a service that is-active")
        cmd = F"{systemctl} stop zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'restart' shall start a service that NOT is-active")
        cmd = F"{systemctl} restart zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top1= top
        #
        logg.info("== 'restart' shall restart a service that is-active")
        cmd = F"{systemctl} restart zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top2 = top
        #
        logg.info("-- and we check that there is a new PID for the service process")
        def find_pids(ps_output: Union[str, List[str]], command: str) -> List[str]:
            pids = []
            for line in _lines4(ps_output):
                if command not in line: continue
                m = re.match(r"\s*[\d:]*\s+(\S+)\s+(\S+)\s+(.*)", line)
                if not m: continue
                pid, ppid, args = m.groups()
                # logg.info("  %s | %s | %s", pid, ppid, args)
                pids.append(pid)
            return pids
        ps1 = find_pids(top1, testsleep)
        ps2 = find_pids(top2, testsleep)
        logg.info("found PIDs %s and %s", ps1, ps2)
        self.assertTrue(len(ps1), 1)
        self.assertTrue(len(ps2), 1)
        self.assertNotEqual(ps1[0], ps2[0])
        #
        logg.info("== 'reload' will NOT restart a service that is-active")
        cmd = F"{systemctl} reload zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top3 = top
        #
        logg.info("-- and we check that there is NO new PID for the service process")
        ps3 = find_pids(top3, testsleep)
        logg.info("found PIDs %s and %s", ps2, ps3)
        self.assertTrue(len(ps2), 1)
        self.assertTrue(len(ps3), 1)
        self.assertEqual(ps2[0], ps3[0])
        #
        logg.info("== 'reload-or-restart' may restart a service that is-active")
        cmd = F"{systemctl} reload-or-restart zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        #
        logg.info("== 'stop' will turn 'failed' to 'inactive' (when the PID is known)")
        cmd = F"{systemctl} stop zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'reload-or-try-restart' will start a not-active service")
        cmd = F"{systemctl} reload-or-try-restart zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        #
        cmd = F"{systemctl} stop zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        #
        logg.info("== 'try-restart' will not start a not-active service")
        cmd = F"{systemctl} try-restart zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'reload-or-restart' will start a not-active service")
        cmd = F"{systemctl} reload-or-restart zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top5 = top
        #
        logg.info("== 'reload-or-try-restart' will restart an is-active service (with no ExecReload)")
        cmd = F"{systemctl} reload-or-try-restart zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top6 = top
        #
        logg.info("== 'try-restart' will restart an is-active service")
        cmd = F"{systemctl} try-restart zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top7 = top
        #
        logg.info("-- and we check that there is a new PID for the service process")
        ps6 = find_pids(top6, testsleep)
        ps7 = find_pids(top7, testsleep)
        logg.info("found PIDs %s and %s", ps6, ps7)
        self.assertTrue(len(ps6), 1)
        self.assertTrue(len(ps7), 1)
        self.assertNotEqual(ps6[0], ps7[0])
        #
        logg.info("LOG\n%s", " "+reads(logfile).replace("\n", "\n "))
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_25046_sysv_service_extras(self) -> None:
        """ check that we manage SysV services in a root env"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        logfile = os_path(root, "/var/log/"+testsleep+".log")
        bindir = os_path(root, "/usr/bin")
        os.makedirs(os_path(root, "/var/run"))
        text_file(logfile, "created\n")
        begin = "{"
        ends = "}"
        shell_file(os_path(testdir, "zzz.init"), F"""
            #! /bin/bash
            ### BEGIN INIT INFO
            # Required-Start: $local_fs $remote_fs $syslog $network
            # Required-Stop:  $local_fs $remote_fs $syslog $network
            # Default-Start:  3 5
            # Default-Stop:   0 1 2 6
            # Short-Description: Testing Z
            # Description:    Allows for SysV testing
            ### END INIT INFO
            logfile={logfile}
            sleeptime=111
            start() {begin}
               [ -d /var/run ] || mkdir -p /var/run
               ({bindir}/{testsleep} $sleeptime 0<&- &>/dev/null &
                echo $! > {root}/var/run/zzz.init.pid
               ) &
               wait %1
               # ps -o pid,ppid,args
               cat "RUNNING `cat {root}/var/run/zzz.init.pid`"
            {ends}
            stop() {begin}
               killall {testsleep}
            {ends}
            case "$1" in start)
               date "+START.%T" >> $logfile
               start >> $logfile 2>&1
               date "+start.%T" >> $logfile
            ;; stop)
               date "+STOP.%T" >> $logfile
               stop >> $logfile 2>&1
               date "+stop.%T" >> $logfile
            ;; restart)
               date "+RESTART.%T" >> $logfile
               stop >> $logfile 2>&1
               start >> $logfile 2>&1
               date "+.%T" >> $logfile
            ;; reload)
               date "+RELOAD.%T" >> $logfile
               echo "...." >> $logfile 2>&1
               date "+reload.%T" >> $logfile
            ;; esac
            echo "done$1" >&2
            exit 0
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_tool(os_path(testdir, "zzz.init"), os_path(root, "/etc/init.d/zzz"))
        #
        cmd = F"{systemctl} enable zzz.service -vv"
        sh____(cmd)
        #
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        #
        logg.info("== 'reload' will not start a not-active service")
        cmd = F"{systemctl} reload zzz.service -vv -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        #
        logg.info("== 'start' will not start a not-active service")
        cmd = F"{systemctl} start zzz.service -vv -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        #
        logg.info("== 'reload' will not start a not-active service")
        cmd = F"{systemctl} reload zzz.service -vv -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top5 = top
        #
        logg.info("LOG\n%s", " "+reads(logfile).replace("\n", "\n "))
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_25047_sysv_service_extras(self) -> None:
        """ check that we manage SysV services in a root env"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        logfile = os_path(root, "/var/log/"+testsleep+".log")
        bindir = os_path(root, "/usr/bin")
        os.makedirs(os_path(root, "/var/run"))
        text_file(logfile, "created\n")
        begin = "{"
        ends = "}"
        shell_file(os_path(testdir, "zzz.init"), F"""
            #! /bin/bash
            ### BEGIN INIT INFO
            # Required-Start: $local_fs $remote_fs $syslog $network
            # Required-Stop:  $local_fs $remote_fs $syslog $network
            # Default-Start:  3 5
            # Default-Stop:   0 1 2 6
            # Short-Description: Testing Z
            # Description:    Allows for SysV testing
            ### END INIT INFO
            logfile={logfile}
            sleeptime=111
            start() {begin}
               [ -d /var/run ] || mkdir -p /var/run
               ({bindir}/{testsleep} $sleeptime 0<&- &>/dev/null &
                echo $! > {root}/var/run/zzz.init.pid
               ) &
               wait %1
               # ps -o pid,ppid,args
               cat "RUNNING `cat {root}/var/run/zzz.init.pid`"
            {ends}
            stop() {begin}
               killall {testsleep}
            {ends}
            case "$1" in start)
               date "+START.%T" >> $logfile
               start >> $logfile 2>&1
               date "+start.%T" >> $logfile
            ;; stop)
               date "+STOP.%T" >> $logfile
               stop >> $logfile 2>&1
               date "+stop.%T" >> $logfile
            ;; restart)
               date "+RESTART.%T" >> $logfile
               stop >> $logfile 2>&1
               start >> $logfile 2>&1
               date "+.%T" >> $logfile
            ;; reload)
               date "+RELOAD.%T" >> $logfile
               echo "...." >> $logfile 2>&1
               date "+reload.%T" >> $logfile
               exit 1
            ;; esac
            echo "done$1" >&2
            exit 0
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_tool(os_path(testdir, "zzz.init"), os_path(root, "/etc/init.d/zzz"))
        #
        cmd = F"{systemctl} enable zzz.service -vv"
        sh____(cmd)
        #
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        #
        logg.info("== 'reload' will not start a not-active service")
        cmd = F"{systemctl} reload zzz.service -vv -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        #
        logg.info("== 'reload-or-restart' will not start a not-active service")
        cmd = F"{systemctl} reload-or-restart zzz.service -vv -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        #
        logg.info("== 'reload' will not start a not-active service")
        cmd = F"{systemctl} reload zzz.service -vv -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "failed")
        top5 = top
        #
        logg.info("LOG\n%s", " "+reads(logfile).replace("\n", "\n "))
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_25050_notify_service_functions_with_long_servicename(self) -> None:
        """ check that we manage notify services in a root env
            with a very long servicename (limiting the socket name)"""
        self.begin()
        socat = self.socat()
        if not os.path.exists(socat):
            self.skipTest("missing "+socat)
        testname = self.testname()
        testdir = self.testdir()
        self.notify_service_functions_with_long_servicename("system", testname, testdir)
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_25051_notify_service_functions_with_long_servicename(self) -> None:
        """ check that we manage notify services in a root env
            with a very long servicename (limiting the socket name)"""
        # real_25037 is also triggering len(socketfile) > 100 | "new notify socketfile"
        self.begin()
        socat = self.socat()
        if not os.path.exists(socat):
            self.skipTest("missing "+socat)
        testname = self.testname()
        testdir = self.testdir()
        self.notify_service_functions_with_long_servicename("user", testname, testdir)
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def notify_service_functions_with_long_servicename(self, system: str, testname: str, testdir: str) -> None:
        socat = self.socat()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        systemctl += F" --{system}"
        testsleep = self.testname("sleep")
        logfile = os_path(root, "/var/log/"+testsleep+".log")
        bindir = os_path(root, "/usr/bin")
        os.makedirs(os_path(root, "/var/run"))
        text_file(logfile, "created\n")
        begin = "{"
        ends = "}"
        shell_file(os_path(testdir, "zzz.init"), F"""
            #! /bin/bash
            logfile={logfile}
            start() {begin}
                ls -l  $NOTIFY_SOCKET
                {bindir}/{testsleep} 4 0<&- &>/dev/null &
                echo "MAINPID=$!" | {socat} -v -d - UNIX-CLIENT:$NOTIFY_SOCKET
                echo "READY=1" | {socat} -v -d - UNIX-CLIENT:$NOTIFY_SOCKET
                wait %1
                # ps -o pid,ppid,args
            {ends}
            stop() {begin}
                killall {testsleep}
            {ends}
            case "$1" in start)
               date "+START.%T" >> $logfile
               start >> $logfile 2>&1
               date "+start.%T" >> $logfile
            ;; stop)
               date "+STOP.%T" >> $logfile
               stop >> $logfile 2>&1
               date "+stop.%T" >> $logfile
            ;; restart)
               date "+RESTART.%T" >> $logfile
               stop >> $logfile 2>&1
               start >> $logfile 2>&1
               date "+.%T" >> $logfile
            ;; reload)
               date "+RELOAD.%T" >> $logfile
               echo "...." >> $logfile 2>&1
               date "+reload.%T" >> $logfile
            ;; esac
            echo "done$1" >&2
            exit 0
            """)
        zzz_service = "zzz-using-a-very-long-service-name-which-needs-to-be-truncated-for-the-notify-socket-file.service"
        text_file(os_path(testdir, zzz_service), F"""
            [Unit]
            Description=Testing Z
            [Service]
            Type=notify
            # PIDFile={root}/var/run/zzz.init.pid
            ExecStart={root}/usr/bin/zzz.init start
            ExecReload={root}/usr/bin/zzz.init reload
            ExecStop={root}/usr/bin/zzz.init stop
            TimeoutRestartSec=4
            TimeoutReloadSec=4
            [Install]
            WantedBy=multi-user.target
            """)
        zzz_service_path = F"/etc/systemd/{system}/{zzz_service}"
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_tool(os_path(testdir, "zzz.init"), os_path(root, "/usr/bin/zzz.init"))
        copy_file(os_path(testdir, zzz_service), os_path(root, zzz_service_path))
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG, system not in ["user"]))
        text_file(debug_log, "")
        logg.info("debug.log = %s", debug_log)
        #
        cmd = F"{systemctl} enable {zzz_service} -vv"
        sh____(cmd)
        #
        cmd = F"{systemctl} is-active {zzz_service} -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'start' shall start a service that is NOT is-active ")
        cmd = F"{systemctl} start {zzz_service} -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        log = reads(debug_log)
        logg.info("debug.log>>%s", i2(log))
        self.assertTrue(greps(log, "old notify socketfile [(]\\d\\d\\d[)]"))
        self.assertTrue(greps(log, "new notify socketfile [(]\\d\\d[)]"))
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = F"{systemctl} is-active {zzz_service} -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        #
        time.sleep(5) # -> "failed"
        cmd = F"{systemctl} is-active {zzz_service} -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "failed")
        #
        logg.info("== 'stop' shall stop a service that is-active")
        cmd = F"{systemctl} stop {zzz_service} -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = F"{systemctl} is-active {zzz_service} -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("LOG\n%s", " "+reads(logfile).replace("\n", "\n "))
    def real_25052_notify_service_functions_with_other_notify_dir(self) -> None:
        """ check that we manage notify services in a root env
            with a very long servicename (limiting the socket name)"""
        self.begin()
        socat = self.socat()
        if not os.path.exists(socat):
            self.skipTest("missing "+socat)
        testname = self.testname()
        testdir = self.testdir()
        self.notify_service_functions_with_other_notify_dir("system", testname, testdir)
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_25053_notify_service_functions_with_other_notify_dir(self) -> None:
        """ check that we manage notify services in a root env
            with a very long servicename (limiting the socket name)"""
        # real_25037 is also triggering len(socketfile) > 100 | "new notify socketfile"
        self.begin()
        socat = self.socat()
        if not os.path.exists(socat):
            self.skipTest("missing "+socat)
        testname = self.testname()
        testdir = self.testdir()
        self.notify_service_functions_with_other_notify_dir("user", testname, testdir)
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def notify_service_functions_with_other_notify_dir(self, system: str, testname: str, testdir: str) -> None:
        socat = self.socat()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        systemctl += F" --{system}"
        systemctl += " -c NOTIFY_SOCKET_FOLDER=/var/run-using-notify-special-folder"
        testsleep = self.testname("sleep")
        logfile = os_path(root, "/var/log/"+testsleep+".log")
        bindir = os_path(root, "/usr/bin")
        os.makedirs(os_path(root, "/var/run"))
        text_file(logfile, "created\n")
        begin = "{"
        ends = "}"
        shell_file(os_path(testdir, "zzz.init"), F"""
            #! /bin/bash
            logfile={logfile}
            start() {begin}
                ls -l  $NOTIFY_SOCKET
                {bindir}/{testsleep} 4 0<&- &>/dev/null &
                echo "MAINPID=$!" | {socat} -v -d - UNIX-CLIENT:$NOTIFY_SOCKET
                echo "READY=1" | {socat} -v -d - UNIX-CLIENT:$NOTIFY_SOCKET
                wait %1
                # ps -o pid,ppid,args
            {ends}
            stop() {begin}
                killall {testsleep}
            {ends}
            case "$1" in start)
               date "+START.%T" >> $logfile
               start >> $logfile 2>&1
               date "+start.%T" >> $logfile
            ;; stop)
               date "+STOP.%T" >> $logfile
               stop >> $logfile 2>&1
               date "+stop.%T" >> $logfile
            ;; restart)
               date "+RESTART.%T" >> $logfile
               stop >> $logfile 2>&1
               start >> $logfile 2>&1
               date "+.%T" >> $logfile
            ;; reload)
               date "+RELOAD.%T" >> $logfile
               echo "...." >> $logfile 2>&1
               date "+reload.%T" >> $logfile
            ;; esac
            echo "done$1" >&2
            exit 0
            """)
        zzz_service = "zzz-using-a-very-long-service-name-which-needs-to-be-truncated-for-the-notify-socket-file.service"
        text_file(os_path(testdir, zzz_service), F"""
            [Unit]
            Description=Testing Z
            [Service]
            Type=notify
            # PIDFile={root}/var/run/zzz.init.pid
            ExecStart={root}/usr/bin/zzz.init start
            ExecReload={root}/usr/bin/zzz.init reload
            ExecStop={root}/usr/bin/zzz.init stop
            TimeoutRestartSec=4
            TimeoutReloadSec=4
            [Install]
            WantedBy=multi-user.target
            """)
        zzz_service_path = F"/etc/systemd/{system}/{zzz_service}"
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_tool(os_path(testdir, "zzz.init"), os_path(root, "/usr/bin/zzz.init"))
        copy_file(os_path(testdir, zzz_service), os_path(root, zzz_service_path))
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG, system not in ["user"]))
        text_file(debug_log, "")
        logg.info("debug.log = %s", debug_log)
        #
        cmd = F"{systemctl} enable {zzz_service} -vv"
        sh____(cmd)
        #
        cmd = F"{systemctl} is-active {zzz_service} -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'start' shall start a service that is NOT is-active ")
        cmd = F"{systemctl} start {zzz_service} -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        log = reads(debug_log)
        logg.info("debug.log>>%s", i2(log))
        self.assertTrue(greps(log, "old notify socketfile [(]\\d\\d\\d[)]"))
        self.assertTrue(greps(log, "new notify socketfile [(]\\d\\d[)].*special-folder"))
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = F"{systemctl} is-active {zzz_service} -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        #
        time.sleep(5) # -> "failed"
        cmd = F"{systemctl} is-active {zzz_service} -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "failed")
        #
        logg.info("== 'stop' shall stop a service that is-active")
        cmd = F"{systemctl} stop {zzz_service} -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = F"{systemctl} is-active {zzz_service} -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("LOG\n%s", " "+reads(logfile).replace("\n", "\n "))

    def real_25060_forking_service_failed_functions(self) -> None:
        """ check that we manage forking services in a root env
            with basic run-service commands: start, stop, restart,
            checking the executions when some part fails."""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        quick = QUICK
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        logfile = os_path(root, "/var/log/"+testsleep+".log")
        bindir = os_path(root, "/usr/bin")
        fail = os_path(root, "/tmp/fail")
        os.makedirs(os_path(root, "/var/run"))
        text_file(logfile, "created\n")
        begin = "{"
        ends = "}"
        shell_file(os_path(testdir, "zzz.init"), F"""
            #! /bin/bash
            logfile={logfile}
            start() {begin}
               [ -d /var/run ] || mkdir -p /var/run
               ({bindir}/{testsleep} 111 0<&- &>/dev/null &
                echo $! > {root}/var/run/zzz.init.pid
               ) &
               wait %1
               # ps -o pid,ppid,args
            {ends}
            stop() {begin}
               killall {testsleep}
            {ends}
            echo "run-$1" >> $logfile
            if test -f {fail}$1; then
               echo "fail-$1" >> $logfile
               exit 1
            fi
            case "$1"
            in start)
               echo "START-IT" >> $logfile
               start >> $logfile 2>&1
               echo "started" >> $logfile
            ;; stop)
               echo "STOP-IT" >> $logfile
               stop >> $logfile 2>&1
               echo "stopped" >> $logfile
            ;; restart)
               echo "RESTART-IT" >> $logfile
               stop >> $logfile 2>&1
               start >> $logfile 2>&1
               echo "restarted" >> $logfile
            ;; reload)
               echo "RELOAD-IT" >> $logfile
               echo "...." >> $logfile 2>&1
               echo "reloaded" >> $logfile
            ;; start-pre)
               echo "START-PRE" >> $logfile
            ;; start-post)
               echo "START-POST" >> $logfile
            ;; stop-post)
               echo "STOP-POST" >> $logfile
            ;; esac
            echo "done$1" >&2
            if test -f {fail}after$1; then
               echo "fail-after-$1" >> $logfile
               exit 1
            fi
            exit 0
            """)
        text_file(os_path(testdir, "zzz.service"), F"""
            [Unit]
            Description=Testing Z
            [Service]
            Type=forking
            PIDFile={root}/var/run/zzz.init.pid
            ExecStartPre={root}/usr/bin/zzz.init start-pre
            ExecStart={root}/usr/bin/zzz.init start
            ExecStartPost={root}/usr/bin/zzz.init start-post
            ExecStop={root}/usr/bin/zzz.init stop
            ExecStopPost={root}/usr/bin/zzz.init stop-post
            [Install]
            WantedBy=multi-user.target
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_tool(os_path(testdir, "zzz.init"), os_path(root, "/usr/bin/zzz.init"))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        #
        cmd = F"{systemctl} enable zzz.service -vv"
        sh____(cmd)
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        log = lines4(open(logfile))
        logg.info("LOG\n %s", "\n ".join(log))
        os.remove(logfile)
        self.assertEqual(log, ["created"])
        #
        logg.info("== 'start' shall start a service that is NOT is-active ")
        cmd = F"{systemctl} start zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        #
        log = lines4(open(logfile))
        logg.info("LOG\n %s", "\n ".join(log))
        os.remove(logfile)
        self.assertEqual(log, [
            "run-start-pre", "START-PRE",
            "run-start", "START-IT", "started",
            "run-start-post", "START-POST"])
        #
        logg.info("== 'stop' shall stop a service that is-active")
        cmd = F"{systemctl} stop zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        log = lines4(open(logfile))
        logg.info("LOG\n %s", "\n ".join(log))
        os.remove(logfile)
        self.assertEqual(log, [
            "run-stop", "STOP-IT", "stopped",
            "run-stop-post", "STOP-POST"])
        #
        text_file(fail+"start", "")
        #
        logg.info("== 'start' returns to stopped if the main call fails ")
        cmd = F"{systemctl} start zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertNotEqual(end, 0)
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertNotEqual(end, 0)
        self.assertEqual(out.strip(), "inactive")
        #
        log = lines4(open(logfile))
        logg.info("LOG\n %s", "\n ".join(log))
        os.remove(logfile)
        self.assertEqual(log, [
            "run-start-pre", "START-PRE",
            "run-start", "fail-start",
            "run-stop-post", "STOP-POST"])
        #
        logg.info("== 'stop' on stopped service does not do much ")
        cmd = F"{systemctl} stop zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertNotEqual(end, 0)
        self.assertEqual(out.strip(), "inactive")
        #
        log = lines4(open(logfile))
        logg.info("LOG\n %s", "\n ".join(log))
        os.remove(logfile)
        self.assertEqual(log[:2], [
            "run-stop", "STOP-IT"])
        self.assertEqual(log[-2:], [
            "run-stop-post", "STOP-POST"])
        #
        logg.info("== 'restart' on a stopped item remains stopped if the main call fails ")
        cmd = F"{systemctl} restart zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertNotEqual(end, 0)
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertNotEqual(end, 0)
        self.assertEqual(out.strip(), "inactive")
        #
        log = lines4(open(logfile))
        logg.info("LOG\n %s", "\n ".join(log))
        os.remove(logfile)
        self.assertEqual(log, [
            "run-start-pre", "START-PRE",
            "run-start", "fail-start",
            "run-stop-post", "STOP-POST"])
        #
        os.remove(fail+"start")
        text_file(fail+"stop", "")
        #
        logg.info("== 'start' that service ")
        cmd = F"{systemctl} start zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        logg.info("== 'stop' may have a failed item ")
        cmd = F"{systemctl} stop zzz.service -vv {quick}"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertNotEqual(end, 0)
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        # 'active' because the PIDFile process was not killed
        #
        log = lines4(open(logfile))
        logg.info("LOG\n %s", "\n ".join(log))
        os.remove(logfile)
        self.assertEqual(log, [
            "run-start-pre", "START-PRE",
            "run-start", "START-IT", "started",
            "run-start-post", "START-POST",
            "run-stop", "fail-stop"])
        #
        os.remove(fail+"stop")
        text_file(fail+"afterstop", "")
        #
        logg.info("== 'start' that service ")
        cmd = F"{systemctl} start zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        logg.info("== 'stop' may have a failed item ")
        cmd = F"{systemctl} stop zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertNotEqual(end, 0)
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertNotEqual(end, 0)
        self.assertEqual(out.strip(), "inactive")
        #
        log = lines4(open(logfile))
        logg.info("LOG\n %s", "\n ".join(log))
        os.remove(logfile)
        self.assertEqual(log, [
            "run-start-pre", "START-PRE",
            "run-start", "START-IT", "started",
            "run-start-post", "START-POST",
            "run-stop", "STOP-IT", "stopped", "fail-after-stop",
            "run-stop-post", "STOP-POST"])
        #
        os.remove(fail+"afterstop")
        text_file(fail+"afterstart", "")
        #
        logg.info("== 'start' shall start a service that is NOT is-active ")
        cmd = F"{systemctl} start zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        cmd = F"{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "failed")
        #
        log = lines4(open(logfile))
        logg.info("LOG\n %s", "\n ".join(log))
        os.remove(logfile)
        self.assertEqual(log, [
            "run-start-pre", "START-PRE",
            "run-start", "START-IT", "started", "fail-after-start",
            "run-stop-post", "STOP-POST"])
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_25070_oneshot_truncate_old_status(self) -> None:
        """ check that we manage a service that has some old .status
            file being around. That is a reboot has occurred and the
            information is not relevant to the current system state."""
        self.begin()
        self.rm_testdir()
        vv = "-vv"
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        logfile = os_path(root, "/var/log/"+testsleep+".log")
        bindir = os_path(root, "/usr/bin")
        os.makedirs(os_path(root, "/var/run"))
        text_file(logfile, "created\n")
        text_file(os_path(testdir, "zzz.service"), F"""
            [Unit]
            Description=Testing Z
            [Service]
            Type=oneshot
            ExecStart=/usr/bin/touch {root}/var/tmp/test.1
            ExecStopPost=/bin/rm {root}/var/tmp/test.1
            [Install]
            WantedBy=multi-user.target
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        text_file(os_path(root, "/var/tmp/test.0"), """..""")
        #
        getpid_boot_time = get_proc_started(os.getpid())
        system_boot_time = datetime.datetime.fromtimestamp(getpid_boot_time - 1)
        bootpid = os.getpid()
        systemctl += F" -c BOOT_PID_MIN={bootpid} -c DEBUG_BOOTTIME"
        #
        cmd = F"{systemctl} enable zzz.service -vv"
        sh____(cmd)
        is_active = F"{systemctl} is-active zzz.service other.service {vv}"
        act, end = output2(is_active)
        self.assertEqual(act.strip(), "inactive\ninactive")
        self.assertEqual(end, 3)
        #
        logg.info("== 'start' shall start a service that is NOT is-active ")
        cmd = F"{systemctl} start zzz.service other.service -vv"
        out, end = output2(cmd)
        logg.info("%s =>\n%s", cmd, out)
        self.assertNotEqual(end, 0)
        is_active = F"{systemctl} is-active zzz.service other.service -vv"
        act, end = output2(is_active)
        self.assertEqual(act.strip(), "active\ninactive")
        self.assertEqual(end, 3)
        self.assertTrue(os.path.exists(os_path(root, "/var/tmp/test.1")))
        #
        is_active = F"{systemctl} is-active zzz.service other.service -vvvv"
        act, end = output2(is_active)
        self.assertEqual(act.strip(), "active\ninactive")
        self.assertEqual(end, 3)
        #
        logg.info("== 'stop' shall stop a service that is-active")
        cmd = F"{systemctl} stop zzz.service other.service -vv"
        out, end = output2(cmd)
        logg.info("%s =>\n%s", cmd, out)
        self.assertNotEqual(end, 0)
        act, end = output2(is_active)
        self.assertEqual(act.strip(), "inactive\ninactive")
        self.assertEqual(end, 3)
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.1")))
        #
        logg.info("== 'restart' shall start a service that NOT is-active\n")
        cmd = F"{systemctl} restart zzz.service other.service -vv"
        out, end = output2(cmd)
        logg.info("%s =>\n%s", cmd, out)
        self.assertNotEqual(end, 0)
        act, end = output2(is_active)
        self.assertEqual(act.strip(), "active\ninactive")
        self.assertEqual(end, 3)
        self.assertTrue(os.path.exists(os_path(root, "/var/tmp/test.1")))
        #
        logg.info("== mark the status file as being too old")
        # status_file = os_path(root, "/run/zzz.service.status")
        cmd = F"{systemctl} -p StatusFilePath show zzz.service"
        status_file = output(cmd).split("=", 1)[1].strip()
        logg.info("status_file = %s", status_file)
        self.assertTrue(os.path.exists(status_file))
        sh____(F"LANG=C stat {status_file} | grep Modify:")
        sh____(F"touch -d '{system_boot_time}' {status_file}")
        sh____(F"LANG=C stat {status_file} | grep Modify:")
        #
        logg.info("== the next is-active shall then truncate it")
        old_size = os.path.getsize(status_file)
        is_activeXX = F"{systemctl} is-active zzz.service other.service {vv} {vv}"
        act, end = output2(is_activeXX)
        self.assertEqual(act.strip(), "inactive\ninactive")
        self.assertEqual(end, 3)
        self.assertTrue(os.path.exists(os_path(root, "/var/tmp/test.1")))
        new_size = os.path.getsize(status_file)
        logg.info("status-file size: old %s new %s", old_size, new_size)
        self.assertGreater(old_size, 0)
        self.assertEqual(new_size, 0)
        #
        logg.info("== 'stop' shall cleanup a service that was not inactive")
        cmd = F"{systemctl} stop zzz.service other.service -vv"
        out, end = output2(cmd)
        logg.info("%s =>\n%s", cmd, out)
        self.assertNotEqual(end, 0)
        act, end = output2(is_active)
        self.assertEqual(act.strip(), "inactive\ninactive")
        self.assertEqual(end, 3)
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.1")))
        # and the status_file is also cleaned away
        self.assertFalse(os.path.exists(status_file))
        #
        logg.info("LOG\n%s", " "+reads(logfile).replace("\n", "\n "))
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_25075_simple_truncate_old_pid(self) -> None:
        """ check that we manage a service that has some old .pid
            file being around. That is a reboot has occurred and the
            information is not relevant to the current system state."""
        self.begin()
        vv = "-vv"
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        logfile = os_path(root, "/var/log/test.log")
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zzz.service"), F"""
            [Unit]
            Description=Testing Z
            After=foo.service
            AssertFileIsExecutable=//usr/bin/killall
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleep} 99
            ExecStop=/usr/bin/killall {testsleep}
            [Install]
            WantedBy=multi-user.target
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        #
        getpid_boot_time = get_proc_started(os.getpid())
        system_boot_time = datetime.datetime.fromtimestamp(getpid_boot_time - 1)
        bootpid = os.getpid()
        systemctl += F" -c BOOT_PID_MIN={bootpid} -c DEBUG_BOOTTIME"
        #
        cmd = F"{systemctl} enable zzz.service -vv"
        sh____(cmd)
        is_active = F"{systemctl} is-active zzz.service other.service {vv}"
        act, end = output2(is_active)
        self.assertEqual(act.strip(), "inactive\ninactive")
        self.assertEqual(end, 3)
        #
        logg.info("== 'start' shall start a service that is NOT is-active ")
        cmd = F"{systemctl} start zzz.service other.service -vv"
        out, end = output2(cmd)
        logg.info("%s =>\n%s", cmd, out)
        self.assertNotEqual(end, 0)
        is_active = F"{systemctl} is-active zzz.service other.service -vv"
        act, end = output2(is_active)
        self.assertEqual(act.strip(), "active\ninactive")
        self.assertEqual(end, 3)
        #
        logg.info("== 'stop' shall stop a service that is-active")
        cmd = F"{systemctl} stop zzz.service other.service -vv"
        out, end = output2(cmd)
        logg.info("%s =>\n%s", cmd, out)
        self.assertNotEqual(end, 0)
        act, end = output2(is_active)
        self.assertEqual(act.strip(), "inactive\ninactive")
        self.assertEqual(end, 3)
        #
        logg.info("== 'restart' shall start a service that NOT is-active\n")
        cmd = F"{systemctl} restart zzz.service other.service -vv"
        out, end = output2(cmd)
        logg.info("%s =>\n%s", cmd, out)
        self.assertNotEqual(end, 0)
        act, end = output2(is_active)
        self.assertEqual(act.strip(), "active\ninactive")
        self.assertEqual(end, 3)
        #
        time.sleep(2)
        logg.info("== mark the status file as being too old")
        # status_file = os_path(root, "/var/run/zzz.service.status")
        cmd = F"{systemctl} -p StatusFilePath show zzz.service"
        status_file = output(cmd).split("=", 1)[1].strip()
        logg.info("status_file = %s", status_file)
        self.assertTrue(os.path.exists(status_file))
        sh____(F"LANG=C stat {status_file} | grep Modify:")
        sh____(F"LANG=C stat /proc/1/status | grep Modify:")
        sh____(F"touch -d '{system_boot_time}' {status_file}")
        sh____(F"LANG=C stat {status_file} | grep Modify:")
        #
        pid_file = os_path(root, "/var/run/zzz.service.pid")
        #+ self.assertTrue(os.path.exists(pid_file))
        #+ sh____(F"LANG=C stat {pid_file} | grep Modify:")
        #+ sh____(F"LANG=C stat /proc/1/status | grep Modify:")
        #+ sh____(F"touch -r /proc/1/status {pid_file}")
        #+ sh____(F"LANG=C stat {pid_file} | grep Modify:")
        #
        logg.info("== the next is-active shall then truncate it")
        old_status = os.path.getsize(status_file)
        # + old_pid = os.path.getsize(pid_file)
        is_activeXX = F"{systemctl} is-active zzz.service other.service {vv} {vv}"
        act, end = output2(is_activeXX)
        self.assertEqual(act.strip(), "inactive\ninactive")
        self.assertEqual(end, 3)
        new_status = os.path.getsize(status_file)
        # + new_pid = os.path.getsize(pid_file)
        logg.info("status-file size: old %s new %s", old_status, new_status)
        self.assertGreater(old_status, 0)
        self.assertEqual(new_status, 0)
        #+ logg.info("pid-file size: old %s new %s", old_pid, new_pid)
        #+ self.assertGreater(old_pid, 0)
        #+ self.assertEqual(new_pid, 0)
        #
        logg.info("== 'stop' shall cleanup a service that was not inactive")
        cmd = F"{systemctl} stop zzz.service other.service -vv"
        out, end = output2(cmd)
        logg.info("%s =>\n%s", cmd, out)
        self.assertNotEqual(end, 0)
        act, end = output2(is_active)
        self.assertEqual(act.strip(), "inactive\ninactive")
        self.assertEqual(end, 3)
        logg.info("== and the status_file / pid_file is also cleaned away")
        self.assertFalse(os.path.exists(status_file))
        self.assertFalse(os.path.exists(pid_file))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_25079_simple_truncate_oldest_pid(self) -> None:
        """ check that we manage a service that has some old .pid
            file being around. That is a reboot has occurred and the
            information is not relevant to the current system state."""
        self.begin()
        vv = "-vv"
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        logfile = os_path(root, "/var/log/test.log")
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zzz.service"), F"""
            [Unit]
            Description=Testing Z
            After=foo.service
            AssertFileIsExecutable=//usr/bin/killall
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleep} 99
            ExecStop=/usr/bin/killall {testsleep}
            [Install]
            WantedBy=multi-user.target
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        #
        pid_max = reads("/proc/sys/kernel/pid_max").strip()
        bootpid = pid_max
        systemctl += F" -c BOOT_PID_MIN={bootpid} -c DEBUG_BOOTTIME"
        #
        cmd = F"{systemctl} enable zzz.service -vv"
        sh____(cmd)
        cmd = F"{systemctl} start zzz.service -vv"
        sh____(cmd)
        #
        cmd = F"{systemctl} is-active zzz.service other.service -vvvv"
        act, err, end = output3(cmd)
        self.assertEqual(act.strip(), "active\ninactive")
        self.assertEqual(end, 3)
        #
        cmd = F"{systemctl} stop zzz.service -vv"
        sh____(cmd)
        #
        logg.info("ERR => %s", err)
        self.assertTrue(greps(err, "boottime from the oldest entry in /proc"))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_24090_simple_service_RemainAfterExit(self) -> None:
        self.real_25090_simple_service_RemainAfterExit(True)
    def real_25090_simple_service_RemainAfterExit(self, real: bool = False) -> None:
        """ check that we manage simple services in a root env
            with commands like start, restart, stop, etc where
            RemainAfterExit=yes says the service is okay even
            when ExecStart has finished."""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir, real)
        vv = "-vv"
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        extrasleep = self.testname("testextrasleep")
        testsleep = self.testname("testsleep")
        testfail = self.testname("testfail.sh")
        bindir = os_path(root, "/usr/bin")
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_tool(_bin_sleep, os_path(bindir, extrasleep))
        text_file(os_path(testdir, "zzz.service"), F"""
            [Unit]
            Description=Testing Z
            [Service]
            Type=simple
            ExecStartPre=/bin/echo %n
            ExecStart={bindir}/{testsleep} 20
            ExecStartPost=/bin/echo started $MAINPID
            ExecStop=/bin/kill $MAINPID
            ExecStopPost=/bin/echo stopped $MAINPID
            ExecStopPost={bindir}/{extrasleep} 2
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zze.service"), F"""
            [Unit]
            Description=Testing E
            [Service]
            Type=simple
            ExecStartPre=/bin/echo %n
            ExecStart={bindir}/{testsleep} 3
            ExecStartPost=/bin/echo started $MAINPID
            ExecStop=/bin/kill $MAINPID
            ExecStopPost=/bin/echo stopped $MAINPID
            ExecStopPost={bindir}/{extrasleep} 2
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zzf.service"), F"""
            [Unit]
            Description=Testing F
            [Service]
            Type=simple
            ExecStartPre=/bin/echo %n
            ExecStart={bindir}/{testfail} 3
            ExecStartPost=/bin/echo started $MAINPID
            ExecStop=/bin/kill $MAINPID
            ExecStopPost=/bin/echo stopped $MAINPID
            ExecStopPost={bindir}/{extrasleep} 2
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zzr.service"), F"""
            [Unit]
            Description=Testing R
            [Service]
            Type=simple
            RemainAfterExit=yes
            ExecStartPre=/bin/echo %n
            ExecStart={bindir}/{testsleep} 3
            ExecStartPost=/bin/echo started $MAINPID
            ExecStop=/bin/kill $MAINPID
            ExecStopPost=/bin/echo stopped $MAINPID
            ExecStopPost={bindir}/{extrasleep} 2
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zzx.service"), F"""
            [Unit]
            Description=Testing X
            [Service]
            Type=simple
            RemainAfterExit=yes
            ExecStartPre=/bin/echo %n
            ExecStart={bindir}/{testfail} 3
            ExecStartPost=/bin/echo started $MAINPID
            ExecStop=/bin/kill $MAINPID
            ExecStopPost=/bin/echo stopped $MAINPID
            ExecStopPost={bindir}/{extrasleep} 2
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "testfail.sh"), F"""
            #! /bin/sh
            {bindir}/{testsleep} $1
            exit 2
            """)
        copy_tool(os_path(testdir, "testfail.sh"), os_path(bindir, testfail))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        copy_file(os_path(testdir, "zze.service"), os_path(root, "/etc/systemd/system/zze.service"))
        copy_file(os_path(testdir, "zzf.service"), os_path(root, "/etc/systemd/system/zzf.service"))
        copy_file(os_path(testdir, "zzr.service"), os_path(root, "/etc/systemd/system/zzr.service"))
        copy_file(os_path(testdir, "zzx.service"), os_path(root, "/etc/systemd/system/zzx.service"))
        sh____(F"{systemctl} daemon-reload")
        #
        cmd = F"{systemctl} is-active zzz.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        cmd = F"{systemctl} enable zzz.service {vv}"
        sh____(cmd)
        cmd = F"{systemctl} is-active zzz.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'start' shall start a normal service ")
        cmd = F"{systemctl} start zzz.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        time.sleep(4)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        #
        logg.info("== 'stop' shall stop a normal service")
        cmd = F"{systemctl} stop zzz.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzz.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        cmd = F"{systemctl} enable zze.service {vv}"
        sh____(cmd)
        #
        logg.info("== 'start' will run a later exiting service ")
        cmd = F"{systemctl} start zze.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        time.sleep(4)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = F"{systemctl} is-active zze.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "failed")
        #
        logg.info("== 'stop' shall clean an already exited service")
        cmd = F"{systemctl} stop zze.service {vv} -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        incontainer = not get_USER_ID()
        if TODO or real or incontainer: self.assertEqual(end, 0)
        else: self.assertEqual(end, 1)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = F"{systemctl} is-active zze.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        if TODO or real: self.assertEqual(out.strip(), "failed")
        else: self.assertEqual(out.strip(), "inactive")

        #
        cmd = F"{systemctl} enable zzf.service {vv}"
        sh____(cmd)
        #
        logg.info("== 'start' will run a later failing service ")
        cmd = F"{systemctl} start zzf.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        time.sleep(4)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzf.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "failed")
        #
        logg.info("== 'reset-failed' shall clean an already failed service")
        cmd = F"{systemctl} reset-failed zzf.service {vv} {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} is-active zzf.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'stop' shall clean an already failed service")
        cmd = F"{systemctl} stop zzf.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        if TODO or real: self.assertEqual(end, 0)
        else: self.assertEqual(end, 1)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzf.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        #
        cmd = F"{systemctl} enable zzr.service {vv}"
        sh____(cmd)
        #
        logg.info("== 'start' will have a later exiting service as remaining active")
        cmd = F"{systemctl} start zzr.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        time.sleep(4)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzr.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active") # <<<<<<<<<<< here's the new functionality
        #
        logg.info("== 'stop' shall clean an exited but remaining service")
        cmd = F"{systemctl} stop zzr.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        incontainer = not get_USER_ID()
        if TODO or real or incontainer: self.assertEqual(end, 0)
        else: self.assertEqual(end, 1)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzr.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        if TODO or real: self.assertEqual(end, 0)
        else: self.assertEqual(end, 3)
        if TODO or real: self.assertEqual(out.strip(), "failed")
        else: self.assertEqual(out.strip(), "inactive")

        #
        cmd = F"{systemctl} enable zzx.service {vv}"
        sh____(cmd)
        #
        #
        logg.info("== 'start' will have a later failing service remaining but failed")
        cmd = F"{systemctl} start zzx.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        time.sleep(4)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzx.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        #
        logg.info("== 'stop' shall clean an already failed remaining service")
        cmd = F"{systemctl} stop zzx.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        incontainer = not get_USER_ID()
        if TODO or real or incontainer: self.assertEqual(end, 0)
        else: self.assertEqual(end, 1)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = F"{systemctl} is-active zzx.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        if TODO or real: self.assertEqual(out.strip(), "failed")
        else: self.assertEqual(out.strip(), "inactive")
        #
        # cleanup
        self.rm_killall()
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
        self.end()
    def real_25101_systemctl_py_kill_basic_behaviour(self) -> None:
        """ check systemctl_py kill basic behaviour"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        testsleepB = testsleep+"B"
        testsleepC = testsleep+"C"
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepB} 99
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zzc.service"), F"""
            [Unit]
            Description=Testing C
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepC} 111
            [Install]
            WantedBy=multi-user.target
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleepB))
        copy_tool(_bin_sleep, os_path(bindir, testsleepC))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        copy_file(os_path(testdir, "zzc.service"), os_path(root, "/etc/systemd/system/zzc.service"))
        #
        cmd = F"{systemctl} start zzb.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} start zzc.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleepB))
        self.assertTrue(greps(top, testsleepC))
        #
        cmd = F"{systemctl} stop zzb.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} kill zzc.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        time.sleep(1) # kill is asynchronous
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleepB))
        self.assertFalse(greps(top, testsleepC))
        #
        cmd = F"{systemctl} start zzb.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} start zzc.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleepB))
        self.assertTrue(greps(top, testsleepC))
        #
        cmd = F"killall {testsleepB}"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = F"killall {testsleepC}"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} stop zzb.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0) # already down
        cmd = F"{systemctl} kill zzc.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0) # nothing to kill
        #
        time.sleep(1)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleepB))
        self.assertFalse(greps(top, testsleepC))
        #
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_25105_systemctl_py_kill_in_stop(self) -> None:
        """ check systemctl_py kill from ExecStop"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        testsleepB = testsleep+"B"
        testsleepC = testsleep+"C"
        begin = "{"
        ends = "}"
        bindir = os_path(root, "/usr/bin")
        rundir = os_path(root, "/var/run")
        text_file(os_path(testdir, "zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepB} 99
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zzc.service"), F"""
            [Unit]
            Description=Testing C
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepC} 111
            ExecStop=/bin/kill ${begin}MAINPID{ends}
            [Install]
            WantedBy=multi-user.target
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleepB))
        copy_tool(_bin_sleep, os_path(bindir, testsleepC))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        copy_file(os_path(testdir, "zzc.service"), os_path(root, "/etc/systemd/system/zzc.service"))
        os.makedirs(rundir)
        #
        cmd = F"{systemctl} stop zzb.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} stop zzc.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        # self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} start zzb.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} start zzc.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleepB))
        self.assertTrue(greps(top, testsleepC))
        #
        cmd = F"ls -l {rundir}"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        if TODO: self.assertTrue(greps(out, "zzb.service.pid"))
        if TODO: self.assertTrue(greps(out, "zzc.service.pid"))
        #
        cmd = F"{systemctl} stop zzb.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} kill zzc.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        time.sleep(1) # kill is asynchronous
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleepB))
        self.assertFalse(greps(top, testsleepC))
        #
        cmd = F"ls -l {rundir}"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        if TODO: self.assertFalse(greps(out, "zzb.service.pid"))
        if TODO: self.assertTrue(greps(out, "zzc.service.pid"))
        #
        cmd = F"{systemctl} start zzb.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = F"{systemctl} start zzc.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleepB))
        self.assertTrue(greps(top, testsleepC))
        #
        cmd = F"ls -l {rundir}"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        if TODO: self.assertTrue(greps(out, "zzb.service.pid"))
        if TODO: self.assertTrue(greps(out, "zzc.service.pid"))
        #
        cmd = F"killall {testsleepB}"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = F"killall {testsleepC}"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} stop zzb.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0) # already down
        cmd = F"{systemctl} kill zzc.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0) # nothing to kill
        #
        cmd = F"ls -l {rundir}"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        if TODO: self.assertFalse(greps(out, "zzb.service.pid")) # issue #13
        if TODO: self.assertTrue(greps(out, "zzc.service.pid")) # TODO ?
        #
        time.sleep(1)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleepB))
        self.assertFalse(greps(top, testsleepC))
        #
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_25120_systemctl_kill_ignore_behaviour(self) -> None:
        """ systemctl kill ignore behaviour"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        quick = QUICK
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("testsleep")
        testsleepB = testsleep+"B"
        testsleepC = testsleep+"C"
        testscriptB = self.testname("testscriptB.sh")
        testscriptC = self.testname("testscriptC.sh")
        logfile = os_path(root, "/var/log/test.log")
        bindir = os_path(root, "/usr/bin")
        begin = "{"
        ends = "}"
        text_file(logfile, "")
        text_file(os_path(testdir, "zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStartPre=/bin/echo %n
            ExecStart={bindir}/{testscriptB} 111
            ExecStartPost=/bin/echo started $MAINPID
            ExecStop=/bin/kill -3 $MAINPID
            ExecStopPost=/bin/echo stopped $MAINPID
            ExecStopPost=/bin/sleep 2
            ExecReload=/bin/kill -10 $MAINPID
            # KillSignal=SIGQUIT
            [Install]
            WantedBy=multi-user.target
            """)
        shell_file(os_path(bindir, testscriptB), F"""
            #! /bin/sh
            date +%T,enter > {logfile}
            stops () {begin}
              date +%T,stopping >> {logfile}
              killall {testsleep}
              date +%T,stopped >> {logfile}
            {ends}
            reload () {begin}
              date +%T,reloading >> {logfile}
              date +%T,reloaded >> {logfile}
            {ends}
            ignored () {begin}
              date +%T,ignored >> {logfile}
            {ends}
            sighup () {begin}
              date +%T,sighup >> {logfile}
            {ends}
            trap "stops" 3     # SIGQUIT
            trap "reload" 10   # SIGUSR1
            trap "ignored" 15  # SIGTERM
            trap "sighup" 1    # SIGHUP
            date +%T,starting >> {logfile}
            {bindir}/{testsleepB} $1 >> {logfile} 2>&1 &
            while kill -0 $!; do
               # use 'kill -0' to check the existance of the child
               date +%T,waiting >> {logfile}
               # use 'wait' for children AND external signals
               wait
            done
            date +%T,leaving >> {logfile}
            trap - 3 10 15 # SIGQUIT SIGUSR1 SIGTERM
            date +%T,leave >> {logfile}
        """)
        copy_tool(_bin_sleep, os_path(bindir, testsleepB))
        copy_tool(_bin_sleep, os_path(bindir, testsleepC))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        #
        cmd = F"{systemctl} start zzb.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleepB))
        #
        cmd = F"{systemctl} stop zzb.service -vv {quick}"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testscriptB))
        self.assertTrue(greps(top, testsleepB))
        #
        cmd = F"{systemctl} kill zzb.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        time.sleep(1) # kill is asynchronous
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testscriptB))
        self.assertFalse(greps(top, testsleepB)) # kills children as well
        #
        log = lines4(reads(logfile))
        logg.info("LOG %s\n| %s", logfile, "\n| ".join(log))
        self.assertTrue(greps(log, "ignored"))
        self.assertFalse(greps(log, "sighup"))
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        cmd = F"{systemctl} __killall {testsleepB}"
        sx____(cmd) # cleanup before check
        self.assertFalse(greps(top, testsleepB))
        #
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_25121_systemctl_kill_ignore_nokill_behaviour(self) -> None:
        """ systemctl kill ignore and nokill behaviour"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        quick = QUICK
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("testsleep")
        testsleepB = testsleep+"B"
        testsleepC = testsleep+"C"
        testscriptB = self.testname("testscriptB.sh")
        testscriptC = self.testname("testscriptC.sh")
        logfile = os_path(root, "/var/log/test.log")
        bindir = os_path(root, "/usr/bin")
        begin = "{"
        ends = "}"
        text_file(logfile, "")
        text_file(os_path(testdir, "zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStartPre=/bin/echo %n
            ExecStart={bindir}/{testscriptB} 111
            ExecStartPost=/bin/echo started $MAINPID
            ExecStop=/bin/kill -3 $MAINPID
            ExecStopPost=/bin/echo stopped $MAINPID
            ExecStopPost=/bin/sleep 2
            ExecReload=/bin/kill -10 $MAINPID
            # KillSignal=SIGQUIT
            SendSIGKILL=no
            [Install]
            WantedBy=multi-user.target
            """)
        shell_file(os_path(bindir, testscriptB), F"""
            #! /bin/sh
            date +%T,enter > {logfile}
            stops () {begin}
              date +%T,stopping >> {logfile}
              killall {testsleep}
              date +%T,stopped >> {logfile}
            {ends}
            reload () {begin}
              date +%T,reloading >> {logfile}
              date +%T,reloaded >> {logfile}
            {ends}
            ignored () {begin}
              date +%T,ignored >> {logfile}
            {ends}
            sighup () {begin}
              date +%T,sighup >> {logfile}
            {ends}
            trap "stops" 3    # SIGQUIT
            trap "reload" 10  # SIGUSR1
            trap "ignored" 15 # SIGTERM
            trap "sighup" 1   # SIGHUP
            date +%T,starting >> {logfile}
            {bindir}/{testsleepB} $1 >> {logfile} 2>&1 &
            while kill -0 $!; do
               # use 'kill -0' to check the existance of the child
               date +%T,waiting >> {logfile}
               # use 'wait' for children AND external signals
               wait
            done
            date +%T,leaving >> {logfile}
            trap - 3 10 15 # SIGQUIT SIGUSR1 SIGTERM
            date +%T,leave >> {logfile}
        """)
        copy_tool(_bin_sleep, os_path(bindir, testsleepB))
        copy_tool(_bin_sleep, os_path(bindir, testsleepC))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        #
        cmd = F"{systemctl} start zzb.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleepB))
        #
        cmd = F"{systemctl} stop zzb.service -vv {quick}"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testscriptB))
        self.assertTrue(greps(top, testsleepB))
        #
        cmd = F"{systemctl} kill zzb.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0) # actually killed
        #
        time.sleep(1) # kill is asynchronous
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testscriptB))
        self.assertFalse(greps(top, testsleepB)) # and it kills children
        #
        log = lines4(reads(logfile))
        logg.info("LOG %s\n| %s", logfile, "\n| ".join(log))
        self.assertTrue(greps(log, "ignored"))
        self.assertFalse(greps(log, "sighup"))
        #
        time.sleep(1) # kill is asynchronous
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        cmd = F"{systemctl} __killall {testsleepB}"
        sx____(cmd) # cleanup before check
        self.assertFalse(greps(top, testscriptB))
        self.assertFalse(greps(top, testsleepB))
        #
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_25151_systemctl_kill_sendsighup(self) -> None:
        """ systemctl kill with sighup"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        quick = QUICK
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("testsleep")
        testsleepB = testsleep+"B"
        testsleepC = testsleep+"C"
        testscriptB = self.testname("testscriptB.sh")
        testscriptC = self.testname("testscriptC.sh")
        logfile = os_path(root, "/var/log/test.log")
        bindir = os_path(root, "/usr/bin")
        begin = "{"
        ends = "}"
        text_file(logfile, "")
        text_file(os_path(testdir, "zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStartPre=/bin/echo %n
            ExecStart={bindir}/{testscriptB} 111
            ExecStartPost=/bin/echo started $MAINPID
            ExecStop=/bin/kill -3 $MAINPID
            ExecStopPost=/bin/echo stopped $MAINPID
            ExecStopPost=/bin/sleep 2
            ExecReload=/bin/kill -10 $MAINPID
            # KillSignal=SIGQUIT
            SendSIGHUP=yes
            [Install]
            WantedBy=multi-user.target
            """)
        shell_file(os_path(bindir, testscriptB), F"""
            #! /bin/sh
            date +%T,enter > {logfile}
            stops () {begin}
              date +%T,stopping >> {logfile}
              killall {testsleep}
              date +%T,stopped >> {logfile}
            {ends}
            reload () {begin}
              date +%T,reloading >> {logfile}
              date +%T,reloaded >> {logfile}
            {ends}
            ignored () {begin}
              date +%T,ignored >> {logfile}
            {ends}
            sighup () {begin}
              date +%T,sighup >> {logfile}
            {ends}
            trap "stops" 3      # SIGQUIT
            trap "reload" 10    # SIGUSR1
            trap "ignored" 15   # SIGTERM
            trap "sighup" 1     # SIGHUP
            date +%T,starting >> {logfile}
            {bindir}/{testsleepB} $1 >> {logfile} 2>&1 &
            while kill -0 $!; do
               # use 'kill -0' to check the existance of the child
               date +%T,waiting >> {logfile}
               # use 'wait' for children AND external signals
               wait
            done
            date +%T,leaving >> {logfile}
            trap - 3 10 15  # SIGQUIT SIGUSR1 SIGTERM
            date +%T,leave >> {logfile}
        """)
        copy_tool(_bin_sleep, os_path(bindir, testsleepB))
        copy_tool(_bin_sleep, os_path(bindir, testsleepC))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        #
        cmd = F"{systemctl} start zzb.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleepB))
        #
        cmd = F"{systemctl} stop zzb.service -vv {quick}"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testscriptB))
        self.assertTrue(greps(top, testsleepB))
        #
        cmd = F"{systemctl} kill zzb.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0) # actually killed
        #
        time.sleep(1) # kill is asynchronous
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testscriptB))
        self.assertFalse(greps(top, testsleepB)) # and it kills children
        #
        log = lines4(reads(logfile))
        logg.info("LOG %s\n| %s", logfile, "\n| ".join(log))
        self.assertTrue(greps(log, "ignored"))
        self.assertTrue(greps(log, "sighup"))
        #
        time.sleep(1) # kill is asynchronous
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        cmd = F"{systemctl} __killall {testsleepB}"
        sx____(cmd) # cleanup before check
        self.assertFalse(greps(top, testscriptB))
        self.assertFalse(greps(top, testsleepB))
        #
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_25160_systemctl_kill_process_hard(self) -> None:
        """ systemctl kill needs to be hard"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        quick = QUICK
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("testsleep")
        testsleepB = testsleep+"B"
        testsleepC = testsleep+"C"
        testscriptB = self.testname("testscriptB.sh")
        testscriptC = self.testname("testscriptC.sh")
        logfile = os_path(root, "/var/log/test.log")
        bindir = os_path(root, "/usr/bin")
        begin = "{"
        ends = "}"
        text_file(logfile, "")
        text_file(os_path(testdir, "zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStartPre=/bin/echo %n
            ExecStart={bindir}/{testscriptB} 111
            ExecStartPost=/bin/echo started $MAINPID
            ExecStop=/bin/kill -3 $MAINPID
            ExecStopPost=/bin/echo stopped $MAINPID
            ExecStopPost=/bin/sleep 2
            ExecReload=/bin/kill -10 $MAINPID
            KillMode=process
            KillSignal=SIGQUIT
            # SendSIGHUP=yes
            [Install]
            WantedBy=multi-user.target
            """)
        shell_file(os_path(bindir, testscriptB), F"""
            #! /bin/sh
            date +%T,enter > {logfile}
            stops () {begin}
              date +%T,stopfails >> {logfile}
              # killall {testsleep} ############## kill ignored
            {ends}
            reload () {begin}
              date +%T,reloading >> {logfile}
              date +%T,reloaded >> {logfile}
            {ends}
            ignored () {begin}
              date +%T,ignored >> {logfile}
            {ends}
            sighup () {begin}
              date +%T,sighup >> {logfile}
            {ends}
            trap "stops" 3      # SIGQUIT
            trap "reload" 10    # SIGUSR1
            trap "ignored" 15   # SIGTERM
            trap "sighup" 1     # SIGHUP
            date +%T,starting >> {logfile}
            {bindir}/{testsleepB} $1 >> {logfile} 2>&1 &
            while kill -0 $!; do
               # use 'kill -0' to check the existance of the child
               date +%T,waiting >> {logfile}
               # use 'wait' for children AND external signals
               wait
            done
            date +%T,leaving >> {logfile}
            trap - 3 10 15  # SIGQUIT SIGUSR1 SIGTERM
            date +%T,leave >> {logfile}
        """)
        copy_tool(_bin_sleep, os_path(bindir, testsleepB))
        copy_tool(_bin_sleep, os_path(bindir, testsleepC))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        #
        cmd = F"{systemctl} start zzb.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleepB))
        #
        cmd = F"{systemctl} stop zzb.service -vv {quick}"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testscriptB))
        self.assertTrue(greps(top, testsleepB))
        #
        cmd = F"{systemctl} kill zzb.service -vv {quick}"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0) # actually killed
        #
        time.sleep(1) # kill is asynchronous
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testscriptB))
        self.assertTrue(greps(top, testsleepB))
        #
        log = lines4(reads(logfile))
        logg.info("LOG %s\n| %s", logfile, "\n| ".join(log))
        # self.assertTrue(greps(log, "ignored"))
        # self.assertTrue(greps(log, "sighup"))
        #
        time.sleep(1) # kill is asynchronous
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        cmd = F"{systemctl} __killall {testsleepB}"
        sx____(cmd) # cleanup before check
        self.assertFalse(greps(top, testscriptB))
        self.assertTrue(greps(top, testsleepB))  # TODO?##
        #
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_25161_systemctl_kill_mixed_hard(self) -> None:
        """ systemctl kill needs to be hard"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        quick = QUICK
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("testsleep")
        testsleepB = testsleep+"B"
        testsleepC = testsleep+"C"
        testscriptB = self.testname("testscriptB.sh")
        testscriptC = self.testname("testscriptC.sh")
        logfile = os_path(root, "/var/log/test.log")
        bindir = os_path(root, "/usr/bin")
        begin = "{"
        ends = "}"
        text_file(logfile, "")
        text_file(os_path(testdir, "zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStartPre=/bin/echo %n
            ExecStart={bindir}/{testscriptB} 111
            ExecStartPost=/bin/echo started $MAINPID
            ExecStop=/bin/kill -3 $MAINPID
            ExecStopPost=/bin/echo stopped $MAINPID
            ExecStopPost=/bin/sleep 2
            ExecReload=/bin/kill -10 $MAINPID
            KillMode=mixed
            KillSignal=SIGQUIT
            # SendSIGHUP=yes
            [Install]
            WantedBy=multi-user.target
            """)
        shell_file(os_path(bindir, testscriptB), F"""
            #! /bin/sh
            date +%T,enter > {logfile}
            stops () {begin}
              date +%T,stopfails >> {logfile}
              # killall {testsleep} ############## kill ignored
            {ends}
            reload () {begin}
              date +%T,reloading >> {logfile}
              date +%T,reloaded >> {logfile}
            {ends}
            ignored () {begin}
              date +%T,ignored >> {logfile}
            {ends}
            sighup () {begin}
              date +%T,sighup >> {logfile}
            {ends}
            trap "stops" 3      # SIGQUIT
            trap "reload" 10    # SIGUSR1
            trap "ignored" 15   # SIGTERM
            trap "sighup" 1     # SIGHUP
            date +%T,starting >> {logfile}
            {bindir}/{testsleepB} $1 >> {logfile} 2>&1 &
            while kill -0 $!; do
               # use 'kill -0' to check the existance of the child
               date +%T,waiting >> {logfile}
               # use 'wait' for children AND external signals
               wait
            done
            date +%T,leaving >> {logfile}
            trap - 3 10 15  # SIGQUIT SIGUSR1 SIGTERM
            date +%T,leave >> {logfile}
        """)
        copy_tool(_bin_sleep, os_path(bindir, testsleepB))
        copy_tool(_bin_sleep, os_path(bindir, testsleepC))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        #
        cmd = F"{systemctl} start zzb.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleepB))
        #
        cmd = F"{systemctl} stop zzb.service -vv {quick}"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testscriptB))
        self.assertTrue(greps(top, testsleepB))
        #
        cmd = F"{systemctl} kill zzb.service -vv {quick}"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0) # actually killed
        #
        time.sleep(1) # kill is asynchronous
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testscriptB))
        self.assertFalse(greps(top, testsleepB))  # TODO?##
        #
        log = lines4(reads(logfile))
        logg.info("LOG %s\n| %s", logfile, "\n| ".join(log))
        # self.assertTrue(greps(log, "ignored"))
        # self.assertTrue(greps(log, "sighup"))
        #
        time.sleep(1) # kill is asynchronous
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        cmd = F"{systemctl} __killall {testsleepB}"
        sx____(cmd) # cleanup before check
        self.assertFalse(greps(top, testscriptB))
        self.assertFalse(greps(top, testsleepB))
        #
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_25201_systemctl_py_dependencies_plain_start_order(self) -> None:
        """ check list-dependencies - standard order of starting
            units is simply the command line order"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStartPre={bindir}/logger 'start-A'
            ExecStart={bindir}/{testsleep} 30
            ExecStopPost={bindir}/logger 'stop-A'
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStartPre={bindir}/logger 'start-B'
            ExecStart={bindir}/{testsleep} 99
            ExecStopPost={bindir}/logger 'stop-B'
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zzc.service"), F"""
            [Unit]
            Description=Testing C
            [Service]
            Type=simple
            ExecStartPre={bindir}/logger 'start-C'
            ExecStart={bindir}/{testsleep} 111
            ExecStopPost={bindir}/logger 'stop-C'
            [Install]
            WantedBy=multi-user.target
            """)
        shell_file(os_path(testdir, "logger"), F"""
            #! /bin/sh
            echo "$@" >> {logfile}
            cat {logfile} | sed -e "s|^| : |"
            true
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_tool(os_path(testdir, "logger"), os_path(bindir, "logger"))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        copy_file(os_path(testdir, "zzc.service"), os_path(root, "/etc/systemd/system/zzc.service"))
        os.makedirs(os_path(root, "/var/run"))
        os.makedirs(os_path(root, "/var/log"))
        #
        list_dependencies = F"{systemctl} list-dependencies zza.service --now"
        deps = output(list_dependencies)
        logg.info("deps \n%s", deps)
        #
        cmd = F"{systemctl} start zza.service zzb.service zzc.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep+" 99"))
        #
        # inspect logfile
        log = lines4(open(logfile))
        logg.info("logs \n| %s", "\n| ".join(log))
        self.assertEqual(log[0], "start-A")
        self.assertEqual(log[1], "start-B")
        self.assertEqual(log[2], "start-C")
        os.remove(logfile)
        #
        cmd = F"{systemctl} stop zza.service zzb.service zzc.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep+" 99"))
        #
        # inspect logfile
        log = lines4(open(logfile))
        logg.info("logs \n| %s", "\n| ".join(log))
        self.assertEqual(log[0], "stop-C")
        self.assertEqual(log[1], "stop-B")
        self.assertEqual(log[2], "stop-A")
        os.remove(logfile)
        #
        kill_testsleep = F"{systemctl} __killall {testsleep}"
        sx____(kill_testsleep)
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_25211_systemctl_py_dependencies_basic_reorder(self) -> None:
        """ check list-dependencies - standard order of starting
            units is simply the command line order (After case)"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            After=zzb.service
            [Service]
            Type=simple
            ExecStartPre={bindir}/logger 'start-A'
            ExecStart={bindir}/{testsleep} 30
            ExecStopPost={bindir}/logger 'stop-A'
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStartPre={bindir}/logger 'start-B'
            ExecStart={bindir}/{testsleep} 99
            ExecStopPost={bindir}/logger 'stop-B'
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zzc.service"), F"""
            [Unit]
            Description=Testing C
            After=zza.service
            [Service]
            Type=simple
            ExecStartPre={bindir}/logger 'start-C'
            ExecStart={bindir}/{testsleep} 111
            ExecStopPost={bindir}/logger 'stop-C'
            [Install]
            WantedBy=multi-user.target
            """)
        shell_file(os_path(testdir, "logger"), F"""
            #! /bin/sh
            echo "$@" >> {logfile}
            cat {logfile} | sed -e "s|^| : |"
            true
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_tool(os_path(testdir, "logger"), os_path(bindir, "logger"))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        copy_file(os_path(testdir, "zzc.service"), os_path(root, "/etc/systemd/system/zzc.service"))
        os.makedirs(os_path(root, "/var/run"))
        os.makedirs(os_path(root, "/var/log"))
        #
        list_dependencies = F"{systemctl} list-dependencies zza.service --now"
        deps = output(list_dependencies)
        logg.info("deps \n%s", deps)
        #
        cmd = F"{systemctl} start zza.service zzb.service zzc.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep+" 99"))
        #
        # inspect logfile
        log = lines4(open(logfile))
        logg.info("logs \n| %s", "\n| ".join(log))
        self.assertEqual(log[0], "start-B")
        self.assertEqual(log[1], "start-A")
        self.assertEqual(log[2], "start-C")
        os.remove(logfile)
        #
        cmd = F"{systemctl} stop zza.service zzb.service zzc.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep+" 99"))
        #
        # inspect logfile
        log = lines4(open(logfile))
        logg.info("logs \n| %s", "\n| ".join(log))
        self.assertEqual(log[0], "stop-C")
        self.assertEqual(log[1], "stop-A")
        self.assertEqual(log[2], "stop-B")
        os.remove(logfile)
        #
        kill_testsleep = F"{systemctl} __killall {testsleep}"
        sx____(kill_testsleep)
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_25251_systemctl_py_dependencies_basic_reorder(self) -> None:
        """ check list-dependencies - standard order of starting
            units is simply the command line order (Before case)"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            Before=zzb.service
            [Service]
            Type=simple
            ExecStartPre={bindir}/logger 'start-A'
            ExecStart={bindir}/{testsleep} 30
            ExecStopPost={bindir}/logger 'stop-A'
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStartPre={bindir}/logger 'start-B'
            ExecStart={bindir}/{testsleep} 99
            ExecStopPost={bindir}/logger 'stop-B'
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zzc.service"), F"""
            [Unit]
            Description=Testing C
            Before=zza.service
            [Service]
            Type=simple
            ExecStartPre={bindir}/logger 'start-C'
            ExecStart={bindir}/{testsleep} 111
            ExecStopPost={bindir}/logger 'stop-C'
            [Install]
            WantedBy=multi-user.target
            """)
        shell_file(os_path(testdir, "logger"), F"""
            #! /bin/sh
            echo "$@" >> {logfile}
            cat {logfile} | sed -e "s|^| : |"
            true
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_tool(os_path(testdir, "logger"), os_path(bindir, "logger"))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        copy_file(os_path(testdir, "zzc.service"), os_path(root, "/etc/systemd/system/zzc.service"))
        os.makedirs(os_path(root, "/var/run"))
        os.makedirs(os_path(root, "/var/log"))
        #
        list_dependencies = F"{systemctl} list-dependencies zza.service --now"
        deps = output(list_dependencies)
        logg.info("deps \n%s", deps)
        #
        cmd = F"{systemctl} start zza.service zzb.service zzc.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep+" 99"))
        #
        # inspect logfile
        log = lines4(open(logfile))
        logg.info("logs \n| %s", "\n| ".join(log))
        self.assertEqual(log[0], "start-C")
        self.assertEqual(log[1], "start-A")
        self.assertEqual(log[2], "start-B")
        os.remove(logfile)
        #
        cmd = F"{systemctl} stop zza.service zzb.service zzc.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        time.sleep(1)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep+" 99"))
        #
        # inspect logfile
        log = lines4(open(logfile))
        logg.info("logs \n| %s", "\n| ".join(log))
        self.assertEqual(log[0], "stop-B")
        self.assertEqual(log[1], "stop-A")
        self.assertEqual(log[2], "stop-C")
        os.remove(logfile)
        #
        kill_testsleep = F"{systemctl} __killall {testsleep}"
        sx____(kill_testsleep)
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_25261_systemctl_py_list_dependencies_with_after(self) -> None:
        """ check list-dependencies - standard order of starting
            units is simply the command line order"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            After=zzb.service
            [Service]
            Type=simple
            ExecStartPre={bindir}/logger 'start-A'
            ExecStart={bindir}/{testsleep} 30
            ExecStopPost={bindir}/logger 'stop-A'
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStartPre={bindir}/logger 'start-B'
            ExecStart={bindir}/{testsleep} 99
            ExecStopPost={bindir}/logger 'stop-B'
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zzc.service"), F"""
            [Unit]
            Description=Testing C
            After=zza.service
            [Service]
            Type=simple
            ExecStartPre={bindir}/logger 'start-C'
            ExecStart={bindir}/{testsleep} 111
            ExecStopPost={bindir}/logger 'stop-C'
            [Install]
            WantedBy=multi-user.target
            """)
        shell_file(os_path(testdir, "logger"), F"""
            #! /bin/sh
            echo "$@" >> {logfile}
            cat {logfile} | sed -e "s|^| : |"
            true
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_tool(os_path(testdir, "logger"), os_path(bindir, "logger"))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        copy_file(os_path(testdir, "zzc.service"), os_path(root, "/etc/systemd/system/zzc.service"))
        os.makedirs(os_path(root, "/var/run"))
        os.makedirs(os_path(root, "/var/log"))
        #
        list_dependencies = F"{systemctl} list-start-dependencies zza.service"
        deps_text = output(list_dependencies)
        # logg.info("deps \n%s", deps_text)
        #
        # inspect logfile
        deps = lines4(deps_text)
        logg.info("deps \n| %s", "\n| ".join(deps))
        self.assertEqual(deps[0], "zza.service\t(Requested)")
        self.assertEqual(len(deps), 1)
        #
        kill_testsleep = F"{systemctl} __killall {testsleep}"
        sx____(kill_testsleep)
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_25262_systemctl_py_list_dependencies_with_wants(self) -> None:
        """ check list-dependencies - standard order of starting
            units is simply the command line order"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            Wants=zzb.service
            [Service]
            Type=simple
            ExecStartPre={bindir}/logger 'start-A'
            ExecStart={bindir}/{testsleep} 30
            ExecStopPost={bindir}/logger 'stop-A'
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStartPre={bindir}/logger 'start-B'
            ExecStart={bindir}/{testsleep} 99
            ExecStopPost={bindir}/logger 'stop-B'
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zzc.service"), F"""
            [Unit]
            Description=Testing C
            Wants=zza.service
            [Service]
            Type=simple
            ExecStartPre={bindir}/logger 'start-C'
            ExecStart={bindir}/{testsleep} 111
            ExecStopPost={bindir}/logger 'stop-C'
            [Install]
            WantedBy=multi-user.target
            """)
        shell_file(os_path(testdir, "logger"), F"""
            #! /bin/sh
            echo "$@" >> {logfile}
            cat {logfile} | sed -e "s|^| : |"
            true
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_tool(os_path(testdir, "logger"), os_path(bindir, "logger"))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        copy_file(os_path(testdir, "zzc.service"), os_path(root, "/etc/systemd/system/zzc.service"))
        os.makedirs(os_path(root, "/var/run"))
        os.makedirs(os_path(root, "/var/log"))
        #
        list_dependencies = F"{systemctl} list-start-dependencies zza.service"
        deps_text = output(list_dependencies)
        # logg.info("deps \n%s", deps_text)
        #
        # inspect logfile
        deps = lines4(deps_text)
        logg.info("deps \n| %s", "\n| ".join(deps))
        self.assertEqual(deps[0], "zzb.service\t(Wants)")
        self.assertEqual(deps[1], "zza.service\t(Requested)")
        self.assertEqual(len(deps), 2)
        #
        list_dependencies = F"{systemctl} list-start-dependencies zzb.service"
        deps_text = output(list_dependencies)
        # logg.info("deps \n%s", deps_text)
        #
        # inspect logfile
        deps = lines4(deps_text)
        logg.info("deps \n| %s", "\n| ".join(deps))
        self.assertEqual(deps[0], "zzb.service\t(Requested)")
        self.assertEqual(len(deps), 1)
        #
        #
        list_dependencies = F"{systemctl} list-start-dependencies zzc.service"
        deps_text = output(list_dependencies)
        # logg.info("deps \n%s", deps_text)
        #
        # inspect logfile
        deps = lines4(deps_text)
        logg.info("deps \n| %s", "\n| ".join(deps))
        self.assertEqual(deps[0], "zza.service\t(Wants)")
        self.assertEqual(deps[1], "zzc.service\t(Requested)")
        self.assertEqual(len(deps), 2)
        #
        kill_testsleep = F"{systemctl} __killall {testsleep}"
        sx____(kill_testsleep)
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_25263_systemctl_py_list_dependencies_with_requires(self) -> None:
        """ check list-dependencies - standard order of starting
            units is simply the command line order"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            Requires=zzb.service
            [Service]
            Type=simple
            ExecStartPre={bindir}/logger 'start-A'
            ExecStart={bindir}/{testsleep} 30
            ExecStopPost={bindir}/logger 'stop-A'
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStartPre={bindir}/logger 'start-B'
            ExecStart={bindir}/{testsleep} 99
            ExecStopPost={bindir}/logger 'stop-B'
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zzc.service"), F"""
            [Unit]
            Description=Testing C
            Requires=zza.service
            [Service]
            Type=simple
            ExecStartPre={bindir}/logger 'start-C'
            ExecStart={bindir}/{testsleep} 111
            ExecStopPost={bindir}/logger 'stop-C'
            [Install]
            WantedBy=multi-user.target
            """)
        shell_file(os_path(testdir, "logger"), F"""
            #! /bin/sh
            echo "$@" >> {logfile}
            cat {logfile} | sed -e "s|^| : |"
            true
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_tool(os_path(testdir, "logger"), os_path(bindir, "logger"))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        copy_file(os_path(testdir, "zzc.service"), os_path(root, "/etc/systemd/system/zzc.service"))
        os.makedirs(os_path(root, "/var/run"))
        os.makedirs(os_path(root, "/var/log"))
        #
        list_dependencies = F"{systemctl} list-start-dependencies zza.service"
        deps_text = output(list_dependencies)
        # logg.info("deps \n%s", deps_text)
        #
        # inspect logfile
        deps = lines4(deps_text)
        logg.info("deps \n| %s", "\n| ".join(deps))
        self.assertEqual(deps[0], "zzb.service\t(Requires)")
        self.assertEqual(deps[1], "zza.service\t(Requested)")
        self.assertEqual(len(deps), 2)
        #
        list_dependencies = F"{systemctl} list-start-dependencies zzb.service"
        deps_text = output(list_dependencies)
        # logg.info("deps \n%s", deps_text)
        #
        # inspect logfile
        deps = lines4(deps_text)
        logg.info("deps \n| %s", "\n| ".join(deps))
        self.assertEqual(deps[0], "zzb.service\t(Requested)")
        self.assertEqual(len(deps), 1)
        #
        #
        list_dependencies = F"{systemctl} list-start-dependencies zzc.service"
        deps_text = output(list_dependencies)
        # logg.info("deps \n%s", deps_text)
        #
        # inspect logfile
        deps = lines4(deps_text)
        logg.info("deps \n| %s", "\n| ".join(deps))
        self.assertEqual(deps[0], "zza.service\t(Requires)")
        self.assertEqual(deps[1], "zzc.service\t(Requested)")
        self.assertEqual(len(deps), 2)
        #
        kill_testsleep = F"{systemctl} __killall {testsleep}"
        sx____(kill_testsleep)
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_25271_systemctl_py_list_dependencies_with_after(self) -> None:
        """ check list-dependencies - standard order of starting
            units is simply the command line order"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            After=zzb.service
            [Service]
            Type=simple
            ExecStartPre={bindir}/logger 'start-A'
            ExecStart={bindir}/{testsleep} 30
            ExecStopPost={bindir}/logger 'stop-A'
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStartPre={bindir}/logger 'start-B'
            ExecStart={bindir}/{testsleep} 99
            ExecStopPost={bindir}/logger 'stop-B'
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zzc.service"), F"""
            [Unit]
            Description=Testing C
            After=zza.service
            [Service]
            Type=simple
            ExecStartPre={bindir}/logger 'start-C'
            ExecStart={bindir}/{testsleep} 111
            ExecStopPost={bindir}/logger 'stop-C'
            [Install]
            WantedBy=multi-user.target
            """)
        shell_file(os_path(testdir, "logger"), F"""
            #! /bin/sh
            echo "$@" >> {logfile}
            cat {logfile} | sed -e "s|^| : |"
            true
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_tool(os_path(testdir, "logger"), os_path(bindir, "logger"))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        copy_file(os_path(testdir, "zzc.service"), os_path(root, "/etc/systemd/system/zzc.service"))
        os.makedirs(os_path(root, "/var/run"))
        os.makedirs(os_path(root, "/var/log"))
        #
        list_dependencies = F"{systemctl} list-dependencies zza.service"
        deps_text = output(list_dependencies)
        # logg.info("deps \n%s", deps_text)
        #
        # inspect logfile
        deps = lines4(deps_text)
        logg.info("deps \n| %s", "\n| ".join(deps))
        self.assertEqual(deps[0], "zza.service:")
        self.assertEqual(len(deps), 1)
        #
        kill_testsleep = F"{systemctl} __killall {testsleep}"
        sx____(kill_testsleep)
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_25272_systemctl_py_list_dependencies_with_wants(self) -> None:
        """ check list-dependencies - standard order of starting
            units is simply the command line order"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            Wants=zzb.service
            [Service]
            Type=simple
            ExecStartPre={bindir}/logger 'start-A'
            ExecStart={bindir}/{testsleep} 30
            ExecStopPost={bindir}/logger 'stop-A'
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStartPre={bindir}/logger 'start-B'
            ExecStart={bindir}/{testsleep} 99
            ExecStopPost={bindir}/logger 'stop-B'
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zzc.service"), F"""
            [Unit]
            Description=Testing C
            Wants=zza.service
            [Service]
            Type=simple
            ExecStartPre={bindir}/logger 'start-C'
            ExecStart={bindir}/{testsleep} 111
            ExecStopPost={bindir}/logger 'stop-C'
            [Install]
            WantedBy=multi-user.target
            """)
        shell_file(os_path(testdir, "logger"), F"""
            #! /bin/sh
            echo "$@" >> {logfile}
            cat {logfile} | sed -e "s|^| : |"
            true
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_tool(os_path(testdir, "logger"), os_path(bindir, "logger"))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        copy_file(os_path(testdir, "zzc.service"), os_path(root, "/etc/systemd/system/zzc.service"))
        os.makedirs(os_path(root, "/var/run"))
        os.makedirs(os_path(root, "/var/log"))
        #
        list_dependencies = F"{systemctl} list-dependencies zza.service"
        deps_text = output(list_dependencies)
        # logg.info("deps \n%s", deps_text)
        #
        # inspect logfile
        deps = lines4(deps_text)
        logg.info("deps \n| %s", "\n| ".join(deps))
        self.assertEqual(deps[0], "zza.service:")
        self.assertEqual(deps[1], "| zzb.service: wanted to start")
        self.assertEqual(len(deps), 2)
        #
        list_dependencies = F"{systemctl} list-dependencies zzb.service"
        deps_text = output(list_dependencies)
        # logg.info("deps \n%s", deps_text)
        #
        # inspect logfile
        deps = lines4(deps_text)
        logg.info("deps \n| %s", "\n| ".join(deps))
        self.assertEqual(deps[0], "zzb.service:")
        self.assertEqual(len(deps), 1)
        #
        #
        list_dependencies = F"{systemctl} list-dependencies zzc.service"
        deps_text = output(list_dependencies)
        # logg.info("deps \n%s", deps_text)
        #
        # inspect logfile
        deps = lines4(deps_text)
        logg.info("deps \n| %s", "\n| ".join(deps))
        self.assertEqual(deps[0], "zzc.service:")
        self.assertEqual(deps[1], "| zza.service: wanted to start")
        self.assertEqual(deps[2], "| | zzb.service: wanted to start")
        self.assertEqual(len(deps), 3)
        #
        kill_testsleep = F"{systemctl} __killall {testsleep}"
        sx____(kill_testsleep)
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_25273_systemctl_py_list_dependencies_with_requires(self) -> None:
        """ check list-dependencies - standard order of starting
            units is simply the command line order"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            Requires=zzb.service
            [Service]
            Type=simple
            ExecStartPre={bindir}/logger 'start-A'
            ExecStart={bindir}/{testsleep} 30
            ExecStopPost={bindir}/logger 'stop-A'
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStartPre={bindir}/logger 'start-B'
            ExecStart={bindir}/{testsleep} 99
            ExecStopPost={bindir}/logger 'stop-B'
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zzc.service"), F"""
            [Unit]
            Description=Testing C
            Requires=zza.service
            [Service]
            Type=simple
            ExecStartPre={bindir}/logger 'start-C'
            ExecStart={bindir}/{testsleep} 111
            ExecStopPost={bindir}/logger 'stop-C'
            [Install]
            WantedBy=multi-user.target
            """)
        shell_file(os_path(testdir, "logger"), F"""
            #! /bin/sh
            echo "$@" >> {logfile}
            cat {logfile} | sed -e "s|^| : |"
            true
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_tool(os_path(testdir, "logger"), os_path(bindir, "logger"))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        copy_file(os_path(testdir, "zzc.service"), os_path(root, "/etc/systemd/system/zzc.service"))
        os.makedirs(os_path(root, "/var/run"))
        os.makedirs(os_path(root, "/var/log"))
        #
        list_dependencies = F"{systemctl} list-dependencies zza.service"
        deps_text = output(list_dependencies)
        # logg.info("deps \n%s", deps_text)
        #
        # inspect logfile
        deps = lines4(deps_text)
        logg.info("deps \n| %s", "\n| ".join(deps))
        self.assertEqual(deps[0], "zza.service:")
        self.assertEqual(deps[1], "| zzb.service: required to start")
        self.assertEqual(len(deps), 2)
        #
        list_dependencies = F"{systemctl} list-dependencies zzb.service"
        deps_text = output(list_dependencies)
        # logg.info("deps \n%s", deps_text)
        #
        # inspect logfile
        deps = lines4(deps_text)
        logg.info("deps \n| %s", "\n| ".join(deps))
        self.assertEqual(deps[0], "zzb.service:")
        self.assertEqual(len(deps), 1)
        #
        #
        list_dependencies = F"{systemctl} list-dependencies zzc.service"
        deps_text = output(list_dependencies)
        # logg.info("deps \n%s", deps_text)
        #
        # inspect logfile
        deps = lines4(deps_text)
        logg.info("deps \n| %s", "\n| ".join(deps))
        self.assertEqual(deps[0], "zzc.service:")
        self.assertEqual(deps[1], "| zza.service: required to start")
        self.assertEqual(deps[2], "| | zzb.service: required to start")
        self.assertEqual(len(deps), 3)
        #
        kill_testsleep = F"{systemctl} __killall {testsleep}"
        sx____(kill_testsleep)
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_25300_background_default_journal(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleepA = self.testname("sleepA")
        testsleepB = self.testname("sleepB")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepA} 4
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepB} 5
            [Install]
            WantedBy=multi-user.target
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleepA))
        copy_tool(_bin_sleep, os_path(bindir, testsleepB))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        cmd = F"{systemctl} enable zza.service"
        sh____(cmd)
        cmd = F"{systemctl} enable zzb.service"
        sh____(cmd)
        #
        INITLOOPSLEEP = 1
        initsystemctl = systemctl
        initsystemctl += F" -c INITLOOPSLEEP={INITLOOPSLEEP}"
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = F"{initsystemctl} -1"
        init = background(cmd)
        time.sleep(INITLOOPSLEEP+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*INITLOOPSLEEP"))
        #
        cmd = F"{systemctl} show zza.service -p JournalFilePath"
        journal_a=output(cmd).strip().split("=", 1)[1]
        cmd = F"{systemctl} show zzb.service -p JournalFilePath"
        journal_b=output(cmd).strip().split("=", 1)[1]
        logg.info("journal zza = %s", journal_a)
        logg.info("journal zzb = %s", journal_b)
        for attempt in range(5):
            time.sleep(1)
            if not os.path.exists(journal_a): continue
            if not os.path.exists(journal_b): continue
            break
        self.assertTrue(os.path.exists(journal_a))
        self.assertTrue(os.path.exists(journal_b))
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_25301_background_default_journal_written(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleepA = self.testname("sleepA")
        testsleepB = self.testname("sleepB")
        bindir = os_path(root, "/usr/bin")
        shell_file(os_path(testdir, "testsleepA.bin"), F"""
            #! /bin/sh
            echo running testsleepA
            exec {bindir}/{testsleepA} "$@"
            """)
        shell_file(os_path(testdir, "testsleepB.bin"), F"""
            #! /bin/sh
            echo running testsleepB
            exec {bindir}/{testsleepB} "$@"
            """)
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepA}.bin 4
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepB}.bin 5
            [Install]
            WantedBy=multi-user.target
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleepA))
        copy_tool(_bin_sleep, os_path(bindir, testsleepB))
        copy_tool(os_path(testdir, "testsleepA.bin"), os_path(bindir, testsleepA + ".bin"))
        copy_tool(os_path(testdir, "testsleepB.bin"), os_path(bindir, testsleepB + ".bin"))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        cmd = F"{systemctl} enable zza.service"
        sh____(cmd)
        cmd = F"{systemctl} enable zzb.service"
        sh____(cmd)
        #
        INITLOOPSLEEP = 1
        initsystemctl = systemctl
        initsystemctl += F" -c INITLOOPSLEEP={INITLOOPSLEEP}"
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = F"{initsystemctl} -1"
        init = background(cmd)
        time.sleep(INITLOOPSLEEP+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*INITLOOPSLEEP"))
        #
        cmd = F"{systemctl} show zza.service -p JournalFilePath"
        journal_a=output(cmd).strip().split("=", 1)[1]
        cmd = F"{systemctl} show zzb.service -p JournalFilePath"
        journal_b=output(cmd).strip().split("=", 1)[1]
        logg.info("journal zza = %s", journal_a)
        logg.info("journal zzb = %s", journal_b)
        time.sleep(1)
        self.assertTrue(os.path.exists(journal_a))
        self.assertTrue(os.path.exists(journal_b))
        out_a = open(journal_a).read()
        out_b = open(journal_b).read()
        logg.info("out_a=%s", out_a.strip())
        logg.info("out_b=%s", out_b.strip())
        self.assertTrue(greps(out_a, "running testsleepA"))
        self.assertTrue(greps(out_b, "running testsleepB"))
        self.assertFalse(greps(out_a, "running testsleepB"))
        self.assertFalse(greps(out_b, "running testsleepA"))
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_25302_background_default_journal_written_error(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleepA = self.testname("sleepA")
        testsleepB = self.testname("sleepB")
        bindir = os_path(root, "/usr/bin")
        shell_file(os_path(testdir, "testsleepA.bin"), F"""
            #! /bin/sh
            echo starts testsleepA >&2
            echo running testsleepA
            exec {bindir}/{testsleepA} "$@"
            """)
        shell_file(os_path(testdir, "testsleepB.bin"), F"""
            #! /bin/sh
            echo starts testsleepB >&2
            echo running testsleepB
            exec {bindir}/{testsleepB} "$@"
            """)
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepA}.bin 4
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepB}.bin 5
            [Install]
            WantedBy=multi-user.target
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleepA))
        copy_tool(_bin_sleep, os_path(bindir, testsleepB))
        copy_tool(os_path(testdir, "testsleepA.bin"), os_path(bindir, testsleepA + ".bin"))
        copy_tool(os_path(testdir, "testsleepB.bin"), os_path(bindir, testsleepB + ".bin"))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        cmd = F"{systemctl} enable zza.service"
        sh____(cmd)
        cmd = F"{systemctl} enable zzb.service"
        sh____(cmd)
        #
        INITLOOPSLEEP = 1
        initsystemctl = systemctl
        initsystemctl += F" -c INITLOOPSLEEP={INITLOOPSLEEP}"
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = F"{initsystemctl} -1"
        init = background(cmd)
        time.sleep(INITLOOPSLEEP+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*INITLOOPSLEEP"))
        #
        cmd = F"{systemctl} show zza.service -p JournalFilePath"
        journal_a=output(cmd).strip().split("=", 1)[1]
        cmd = F"{systemctl} show zzb.service -p JournalFilePath"
        journal_b=output(cmd).strip().split("=", 1)[1]
        logg.info("journal zza = %s", journal_a)
        logg.info("journal zzb = %s", journal_b)
        time.sleep(1)
        self.assertTrue(os.path.exists(journal_a))
        self.assertTrue(os.path.exists(journal_b))
        out_a = open(journal_a).read()
        out_b = open(journal_b).read()
        logg.info("out_a=%s", out_a.strip())
        logg.info("out_b=%s", out_b.strip())
        self.assertTrue(greps(out_a, "running testsleepA"))
        self.assertTrue(greps(out_b, "running testsleepB"))
        self.assertTrue(greps(out_a, "starts testsleepA"))
        self.assertTrue(greps(out_b, "starts testsleepB"))
        self.assertFalse(greps(out_a, "running testsleepB"))
        self.assertFalse(greps(out_b, "running testsleepA"))
        self.assertFalse(greps(out_a, "starts testsleepB"))
        self.assertFalse(greps(out_b, "starts testsleepA"))

        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_25303_background_default_journal_null_stderr(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleepA = self.testname("sleepA")
        testsleepB = self.testname("sleepB")
        bindir = os_path(root, "/usr/bin")
        shell_file(os_path(testdir, "testsleepA.bin"), F"""
            #! /bin/sh
            echo starts testsleepA >&2
            echo running testsleepA
            exec {bindir}/{testsleepA} "$@"
            """)
        shell_file(os_path(testdir, "testsleepB.bin"), F"""
            #! /bin/sh
            echo starts testsleepB >&2
            echo running testsleepB
            exec {bindir}/{testsleepB} "$@"
            """)
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepA}.bin 4
            StandardError=null
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepB}.bin 5
            StandardError=null
            [Install]
            WantedBy=multi-user.target
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleepA))
        copy_tool(_bin_sleep, os_path(bindir, testsleepB))
        copy_tool(os_path(testdir, "testsleepA.bin"), os_path(bindir, testsleepA + ".bin"))
        copy_tool(os_path(testdir, "testsleepB.bin"), os_path(bindir, testsleepB + ".bin"))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        cmd = F"{systemctl} enable zza.service"
        sh____(cmd)
        cmd = F"{systemctl} enable zzb.service"
        sh____(cmd)
        #
        INITLOOPSLEEP = 1
        initsystemctl = systemctl
        initsystemctl += F" -c INITLOOPSLEEP={INITLOOPSLEEP}"
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = F"{initsystemctl} -1"
        init = background(cmd)
        time.sleep(INITLOOPSLEEP+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*INITLOOPSLEEP"))
        #
        cmd = F"{systemctl} show zza.service -p JournalFilePath"
        journal_a=output(cmd).strip().split("=", 1)[1]
        cmd = F"{systemctl} show zzb.service -p JournalFilePath"
        journal_b=output(cmd).strip().split("=", 1)[1]
        logg.info("journal zza = %s", journal_a)
        logg.info("journal zzb = %s", journal_b)
        time.sleep(1)
        self.assertTrue(os.path.exists(journal_a))
        self.assertTrue(os.path.exists(journal_b))
        out_a = open(journal_a).read()
        out_b = open(journal_b).read()
        logg.info("out_a=%s", out_a.strip())
        logg.info("out_b=%s", out_b.strip())
        self.assertTrue(greps(out_a, "running testsleepA"))
        self.assertTrue(greps(out_b, "running testsleepB"))
        self.assertFalse(greps(out_a, "starts testsleepA"))
        self.assertFalse(greps(out_b, "starts testsleepB"))
        self.assertFalse(greps(out_a, "running testsleepB"))
        self.assertFalse(greps(out_b, "running testsleepA"))
        self.assertFalse(greps(out_a, "starts testsleepB"))
        self.assertFalse(greps(out_b, "starts testsleepA"))
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_25304_background_default_journal_null_stdout(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleepA = self.testname("sleepA")
        testsleepB = self.testname("sleepB")
        bindir = os_path(root, "/usr/bin")
        shell_file(os_path(testdir, "testsleepA.bin"), F"""
            #! /bin/sh
            echo starts testsleepA >&2
            echo running testsleepA
            exec {bindir}/{testsleepA} "$@"
            """)
        shell_file(os_path(testdir, "testsleepB.bin"), F"""
            #! /bin/sh
            echo starts testsleepB >&2
            echo running testsleepB
            exec {bindir}/{testsleepB} "$@"
            """)
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepA}.bin 4
            StandardOutput=null
            StandardError=journal
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepB}.bin 5
            StandardOutput=null
            StandardError=journal
            [Install]
            WantedBy=multi-user.target
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleepA))
        copy_tool(_bin_sleep, os_path(bindir, testsleepB))
        copy_tool(os_path(testdir, "testsleepA.bin"), os_path(bindir, testsleepA + ".bin"))
        copy_tool(os_path(testdir, "testsleepB.bin"), os_path(bindir, testsleepB + ".bin"))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        cmd = F"{systemctl} enable zza.service"
        sh____(cmd)
        cmd = F"{systemctl} enable zzb.service"
        sh____(cmd)
        #
        INITLOOPSLEEP = 1
        initsystemctl = systemctl
        initsystemctl += F" -c INITLOOPSLEEP={INITLOOPSLEEP}"
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = F"{initsystemctl} -1"
        init = background(cmd)
        time.sleep(INITLOOPSLEEP+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*INITLOOPSLEEP"))
        #
        cmd = F"{systemctl} show zza.service -p JournalFilePath"
        journal_a=output(cmd).strip().split("=", 1)[1]
        cmd = F"{systemctl} show zzb.service -p JournalFilePath"
        journal_b=output(cmd).strip().split("=", 1)[1]
        logg.info("journal zza = %s", journal_a)
        logg.info("journal zzb = %s", journal_b)
        time.sleep(1)
        self.assertTrue(os.path.exists(journal_a))
        self.assertTrue(os.path.exists(journal_b))
        out_a = open(journal_a).read()
        out_b = open(journal_b).read()
        logg.info("out_a=%s", out_a.strip())
        logg.info("out_b=%s", out_b.strip())
        self.assertFalse(greps(out_a, "running testsleepA"))
        self.assertFalse(greps(out_b, "running testsleepB"))
        self.assertTrue(greps(out_a, "starts testsleepA"))
        self.assertTrue(greps(out_b, "starts testsleepB"))
        self.assertFalse(greps(out_a, "running testsleepB"))
        self.assertFalse(greps(out_b, "running testsleepA"))
        self.assertFalse(greps(out_a, "starts testsleepB"))
        self.assertFalse(greps(out_b, "starts testsleepA"))
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_25308_background_default_journal_null_stdout_stderr(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleepA = self.testname("sleepA")
        testsleepB = self.testname("sleepB")
        bindir = os_path(root, "/usr/bin")
        shell_file(os_path(testdir, "testsleepA.bin"), F"""
            #! /bin/sh
            echo starts testsleepA >&2
            echo running testsleepA
            exec {bindir}/{testsleepA} "$@"
            """)
        shell_file(os_path(testdir, "testsleepB.bin"), F"""
            #! /bin/sh
            echo starts testsleepB >&2
            echo running testsleepB
            exec {bindir}/{testsleepB} "$@"
            """)
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepA}.bin 4
            StandardOutput=null
            StandardError=null
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepB}.bin 5
            StandardOutput=null
            StandardError=null
            [Install]
            WantedBy=multi-user.target
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleepA))
        copy_tool(_bin_sleep, os_path(bindir, testsleepB))
        copy_tool(os_path(testdir, "testsleepA.bin"), os_path(bindir, testsleepA + ".bin"))
        copy_tool(os_path(testdir, "testsleepB.bin"), os_path(bindir, testsleepB + ".bin"))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        cmd = F"{systemctl} enable zza.service"
        sh____(cmd)
        cmd = F"{systemctl} enable zzb.service"
        sh____(cmd)
        #
        INITLOOPSLEEP = 1
        initsystemctl = systemctl
        initsystemctl += F" -c INITLOOPSLEEP={INITLOOPSLEEP}"
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = F"{initsystemctl} -1"
        init = background(cmd)
        time.sleep(INITLOOPSLEEP+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*INITLOOPSLEEP"))
        #
        cmd = F"{systemctl} show zza.service -p JournalFilePath"
        journal_a=output(cmd).strip().split("=", 1)[1]
        cmd = F"{systemctl} show zzb.service -p JournalFilePath"
        journal_b=output(cmd).strip().split("=", 1)[1]
        logg.info("journal zza = %s", journal_a)
        logg.info("journal zzb = %s", journal_b)
        time.sleep(1)
        self.assertFalse(os.path.exists(journal_a))
        self.assertFalse(os.path.exists(journal_b))
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_25309_background_default_journal_null_stdout_inherit(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleepA = self.testname("sleepA")
        testsleepB = self.testname("sleepB")
        bindir = os_path(root, "/usr/bin")
        shell_file(os_path(testdir, "testsleepA.bin"), F"""
            #! /bin/sh
            echo starts testsleepA >&2
            echo running testsleepA
            exec {bindir}/{testsleepA} "$@"
            """)
        shell_file(os_path(testdir, "testsleepB.bin"), F"""
            #! /bin/sh
            echo starts testsleepB >&2
            echo running testsleepB
            exec {bindir}/{testsleepB} "$@"
            """)
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepA}.bin 4
            StandardOutput=null
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepB}.bin 5
            StandardOutput=null
            [Install]
            WantedBy=multi-user.target
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleepA))
        copy_tool(_bin_sleep, os_path(bindir, testsleepB))
        copy_tool(os_path(testdir, "testsleepA.bin"), os_path(bindir, testsleepA + ".bin"))
        copy_tool(os_path(testdir, "testsleepB.bin"), os_path(bindir, testsleepB + ".bin"))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        cmd = F"{systemctl} enable zza.service"
        sh____(cmd)
        cmd = F"{systemctl} enable zzb.service"
        sh____(cmd)
        #
        INITLOOPSLEEP = 1
        initsystemctl = systemctl
        initsystemctl += F" -c INITLOOPSLEEP={INITLOOPSLEEP}"
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = F"{initsystemctl} -1"
        init = background(cmd)
        time.sleep(INITLOOPSLEEP+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*INITLOOPSLEEP"))
        #
        cmd = F"{systemctl} show zza.service -p JournalFilePath"
        journal_a=output(cmd).strip().split("=", 1)[1]
        cmd = F"{systemctl} show zzb.service -p JournalFilePath"
        journal_b=output(cmd).strip().split("=", 1)[1]
        logg.info("journal zza = %s", journal_a)
        logg.info("journal zzb = %s", journal_b)
        time.sleep(1)
        self.assertFalse(os.path.exists(journal_a))
        self.assertFalse(os.path.exists(journal_b))
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_25311_background_logfile_journal(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleepA = self.testname("sleepA")
        testsleepB = self.testname("sleepB")
        bindir = os_path(root, "/usr/bin")
        shell_file(os_path(testdir, "testsleepA.bin"), F"""
            #! /bin/sh
            echo starts testsleepA >&2
            echo running testsleepA
            exec {bindir}/{testsleepA} "$@"
            """)
        shell_file(os_path(testdir, "testsleepB.bin"), F"""
            #! /bin/sh
            echo starts testsleepB >&2
            echo running testsleepB
            exec {bindir}/{testsleepB} "$@"
            """)
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepA}.bin 4
            StandardOutput=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepB}.bin 5
            StandardOutput=file:{root}/var/log/zzb.log
            [Install]
            WantedBy=multi-user.target
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleepA))
        copy_tool(_bin_sleep, os_path(bindir, testsleepB))
        copy_tool(os_path(testdir, "testsleepA.bin"), os_path(bindir, testsleepA + ".bin"))
        copy_tool(os_path(testdir, "testsleepB.bin"), os_path(bindir, testsleepB + ".bin"))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        cmd = F"{systemctl} enable zza.service"
        sh____(cmd)
        cmd = F"{systemctl} enable zzb.service"
        sh____(cmd)
        #
        INITLOOPSLEEP = 1
        initsystemctl = systemctl
        initsystemctl += F" -c INITLOOPSLEEP={INITLOOPSLEEP}"
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = F"{initsystemctl} -1"
        init = background(cmd)
        time.sleep(INITLOOPSLEEP+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*INITLOOPSLEEP"))
        #
        cmd = F"{systemctl} show zza.service -p JournalFilePath"
        journal_a=output(cmd).strip().split("=", 1)[1]
        cmd = F"{systemctl} show zzb.service -p JournalFilePath"
        journal_b=output(cmd).strip().split("=", 1)[1]
        logg.info("journal zza = %s", journal_a)
        logg.info("journal zzb = %s", journal_b)
        time.sleep(1)
        self.assertFalse(os.path.exists(journal_a))
        self.assertFalse(os.path.exists(journal_b))
        log_a = root + "/var/log/zza.log"
        log_b = root + "/var/log/zzb.log"
        logg.info("log zza = %s", log_a)
        logg.info("log zzb = %s", log_b)
        self.assertTrue(os.path.exists(log_a))
        self.assertTrue(os.path.exists(log_b))
        out_a = open(log_a).read()
        out_b = open(log_b).read()
        logg.info("out_a=%s", out_a.strip())
        logg.info("out_b=%s", out_b.strip())
        self.assertTrue(greps(out_a, "running testsleepA"))
        self.assertTrue(greps(out_b, "running testsleepB"))
        self.assertFalse(greps(out_a, "running testsleepB"))
        self.assertFalse(greps(out_b, "running testsleepA"))
        self.assertTrue(greps(out_a, "starts testsleepA"))
        self.assertTrue(greps(out_b, "starts testsleepB"))
        self.assertFalse(greps(out_a, "starts testsleepB"))
        self.assertFalse(greps(out_b, "starts testsleepA"))
        #
        logg.info("kill daemon at %s", init.pid)
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_25312_background_logfile_journal(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleepA = self.testname("sleepA")
        testsleepB = self.testname("sleepB")
        bindir = os_path(root, "/usr/bin")
        shell_file(os_path(testdir, "testsleepA.bin"), F"""
            #! /bin/sh
            echo starts testsleepA >&2
            echo running testsleepA
            exec {bindir}/{testsleepA} "$@"
            """)
        shell_file(os_path(testdir, "testsleepB.bin"), F"""
            #! /bin/sh
            echo starts testsleepB >&2
            echo running testsleepB
            exec {bindir}/{testsleepB} "$@"
            """)
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepA}.bin 4
            StandardError=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepB}.bin 5
            StandardError=file:{root}/var/log/zzb.log
            [Install]
            WantedBy=multi-user.target
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleepA))
        copy_tool(_bin_sleep, os_path(bindir, testsleepB))
        copy_tool(os_path(testdir, "testsleepA.bin"), os_path(bindir, testsleepA + ".bin"))
        copy_tool(os_path(testdir, "testsleepB.bin"), os_path(bindir, testsleepB + ".bin"))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        cmd = F"{systemctl} enable zza.service"
        sh____(cmd)
        cmd = F"{systemctl} enable zzb.service"
        sh____(cmd)
        #
        INITLOOPSLEEP = 1
        initsystemctl = systemctl
        initsystemctl += F" -c INITLOOPSLEEP={INITLOOPSLEEP}"
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = F"{initsystemctl} -1"
        init = background(cmd)
        time.sleep(INITLOOPSLEEP+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*INITLOOPSLEEP"))
        #
        cmd = F"{systemctl} show zza.service -p JournalFilePath"
        journal_a=output(cmd).strip().split("=", 1)[1]
        cmd = F"{systemctl} show zzb.service -p JournalFilePath"
        journal_b=output(cmd).strip().split("=", 1)[1]
        logg.info("journal zza = %s", journal_a)
        logg.info("journal zzb = %s", journal_b)
        time.sleep(1)
        self.assertTrue(os.path.exists(journal_a))
        self.assertTrue(os.path.exists(journal_b))
        out_a = open(journal_a).read()
        out_b = open(journal_b).read()
        self.assertTrue(greps(out_a, "running testsleepA"))
        self.assertTrue(greps(out_b, "running testsleepB"))
        self.assertFalse(greps(out_a, "running testsleepB"))
        self.assertFalse(greps(out_b, "running testsleepA"))
        log_a = root + "/var/log/zza.log"
        log_b = root + "/var/log/zzb.log"
        logg.info("log zza = %s", log_a)
        logg.info("log zzb = %s", log_b)
        self.assertTrue(os.path.exists(log_a))
        self.assertTrue(os.path.exists(log_b))
        out_a = open(log_a).read()
        out_b = open(log_b).read()
        logg.info("out_a=%s", out_a.strip())
        logg.info("out_b=%s", out_b.strip())
        self.assertTrue(greps(out_a, "starts testsleepA"))
        self.assertTrue(greps(out_b, "starts testsleepB"))
        self.assertFalse(greps(out_a, "starts testsleepB"))
        self.assertFalse(greps(out_b, "starts testsleepA"))
        #
        logg.info("kill daemon at %s", init.pid)
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_25313_background_logfile_journal(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleepA = self.testname("sleepA")
        testsleepB = self.testname("sleepB")
        bindir = os_path(root, "/usr/bin")
        shell_file(os_path(testdir, "testsleepA.bin"), F"""
            #! /bin/sh
            echo starts testsleepA >&2
            echo running testsleepA
            exec {bindir}/{testsleepA} "$@"
            """)
        shell_file(os_path(testdir, "testsleepB.bin"), F"""
            #! /bin/sh
            echo starts testsleepB >&2
            echo running testsleepB
            exec {bindir}/{testsleepB} "$@"
            """)
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepA}.bin 4
            StandardOutput=file:{root}/var/log/zza.log
            StandardError=journal
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepB}.bin 5
            StandardOutput=file:{root}/var/log/zzb.log
            StandardError=journal
            [Install]
            WantedBy=multi-user.target
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleepA))
        copy_tool(_bin_sleep, os_path(bindir, testsleepB))
        copy_tool(os_path(testdir, "testsleepA.bin"), os_path(bindir, testsleepA + ".bin"))
        copy_tool(os_path(testdir, "testsleepB.bin"), os_path(bindir, testsleepB + ".bin"))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        cmd = F"{systemctl} enable zza.service"
        sh____(cmd)
        cmd = F"{systemctl} enable zzb.service"
        sh____(cmd)
        #
        INITLOOPSLEEP = 1
        initsystemctl = systemctl
        initsystemctl += F" -c INITLOOPSLEEP={INITLOOPSLEEP}"
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = F"{initsystemctl} -1"
        init = background(cmd)
        time.sleep(INITLOOPSLEEP+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*INITLOOPSLEEP"))
        #
        cmd = F"{systemctl} show zza.service -p JournalFilePath"
        journal_a=output(cmd).strip().split("=", 1)[1]
        cmd = F"{systemctl} show zzb.service -p JournalFilePath"
        journal_b=output(cmd).strip().split("=", 1)[1]
        logg.info("journal zza = %s", journal_a)
        logg.info("journal zzb = %s", journal_b)
        time.sleep(1)
        self.assertTrue(os.path.exists(journal_a))
        self.assertTrue(os.path.exists(journal_b))
        out_a = open(journal_a).read()
        out_b = open(journal_b).read()
        self.assertTrue(greps(out_a, "starts testsleepA"))
        self.assertTrue(greps(out_b, "starts testsleepB"))
        self.assertFalse(greps(out_a, "starts testsleepB"))
        self.assertFalse(greps(out_b, "starts testsleepA"))
        log_a = root + "/var/log/zza.log"
        log_b = root + "/var/log/zzb.log"
        logg.info("log zza = %s", log_a)
        logg.info("log zzb = %s", log_b)
        self.assertTrue(os.path.exists(log_a))
        self.assertTrue(os.path.exists(log_b))
        out_a = open(log_a).read()
        out_b = open(log_b).read()
        logg.info("out_a=%s", out_a.strip())
        logg.info("out_b=%s", out_b.strip())
        self.assertTrue(greps(out_a, "running testsleepA"))
        self.assertTrue(greps(out_b, "running testsleepB"))
        self.assertFalse(greps(out_a, "running testsleepB"))
        self.assertFalse(greps(out_b, "running testsleepA"))
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_25321_background_logfile_journal(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleepA = self.testname("sleepA")
        testsleepB = self.testname("sleepB")
        bindir = os_path(root, "/usr/bin")
        shell_file(os_path(testdir, "testsleepA.bin"), F"""
            #! /bin/sh
            echo starts testsleepA >&2
            echo running testsleepA
            exec {bindir}/{testsleepA} "$@"
            """)
        shell_file(os_path(testdir, "testsleepB.bin"), F"""
            #! /bin/sh
            echo starts testsleepB >&2
            echo running testsleepB
            exec {bindir}/{testsleepB} "$@"
            """)
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepA}.bin 4
            StandardOutput=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepB}.bin 5
            StandardOutput=file:{root}/var/log/zzb.log
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "append.log"), "append")
        copy_tool(_bin_sleep, os_path(bindir, testsleepA))
        copy_tool(_bin_sleep, os_path(bindir, testsleepB))
        copy_tool(os_path(testdir, "testsleepA.bin"), os_path(bindir, testsleepA + ".bin"))
        copy_tool(os_path(testdir, "testsleepB.bin"), os_path(bindir, testsleepB + ".bin"))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        copy_file(os_path(testdir, "append.log"), os_path(root, "/var/log/zza.log"))
        copy_file(os_path(testdir, "append.log"), os_path(root, "/var/log/zzb.log"))
        cmd = F"{systemctl} enable zza.service"
        sh____(cmd)
        cmd = F"{systemctl} enable zzb.service"
        sh____(cmd)
        #
        INITLOOPSLEEP = 1
        initsystemctl = systemctl
        initsystemctl += F" -c INITLOOPSLEEP={INITLOOPSLEEP}"
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = F"{initsystemctl} -1"
        init = background(cmd)
        time.sleep(INITLOOPSLEEP+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*INITLOOPSLEEP"))
        #
        cmd = F"{systemctl} show zza.service -p JournalFilePath"
        journal_a=output(cmd).strip().split("=", 1)[1]
        cmd = F"{systemctl} show zzb.service -p JournalFilePath"
        journal_b=output(cmd).strip().split("=", 1)[1]
        logg.info("journal zza = %s", journal_a)
        logg.info("journal zzb = %s", journal_b)
        time.sleep(1)
        self.assertFalse(os.path.exists(journal_a))
        self.assertFalse(os.path.exists(journal_b))
        log_a = root + "/var/log/zza.log"
        log_b = root + "/var/log/zzb.log"
        logg.info("log zza = %s", log_a)
        logg.info("log zzb = %s", log_b)
        self.assertTrue(os.path.exists(log_a))
        self.assertTrue(os.path.exists(log_b))
        out_a = open(log_a).read()
        out_b = open(log_b).read()
        logg.info("out_a=%s", out_a.strip())
        logg.info("out_b=%s", out_b.strip())
        self.assertTrue(greps(out_a, "running testsleepA"))
        self.assertTrue(greps(out_b, "running testsleepB"))
        self.assertFalse(greps(out_a, "running testsleepB"))
        self.assertFalse(greps(out_b, "running testsleepA"))
        self.assertTrue(greps(out_a, "starts testsleepA"))
        self.assertTrue(greps(out_b, "starts testsleepB"))
        self.assertFalse(greps(out_a, "starts testsleepB"))
        self.assertFalse(greps(out_b, "starts testsleepA"))
        self.assertFalse(greps(out_a, "append"))
        self.assertFalse(greps(out_b, "append"))
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_25322_background_logfile_journal(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleepA = self.testname("sleepA")
        testsleepB = self.testname("sleepB")
        bindir = os_path(root, "/usr/bin")
        shell_file(os_path(testdir, "testsleepA.bin"), F"""
            #! /bin/sh
            echo starts testsleepA >&2
            echo running testsleepA
            exec {bindir}/{testsleepA} "$@"
            """)
        shell_file(os_path(testdir, "testsleepB.bin"), F"""
            #! /bin/sh
            echo starts testsleepB >&2
            echo running testsleepB
            exec {bindir}/{testsleepB} "$@"
            """)
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepA}.bin 4
            StandardError=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepB}.bin 5
            StandardError=file:{root}/var/log/zzb.log
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "append.log"), "append")
        copy_tool(_bin_sleep, os_path(bindir, testsleepA))
        copy_tool(_bin_sleep, os_path(bindir, testsleepB))
        copy_tool(os_path(testdir, "testsleepA.bin"), os_path(bindir, testsleepA + ".bin"))
        copy_tool(os_path(testdir, "testsleepB.bin"), os_path(bindir, testsleepB + ".bin"))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        copy_file(os_path(testdir, "append.log"), os_path(root, "/var/log/zza.log"))
        copy_file(os_path(testdir, "append.log"), os_path(root, "/var/log/zzb.log"))
        cmd = F"{systemctl} enable zza.service"
        sh____(cmd)
        cmd = F"{systemctl} enable zzb.service"
        sh____(cmd)
        #
        INITLOOPSLEEP = 1
        initsystemctl = systemctl
        initsystemctl += F" -c INITLOOPSLEEP={INITLOOPSLEEP}"
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = F"{initsystemctl} -1"
        init = background(cmd)
        time.sleep(INITLOOPSLEEP+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*INITLOOPSLEEP"))
        #
        cmd = F"{systemctl} show zza.service -p JournalFilePath"
        journal_a=output(cmd).strip().split("=", 1)[1]
        cmd = F"{systemctl} show zzb.service -p JournalFilePath"
        journal_b=output(cmd).strip().split("=", 1)[1]
        logg.info("journal zza = %s", journal_a)
        logg.info("journal zzb = %s", journal_b)
        time.sleep(1)
        self.assertTrue(os.path.exists(journal_a))
        self.assertTrue(os.path.exists(journal_b))
        out_a = open(journal_a).read()
        out_b = open(journal_b).read()
        self.assertTrue(greps(out_a, "running testsleepA"))
        self.assertTrue(greps(out_b, "running testsleepB"))
        self.assertFalse(greps(out_a, "running testsleepB"))
        self.assertFalse(greps(out_b, "running testsleepA"))
        log_a = root + "/var/log/zza.log"
        log_b = root + "/var/log/zzb.log"
        logg.info("log zza = %s", log_a)
        logg.info("log zzb = %s", log_b)
        self.assertTrue(os.path.exists(log_a))
        self.assertTrue(os.path.exists(log_b))
        out_a = open(log_a).read()
        out_b = open(log_b).read()
        logg.info("out_a=%s", out_a.strip())
        logg.info("out_b=%s", out_b.strip())
        self.assertTrue(greps(out_a, "starts testsleepA"))
        self.assertTrue(greps(out_b, "starts testsleepB"))
        self.assertFalse(greps(out_a, "starts testsleepB"))
        self.assertFalse(greps(out_b, "starts testsleepA"))
        self.assertFalse(greps(out_a, "append"))
        self.assertFalse(greps(out_b, "append"))
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_25323_background_logfile_journal(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleepA = self.testname("sleepA")
        testsleepB = self.testname("sleepB")
        bindir = os_path(root, "/usr/bin")
        shell_file(os_path(testdir, "testsleepA.bin"), F"""
            #! /bin/sh
            echo starts testsleepA >&2
            echo running testsleepA
            exec {bindir}/{testsleepA} "$@"
            """)
        shell_file(os_path(testdir, "testsleepB.bin"), F"""
            #! /bin/sh
            echo starts testsleepB >&2
            echo running testsleepB
            exec {bindir}/{testsleepB} "$@"
            """)
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepA}.bin 4
            StandardOutput=file:{root}/var/log/zza.log
            StandardError=journal
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepB}.bin 5
            StandardOutput=file:{root}/var/log/zzb.log
            StandardError=journal
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "append.log"), "append")
        copy_tool(_bin_sleep, os_path(bindir, testsleepA))
        copy_tool(_bin_sleep, os_path(bindir, testsleepB))
        copy_tool(os_path(testdir, "testsleepA.bin"), os_path(bindir, testsleepA + ".bin"))
        copy_tool(os_path(testdir, "testsleepB.bin"), os_path(bindir, testsleepB + ".bin"))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        copy_file(os_path(testdir, "append.log"), os_path(root, "/var/log/zza.log"))
        copy_file(os_path(testdir, "append.log"), os_path(root, "/var/log/zzb.log"))
        cmd = F"{systemctl} enable zza.service"
        sh____(cmd)
        cmd = F"{systemctl} enable zzb.service"
        sh____(cmd)
        #
        INITLOOPSLEEP = 1
        initsystemctl = systemctl
        initsystemctl += F" -c INITLOOPSLEEP={INITLOOPSLEEP}"
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = F"{initsystemctl} -1"
        init = background(cmd)
        time.sleep(INITLOOPSLEEP+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*INITLOOPSLEEP"))
        #
        cmd = F"{systemctl} show zza.service -p JournalFilePath"
        journal_a=output(cmd).strip().split("=", 1)[1]
        cmd = F"{systemctl} show zzb.service -p JournalFilePath"
        journal_b=output(cmd).strip().split("=", 1)[1]
        logg.info("journal zza = %s", journal_a)
        logg.info("journal zzb = %s", journal_b)
        time.sleep(1)
        self.assertTrue(os.path.exists(journal_a))
        self.assertTrue(os.path.exists(journal_b))
        out_a = open(journal_a).read()
        out_b = open(journal_b).read()
        self.assertTrue(greps(out_a, "starts testsleepA"))
        self.assertTrue(greps(out_b, "starts testsleepB"))
        self.assertFalse(greps(out_a, "starts testsleepB"))
        self.assertFalse(greps(out_b, "starts testsleepA"))
        log_a = root + "/var/log/zza.log"
        log_b = root + "/var/log/zzb.log"
        logg.info("log zza = %s", log_a)
        logg.info("log zzb = %s", log_b)
        self.assertTrue(os.path.exists(log_a))
        self.assertTrue(os.path.exists(log_b))
        out_a = open(log_a).read()
        out_b = open(log_b).read()
        logg.info("out_a=%s", out_a.strip())
        logg.info("out_b=%s", out_b.strip())
        self.assertTrue(greps(out_a, "running testsleepA"))
        self.assertTrue(greps(out_b, "running testsleepB"))
        self.assertFalse(greps(out_a, "running testsleepB"))
        self.assertFalse(greps(out_b, "running testsleepA"))
        self.assertFalse(greps(out_a, "append"))
        self.assertFalse(greps(out_b, "append"))
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_25331_background_logfile_journal(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleepA = self.testname("sleepA")
        testsleepB = self.testname("sleepB")
        bindir = os_path(root, "/usr/bin")
        shell_file(os_path(testdir, "testsleepA.bin"), F"""
            #! /bin/sh
            echo starts testsleepA >&2
            echo running testsleepA
            exec {bindir}/{testsleepA} "$@"
            """)
        shell_file(os_path(testdir, "testsleepB.bin"), F"""
            #! /bin/sh
            echo starts testsleepB >&2
            echo running testsleepB
            exec {bindir}/{testsleepB} "$@"
            """)
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepA}.bin 4
            StandardOutput=append:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepB}.bin 5
            StandardOutput=append:{root}/var/log/zzb.log
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "append.log"), "append")
        copy_tool(_bin_sleep, os_path(bindir, testsleepA))
        copy_tool(_bin_sleep, os_path(bindir, testsleepB))
        copy_tool(os_path(testdir, "testsleepA.bin"), os_path(bindir, testsleepA + ".bin"))
        copy_tool(os_path(testdir, "testsleepB.bin"), os_path(bindir, testsleepB + ".bin"))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        copy_file(os_path(testdir, "append.log"), os_path(root, "/var/log/zza.log"))
        copy_file(os_path(testdir, "append.log"), os_path(root, "/var/log/zzb.log"))
        cmd = F"{systemctl} enable zza.service"
        sh____(cmd)
        cmd = F"{systemctl} enable zzb.service"
        sh____(cmd)
        #
        INITLOOPSLEEP = 1
        initsystemctl = systemctl
        initsystemctl += F" -c INITLOOPSLEEP={INITLOOPSLEEP}"
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = F"{initsystemctl} -1"
        init = background(cmd)
        time.sleep(INITLOOPSLEEP+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*INITLOOPSLEEP"))
        #
        cmd = F"{systemctl} show zza.service -p JournalFilePath"
        journal_a=output(cmd).strip().split("=", 1)[1]
        cmd = F"{systemctl} show zzb.service -p JournalFilePath"
        journal_b=output(cmd).strip().split("=", 1)[1]
        logg.info("journal zza = %s", journal_a)
        logg.info("journal zzb = %s", journal_b)
        time.sleep(1)
        self.assertFalse(os.path.exists(journal_a))
        self.assertFalse(os.path.exists(journal_b))
        log_a = root + "/var/log/zza.log"
        log_b = root + "/var/log/zzb.log"
        logg.info("log zza = %s", log_a)
        logg.info("log zzb = %s", log_b)
        self.assertTrue(os.path.exists(log_a))
        self.assertTrue(os.path.exists(log_b))
        out_a = open(log_a).read()
        out_b = open(log_b).read()
        logg.info("out_a=%s", out_a.strip())
        logg.info("out_b=%s", out_b.strip())
        self.assertTrue(greps(out_a, "running testsleepA"))
        self.assertTrue(greps(out_b, "running testsleepB"))
        self.assertFalse(greps(out_a, "running testsleepB"))
        self.assertFalse(greps(out_b, "running testsleepA"))
        self.assertTrue(greps(out_a, "starts testsleepA"))
        self.assertTrue(greps(out_b, "starts testsleepB"))
        self.assertFalse(greps(out_a, "starts testsleepB"))
        self.assertFalse(greps(out_b, "starts testsleepA"))
        self.assertTrue(greps(out_a, "append"))
        self.assertTrue(greps(out_b, "append"))
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_25332_background_logfile_journal(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleepA = self.testname("sleepA")
        testsleepB = self.testname("sleepB")
        bindir = os_path(root, "/usr/bin")
        shell_file(os_path(testdir, "testsleepA.bin"), F"""
            #! /bin/sh
            echo starts testsleepA >&2
            echo running testsleepA
            exec {bindir}/{testsleepA} "$@"
            """)
        shell_file(os_path(testdir, "testsleepB.bin"), F"""
            #! /bin/sh
            echo starts testsleepB >&2
            echo running testsleepB
            exec {bindir}/{testsleepB} "$@"
            """)
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepA}.bin 4
            StandardError=append:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepB}.bin 5
            StandardError=append:{root}/var/log/zzb.log
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "append.log"), "append")
        copy_tool(_bin_sleep, os_path(bindir, testsleepA))
        copy_tool(_bin_sleep, os_path(bindir, testsleepB))
        copy_tool(os_path(testdir, "testsleepA.bin"), os_path(bindir, testsleepA + ".bin"))
        copy_tool(os_path(testdir, "testsleepB.bin"), os_path(bindir, testsleepB + ".bin"))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        copy_file(os_path(testdir, "append.log"), os_path(root, "/var/log/zza.log"))
        copy_file(os_path(testdir, "append.log"), os_path(root, "/var/log/zzb.log"))
        cmd = F"{systemctl} enable zza.service"
        sh____(cmd)
        cmd = F"{systemctl} enable zzb.service"
        sh____(cmd)
        #
        INITLOOPSLEEP = 1
        initsystemctl = systemctl
        initsystemctl += F" -c INITLOOPSLEEP={INITLOOPSLEEP}"
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = F"{initsystemctl} -1"
        init = background(cmd)
        time.sleep(INITLOOPSLEEP+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*INITLOOPSLEEP"))
        #
        cmd = F"{systemctl} show zza.service -p JournalFilePath"
        journal_a=output(cmd).strip().split("=", 1)[1]
        cmd = F"{systemctl} show zzb.service -p JournalFilePath"
        journal_b=output(cmd).strip().split("=", 1)[1]
        logg.info("journal zza = %s", journal_a)
        logg.info("journal zzb = %s", journal_b)
        time.sleep(1)
        self.assertTrue(os.path.exists(journal_a))
        self.assertTrue(os.path.exists(journal_b))
        out_a = open(journal_a).read()
        out_b = open(journal_b).read()
        self.assertTrue(greps(out_a, "running testsleepA"))
        self.assertTrue(greps(out_b, "running testsleepB"))
        self.assertFalse(greps(out_a, "running testsleepB"))
        self.assertFalse(greps(out_b, "running testsleepA"))
        log_a = root + "/var/log/zza.log"
        log_b = root + "/var/log/zzb.log"
        logg.info("log zza = %s", log_a)
        logg.info("log zzb = %s", log_b)
        self.assertTrue(os.path.exists(log_a))
        self.assertTrue(os.path.exists(log_b))
        out_a = open(log_a).read()
        out_b = open(log_b).read()
        logg.info("out_a=%s", out_a.strip())
        logg.info("out_b=%s", out_b.strip())
        self.assertTrue(greps(out_a, "starts testsleepA"))
        self.assertTrue(greps(out_b, "starts testsleepB"))
        self.assertFalse(greps(out_a, "starts testsleepB"))
        self.assertFalse(greps(out_b, "starts testsleepA"))
        self.assertTrue(greps(out_a, "append"))
        self.assertTrue(greps(out_b, "append"))
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_25333_background_logfile_journal(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleepA = self.testname("sleepA")
        testsleepB = self.testname("sleepB")
        bindir = os_path(root, "/usr/bin")
        shell_file(os_path(testdir, "testsleepA.bin"), F"""
            #! /bin/sh
            echo starts testsleepA >&2
            echo running testsleepA
            exec {bindir}/{testsleepA} "$@"
            """)
        shell_file(os_path(testdir, "testsleepB.bin"), F"""
            #! /bin/sh
            echo starts testsleepB >&2
            echo running testsleepB
            exec {bindir}/{testsleepB} "$@"
            """)
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepA}.bin 4
            StandardOutput=append:{root}/var/log/zza.log
            StandardError=journal
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepB}.bin 5
            StandardOutput=append:{root}/var/log/zzb.log
            StandardError=journal
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "append.log"), "append")
        copy_tool(_bin_sleep, os_path(bindir, testsleepA))
        copy_tool(_bin_sleep, os_path(bindir, testsleepB))
        copy_tool(os_path(testdir, "testsleepA.bin"), os_path(bindir, testsleepA + ".bin"))
        copy_tool(os_path(testdir, "testsleepB.bin"), os_path(bindir, testsleepB + ".bin"))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        copy_file(os_path(testdir, "append.log"), os_path(root, "/var/log/zza.log"))
        copy_file(os_path(testdir, "append.log"), os_path(root, "/var/log/zzb.log"))
        cmd = F"{systemctl} enable zza.service"
        sh____(cmd)
        cmd = F"{systemctl} enable zzb.service"
        sh____(cmd)
        #
        INITLOOPSLEEP = 1
        initsystemctl = systemctl
        initsystemctl += F" -c INITLOOPSLEEP={INITLOOPSLEEP}"
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = F"{initsystemctl} -1"
        init = background(cmd)
        time.sleep(INITLOOPSLEEP+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*INITLOOPSLEEP"))
        #
        cmd = F"{systemctl} show zza.service -p JournalFilePath"
        journal_a=output(cmd).strip().split("=", 1)[1]
        cmd = F"{systemctl} show zzb.service -p JournalFilePath"
        journal_b=output(cmd).strip().split("=", 1)[1]
        logg.info("journal zza = %s", journal_a)
        logg.info("journal zzb = %s", journal_b)
        time.sleep(1)
        self.assertTrue(os.path.exists(journal_a))
        self.assertTrue(os.path.exists(journal_b))
        out_a = open(journal_a).read()
        out_b = open(journal_b).read()
        self.assertTrue(greps(out_a, "starts testsleepA"))
        self.assertTrue(greps(out_b, "starts testsleepB"))
        self.assertFalse(greps(out_a, "starts testsleepB"))
        self.assertFalse(greps(out_b, "starts testsleepA"))
        log_a = root + "/var/log/zza.log"
        log_b = root + "/var/log/zzb.log"
        logg.info("log zza = %s", log_a)
        logg.info("log zzb = %s", log_b)
        self.assertTrue(os.path.exists(log_a))
        self.assertTrue(os.path.exists(log_b))
        out_a = open(log_a).read()
        out_b = open(log_b).read()
        logg.info("out_a=%s", out_a.strip())
        logg.info("out_b=%s", out_b.strip())
        self.assertTrue(greps(out_a, "running testsleepA"))
        self.assertTrue(greps(out_b, "running testsleepB"))
        self.assertFalse(greps(out_a, "running testsleepB"))
        self.assertFalse(greps(out_b, "running testsleepA"))
        self.assertTrue(greps(out_a, "append"))
        self.assertTrue(greps(out_b, "append"))
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_25351_background_logfile_journal(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleepA = self.testname("sleepA")
        testsleepB = self.testname("sleepB")
        bindir = os_path(root, "/usr/bin")
        shell_file(os_path(testdir, "testsleepA.bin"), F"""
            #! /bin/sh
            echo starts testsleepA >&2
            echo running testsleepA
            exec {bindir}/{testsleepA} "$@"
            """)
        shell_file(os_path(testdir, "testsleepB.bin"), F"""
            #! /bin/sh
            echo starts testsleepB >&2
            echo running testsleepB
            exec {bindir}/{testsleepB} "$@"
            """)
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepA}.bin 4
            StandardOutput=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepB}.bin 5
            StandardOutput=file:{root}/var/log/zzb.log
            [Install]
            WantedBy=multi-user.target
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleepA))
        copy_tool(_bin_sleep, os_path(bindir, testsleepB))
        copy_tool(os_path(testdir, "testsleepA.bin"), os_path(bindir, testsleepA + ".bin"))
        copy_tool(os_path(testdir, "testsleepB.bin"), os_path(bindir, testsleepB + ".bin"))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        os.makedirs(os_path(root, "/var/log/zza.log"))
        os.makedirs(os_path(root, "/var/log/zzb.log"))
        cmd = F"{systemctl} enable zza.service"
        sh____(cmd)
        cmd = F"{systemctl} enable zzb.service"
        sh____(cmd)
        #
        INITLOOPSLEEP = 1
        initsystemctl = systemctl
        initsystemctl += F" -c INITLOOPSLEEP={INITLOOPSLEEP}"
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = F"{initsystemctl} -1"
        init = background(cmd)
        time.sleep(INITLOOPSLEEP+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*INITLOOPSLEEP"))
        self.assertTrue(greps(top, testsleepA))
        self.assertTrue(greps(top, testsleepB))
        #
        cmd = F"{systemctl} show zza.service -p JournalFilePath"
        journal_a=output(cmd).strip().split("=", 1)[1]
        cmd = F"{systemctl} show zzb.service -p JournalFilePath"
        journal_b=output(cmd).strip().split("=", 1)[1]
        logg.info("journal zza = %s", journal_a)
        logg.info("journal zzb = %s", journal_b)
        time.sleep(1)
        self.assertTrue(os.path.exists(journal_a))
        self.assertTrue(os.path.exists(journal_b))
        log_a = root + "/var/log/zza.log"
        log_b = root + "/var/log/zzb.log"
        logg.info("log zza = %s", log_a)
        logg.info("log zzb = %s", log_b)
        # self.assertFalse(os.path.exists(log_a))
        # self.assertFalse(os.path.exists(log_b))
        #
        out_a = open(journal_a).read()
        out_b = open(journal_b).read()
        logg.info("out_a=%s", out_a.strip())
        logg.info("out_b=%s", out_b.strip())
        self.assertTrue(greps(out_a, "running testsleepA"))
        self.assertTrue(greps(out_b, "running testsleepB"))
        self.assertFalse(greps(out_a, "running testsleepB"))
        self.assertFalse(greps(out_b, "running testsleepA"))
        self.assertTrue(greps(out_a, "starts testsleepA"))
        self.assertTrue(greps(out_b, "starts testsleepB"))
        self.assertFalse(greps(out_a, "starts testsleepB"))
        self.assertFalse(greps(out_b, "starts testsleepA"))
        self.assertFalse(greps(out_a, "append"))
        self.assertFalse(greps(out_b, "append"))
        self.assertTrue(greps(out_a, "Is a directory"))
        self.assertTrue(greps(out_b, "Is a directory"))
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_25352_background_logfile_journal(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleepA = self.testname("sleepA")
        testsleepB = self.testname("sleepB")
        bindir = os_path(root, "/usr/bin")
        shell_file(os_path(testdir, "testsleepA.bin"), F"""
            #! /bin/sh
            echo starts testsleepA >&2
            echo running testsleepA
            exec {bindir}/{testsleepA} "$@"
            """)
        shell_file(os_path(testdir, "testsleepB.bin"), F"""
            #! /bin/sh
            echo starts testsleepB >&2
            echo running testsleepB
            exec {bindir}/{testsleepB} "$@"
            """)
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepA}.bin 4
            StandardError=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepB}.bin 5
            StandardError=file:{root}/var/log/zzb.log
            [Install]
            WantedBy=multi-user.target
            """)
        copy_tool(_bin_sleep, os_path(bindir, testsleepA))
        copy_tool(_bin_sleep, os_path(bindir, testsleepB))
        copy_tool(os_path(testdir, "testsleepA.bin"), os_path(bindir, testsleepA + ".bin"))
        copy_tool(os_path(testdir, "testsleepB.bin"), os_path(bindir, testsleepB + ".bin"))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        os.makedirs(os_path(root, "/var/log/zza.log"))
        os.makedirs(os_path(root, "/var/log/zzb.log"))
        cmd = F"{systemctl} enable zza.service"
        sh____(cmd)
        cmd = F"{systemctl} enable zzb.service"
        sh____(cmd)
        #
        INITLOOPSLEEP = 1
        initsystemctl = systemctl
        initsystemctl += F" -c INITLOOPSLEEP={INITLOOPSLEEP}"
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = F"{initsystemctl} -1"
        init = background(cmd)
        time.sleep(INITLOOPSLEEP+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*INITLOOPSLEEP"))
        self.assertTrue(greps(top, testsleepA))
        self.assertTrue(greps(top, testsleepB))
        #
        cmd = F"{systemctl} show zza.service -p JournalFilePath"
        journal_a=output(cmd).strip().split("=", 1)[1]
        cmd = F"{systemctl} show zzb.service -p JournalFilePath"
        journal_b=output(cmd).strip().split("=", 1)[1]
        logg.info("journal zza = %s", journal_a)
        logg.info("journal zzb = %s", journal_b)
        time.sleep(1)
        self.assertTrue(os.path.exists(journal_a))
        self.assertTrue(os.path.exists(journal_b))
        out_a = open(journal_a).read()
        out_b = open(journal_b).read()
        self.assertTrue(greps(out_a, "running testsleepA"))
        self.assertTrue(greps(out_b, "running testsleepB"))
        self.assertFalse(greps(out_a, "running testsleepB"))
        self.assertFalse(greps(out_b, "running testsleepA"))
        log_a = root + "/var/log/zza.log"
        log_b = root + "/var/log/zzb.log"
        logg.info("log zza = %s", log_a)
        logg.info("log zzb = %s", log_b)
        self.assertTrue(os.path.exists(log_a))
        self.assertTrue(os.path.exists(log_b))
        #
        out_a = open(journal_a).read()
        out_b = open(journal_b).read()
        logg.info("out_a=%s", out_a.strip())
        logg.info("out_b=%s", out_b.strip())
        self.assertTrue(greps(out_a, "starts testsleepA"))
        self.assertTrue(greps(out_b, "starts testsleepB"))
        self.assertFalse(greps(out_a, "starts testsleepB"))
        self.assertFalse(greps(out_b, "starts testsleepA"))
        self.assertFalse(greps(out_a, "append"))
        self.assertFalse(greps(out_b, "append"))
        self.assertTrue(greps(out_a, "Is a directory"))
        self.assertTrue(greps(out_b, "Is a directory"))
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_25353_background_logfile_journal(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleepA = self.testname("sleepA")
        testsleepB = self.testname("sleepB")
        bindir = os_path(root, "/usr/bin")
        copy_tool(_bin_sleep, os_path(bindir, testsleepA))
        copy_tool(_bin_sleep, os_path(bindir, testsleepB))
        self.assertTrue(os.path.isfile("/bin/sh"))
        shell_file(os_path(testdir, "testsleepA.bin"), F"""
            #! /bin/sh
            echo starts testsleepA >&2
            echo running testsleepA
            exec {bindir}/{testsleepA} "$@"
            """)
        shell_file(os_path(testdir, "testsleepB.bin"), F"""
            #! /bin/sh
            echo starts testsleepB >&2
            echo running testsleepB
            exec {bindir}/{testsleepB} "$@"
            """)
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepA}.bin 4
            StandardOutput=file:{root}/var/log/zza.log
            StandardError=journal
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepB}.bin 5
            StandardOutput=file:{root}/var/log/zzb.log
            StandardError=journal
            [Install]
            WantedBy=multi-user.target
            """)
        copy_tool(os_path(testdir, "testsleepA.bin"), os_path(bindir, testsleepA + ".bin"))
        copy_tool(os_path(testdir, "testsleepB.bin"), os_path(bindir, testsleepB + ".bin"))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        os.makedirs(os_path(root, "/var/log/zza.log"))
        os.makedirs(os_path(root, "/var/log/zzb.log"))
        cmd = F"{systemctl} enable zza.service"
        sh____(cmd)
        cmd = F"{systemctl} enable zzb.service"
        sh____(cmd)
        #
        INITLOOPSLEEP = 1
        initsystemctl = systemctl
        initsystemctl += F" -c INITLOOPSLEEP={INITLOOPSLEEP}"
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = F"{initsystemctl} -1"
        init = background(cmd)
        time.sleep(INITLOOPSLEEP+1)
        ##
        logdata = open(debug_log).read()
        logg.info("debug.log>>\n%s", oi22(logdata, maxlines=55))
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*INITLOOPSLEEP"))
        self.assertTrue(greps(top, testsleepA))
        self.assertTrue(greps(top, testsleepB))
        #
        cmd = F"{systemctl} show zza.service -p JournalFilePath"
        journal_a=output(cmd).strip().split("=", 1)[1]
        cmd = F"{systemctl} show zzb.service -p JournalFilePath"
        journal_b=output(cmd).strip().split("=", 1)[1]
        ##
        logg.info("journal zza = %s", journal_a)
        logg.info("journal zzb = %s", journal_b)
        time.sleep(1)
        self.assertTrue(os.path.exists(journal_a))
        self.assertTrue(os.path.exists(journal_b))
        out_a = open(journal_a).read()
        out_b = open(journal_b).read()
        self.assertTrue(greps(out_a, "starts testsleepA"))
        self.assertTrue(greps(out_b, "starts testsleepB"))
        self.assertFalse(greps(out_a, "starts testsleepB"))
        self.assertFalse(greps(out_b, "starts testsleepA"))
        log_a = root + "/var/log/zza.log"
        log_b = root + "/var/log/zzb.log"
        logg.info("log zza = %s", log_a)
        logg.info("log zzb = %s", log_b)
        self.assertTrue(os.path.exists(log_a))
        self.assertTrue(os.path.exists(log_b))
        #
        out_a = open(journal_a).read()
        out_b = open(journal_b).read()
        logg.info("out_a=%s", out_a.strip())
        logg.info("out_b=%s", out_b.strip())
        self.assertTrue(greps(out_a, "running testsleepA"))
        self.assertTrue(greps(out_b, "running testsleepB"))
        self.assertFalse(greps(out_a, "running testsleepB"))
        self.assertFalse(greps(out_b, "running testsleepA"))
        self.assertFalse(greps(out_a, "append"))
        self.assertFalse(greps(out_b, "append"))
        self.assertTrue(greps(out_a, "Is a directory"))
        self.assertTrue(greps(out_b, "Is a directory"))
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_25401_background_logfile_input(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        replyA = self.testname("replyA")
        replyB = self.testname("replyB")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} echo
            StandardOutput=file:{root}/var/log/zza.log
            StandardInput=file:{root}/var/log/zza.txt
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart={bindir}/{replyB} echo
            StandardOutput=file:{root}/var/log/zzb.log
            StandardInput=file:{root}/var/log/zzb.txt
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zza.txt"), """testing zzA""")
        text_file(os_path(testdir, "zzb.txt"), """testing zzB""")
        reply = reply_tool()
        copy_tool(reply, os_path(bindir, replyA))
        copy_tool(reply, os_path(bindir, replyB))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        copy_file(os_path(testdir, "zza.txt"), os_path(root, "/var/log/zza.txt"))
        copy_file(os_path(testdir, "zzb.txt"), os_path(root, "/var/log/zzb.txt"))
        cmd = F"{systemctl} enable zza.service"
        sh____(cmd)
        cmd = F"{systemctl} enable zzb.service"
        sh____(cmd)
        #
        INITLOOPSLEEP = 1
        initsystemctl = systemctl
        initsystemctl += F" -c INITLOOPSLEEP={INITLOOPSLEEP}"
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = F"{initsystemctl} -1"
        init = background(cmd)
        time.sleep(INITLOOPSLEEP+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*INITLOOPSLEEP"))
        #
        cmd = F"{systemctl} show zza.service -p JournalFilePath"
        journal_a=output(cmd).strip().split("=", 1)[1]
        cmd = F"{systemctl} show zzb.service -p JournalFilePath"
        journal_b=output(cmd).strip().split("=", 1)[1]
        logg.info("journal zza = %s", journal_a)
        logg.info("journal zzb = %s", journal_b)
        time.sleep(2)
        self.assertFalse(os.path.exists(journal_a))
        self.assertFalse(os.path.exists(journal_b))
        log_a = root + "/var/log/zza.log"
        log_b = root + "/var/log/zzb.log"
        logg.info("log zza = %s", log_a)
        logg.info("log zzb = %s", log_b)
        #
        out_a = open(log_a).read()
        out_b = open(log_b).read()
        logg.info("out_a=%s", out_a.strip())
        logg.info("out_b=%s", out_b.strip())
        self.assertTrue(greps(out_a, "TESTING ZZA"))
        self.assertTrue(greps(out_b, "TESTING ZZB"))
        self.assertFalse(greps(out_a, "TESTING ZZB"))
        self.assertFalse(greps(out_b, "TESTING ZZA"))
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_25408_background_logfile_input_noexistant(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        replyA = self.testname("replyA")
        replyB = self.testname("replyB")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} echo
            StandardOutput=file:{root}/var/log/zza.log
            StandardInput=file:{root}/var/log/zza-nothing.txt
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart={bindir}/{replyB} echo
            StandardOutput=file:{root}/var/log/zzb.log
            StandardInput=file:{root}/var/log/zzb.txt
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zza.txt"), """testing zzA""")
        text_file(os_path(testdir, "zzb.txt"), """testing zzB""")
        reply = reply_tool()
        copy_tool(reply, os_path(bindir, replyA))
        copy_tool(reply, os_path(bindir, replyB))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        copy_file(os_path(testdir, "zza.txt"), os_path(root, "/var/log/zza.txt"))
        copy_file(os_path(testdir, "zzb.txt"), os_path(root, "/var/log/zzb.txt"))
        cmd = F"{systemctl} enable zza.service"
        sh____(cmd)
        cmd = F"{systemctl} enable zzb.service"
        sh____(cmd)
        #
        INITLOOPSLEEP = 1
        initsystemctl = systemctl
        initsystemctl += F" -c INITLOOPSLEEP={INITLOOPSLEEP}"
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = F"{initsystemctl} -1"
        init = background(cmd)
        time.sleep(INITLOOPSLEEP+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*INITLOOPSLEEP"))
        #
        cmd = F"{systemctl} show zza.service -p JournalFilePath"
        journal_a=output(cmd).strip().split("=", 1)[1]
        cmd = F"{systemctl} show zzb.service -p JournalFilePath"
        journal_b=output(cmd).strip().split("=", 1)[1]
        logg.info("journal zza = %s", journal_a)
        logg.info("journal zzb = %s", journal_b)
        time.sleep(2)
        self.assertFalse(os.path.exists(journal_a))
        self.assertFalse(os.path.exists(journal_b))
        log_a = root + "/var/log/zza.log"
        log_b = root + "/var/log/zzb.log"
        logg.info("log zza = %s", log_a)
        logg.info("log zzb = %s", log_b)
        #
        out_a = open(log_a).read()
        out_b = open(log_b).read()
        logg.info("out_a=%s", out_a.strip())
        logg.info("out_b=%s", out_b.strip())
        self.assertFalse(greps(out_a, "TESTING ZZA"))
        self.assertTrue(greps(out_b, "TESTING ZZB"))
        self.assertFalse(greps(out_a, "TESTING ZZB"))
        self.assertFalse(greps(out_b, "TESTING ZZA"))
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_25409_background_logfile_input_noexistant(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        replyA = self.testname("replyA")
        replyB = self.testname("replyB")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} echo
            StandardOutput=file:{root}/var/log/zza.log
            StandardInput=syslog
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart={bindir}/{replyB} echo
            StandardOutput=file:{root}/var/log/zzb.log
            StandardInput=file:{root}/var/log/zzb.txt
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zza.txt"), """testing zzA""")
        text_file(os_path(testdir, "zzb.txt"), """testing zzB""")
        reply = reply_tool()
        copy_tool(reply, os_path(bindir, replyA))
        copy_tool(reply, os_path(bindir, replyB))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        copy_file(os_path(testdir, "zza.txt"), os_path(root, "/var/log/zza.txt"))
        copy_file(os_path(testdir, "zzb.txt"), os_path(root, "/var/log/zzb.txt"))
        cmd = F"{systemctl} enable zza.service"
        sh____(cmd)
        cmd = F"{systemctl} enable zzb.service"
        sh____(cmd)
        #
        INITLOOPSLEEP = 1
        initsystemctl = systemctl
        initsystemctl += F" -c INITLOOPSLEEP={INITLOOPSLEEP}"
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = F"{initsystemctl} -1"
        init = background(cmd)
        time.sleep(INITLOOPSLEEP+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*INITLOOPSLEEP"))
        #
        cmd = F"{systemctl} show zza.service -p JournalFilePath"
        journal_a=output(cmd).strip().split("=", 1)[1]
        cmd = F"{systemctl} show zzb.service -p JournalFilePath"
        journal_b=output(cmd).strip().split("=", 1)[1]
        logg.info("journal zza = %s", journal_a)
        logg.info("journal zzb = %s", journal_b)
        time.sleep(2)
        self.assertFalse(os.path.exists(journal_a))
        self.assertFalse(os.path.exists(journal_b))
        log_a = root + "/var/log/zza.log"
        log_b = root + "/var/log/zzb.log"
        logg.info("log zza = %s", log_a)
        logg.info("log zzb = %s", log_b)
        #
        out_a = open(log_a).read()
        out_b = open(log_b).read()
        logg.info("out_a=%s", out_a.strip())
        logg.info("out_b=%s", out_b.strip())
        self.assertFalse(greps(out_a, "TESTING ZZA"))
        self.assertTrue(greps(out_b, "TESTING ZZB"))
        self.assertFalse(greps(out_a, "TESTING ZZB"))
        self.assertFalse(greps(out_b, "TESTING ZZA"))
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_testdir()
        self.rm_killall()
        self.coverage()
        self.end()
    def real_26411_socket_accept(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} serverUNIX -f {sockfile}
            StandardOutput=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zza.socket"), F"""
            [Unit]
            Description=Testing B
            [Socket]
            Accept=yes
            ListenStream={sockfile}
            Service=zza.service
            [Install]
            WantedBy=multi-user.target
            """)
        reply = reply_tool()
        copy_tool(reply, os_path(bindir, replyA))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        cmd = F"{systemctl} enable zza.socket"
        sh____(cmd)
        #
        INITLOOPSLEEP = 1
        initsystemctl = systemctl
        initsystemctl += F" -c INITLOOPSLEEP={INITLOOPSLEEP}"
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = F"{initsystemctl} -1"
        init = background(cmd)
        time.sleep(INITLOOPSLEEP+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*INITLOOPSLEEP"))
        #
        oo = reads(debug_log.format(**locals())) # TODO
        logg.info("debug.log>>\n%s", oo)
        #
        cmd = F"{reply} sendUNIX -d foo -f {sockfile}"
        out, end = output2(cmd)
        self.assertEqual(end, 0)
        logg.info("send.log>>\n%s", out)
        self.assertTrue(greps(out, "request: foo"))
        self.assertTrue(greps(out, "replied: FOO"))
        #
        log = F"{root}/var/log/zza.log"
        out = reads(log)
        logg.info("zza.log>>%s", out)
        self.assertTrue(greps(out, "received:.*foo"))
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_26412_start_socket_accept(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} serverUNIX -f {sockfile}
            StandardOutput=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zza.socket"), F"""
            [Unit]
            Description=Testing B
            [Socket]
            Accept=yes
            ListenStream={sockfile}
            Service=zza.service
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zzc.service"), F"""
            [Unit]
            Description=Testing C
            [Service]
            Accept=yes
            ExecStart={root}/usr/bin/{testsleep} 5
            [Install]
            WantedBy=multi-user.target
            """)
        reply = reply_tool()
        copy_tool(reply, os_path(bindir, replyA))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        copy_file(os_path(testdir, "zzc.service"), os_path(root, "/etc/systemd/system/zzc.service"))
        cmd = F"{systemctl} enable zzc.service"
        sh____(cmd)
        #
        INITLOOPSLEEP = 1
        initsystemctl = systemctl
        initsystemctl += F" -c INITLOOPSLEEP={INITLOOPSLEEP}"
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = F"{initsystemctl} -1"
        init = background(cmd)
        time.sleep(INITLOOPSLEEP+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*INITLOOPSLEEP"))
        #
        oo = reads(debug_log.format(**locals()))  # TODO
        logg.info("debug.log>>\n%s", oo)
        #
        cmd = F"{reply} sendUNIX -d foo -f {sockfile}"
        out, end = output2(cmd)
        self.assertEqual(end, 0)
        logg.info("send.log>>\n%s", out)
        self.assertTrue(greps(out, "request: foo"))
        self.assertFalse(greps(out, "replied: FOO"))
        #
        cmd = F"{systemctl} start zza.socket -vvvv"
        sh____(cmd)
        #
        cmd = F"{reply} sendUNIX -d foo -f {sockfile}"
        out, end = output2(cmd)
        self.assertEqual(end, 0)
        logg.info("send.log>>\n%s", out)
        self.assertTrue(greps(out, "request: foo"))
        self.assertTrue(greps(out, "replied: FOO"))
        #
        log = F"{root}/var/log/zza.log"
        out = reads(log)
        logg.info("zza.log>>%s", out)
        self.assertTrue(greps(out, "received:.*foo"))
        #
        cmd = F"{systemctl} stop zza.socket -vvvv"
        sh____(cmd)
        #
        cmd = F"{reply} sendUNIX -d foo -f {sockfile}"
        out, end = output2(cmd)
        self.assertEqual(end, 0)
        logg.info("send.log>>\n%s", out)
        self.assertTrue(greps(out, "request: foo"))
        self.assertFalse(greps(out, "replied: FOO"))
        #
        ##################################################
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_26413_start_pre_socket_accept(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(root, "/var/run/zz.txt"), "zz")
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} serverUNIX -f {sockfile}
            StandardOutput=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zza.socket"), F"""
            [Unit]
            Description=Testing B
            [Socket]
            Accept=yes
            ListenStream={sockfile}
            Service=zza.service
            ExecStartPre=/usr/bin/touch {root}/var/run/zza.socket.pre.txt
            ExecStartPost=/usr/bin/touch {root}/var/run/zza.socket.post.txt
            ExecStopPost=/usr/bin/touch {root}/var/run/zza.socket.end.txt
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zzc.service"), F"""
            [Unit]
            Description=Testing C
            [Service]
            Accept=yes
            ExecStart={root}/usr/bin/{testsleep} 5
            [Install]
            WantedBy=multi-user.target
            """)
        reply = reply_tool()
        copy_tool(reply, os_path(bindir, replyA))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        copy_file(os_path(testdir, "zzc.service"), os_path(root, "/etc/systemd/system/zzc.service"))
        cmd = F"{systemctl} enable zzc.service"
        sh____(cmd)
        #
        INITLOOPSLEEP = 1
        initsystemctl = systemctl
        initsystemctl += F" -c INITLOOPSLEEP={INITLOOPSLEEP}"
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = F"{initsystemctl} -1"
        init = background(cmd)
        time.sleep(INITLOOPSLEEP+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*INITLOOPSLEEP"))
        #
        oo = reads(debug_log.format(**locals())) # TODO
        logg.info("debug.log>>\n%s", oo)
        #
        cmd = F"{reply} sendUNIX -d foo -f {sockfile}"
        out, end = output2(cmd)
        self.assertEqual(end, 0)
        logg.info("send.log>>\n%s", out)
        self.assertTrue(greps(out, "request: foo"))
        self.assertFalse(greps(out, "replied: FOO"))
        #
        zza_pre = os_path(root, "/var/run/zza.socket.pre.txt")
        zza_post = os_path(root, "/var/run/zza.socket.post.txt")
        zza_end = os_path(root, "/var/run/zza.socket.end.txt")
        self.assertFalse(os.path.exists(zza_pre))
        self.assertFalse(os.path.exists(zza_post))
        self.assertFalse(os.path.exists(zza_end))
        #
        cmd = F"{systemctl} start zza.socket -vvvv"
        sh____(cmd)
        self.assertTrue(os.path.exists(zza_pre))
        self.assertTrue(os.path.exists(zza_post))
        self.assertFalse(os.path.exists(zza_end))
        #
        cmd = F"{reply} sendUNIX -d foo -f {sockfile}"
        out, end = output2(cmd)
        self.assertEqual(end, 0)
        logg.info("send.log>>\n%s", out)
        self.assertTrue(greps(out, "request: foo"))
        self.assertTrue(greps(out, "replied: FOO"))
        #
        log = F"{root}/var/log/zza.log"
        out = reads(log)
        logg.info("zza.log>>%s", out)
        self.assertTrue(greps(out, "received:.*foo"))
        #
        cmd = F"{systemctl} stop zza.socket -vvvv"
        sh____(cmd)
        self.assertTrue(os.path.exists(zza_pre))
        self.assertTrue(os.path.exists(zza_post))
        self.assertTrue(os.path.exists(zza_end))
        #
        cmd = F"{reply} sendUNIX -d foo -f {sockfile}"
        out, end = output2(cmd)
        self.assertEqual(end, 0)
        logg.info("send.log>>\n%s", out)
        self.assertTrue(greps(out, "request: foo"))
        self.assertFalse(greps(out, "replied: FOO"))
        #
        ##################################################
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_26414_start_pre_enabled_socket_accept(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(root, "/var/run/zz.txt"), "zz")
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} serverUNIX -f {sockfile}
            StandardOutput=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zza.socket"), F"""
            [Unit]
            Description=Testing B
            [Socket]
            Accept=yes
            ListenStream={sockfile}
            Service=zza.service
            ExecStartPre=/usr/bin/touch {root}/var/run/zza.socket.pre.txt
            ExecStartPost=/usr/bin/touch {root}/var/run/zza.socket.post.txt
            ExecStopPost=/usr/bin/touch {root}/var/run/zza.socket.end.txt
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zzc.service"), F"""
            [Unit]
            Description=Testing C
            [Service]
            Accept=yes
            ExecStart={root}/usr/bin/{testsleep} 5
            [Install]
            WantedBy=multi-user.target
            """)
        reply = reply_tool()
        copy_tool(reply, os_path(bindir, replyA))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        copy_file(os_path(testdir, "zzc.service"), os_path(root, "/etc/systemd/system/zzc.service"))
        cmd = F"{systemctl} enable zza.socket"
        sh____(cmd)
        #
        INITLOOPSLEEP = 1
        initsystemctl = systemctl
        initsystemctl += F" -c INITLOOPSLEEP={INITLOOPSLEEP}"
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        sx____(F"ls -l {root}/var/run/zz*")
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = F"{initsystemctl} -1"
        init = background(cmd)
        time.sleep(INITLOOPSLEEP+1)
        #
        sx____(F"ls -l {root}/var/run/zz*")
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*INITLOOPSLEEP"))
        #
        oo = reads(debug_log.format(**locals()))  # TODO
        logg.info("debug.log>>\n%s", i2(oo))
        #
        sx____(F"ls -l {root}/var/run/zz*")
        zza_pre = os_path(root, "/var/run/zza.socket.pre.txt")
        zza_post = os_path(root, "/var/run/zza.socket.post.txt")
        zza_end = os_path(root, "/var/run/zza.socket.end.txt")
        self.assertTrue(os.path.exists(zza_pre))
        self.assertTrue(os.path.exists(zza_post))
        self.assertFalse(os.path.exists(zza_end))
        #
        cmd = F"{reply} sendUNIX -d foo -f {sockfile}"
        out, end = output2(cmd)
        self.assertEqual(end, 0)
        logg.info("send.log>>\n%s", out)
        self.assertTrue(greps(out, "request: foo"))
        self.assertTrue(greps(out, "replied: FOO"))
        #
        log = F"{root}/var/log/zza.log"
        out = reads(log)
        logg.info("zza.log>>%s", out)
        self.assertTrue(greps(out, "received:.*foo"))
        #
        cmd = F"{systemctl} stop zza.socket -vvvv"
        sh____(cmd)
        self.assertTrue(os.path.exists(zza_pre))
        self.assertTrue(os.path.exists(zza_post))
        self.assertTrue(os.path.exists(zza_end))
        #
        cmd = F"{reply} sendUNIX -d foo -f {sockfile}"
        out, end = output2(cmd)
        self.assertEqual(end, 0)
        logg.info("send.log>>\n%s", out)
        self.assertTrue(greps(out, "request: foo"))
        self.assertFalse(greps(out, "replied: FOO"))
        #
        ##################################################
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_26417_stop_post_socket_accept(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(root, "/var/run/zz.txt"), "zz")
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStartPre=/bin/false
            ExecStart={bindir}/{replyA} serverUNIX -f {sockfile}
            StandardOutput=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zza.socket"), F"""
            [Unit]
            Description=Testing B
            [Socket]
            Accept=yes
            ListenStream={sockfile}
            Service=zza.service
            ExecStartPre=/usr/bin/touch {root}/var/run/zza.socket.pre.txt
            ExecStartPost=/usr/bin/touch {root}/var/run/zza.socket.post.txt
            ExecStopPost=/usr/bin/touch {root}/var/run/zza.socket.end.txt
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zzc.service"), F"""
            [Unit]
            Description=Testing C
            [Service]
            Accept=yes
            ExecStart={root}/usr/bin/{testsleep} 5
            [Install]
            WantedBy=multi-user.target
            """)
        reply = reply_tool()
        copy_tool(reply, os_path(bindir, replyA))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        copy_file(os_path(testdir, "zzc.service"), os_path(root, "/etc/systemd/system/zzc.service"))
        cmd = F"{systemctl} enable zzc.service"
        sh____(cmd)
        #
        INITLOOPSLEEP = 1
        initsystemctl = systemctl
        initsystemctl += F" -c INITLOOPSLEEP={INITLOOPSLEEP}"
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = F"{initsystemctl} -1"
        init = background(cmd)
        time.sleep(INITLOOPSLEEP+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*INITLOOPSLEEP"))
        #
        oo = reads(debug_log.format(**locals())) # TODO
        logg.info("debug.log>>\n%s", oo)
        #
        cmd = F"{reply} sendUNIX -d foo -f {sockfile}"
        out, end = output2(cmd)
        self.assertEqual(end, 0)
        logg.info("send.log>>\n%s", out)
        self.assertTrue(greps(out, "request: foo"))
        self.assertFalse(greps(out, "replied: FOO"))
        #
        zza_pre = os_path(root, "/var/run/zza.socket.pre.txt")
        zza_post = os_path(root, "/var/run/zza.socket.post.txt")
        zza_end = os_path(root, "/var/run/zza.socket.end.txt")
        self.assertFalse(os.path.exists(zza_pre))
        self.assertFalse(os.path.exists(zza_post))
        self.assertFalse(os.path.exists(zza_end))
        #
        cmd = F"{systemctl} start zza.socket -vvvv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        self.assertTrue(os.path.exists(zza_pre))
        self.assertFalse(os.path.exists(zza_post))
        self.assertTrue(os.path.exists(zza_end))
        #
        cmd = F"{reply} sendUNIX -d foo -f {sockfile}"
        out, end = output2(cmd)
        self.assertEqual(end, 0)
        logg.info("send.log>>\n%s", out)
        self.assertTrue(greps(out, "request: foo"))
        self.assertFalse(greps(out, "replied: FOO"))
        #
        cmd = F"{systemctl} stop zza.socket -vvvv"
        sh____(cmd)
        self.assertTrue(os.path.exists(zza_pre))
        self.assertFalse(os.path.exists(zza_post))
        self.assertTrue(os.path.exists(zza_end))
        #
        ##################################################
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_26418_stop_post_enabled_socket_accept(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(root, "/var/run/zz.txt"), "zz")
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStartPre=/bin/false
            ExecStart={bindir}/{replyA} serverUNIX -f {sockfile}
            StandardOutput=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zza.socket"), F"""
            [Unit]
            Description=Testing B
            [Socket]
            Accept=yes
            ListenStream={sockfile}
            Service=zza.service
            ExecStartPre=/usr/bin/touch {root}/var/run/zza.socket.pre.txt
            ExecStartPost=/usr/bin/touch {root}/var/run/zza.socket.post.txt
            ExecStopPost=/usr/bin/touch {root}/var/run/zza.socket.end.txt
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zzc.service"), F"""
            [Unit]
            Description=Testing C
            [Service]
            Accept=yes
            ExecStart={root}/usr/bin/{testsleep} 5
            [Install]
            WantedBy=multi-user.target
            """)
        reply = reply_tool()
        copy_tool(reply, os_path(bindir, replyA))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        copy_file(os_path(testdir, "zzc.service"), os_path(root, "/etc/systemd/system/zzc.service"))
        cmd = F"{systemctl} enable zza.socket"
        sh____(cmd)
        #
        INITLOOPSLEEP = 1
        initsystemctl = systemctl
        initsystemctl += F" -c INITLOOPSLEEP={INITLOOPSLEEP}"
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = F"{initsystemctl} -1"
        init = background(cmd)
        time.sleep(INITLOOPSLEEP+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*INITLOOPSLEEP"))
        #
        oo = reads(debug_log.format(**locals())) # TODO
        logg.info("debug.log>>\n%s", oo)
        #
        zza_pre = os_path(root, "/var/run/zza.socket.pre.txt")
        zza_post = os_path(root, "/var/run/zza.socket.post.txt")
        zza_end = os_path(root, "/var/run/zza.socket.end.txt")
        self.assertTrue(os.path.exists(zza_pre))
        if not COVERAGE:
            self.assertFalse(os.path.exists(zza_post))
            self.assertTrue(os.path.exists(zza_end))
        #
        cmd = F"{reply} sendUNIX -d foo -f {sockfile}"
        out, end = output2(cmd)
        self.assertEqual(end, 0)
        logg.info("send.log>>\n%s", out)
        self.assertTrue(greps(out, "request: foo"))
        if not COVERAGE:
            self.assertFalse(greps(out, "replied: FOO"))
        #
        cmd = F"{systemctl} stop zza.socket -vvvv"
        sh____(cmd)
        self.assertTrue(os.path.exists(zza_pre))
        if not COVERAGE:
            self.assertFalse(os.path.exists(zza_post))
            self.assertTrue(os.path.exists(zza_end))
        #
        ##################################################
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_26421_chown_user_socket_accept(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        this_user=get_USER()
        text_file(os_path(root, "/var/run/zz.txt"), "zz")
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} serverUNIX -f {sockfile}
            StandardOutput=file:{root}/var/log/zza.log
            # ExecStartPre=/usr/bin/touch {root}/var/run/zza.service.pre.txt
            # ExecStartPost=/usr/bin/touch {root}/var/run/zza.service.post.txt
            # ExecStopPost=/usr/bin/touch {root}/var/run/zza.service.end.txt
            # User={this_user}
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zza.socket"), F"""
            [Unit]
            Description=Testing B
            [Socket]
            Accept=yes
            ListenStream={sockfile}
            SocketUser={this_user}
            Service=zza.service
            ExecStartPre=/usr/bin/touch {root}/var/run/zza.socket.pre.txt
            ExecStartPost=/usr/bin/touch {root}/var/run/zza.socket.post.txt
            ExecStopPost=/usr/bin/touch {root}/var/run/zza.socket.end.txt
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zzc.service"), F"""
            [Unit]
            Description=Testing C
            [Service]
            Accept=yes
            ExecStart={root}/usr/bin/{testsleep} 5
            [Install]
            WantedBy=multi-user.target
            """)
        reply = reply_tool()
        copy_tool(reply, os_path(bindir, replyA))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        copy_file(os_path(testdir, "zzc.service"), os_path(root, "/etc/systemd/system/zzc.service"))
        cmd = F"{systemctl} enable zzc.service"
        sh____(cmd)
        #
        INITLOOPSLEEP = 1
        initsystemctl = systemctl
        initsystemctl += F" -c INITLOOPSLEEP={INITLOOPSLEEP}"
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = F"{initsystemctl} -1"
        init = background(cmd)
        time.sleep(INITLOOPSLEEP+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*INITLOOPSLEEP"))
        #
        oo = reads(debug_log.format(**locals())) # TODO
        logg.info("debug.log>>\n%s", oo)
        #
        cmd = F"{reply} sendUNIX -d foo -f {sockfile}"
        out, end = output2(cmd)
        self.assertEqual(end, 0)
        logg.info("send.log>>\n%s", out)
        self.assertTrue(greps(out, "request: foo"))
        self.assertFalse(greps(out, "replied: FOO"))
        #
        zza_pre = os_path(root, "/var/run/zza.socket.pre.txt")
        zza_post = os_path(root, "/var/run/zza.socket.post.txt")
        zza_end = os_path(root, "/var/run/zza.socket.end.txt")
        self.assertFalse(os.path.exists(zza_pre))
        self.assertFalse(os.path.exists(zza_post))
        self.assertFalse(os.path.exists(zza_end))
        #
        cmd = F"{systemctl} start zza.socket -vvvv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(os.path.exists(zza_pre))
        self.assertTrue(os.path.exists(zza_post))
        self.assertFalse(os.path.exists(zza_end))
        #
        cmd = F"{reply} sendUNIX -d foo -f {sockfile}"
        out, end = output2(cmd)
        self.assertEqual(end, 0)
        logg.info("send.log>>\n%s", out)
        self.assertTrue(greps(out, "request: foo"))
        self.assertTrue(greps(out, "replied: FOO"))
        #
        cmd = F"{systemctl} stop zza.socket -vvvv"
        sh____(cmd)
        self.assertTrue(os.path.exists(zza_pre))
        self.assertTrue(os.path.exists(zza_post))
        self.assertTrue(os.path.exists(zza_end))
        #
        ##################################################
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_26422_chown_user_group_socket_accept(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        this_user=get_USER()
        this_group=get_GROUP()
        text_file(os_path(root, "/var/run/zz.txt"), "zz")
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} serverUNIX -f {sockfile}
            StandardOutput=file:{root}/var/log/zza.log
            # ExecStartPre=/usr/bin/touch {root}/var/run/zza.service.pre.txt
            # ExecStartPost=/usr/bin/touch {root}/var/run/zza.service.post.txt
            # ExecStopPost=/usr/bin/touch {root}/var/run/zza.service.end.txt
            # User={this_user}
            # Group={this_group}
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zza.socket"), F"""
            [Unit]
            Description=Testing B
            [Socket]
            Accept=yes
            ListenStream={sockfile}
            SocketUser={this_user}
            SocketGroup={this_group}
            Service=zza.service
            ExecStartPre=/usr/bin/touch {root}/var/run/zza.socket.pre.txt
            ExecStartPost=/usr/bin/touch {root}/var/run/zza.socket.post.txt
            ExecStopPost=/usr/bin/touch {root}/var/run/zza.socket.end.txt
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zzc.service"), F"""
            [Unit]
            Description=Testing C
            [Service]
            Accept=yes
            ExecStart={root}/usr/bin/{testsleep} 5
            [Install]
            WantedBy=multi-user.target
            """)
        reply = reply_tool()
        copy_tool(reply, os_path(bindir, replyA))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        copy_file(os_path(testdir, "zzc.service"), os_path(root, "/etc/systemd/system/zzc.service"))
        cmd = F"{systemctl} enable zzc.service"
        sh____(cmd)
        #
        INITLOOPSLEEP = 1
        initsystemctl = systemctl
        initsystemctl += F" -c INITLOOPSLEEP={INITLOOPSLEEP}"
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = F"{initsystemctl} -1"
        init = background(cmd)
        time.sleep(INITLOOPSLEEP+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*INITLOOPSLEEP"))
        #
        oo = reads(debug_log.format(**locals())) # TODO
        logg.info("debug.log>>\n%s", oo)
        #
        cmd = F"{reply} sendUNIX -d foo -f {sockfile}"
        out, end = output2(cmd)
        self.assertEqual(end, 0)
        logg.info("send.log>>\n%s", out)
        self.assertTrue(greps(out, "request: foo"))
        self.assertFalse(greps(out, "replied: FOO"))
        #
        zza_pre = os_path(root, "/var/run/zza.socket.pre.txt")
        zza_post = os_path(root, "/var/run/zza.socket.post.txt")
        zza_end = os_path(root, "/var/run/zza.socket.end.txt")
        self.assertFalse(os.path.exists(zza_pre))
        self.assertFalse(os.path.exists(zza_post))
        self.assertFalse(os.path.exists(zza_end))
        #
        cmd = F"{systemctl} start zza.socket -vvvv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(os.path.exists(zza_pre))
        self.assertTrue(os.path.exists(zza_post))
        self.assertFalse(os.path.exists(zza_end))
        #
        cmd = F"{reply} sendUNIX -d foo -f {sockfile}"
        out, end = output2(cmd)
        self.assertEqual(end, 0)
        logg.info("send.log>>\n%s", out)
        self.assertTrue(greps(out, "request: foo"))
        self.assertTrue(greps(out, "replied: FOO"))
        #
        cmd = F"{systemctl} stop zza.socket -vvvv"
        sh____(cmd)
        self.assertTrue(os.path.exists(zza_pre))
        self.assertTrue(os.path.exists(zza_post))
        self.assertTrue(os.path.exists(zza_end))
        #
        ##################################################
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_26423_chown_group_socket_accept(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        testsleep = self.testname("sleep")
        this_group=get_GROUP()
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(root, "/var/run/zz.txt"), "zz")
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} serverUNIX -f {sockfile}
            StandardOutput=file:{root}/var/log/zza.log
            # ExecStartPre=/usr/bin/touch {root}/var/run/zza.service.pre.txt
            # ExecStartPost=/usr/bin/touch {root}/var/run/zza.service.post.txt
            # ExecStopPost=/usr/bin/touch {root}/var/run/zza.service.end.txt
            Group={this_group}
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zza.socket"), F"""
            [Unit]
            Description=Testing B
            [Socket]
            Accept=yes
            ListenStream={sockfile}
            SocketGroup={this_group}
            Service=zza.service
            ExecStartPre=/usr/bin/touch {root}/var/run/zza.socket.pre.txt
            ExecStartPost=/usr/bin/touch {root}/var/run/zza.socket.post.txt
            ExecStopPost=/usr/bin/touch {root}/var/run/zza.socket.end.txt
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zzc.service"), F"""
            [Unit]
            Description=Testing C
            [Service]
            Accept=yes
            ExecStart={root}/usr/bin/{testsleep} 5
            [Install]
            WantedBy=multi-user.target
            """)
        reply = reply_tool()
        copy_tool(reply, os_path(bindir, replyA))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        copy_file(os_path(testdir, "zzc.service"), os_path(root, "/etc/systemd/system/zzc.service"))
        cmd = F"{systemctl} enable zzc.service"
        sh____(cmd)
        #
        INITLOOPSLEEP = 1
        initsystemctl = systemctl
        initsystemctl += F" -c INITLOOPSLEEP={INITLOOPSLEEP}"
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = F"{initsystemctl} -1"
        init = background(cmd)
        time.sleep(INITLOOPSLEEP+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*INITLOOPSLEEP"))
        #
        oo = reads(debug_log.format(**locals())) # TODO
        logg.info("debug.log>>\n%s", oo)
        #
        cmd = F"{reply} sendUNIX -d foo -f {sockfile}"
        out, end = output2(cmd)
        self.assertEqual(end, 0)
        logg.info("send.log>>\n%s", out)
        self.assertTrue(greps(out, "request: foo"))
        self.assertFalse(greps(out, "replied: FOO"))
        #
        zza_pre = os_path(root, "/var/run/zza.socket.pre.txt")
        zza_post = os_path(root, "/var/run/zza.socket.post.txt")
        zza_end = os_path(root, "/var/run/zza.socket.end.txt")
        self.assertFalse(os.path.exists(zza_pre))
        self.assertFalse(os.path.exists(zza_post))
        self.assertFalse(os.path.exists(zza_end))
        #
        cmd = F"{systemctl} start zza.socket -vvvv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(os.path.exists(zza_pre))
        self.assertTrue(os.path.exists(zza_post))
        self.assertFalse(os.path.exists(zza_end))
        #
        cmd = F"{reply} sendUNIX -d foo -f {sockfile}"
        out, end = output2(cmd)
        self.assertEqual(end, 0)
        logg.info("send.log>>\n%s", out)
        self.assertTrue(greps(out, "request: foo"))
        self.assertTrue(greps(out, "replied: FOO"))
        #
        cmd = F"{systemctl} stop zza.socket -vvvv"
        sh____(cmd)
        self.assertTrue(os.path.exists(zza_pre))
        self.assertTrue(os.path.exists(zza_post))
        self.assertTrue(os.path.exists(zza_end))
        #
        ##################################################
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_26426_chown_user_enabled_socket_accept(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        this_user=get_USER()
        text_file(os_path(root, "/var/run/zz.txt"), "zz")
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} serverUNIX -f {sockfile}
            StandardOutput=file:{root}/var/log/zza.log
            # ExecStartPre=/usr/bin/touch {root}/var/run/zza.service.pre.txt
            # ExecStartPost=/usr/bin/touch {root}/var/run/zza.service.post.txt
            # ExecStopPost=/usr/bin/touch {root}/var/run/zza.service.end.txt
            # User={this_user}
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zza.socket"), F"""
            [Unit]
            Description=Testing B
            [Socket]
            Accept=yes
            ListenStream={sockfile}
            SocketUser={this_user}
            Service=zza.service
            ExecStartPre=/usr/bin/touch {root}/var/run/zza.socket.pre.txt
            ExecStartPost=/usr/bin/touch {root}/var/run/zza.socket.post.txt
            ExecStopPost=/usr/bin/touch {root}/var/run/zza.socket.end.txt
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zzc.service"), F"""
            [Unit]
            Description=Testing C
            [Service]
            Accept=yes
            ExecStart={root}/usr/bin/{testsleep} 5
            [Install]
            WantedBy=multi-user.target
            """)
        reply = reply_tool()
        copy_tool(reply, os_path(bindir, replyA))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        copy_file(os_path(testdir, "zzc.service"), os_path(root, "/etc/systemd/system/zzc.service"))
        cmd = F"{systemctl} enable zza.socket"
        sh____(cmd)
        #
        INITLOOPSLEEP = 1
        initsystemctl = systemctl
        initsystemctl += F" -c INITLOOPSLEEP={INITLOOPSLEEP}"
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = F"{initsystemctl} -1"
        init = background(cmd)
        time.sleep(INITLOOPSLEEP+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*INITLOOPSLEEP"))
        #
        oo = reads(debug_log.format(**locals())) # TODO
        logg.info("debug.log>>\n%s", oo)
        #
        zza_pre = os_path(root, "/var/run/zza.socket.pre.txt")
        zza_post = os_path(root, "/var/run/zza.socket.post.txt")
        zza_end = os_path(root, "/var/run/zza.socket.end.txt")
        self.assertTrue(os.path.exists(zza_pre))
        self.assertTrue(os.path.exists(zza_post))
        self.assertFalse(os.path.exists(zza_end))
        #
        cmd = F"{reply} sendUNIX -d foo -f {sockfile}"
        out, end = output2(cmd)
        self.assertEqual(end, 0)
        logg.info("send.log>>\n%s", out)
        self.assertTrue(greps(out, "request: foo"))
        self.assertTrue(greps(out, "replied: FOO"))
        #
        cmd = F"{systemctl} stop zza.socket -vvvv"
        sh____(cmd)
        self.assertTrue(os.path.exists(zza_pre))
        self.assertTrue(os.path.exists(zza_post))
        self.assertTrue(os.path.exists(zza_end))
        #
        ##################################################
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_26427_chown_user_group_enabled_socket_accept(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        this_user=get_USER()
        this_group=get_GROUP()
        text_file(os_path(root, "/var/run/zz.txt"), "zz")
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} serverUNIX -f {sockfile}
            StandardOutput=file:{root}/var/log/zza.log
            # ExecStartPre=/usr/bin/touch {root}/var/run/zza.service.pre.txt
            # ExecStartPost=/usr/bin/touch {root}/var/run/zza.service.post.txt
            # ExecStopPost=/usr/bin/touch {root}/var/run/zza.service.end.txt
            # User={this_user}
            # Group={this_group}
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zza.socket"), F"""
            [Unit]
            Description=Testing B
            [Socket]
            Accept=yes
            ListenStream={sockfile}
            SocketUser={this_user}
            SocketGroup={this_group}
            Service=zza.service
            ExecStartPre=/usr/bin/touch {root}/var/run/zza.socket.pre.txt
            ExecStartPost=/usr/bin/touch {root}/var/run/zza.socket.post.txt
            ExecStopPost=/usr/bin/touch {root}/var/run/zza.socket.end.txt
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zzc.service"), F"""
            [Unit]
            Description=Testing C
            [Service]
            Accept=yes
            ExecStart={root}/usr/bin/{testsleep} 5
            [Install]
            WantedBy=multi-user.target
            """)
        reply = reply_tool()
        copy_tool(reply, os_path(bindir, replyA))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        copy_file(os_path(testdir, "zzc.service"), os_path(root, "/etc/systemd/system/zzc.service"))
        cmd = F"{systemctl} enable zza.socket"
        sh____(cmd)
        #
        INITLOOPSLEEP = 1
        initsystemctl = systemctl
        initsystemctl += F" -c INITLOOPSLEEP={INITLOOPSLEEP}"
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = F"{initsystemctl} -1"
        init = background(cmd)
        time.sleep(INITLOOPSLEEP+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*INITLOOPSLEEP"))
        #
        oo = reads(debug_log.format(**locals())) # TODO
        logg.info("debug.log>>\n%s", oo)
        #
        zza_pre = os_path(root, "/var/run/zza.socket.pre.txt")
        zza_post = os_path(root, "/var/run/zza.socket.post.txt")
        zza_end = os_path(root, "/var/run/zza.socket.end.txt")
        self.assertTrue(os.path.exists(zza_pre))
        self.assertTrue(os.path.exists(zza_post))
        self.assertFalse(os.path.exists(zza_end))
        #
        cmd = F"{reply} sendUNIX -d foo -f {sockfile}"
        out, end = output2(cmd)
        self.assertEqual(end, 0)
        logg.info("send.log>>\n%s", out)
        self.assertTrue(greps(out, "request: foo"))
        self.assertTrue(greps(out, "replied: FOO"))
        #
        cmd = F"{systemctl} stop zza.socket -vvvv"
        sh____(cmd)
        self.assertTrue(os.path.exists(zza_pre))
        self.assertTrue(os.path.exists(zza_post))
        self.assertTrue(os.path.exists(zza_end))
        #
        ##################################################
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_26428_chown_group_enabled_socket_accept(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        this_group=get_GROUP()
        text_file(os_path(root, "/var/run/zz.txt"), "zz")
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} serverUNIX -f {sockfile}
            StandardOutput=file:{root}/var/log/zza.log
            # ExecStartPre=/usr/bin/touch {root}/var/run/zza.service.pre.txt
            # ExecStartPost=/usr/bin/touch {root}/var/run/zza.service.post.txt
            # ExecStopPost=/usr/bin/touch {root}/var/run/zza.service.end.txt
            Group={this_group}
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zza.socket"), F"""
            [Unit]
            Description=Testing B
            [Socket]
            Accept=yes
            ListenStream={sockfile}
            SocketGroup={this_group}
            Service=zza.service
            ExecStartPre=/usr/bin/touch {root}/var/run/zza.socket.pre.txt
            ExecStartPost=/usr/bin/touch {root}/var/run/zza.socket.post.txt
            ExecStopPost=/usr/bin/touch {root}/var/run/zza.socket.end.txt
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zzc.service"), F"""
            [Unit]
            Description=Testing C
            [Service]
            Accept=yes
            ExecStart={root}/usr/bin/{testsleep} 5
            [Install]
            WantedBy=multi-user.target
            """)
        reply = reply_tool()
        copy_tool(reply, os_path(bindir, replyA))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        copy_file(os_path(testdir, "zzc.service"), os_path(root, "/etc/systemd/system/zzc.service"))
        cmd = F"{systemctl} enable zza.socket"
        sh____(cmd)
        #
        INITLOOPSLEEP = 1
        initsystemctl = systemctl
        initsystemctl += F" -c INITLOOPSLEEP={INITLOOPSLEEP}"
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = F"{initsystemctl} -1"
        init = background(cmd)
        time.sleep(INITLOOPSLEEP+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*INITLOOPSLEEP"))
        #
        oo = reads(debug_log.format(**locals())) # TODO
        logg.info("debug.log>>\n%s", oo)
        #
        zza_pre = os_path(root, "/var/run/zza.socket.pre.txt")
        zza_post = os_path(root, "/var/run/zza.socket.post.txt")
        zza_end = os_path(root, "/var/run/zza.socket.end.txt")
        self.assertTrue(os.path.exists(zza_pre))
        self.assertTrue(os.path.exists(zza_post))
        self.assertFalse(os.path.exists(zza_end))
        #
        cmd = F"{reply} sendUNIX -d foo -f {sockfile}"
        out, end = output2(cmd)
        self.assertEqual(end, 0)
        logg.info("send.log>>\n%s", out)
        self.assertTrue(greps(out, "request: foo"))
        self.assertTrue(greps(out, "replied: FOO"))
        #
        cmd = F"{systemctl} stop zza.socket -vvvv"
        sh____(cmd)
        self.assertTrue(os.path.exists(zza_pre))
        self.assertTrue(os.path.exists(zza_post))
        self.assertTrue(os.path.exists(zza_end))
        #
        ##################################################
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_26511_unix_socket_accept(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        replyB = self.testname("replyB")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} serverUNIX -f {sockfile}
            StandardOutput=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zza.socket"), F"""
            [Unit]
            Description=Testing B
            [Socket]
            Accept=yes
            ListenStream={sockfile}
            Service=zza.service
            [Install]
            WantedBy=multi-user.target
            """)
        reply = reply_tool()
        copy_tool(reply, os_path(bindir, replyA))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        cmd = F"{systemctl} enable zza.socket"
        sh____(cmd)
        #
        INITLOOPSLEEP = 1
        initsystemctl = systemctl
        initsystemctl += F" -c INITLOOPSLEEP={INITLOOPSLEEP}"
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = F"{initsystemctl} listen zza.socket"
        init = background(cmd)
        time.sleep(INITLOOPSLEEP+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*listen"))
        #
        cmd = F"{reply} sendUNIX -d foo -f {sockfile}"
        out, end = output2(cmd)
        self.assertEqual(end, 0)
        logg.info("send.log>>\n%s", out)
        self.assertTrue(greps(out, "request: foo"))
        self.assertTrue(greps(out, "replied: FOO"))
        log = F"{root}/var/log/zza.log"
        out = reads(log)
        logg.info("zza.log>>\n%s", out)
        self.assertTrue(greps(out, "received:.*foo"))
        #
        logg.info("kill daemon at %s", init.pid)
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_26512_unix_socket_listen(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        replyB = self.testname("replyB")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} serverUNIX -f {sockfile}
            StandardOutput=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zza.socket"), F"""
            [Unit]
            Description=Testing B
            [Socket]
            ListenStream={sockfile}
            Service=zza.service
            [Install]
            WantedBy=multi-user.target
            """)
        reply = reply_tool()
        copy_tool(reply, os_path(bindir, replyA))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        cmd = F"{systemctl} enable zza.socket"
        sh____(cmd)
        #
        INITLOOPSLEEP = 1
        initsystemctl = systemctl
        initsystemctl += F" -c INITLOOPSLEEP={INITLOOPSLEEP}"
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = F"{initsystemctl} listen zza.socket -c TESTING_LISTEN -c TESTING_ACCEPT"
        init = background(cmd)
        time.sleep(INITLOOPSLEEP+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*listen"))
        #
        cmd = F"{reply} sendUNIX -d foo -f {sockfile}"
        out, end = output2(cmd)
        # self.assertEqual(end, 0) # FIXME
        logg.info("send.log>>\n%s", out)
        self.assertTrue(greps(out, "request: foo"))
        # self.assertTrue(greps(out, "replied: FOO")) # FIXME
        self.assertTrue(greps(out, "replied: ERROR: FOO"))
        ### log = F"{root}/var/log/zza.log"
        ### out = open(log).read()
        ### logg.info("zza.log>>\n%s", out)
        # self.assertTrue(greps(out, "received:.*foo")) # FIXME
        #
        logg.info("kill daemon at %s", init.pid)
        if TESTING_LISTEN:
            self.assertTrue(self.kill(init.pid))
        elif not self.kill(init.pid):
            self.kill(init.pid, sig = signal.SIGKILL)
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_26513_unix_socket_listen_user_group(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        this_user=get_USER()
        this_group=get_GROUP()
        logfile = os_path(root, "/var/log/"+testname+".log")
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        replyB = self.testname("replyB")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} serverUNIX -f {sockfile}
            StandardOutput=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zza.socket"), F"""
            [Unit]
            Description=Testing B
            [Socket]
            ListenStream={sockfile}
            SocketUser={this_user}
            SocketGroup={this_group}
            Service=zza.service
            [Install]
            WantedBy=multi-user.target
            """)
        reply = reply_tool()
        copy_tool(reply, os_path(bindir, replyA))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        cmd = F"{systemctl} enable zza.socket"
        sh____(cmd)
        #
        INITLOOPSLEEP = 1
        initsystemctl = systemctl
        initsystemctl += F" -c INITLOOPSLEEP={INITLOOPSLEEP}"
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = F"{initsystemctl} listen zza.socket -c TESTING_LISTEN -c TESTING_ACCEPT"
        init = background(cmd)
        time.sleep(INITLOOPSLEEP+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*listen"))
        #
        cmd = F"{reply} sendUNIX -d foo -f {sockfile}"
        out, end = output2(cmd)
        # self.assertEqual(end, 0) # FIXME
        logg.info("send.log>>\n%s", out)
        self.assertTrue(greps(out, "request: foo"))
        # self.assertTrue(greps(out, "replied: FOO")) # FIXME
        self.assertTrue(greps(out, "replied: ERROR: FOO"))
        ### log = F"{root}/var/log/zza.log"
        ### out = open(log).read()
        ### logg.info("zza.log>>\n%s", out)
        # self.assertTrue(greps(out, "received:.*foo")) # FIXME
        #
        logg.info("kill daemon at %s", init.pid)
        if TESTING_LISTEN:
            self.assertTrue(self.kill(init.pid))
        elif not self.kill(init.pid):
            self.kill(init.pid, sig = signal.SIGKILL)

        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_26514_unix_socket_listen_group(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        this_user=get_USER()
        this_group=get_GROUP()
        logfile = os_path(root, "/var/log/"+testname+".log")
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        replyB = self.testname("replyB")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} serverUNIX -f {sockfile}
            StandardOutput=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zza.socket"), F"""
            [Unit]
            Description=Testing B
            [Socket]
            ListenStream={sockfile}
            # SocketUser={this_user}
            SocketGroup={this_group}
            Service=zza.service
            [Install]
            WantedBy=multi-user.target
            """)
        reply = reply_tool()
        copy_tool(reply, os_path(bindir, replyA))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        cmd = F"{systemctl} enable zza.socket"
        sh____(cmd)
        #
        INITLOOPSLEEP = 1
        initsystemctl = systemctl
        initsystemctl += F" -c INITLOOPSLEEP={INITLOOPSLEEP}"
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = F"{initsystemctl} listen zza.socket -c TESTING_LISTEN -c TESTING_ACCEPT"
        init = background(cmd)
        time.sleep(INITLOOPSLEEP+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*listen"))
        #
        cmd = F"{reply} sendUNIX -d foo -f {sockfile}"
        out, end = output2(cmd)
        # self.assertEqual(end, 0) # FIXME
        logg.info("send.log>>\n%s", out)
        self.assertTrue(greps(out, "request: foo"))
        # self.assertTrue(greps(out, "replied: FOO")) # FIXME
        self.assertTrue(greps(out, "replied: ERROR: FOO"))
        ### log = F"{root}/var/log/zza.log"
        ### out = open(log).read()
        ### logg.info("zza.log>>\n%s", out)
        # self.assertTrue(greps(out, "received:.*foo")) # FIXME
        #
        logg.info("kill daemon at %s", init.pid)
        if TESTING_LISTEN:
            self.assertTrue(self.kill(init.pid))
        elif not self.kill(init.pid):
            self.kill(init.pid, sig = signal.SIGKILL)

        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_26515_unix_socket_listen_user(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        this_user=get_USER()
        this_group=get_GROUP()
        logfile = os_path(root, "/var/log/"+testname+".log")
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        replyB = self.testname("replyB")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} serverUNIX -f {sockfile}
            StandardOutput=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zza.socket"), F"""
            [Unit]
            Description=Testing B
            [Socket]
            ListenStream={sockfile}
            SocketUser={this_user}
            # SocketGroup={this_group}
            Service=zza.service
            [Install]
            WantedBy=multi-user.target
            """)
        reply = reply_tool()
        copy_tool(reply, os_path(bindir, replyA))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        cmd = F"{systemctl} enable zza.socket"
        sh____(cmd)
        #
        INITLOOPSLEEP = 1
        initsystemctl = systemctl
        initsystemctl += F" -c INITLOOPSLEEP={INITLOOPSLEEP}"
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = F"{initsystemctl} listen zza.socket -c TESTING_LISTEN -c TESTING_ACCEPT"
        init = background(cmd)
        time.sleep(INITLOOPSLEEP+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*listen"))
        #
        cmd = F"{reply} sendUNIX -d foo -f {sockfile}"
        out, end = output2(cmd)
        # self.assertEqual(end, 0) # FIXME
        logg.info("send.log>>\n%s", out)
        self.assertTrue(greps(out, "request: foo"))
        # self.assertTrue(greps(out, "replied: FOO")) # FIXME
        self.assertTrue(greps(out, "replied: ERROR: FOO"))
        ### log = F"{root}/var/log/zza.log"
        ### out = open(log).read()
        ### logg.info("zza.log>>\n%s", out)
        # self.assertTrue(greps(out, "received:.*foo")) # FIXME
        #
        logg.info("kill daemon at %s", init.pid)
        if TESTING_LISTEN:
            self.assertTrue(self.kill(init.pid))
        elif not self.kill(init.pid):
            self.kill(init.pid, sig = signal.SIGKILL)

        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_26516_unix_socket_listen_bad_pre(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        replyB = self.testname("replyB")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} serverUNIX -f {sockfile}
            StandardOutput=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zza.socket"), F"""
            [Unit]
            Description=Testing B
            [Socket]
            ExecStartPre=/bin/false
            ListenStream={sockfile}
            Service=zza.service
            [Install]
            WantedBy=multi-user.target
            """)
        reply = reply_tool()
        copy_tool(reply, os_path(bindir, replyA))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        cmd = F"{systemctl} enable zza.socket"
        sh____(cmd)
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        text_file(debug_log, "")
        #
        INITLOOPSLEEP = 1
        initsystemctl = systemctl
        initsystemctl += F" -c INITLOOPSLEEP={INITLOOPSLEEP}"
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = F"{initsystemctl} listen zza.socket -c TESTING_LISTEN -c TESTING_ACCEPT"
        init = background(cmd)
        time.sleep(INITLOOPSLEEP+1)
        #
        log = reads(debug_log)
        logg.info("systemctl.debug.log:\n%s", i2(log))
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, "systemctl.*listen"))
        #
        # no reply
        #
        logg.info("kill daemon at %s", init.pid)
        if TESTING_LISTEN:
            self.assertTrue(self.kill(init.pid))
        elif not self.kill(init.pid):
            self.kill(init.pid, sig = signal.SIGKILL)

        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_26517_unix_socket_listen_bad_post(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        replyB = self.testname("replyB")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} serverUNIX -f {sockfile}
            StandardOutput=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zza.socket"), F"""
            [Unit]
            Description=Testing B
            [Socket]
            ExecStartPost=/bin/false
            ListenStream={sockfile}
            Service=zza.service
            [Install]
            WantedBy=multi-user.target
            """)
        reply = reply_tool()
        copy_tool(reply, os_path(bindir, replyA))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        cmd = F"{systemctl} enable zza.socket"
        sh____(cmd)
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        text_file(debug_log, "")
        #
        INITLOOPSLEEP = 1
        initsystemctl = systemctl
        initsystemctl += F" -c INITLOOPSLEEP={INITLOOPSLEEP}"
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = F"{initsystemctl} listen zza.socket -c TESTING_LISTEN -c TESTING_ACCEPT"
        init = background(cmd)
        time.sleep(INITLOOPSLEEP+1)
        #
        log = reads(debug_log)
        logg.info("systemctl.debug.log:\n%s", i2(log))
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*listen"))
        #
        cmd = F"{reply} sendUNIX -d foo -f {sockfile}"
        out, end = output2(cmd)
        self.assertEqual(end, 0) # FIXME
        logg.info("send.log>>\n%s", out)
        self.assertTrue(greps(out, "request: foo"))
        self.assertTrue(greps(out, "replied: ERROR: FOO"))
        #
        logg.info("kill daemon at %s", init.pid)
        if TESTING_LISTEN:
            self.assertTrue(self.kill(init.pid))
        elif not self.kill(init.pid):
            self.kill(init.pid, sig = signal.SIGKILL)

        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_26518_unix_socket_listen_bad_start(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        replyB = self.testname("replyB")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart=/bin/false
            StandardOutput=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zza.socket"), F"""
            [Unit]
            Description=Testing B
            [Socket]
            ExecStartPre=/bin/false
            ExecStopPost=/bin/true
            ListenStream={sockfile}
            Service=zza.service
            [Install]
            WantedBy=multi-user.target
            """)
        reply = reply_tool()
        copy_tool(reply, os_path(bindir, replyA))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        cmd = F"{systemctl} enable zza.socket"
        sh____(cmd)
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        text_file(debug_log, "")
        #
        INITLOOPSLEEP = 1
        initsystemctl = systemctl
        initsystemctl += F" -c INITLOOPSLEEP={INITLOOPSLEEP}"
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = F"{initsystemctl} listen zza.socket -c TESTING_LISTEN -c TESTING_ACCEPT"
        init = background(cmd)
        time.sleep(INITLOOPSLEEP+1)
        #
        log = reads(debug_log)
        logg.info("systemctl.debug.log:\n%s", i2(log))
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, "systemctl.*listen"))
        #
        # no reply
        #
        logg.info("kill daemon at %s", init.pid)
        if TESTING_LISTEN:
            self.assertTrue(self.kill(init.pid))
        elif not self.kill(init.pid):
            self.kill(init.pid, sig = signal.SIGKILL)

        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_26519_unix_socket_listen_bad_start_bad_post(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        replyB = self.testname("replyB")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart=/bin/false
            StandardOutput=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zza.socket"), F"""
            [Unit]
            Description=Testing B
            [Socket]
            ExecStartPre=/bin/false
            ExecStopPost=/bin/false
            ListenStream={sockfile}
            Service=zza.service
            [Install]
            WantedBy=multi-user.target
            """)
        reply = reply_tool()
        copy_tool(reply, os_path(bindir, replyA))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        cmd = F"{systemctl} enable zza.socket"
        sh____(cmd)
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        text_file(debug_log, "")
        #
        INITLOOPSLEEP = 1
        initsystemctl = systemctl
        initsystemctl += F" -c INITLOOPSLEEP={INITLOOPSLEEP}"
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = F"{initsystemctl} listen zza.socket -c TESTING_LISTEN -c TESTING_ACCEPT"
        init = background(cmd)
        time.sleep(INITLOOPSLEEP+1)
        #
        log = reads(debug_log)
        logg.info("systemctl.debug.log:\n%s", i2(log))
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, "systemctl.*listen"))
        #
        # no reply
        #
        logg.info("kill daemon at %s", init.pid)
        if TESTING_LISTEN:
            self.assertTrue(self.kill(init.pid))
        elif not self.kill(init.pid):
            self.kill(init.pid, sig = signal.SIGKILL)

        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_26520_udp_socket_accept(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        testport = self.testport()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        replyB = self.testname("replyB")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} serverUDP -p {testport}
            StandardOutput=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zza.socket"), F"""
            [Unit]
            Description=Testing B
            [Socket]
            Accept=yes
            ListenStream={testport}
            Service=zza.service
            [Install]
            WantedBy=multi-user.target
            """)
        reply = reply_tool()
        copy_tool(reply, os_path(bindir, replyA))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        cmd = F"{systemctl} enable zza.socket"
        sh____(cmd)
        #
        INITLOOPSLEEP = 1
        initsystemctl = systemctl
        initsystemctl += F" -c INITLOOPSLEEP={INITLOOPSLEEP}"
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = F"{initsystemctl} listen zza.socket"
        init = background(cmd)
        time.sleep(INITLOOPSLEEP+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*listen"))
        #
        cmd = F"{reply} sendUDP -d foo -p {testport}"
        out, end = output2(cmd)
        self.assertEqual(end, 0)
        logg.info("send.log>>\n%s", out)
        self.assertTrue(greps(out, "request: foo"))
        self.assertTrue(greps(out, "replied: FOO"))
        log = F"{root}/var/log/zza.log"
        out = open(log).read()
        logg.info("zza.log>>\n%s", out)
        self.assertTrue(greps(out, "received:.*foo"))
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_26521_tcp_socket_accept(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        testport = self.testport()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        replyB = self.testname("replyB")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} serverTCP -p {testport}
            StandardOutput=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zza.socket"), F"""
            [Unit]
            Description=Testing B
            [Socket]
            Accept=yes
            ListenStream={testport}
            Service=zza.service
            [Install]
            WantedBy=multi-user.target
            """)
        reply = reply_tool()
        copy_tool(reply, os_path(bindir, replyA))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        cmd = F"{systemctl} enable zza.socket"
        sh____(cmd)
        #
        INITLOOPSLEEP = 1
        initsystemctl = systemctl
        initsystemctl += F" -c INITLOOPSLEEP={INITLOOPSLEEP}"
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = F"{initsystemctl} listen zza.socket"
        init = background(cmd)
        time.sleep(INITLOOPSLEEP+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*listen"))
        #
        cmd = F"{reply} sendTCP -d foo -p {testport}"
        out, end = output2(cmd)
        self.assertEqual(end, 0)
        logg.info("send.log>>\n%s", out)
        self.assertTrue(greps(out, "request: foo"))
        self.assertTrue(greps(out, "replied: FOO"))
        log = F"{root}/var/log/zza.log"
        out = open(log).read()
        logg.info("zza.log>>\n%s", out)
        self.assertTrue(greps(out, "received:.*foo"))
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_26522_inet_socket_accept(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        testport = self.testport()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        replyB = self.testname("replyB")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} serverINET -p {testport}
            StandardOutput=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zza.socket"), F"""
            [Unit]
            Description=Testing B
            [Socket]
            Accept=yes
            ListenStream={testport}
            Service=zza.service
            [Install]
            WantedBy=multi-user.target
            """)
        reply = reply_tool()
        copy_tool(reply, os_path(bindir, replyA))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        cmd = F"{systemctl} enable zza.socket"
        sh____(cmd)
        #
        INITLOOPSLEEP = 1
        initsystemctl = systemctl
        initsystemctl += F" -c INITLOOPSLEEP={INITLOOPSLEEP}"
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = F"{initsystemctl} listen zza.socket"
        init = background(cmd)
        time.sleep(INITLOOPSLEEP+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*listen"))
        #
        cmd = F"{reply} sendTCP -d foo -p {testport}"
        out, end = output2(cmd)
        self.assertEqual(end, 0)
        logg.info("send.log>>\n%s", out)
        self.assertTrue(greps(out, "request: foo"))
        self.assertTrue(greps(out, "replied: FOO"))
        log = F"{root}/var/log/zza.log"
        out = open(log).read()
        logg.info("zza.log>>\n%s", out)
        self.assertTrue(greps(out, "received:.*foo"))
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_26530_udp_socket_listen(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        testport = self.testport()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        replyB = self.testname("replyB")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} serverUDP -p {testport}
            StandardOutput=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zza.socket"), F"""
            [Unit]
            Description=Testing B
            [Socket]
            ListenDatagram={testport}
            Service=zza.service
            [Install]
            WantedBy=multi-user.target
            """)
        reply = reply_tool()
        copy_tool(reply, os_path(bindir, replyA))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        cmd = F"{systemctl} enable zza.socket"
        sh____(cmd)
        #
        INITLOOPSLEEP = 1
        initsystemctl = systemctl
        initsystemctl += F" -c INITLOOPSLEEP={INITLOOPSLEEP}"
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = F"{initsystemctl} listen zza.socket -c TESTING_LISTEN -c TESTING_ACCEPT"
        init = background(cmd)
        time.sleep(INITLOOPSLEEP+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*listen"))
        #
        cmd = F"{reply} sendUDP -d foo -p {testport}"
        out, end = output2(cmd)
        self.assertEqual(end, 0)
        logg.info("send.log>>\n%s", out)
        self.assertTrue(greps(out, "request: foo"))
        # self.assertTrue(greps(out, "replied: FOO"))
        self.assertTrue(greps(out, "replied: ERROR: FOO"))
        log = F"{root}/var/log/zza.log"
        ### out = open(log).read()
        ### logg.info("zza.log>>\n%s", out)
        ### self.assertTrue(greps(out, "received:.*foo"))
        #
        logg.info("kill daemon at %s", init.pid)
        if TESTING_LISTEN:
            self.assertTrue(self.kill(init.pid))
        elif not self.kill(init.pid):
            self.kill(init.pid, sig = signal.SIGKILL)

        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_26531_tcp_socket_listen(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        testport = self.testport()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        replyB = self.testname("replyB")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} serverTCP -p {testport}
            StandardOutput=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zza.socket"), F"""
            [Unit]
            Description=Testing B
            [Socket]
            ListenStream={testport}
            Service=zza.service
            [Install]
            WantedBy=multi-user.target
            """)
        reply = reply_tool()
        copy_tool(reply, os_path(bindir, replyA))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        cmd = F"{systemctl} enable zza.socket"
        sh____(cmd)
        #
        INITLOOPSLEEP = 1
        initsystemctl = systemctl
        initsystemctl += F" -c INITLOOPSLEEP={INITLOOPSLEEP}"
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = F"{initsystemctl} listen zza.socket -c TESTING_LISTEN -c TESTING_ACCEPT"
        init = background(cmd)
        time.sleep(INITLOOPSLEEP+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*listen"))
        #
        cmd = F"{reply} sendTCP -d foo -p {testport}"
        out, end = output2(cmd)
        self.assertEqual(end, 0)
        logg.info("send.log>>\n%s", out)
        self.assertTrue(greps(out, "request: foo"))
        # self.assertTrue(greps(out, "replied: FOO"))
        self.assertTrue(greps(out, "replied: ERROR: FOO"))
        log = F"{root}/var/log/zza.log"
        ### out = open(log).read()
        ### logg.info("zza.log>>\n%s", out)
        ### self.assertTrue(greps(out, "received:.*foo"))
        #
        logg.info("kill daemon at %s", init.pid)
        if TESTING_LISTEN:
            self.assertTrue(self.kill(init.pid))
        elif not self.kill(init.pid):
            self.kill(init.pid, sig = signal.SIGKILL)

        self.assertTrue(self.kill(init.pid))
        #
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_26532_tcp4_socket_listen(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        testport = self.testport()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        replyB = self.testname("replyB")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} serverTCP -p {testport}
            StandardOutput=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zza.socket"), F"""
            [Unit]
            Description=Testing B
            [Socket]
            ListenStream=127.0.0.1:{testport}
            Service=zza.service
            [Install]
            WantedBy=multi-user.target
            """)
        reply = reply_tool()
        copy_tool(reply, os_path(bindir, replyA))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        cmd = F"{systemctl} enable zza.socket"
        sh____(cmd)
        #
        INITLOOPSLEEP = 1
        initsystemctl = systemctl
        initsystemctl += F" -c INITLOOPSLEEP={INITLOOPSLEEP}"
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = F"{initsystemctl} listen zza.socket -c TESTING_LISTEN -c TESTING_ACCEPT"
        init = background(cmd)
        time.sleep(INITLOOPSLEEP+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*listen"))
        #
        cmd = F"{reply} sendTCP -d foo -p {testport} -a 127.0.0.1"
        out, end = output2(cmd)
        self.assertEqual(end, 0)
        logg.info("send.log>>\n%s", out)
        self.assertTrue(greps(out, "request: foo"))
        # self.assertTrue(greps(out, "replied: FOO"))
        self.assertTrue(greps(out, "replied: ERROR: FOO"))
        log = F"{root}/var/log/zza.log"
        ### out = open(log).read()
        ### logg.info("zza.log>>\n%s", out)
        ### self.assertTrue(greps(out, "received:.*foo"))
        #
        logg.info("kill daemon at %s", init.pid)
        if TESTING_LISTEN:
            self.assertTrue(self.kill(init.pid))
        elif not self.kill(init.pid):
            self.kill(init.pid, sig = signal.SIGKILL)

        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_26534_inet4_socket_listen(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        testport = self.testport()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        replyB = self.testname("replyB")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} serverINET -p {testport}
            StandardOutput=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zza.socket"), F"""
            [Unit]
            Description=Testing B
            [Socket]
            ListenStream=127.0.0.1:{testport}
            Service=zza.service
            [Install]
            WantedBy=multi-user.target
            """)
        reply = reply_tool()
        copy_tool(reply, os_path(bindir, replyA))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        cmd = F"{systemctl} enable zza.socket"
        sh____(cmd)
        #
        INITLOOPSLEEP = 1
        initsystemctl = systemctl
        initsystemctl += F" -c INITLOOPSLEEP={INITLOOPSLEEP}"
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = F"{initsystemctl} listen zza.socket -c TESTING_LISTEN -c TESTING_ACCEPT"
        init = background(cmd)
        time.sleep(INITLOOPSLEEP+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*listen"))
        #
        cmd = F"{reply} sendTCP4 -d foo -p {testport} -a 127.0.0.1"
        out, end = output2(cmd)
        self.assertEqual(end, 0)
        logg.info("send.log>>\n%s", out)
        self.assertTrue(greps(out, "request: foo"))
        # self.assertTrue(greps(out, "replied: FOO"))
        self.assertTrue(greps(out, "replied: ERROR: FOO"))
        log = F"{root}/var/log/zza.log"
        ### out = open(log).read()
        ### logg.info("zza.log>>\n%s", out)
        ### self.assertTrue(greps(out, "received:.*foo"))
        #
        logg.info("kill daemon at %s", init.pid)
        if TESTING_LISTEN:
            self.assertTrue(self.kill(init.pid))
        elif not self.kill(init.pid):
            self.kill(init.pid, sig = signal.SIGKILL)

        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_26536_tcp6_socket_listen(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        testport = self.testport()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        replyB = self.testname("replyB")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} serverINET6 -p {testport}
            StandardOutput=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zza.socket"), F"""
            [Unit]
            Description=Testing B
            [Socket]
            ListenStream=[::1]:{testport}
            Service=zza.service
            [Install]
            WantedBy=multi-user.target
            """)
        reply = reply_tool()
        copy_tool(reply, os_path(bindir, replyA))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        cmd = F"{systemctl} enable zza.socket"
        sh____(cmd)
        #
        INITLOOPSLEEP = 1
        initsystemctl = systemctl
        initsystemctl += F" -c INITLOOPSLEEP={INITLOOPSLEEP}"
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = F"{initsystemctl} listen zza.socket -c TESTING_LISTEN -c TESTING_ACCEPT"
        init = background(cmd)
        time.sleep(INITLOOPSLEEP+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*listen"))
        #
        cmd = F"{reply} sendTCP6 -d foo -p {testport} -a '::1'"
        out, end = output2(cmd)
        self.assertEqual(end, 0)
        logg.info("send.log>>\n%s", out)
        self.assertTrue(greps(out, "request: foo"))
        # self.assertTrue(greps(out, "replied: FOO"))
        self.assertTrue(greps(out, "replied: ERROR: FOO"))
        log = F"{root}/var/log/zza.log"
        ### out = open(log).read()
        ### logg.info("zza.log>>\n%s", out)
        ### self.assertTrue(greps(out, "received:.*foo"))
        #
        logg.info("kill daemon at %s", init.pid)
        if TESTING_LISTEN:
            self.assertTrue(self.kill(init.pid))
        elif not self.kill(init.pid):
            self.kill(init.pid, sig = signal.SIGKILL)

        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_26540_udp_socket_server(self) -> None:
        self.skipTest("LISTEN_FDS not implemented yet")
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        testport = self.testport()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        replyB = self.testname("replyB")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} socketUDP -p {testport}
            StandardOutput=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zza.socket"), F"""
            [Unit]
            Description=Testing B
            [Socket]
            ListenDatagram={testport}
            Service=zza.service
            [Install]
            WantedBy=multi-user.target
            """)
        reply = reply_tool()
        copy_tool(reply, os_path(bindir, replyA))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        cmd = F"{systemctl} enable zza.socket"
        sh____(cmd)
        #
        INITLOOPSLEEP = 1
        initsystemctl = systemctl
        initsystemctl += F" -c INITLOOPSLEEP={INITLOOPSLEEP}"
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = F"{initsystemctl} listen zza.socket -c TESTING_LISTEN"
        init = background(cmd)
        time.sleep(INITLOOPSLEEP+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*listen"))
        #
        cmd = F"{reply} sendUDP -d foo -p {testport}"
        out, end = output2(cmd)
        self.assertEqual(end, 0)
        logg.info("send.log>>\n%s", out)
        self.assertTrue(greps(out, "request: foo"))
        # self.assertTrue(greps(out, "replied: FOO"))
        self.assertTrue(greps(out, "replied: ERROR: FOO"))
        log = F"{root}/var/log/zza.log"
        ### out = open(log).read()
        ### logg.info("zza.log>>\n%s", out)
        ### self.assertTrue(greps(out, "received:.*foo"))
        #
        logg.info("kill daemon at %s", init.pid)
        if TESTING_LISTEN:
            self.assertTrue(self.kill(init.pid))
        elif not self.kill(init.pid):
            self.kill(init.pid, sig = signal.SIGKILL)

        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_26542_tcp_socket_server(self) -> None:
        self.skipTest("LISTEN_FDS not implemented yet")
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        testport = self.testport()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        replyB = self.testname("replyB")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} socketTCP -p {testport}
            StandardOutput=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zza.socket"), F"""
            [Unit]
            Description=Testing B
            [Socket]
            ListenStream=127.0.0.1:{testport}
            Service=zza.service
            [Install]
            WantedBy=multi-user.target
            """)
        reply = reply_tool()
        copy_tool(reply, os_path(bindir, replyA))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        cmd = F"{systemctl} enable zza.socket"
        sh____(cmd)
        #
        INITLOOPSLEEP = 1
        initsystemctl = systemctl
        initsystemctl += F" -c INITLOOPSLEEP={INITLOOPSLEEP}"
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = F"{initsystemctl} listen zza.socket -c TESTING_LISTEN"
        init = background(cmd)
        time.sleep(INITLOOPSLEEP+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*listen"))
        #
        cmd = F"{reply} sendTCP -d foo -p {testport} -a 127.0.0.1"
        out, end = output2(cmd)
        self.assertEqual(end, 0)
        logg.info("send.log>>\n%s", out)
        self.assertTrue(greps(out, "request: foo"))
        # self.assertTrue(greps(out, "replied: FOO"))
        self.assertTrue(greps(out, "replied: ERROR: FOO"))
        log = F"{root}/var/log/zza.log"
        ### out = open(log).read()
        ### logg.info("zza.log>>\n%s", out)
        ### self.assertTrue(greps(out, "received:.*foo"))
        #
        logg.info("kill daemon at %s", init.pid)
        if TESTING_LISTEN:
            self.assertTrue(self.kill(init.pid))
        elif not self.kill(init.pid):
            self.kill(init.pid, sig = signal.SIGKILL)

        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_26551_ListenUSB_not_implemented(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        testport = self.testport()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        replyB = self.testname("replyB")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} socketTCP -p {testport}
            StandardOutput=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zza.socket"), F"""
            [Unit]
            Description=Testing B
            [Socket]
            ListenUSBFunction=foo
            Service=zza.service
            [Install]
            WantedBy=multi-user.target
            """)
        reply = reply_tool()
        copy_tool(reply, os_path(bindir, replyA))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        #
        cmd = F"{systemctl} start zza.socket -c TESTING_LISTEN -vvvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertTrue(greps(err, "ListenUSBFunction sockets are not implemented"))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_26552_ListenSpecial_not_implemented(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        testport = self.testport()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        replyB = self.testname("replyB")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} socketTCP -p {testport}
            StandardOutput=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zza.socket"), F"""
            [Unit]
            Description=Testing B
            [Socket]
            ListenSpecial=foo
            Service=zza.service
            [Install]
            WantedBy=multi-user.target
            """)
        reply = reply_tool()
        copy_tool(reply, os_path(bindir, replyA))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        #
        cmd = F"{systemctl} start zza.socket -c TESTING_LISTEN -vvvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertTrue(greps(err, "ListenSpecial sockets are not implemented"))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_26553_ListenFIFO_not_implemented(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        testport = self.testport()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        replyB = self.testname("replyB")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} socketTCP -p {testport}
            StandardOutput=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zza.socket"), F"""
            [Unit]
            Description=Testing B
            [Socket]
            ListenFIFO=foo
            Service=zza.service
            [Install]
            WantedBy=multi-user.target
            """)
        reply = reply_tool()
        copy_tool(reply, os_path(bindir, replyA))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        #
        cmd = F"{systemctl} start zza.socket -c TESTING_LISTEN -vvvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertTrue(greps(err, "ListenFIFO sockets are not implemented"))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_26554_ListenSequentialPacket_not_implemented(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        testport = self.testport()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        replyB = self.testname("replyB")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} socketTCP -p {testport}
            StandardOutput=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zza.socket"), F"""
            [Unit]
            Description=Testing B
            [Socket]
            ListenSequentialPacket=foo
            Service=zza.service
            [Install]
            WantedBy=multi-user.target
            """)
        reply = reply_tool()
        copy_tool(reply, os_path(bindir, replyA))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        #
        cmd = F"{systemctl} start zza.socket -c TESTING_LISTEN -vvvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertTrue(greps(err, "ListenSequentialPacket sockets are not implemented"))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_26555_ListenMessageQueue_not_implemented(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        testport = self.testport()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        replyB = self.testname("replyB")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} socketTCP -p {testport}
            StandardOutput=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zza.socket"), F"""
            [Unit]
            Description=Testing B
            [Socket]
            ListenMessageQueue=foo
            Service=zza.service
            [Install]
            WantedBy=multi-user.target
            """)
        reply = reply_tool()
        copy_tool(reply, os_path(bindir, replyA))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        #
        cmd = F"{systemctl} start zza.socket -c TESTING_LISTEN -vvvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertTrue(greps(err, "ListenMessageQueue sockets are not implemented"))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_26561_vsock_not_implemented(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        testport = self.testport()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        replyB = self.testname("replyB")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} socketTCP -p {testport}
            StandardOutput=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zza.socket"), F"""
            [Unit]
            Description=Testing B
            [Socket]
            ListenStream=vsock:foo
            Service=zza.service
            [Install]
            WantedBy=multi-user.target
            """)
        reply = reply_tool()
        copy_tool(reply, os_path(bindir, replyA))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        #
        cmd = F"{systemctl} start zza.socket -c TESTING_LISTEN -vvvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertTrue(greps(err, "virtual machine socket not implemented"))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_26562_abstract_not_implemented(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        testport = self.testport()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        replyB = self.testname("replyB")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} socketTCP -p {testport}
            StandardOutput=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zza.socket"), F"""
            [Unit]
            Description=Testing B
            [Socket]
            ListenStream=@/foo
            Service=zza.service
            [Install]
            WantedBy=multi-user.target
            """)
        reply = reply_tool()
        copy_tool(reply, os_path(bindir, replyA))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        #
        cmd = F"{systemctl} start zza.socket -c TESTING_LISTEN -vvvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertTrue(greps(err, "abstract namespace socket not implemented"))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_26566_unknown_type_not_implemented(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        testport = self.testport()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        replyB = self.testname("replyB")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} socketTCP -p {testport}
            StandardOutput=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zza.socket"), F"""
            [Unit]
            Description=Testing B
            [Socket]
            ListenStream=&append
            Service=zza.service
            [Install]
            WantedBy=multi-user.target
            """)
        reply = reply_tool()
        copy_tool(reply, os_path(bindir, replyA))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        #
        cmd = F"{systemctl} start zza.socket -c TESTING_LISTEN -vvvv"
        out, err, end = output3(cmd)
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertTrue(greps(err, "unknown socket address type"))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_26600_systemctl_py_start_target_units(self) -> None:
        """ check that we can enable template services in a target"""
        vv = self.begin()
        self.rm_testdir()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=oneshot
            ExecStart=/bin/touch {root}/tmp/zz.a.txt
            ExecStop=/bin/rm {root}/tmp/zz.a.txt
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            Type=oneshot
            ExecStart=/bin/touch {root}/tmp/zz.b.txt
            ExecStop=/bin/rm {root}/tmp/zz.b.txt
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zz@.service"), F"""
            [Unit]
            Description=Testing Z.%i
            [Service]
            Type=oneshot
            ExecStart=/bin/touch {root}/tmp/zz.%i.txt
            ExecStop=/bin/rm {root}/tmp/zz.%i.txt
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zzxx.target"), F"""
            [Unit]
            Description=Testing D
            Requires= zza.service zz@rsa.service
            """)
        #
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        copy_file(os_path(testdir, "zz@.service"), os_path(root, "/etc/systemd/system/zz@.service"))
        copy_file(os_path(testdir, "zzxx.target"), os_path(root, "/etc/systemd/system/zzxx.target"))
        text_file(os_path(root, "/tmp/zz.tmp"), "")
        cmd = F"{systemctl} enable zza.service"
        sh____(cmd)
        cmd = F"{systemctl} enable zzb.service"
        sh____(cmd)
        cmd = F"{systemctl} default-services | sort"
        out = output(cmd)
        logg.info("\n>\n%s", out)
        self.assertEqual(sorted4(out), ["zza.service","zzb.service"])
        cmd = F"{systemctl} default-services zzxx.target | sort"
        out = output(cmd)
        logg.info("\n>\n%s", out)
        self.assertEqual(sorted4(out), ["zz@rsa.service","zza.service"])
        #
        cmd = F"{systemctl} is-active zzxx.target"
        out = output(cmd)
        logg.info("\n>\n%s", out)
        self.assertEqual(out.strip(), "inactive")
        cmd = F"{systemctl} is-active zza.service"
        out = output(cmd)
        logg.info("\n>\n%s", out)
        self.assertEqual(out.strip(), "inactive")
        #
        cmd = F"{systemctl} start zza.service {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} is-active zzxx.target"
        out = output(cmd)
        logg.info("\n>\n%s", out)
        self.assertEqual(out.strip(), "inactive")
        cmd = F"{systemctl} is-active zza.service"
        out = output(cmd)
        logg.info("\n>\n%s", out)
        self.assertEqual(out.strip(), "active")
        #
        cmd = F"{systemctl} start zzxx.target {vv}"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = F"{systemctl} is-active zzxx.target {vv}"
        out = output(cmd)
        logg.info("\n>\n%s", out)
        self.assertEqual(out.strip(), "active")
        cmd = F"{systemctl} is-active zza.service"
        out = output(cmd)
        logg.info("\n>\n%s", out)
        self.assertEqual(out.strip(), "active")
        cmd = F"{systemctl} is-active zz@rsa.service"
        out = output(cmd)
        logg.info("\n>\n%s", out)
        self.assertEqual(out.strip(), "active")
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_27700_systemctl_py_restart_failed_units(self) -> None:
        """ check that we can enable services in a docker container to be run as default-services
            and failed units are going to be restarted"""
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleepA = self.testname("sleepA")
        testsleepB = self.testname("sleepB")
        testsleepC = self.testname("sleepC")
        testsleepD = self.testname("sleepD")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepA} 44
            Restart=on-failure
            RestartSec=4
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepB} 55
            Restart=on-failure
            RestartSec=5
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zzc.service"), F"""
            [Unit]
            Description=Testing C
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepC} 66
            Restart=on-failure
            RestartSec=6
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zzd.service"), F"""
            [Unit]
            Description=Testing D
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepD} 122
            [Install]
            WantedBy=multi-user.target
            """)
        #
        copy_tool(_bin_sleep, os_path(bindir, testsleepA))
        copy_tool(_bin_sleep, os_path(bindir, testsleepB))
        copy_tool(_bin_sleep, os_path(bindir, testsleepC))
        copy_tool(_bin_sleep, os_path(bindir, testsleepD))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        copy_file(os_path(testdir, "zzc.service"), os_path(root, "/etc/systemd/system/zzc.service"))
        copy_file(os_path(testdir, "zzd.service"), os_path(root, "/etc/systemd/system/zzd.service"))
        cmd = F"{systemctl} enable zza.service"
        sh____(cmd)
        cmd = F"{systemctl} enable zzb.service"
        sh____(cmd)
        cmd = F"{systemctl} enable zzc.service"
        sh____(cmd)
        cmd = F"{systemctl} enable zzd.service"
        sh____(cmd)
        cmd = F"{systemctl} default-services -v"
        sh____(cmd)
        # sh____(cmd)
        out2 = output(cmd)
        logg.info("\n>\n%s", out2)
        #
        INITLOOPSLEEP = 1
        initsystemctl = systemctl
        initsystemctl += F" -c INITLOOPSLEEP={INITLOOPSLEEP}"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = F"{initsystemctl} -1"
        init = background(cmd)
        time.sleep(INITLOOPSLEEP+2)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "sleepA"))
        self.assertTrue(greps(top, "sleepB"))
        self.assertTrue(greps(top, "sleepC"))
        self.assertTrue(greps(top, "sleepD"))
        #
        check = F"{systemctl} list-units --state=running --type=service"
        top = output(check)
        logg.info("\n>>>\n%s", top)
        self.assertEqual(len(greps(top, "zz")), 4)
        #
        log = lines4(open(debug_log))
        logg.info("systemctl.debug.log>\n\t%s", "\n\t".join(log))
        self.assertFalse(greps(log, "restart"))
        #
        cmd = F"{systemctl} __killall {testsleepD}" # <<<
        sh____(cmd)
        #
        time.sleep(INITLOOPSLEEP+1)
        log = lines4(open(debug_log))
        # logg.info("systemctl.debug.log>\n\t%s", "\n\t".join(log))
        self.assertFalse(greps(log, "restart"))
        #
        check = F"{systemctl} list-units --state=running --type=service"
        top = output(check)
        logg.info("\n>>>\n%s", top)
        self.assertEqual(len(greps(top, "zz")), 3)
        #
        cmd = F"{systemctl} __killall {testsleepC}" # <<<
        sh____(cmd)
        #
        check = F"{systemctl} list-units --state=running --type=service"
        top = output(check)
        logg.info("\n>>>\n%s", top)
        self.assertEqual(len(greps(top, "zz")), 2)
        #
        time.sleep(INITLOOPSLEEP+1) # RestartSec=6
        #
        check = F"{systemctl} list-units --state=running --type=service"
        top = output(check)
        logg.info("\n>>>\n%s", top)
        self.assertEqual(len(greps(top, "zz")), 2)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        logg.info("============== wait for a Restart")
        time.sleep(6) # to have RestartSec=6
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        logg.info("==============>>")
        #
        log = lines4(open(debug_log))
        logg.info("systemctl.debug.log>\n\t%s", "\n\t".join(log[-20:]))
        #
        check = F"{systemctl} list-units --state=running --type=service"
        top = output(check)
        logg.info("\n>>>\n%s", top)
        self.assertEqual(len(greps(top, "zz")), 3)
        #
        time.sleep(INITLOOPSLEEP+1)
        log = lines4(open(debug_log))
        logg.info("systemctl.debug.log>\n\t%s", "\n\t".join(log))
        self.assertTrue(greps(log, "restart"))
        #
        self.assertTrue(greps(log, ".zzc.service. --- restarting failed unit"))
        self.assertTrue(greps(log, ".zzd.service. Current NoCheck .Restart=no."))
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid, 20))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_27710_systemctl_py_restart_failed_units_rate_limit(self) -> None:
        """ check that we can enable services in a docker container to be run as default-services
            and failed units are going to be restarted"""
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleepA = self.testname("sleepA")
        testsleepB = self.testname("sleepB")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepA} 2
            Restart=on-failure
            RestartSec=1
            StartLimitBurst=3
            StartLimitIntervalSec=12
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepB} 6
            Restart=on-failure
            RestartSec=3
            [Install]
            WantedBy=multi-user.target
            """)
        #
        copy_tool(_bin_sleep, os_path(bindir, testsleepA))
        copy_tool(_bin_sleep, os_path(bindir, testsleepB))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        cmd = F"{systemctl} enable zza.service"
        sh____(cmd)
        cmd = F"{systemctl} enable zzb.service"
        sh____(cmd)
        cmd = F"{systemctl} default-services -v"
        sh____(cmd)
        # sh____(cmd)
        out2 = output(cmd)
        logg.info("\n>\n%s", out2)
        #
        INITLOOPSLEEP = 1
        systemctl += F" -c INITLOOPSLEEP={INITLOOPSLEEP}"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = F"{systemctl} -1"
        init = background(cmd)
        time.sleep(1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "sleepA"))
        self.assertTrue(greps(top, "sleepB"))
        #
        logg.info("===============SLEEP")
        time.sleep(22)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        logg.info("==============>>")
        #
        log = lines4(open(debug_log))
        logg.info("systemctl.debug.log>\n\t%s", "\n\t".join(log[-20:]))
        #
        check = F"{systemctl} list-units --state=running --type=service"
        top = output(check)
        logg.info("\n>>>\n%s", top)
        # self.assertEqual(len(greps(top, "zz")), 3)
        #
        time.sleep(INITLOOPSLEEP+1)
        log = lines4(open(debug_log))
        logg.info("systemctl.debug.log>\n\t%s", "\n\t".join(log))
        self.assertTrue(greps(log, "restart"))
        self.assertTrue(greps(log, "zza.service.*Blocking Restart"))
        self.assertTrue(greps(log, "zza.service.*Status: error"))
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_27760_systemctl_py_restart_sec_shortens_interval(self) -> None:
        """ check that we can enable services in a docker container to be run as default-services
            and RestartSec shortes the InitLoop interval"""
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleepA = self.testname("sleepA")
        testsleepB = self.testname("sleepB")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepA} 2
            Restart=on-failure
            RestartSec=200ms
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepB} 6
            Restart=on-failure
            RestartSec=2
            [Install]
            WantedBy=multi-user.target
            """)
        #
        copy_tool(_bin_sleep, os_path(bindir, testsleepA))
        copy_tool(_bin_sleep, os_path(bindir, testsleepB))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        cmd = F"{systemctl} enable zza.service"
        sh____(cmd)
        cmd = F"{systemctl} enable zzb.service"
        sh____(cmd)
        cmd = F"{systemctl} default-services -v"
        sh____(cmd)
        # sh____(cmd)
        out2 = output(cmd)
        logg.info("\n>\n%s", out2)
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = F"{systemctl} -1"
        init = background(cmd)
        time.sleep(2)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "sleepA"))
        self.assertTrue(greps(top, "sleepB"))
        #
        logg.info("===============SLEEP")
        time.sleep(6)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        logg.info("==============>>")
        #
        log = lines4(open(debug_log))
        logg.info("systemctl.debug.log>\n\t%s", "\n\t".join(log[-20:]))
        #
        self.assertTrue(greps(log, ".zzb.service. set loop-sleep from 5s to 2 .caused by RestartSec=2.000s"))
        self.assertFalse(greps(log, "zza.service.*set loop-sleep"))
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_27770_systemctl_py_restart_sec_shortens_interval(self) -> None:
        """ check that we can enable services in a docker container to be run as default-services
            and RestartSec shortes the InitLoop interval"""
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleepA = self.testname("sleepA")
        testsleepB = self.testname("sleepB")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepA} 2
            Restart=on-failure
            RestartSec=2
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepB} 6
            Restart=on-failure
            RestartSec=0
            [Install]
            WantedBy=multi-user.target
            """)
        #
        copy_tool(_bin_sleep, os_path(bindir, testsleepA))
        copy_tool(_bin_sleep, os_path(bindir, testsleepB))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        cmd = F"{systemctl} enable zza.service"
        sh____(cmd)
        cmd = F"{systemctl} enable zzb.service"
        sh____(cmd)
        cmd = F"{systemctl} default-services -v"
        sh____(cmd)
        # sh____(cmd)
        out2 = output(cmd)
        logg.info("\n>\n%s", out2)
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = F"{systemctl} -1"
        init = background(cmd)
        time.sleep(2)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "sleepA"))
        self.assertTrue(greps(top, "sleepB"))
        #
        logg.info("===============SLEEP")
        time.sleep(6)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        logg.info("==============>>")
        #
        log = lines4(open(debug_log))
        logg.info("systemctl.debug.log>\n\t%s", "\n\t".join(log[-20:]))
        #
        self.assertTrue(greps(log, ".zza.service. set loop-sleep from 5s to 2"))
        self.assertTrue(greps(log, ".zzb.service. set loop-sleep from 2s to 1 .caused by RestartSec=0!"))
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_28000_is_system_running_features(self) -> None:
        """ check that we can enable services in a docker container
            and the is-system-running will not report true unless
            they are up and running"""
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        systemctl += " -c INITLOOPSLEEP=2"
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleepA = self.testname("sleepA")
        testsleepB = self.testname("sleepB")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStartPre={bindir}/{testsleepA} 4
            ExecStart={bindir}/{testsleepA} 5
            Restart=no
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(testdir, "zzb.service"), F"""
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepB} 16
            Restart=on-failure
            RestartSec=0
            [Install]
            WantedBy=multi-user.target
            """)
        #
        copy_tool(_bin_sleep, os_path(bindir, testsleepA))
        copy_tool(_bin_sleep, os_path(bindir, testsleepB))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        cmd = F"{systemctl} enable zza.service"
        sh____(cmd)
        cmd = F"{systemctl} enable zzb.service"
        sh____(cmd)
        cmd = F"{systemctl} default-services -v"
        sh____(cmd)
        # sh____(cmd)
        out2 = output(cmd)
        logg.info("\n>\n%s", out2)
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = F"{systemctl} -1" # init
        init = background(cmd)
        #
        time.sleep(1)
        cmd = F"{systemctl} is-system-running"
        out, err, rc = output3(cmd)
        logg.info("\n>>>(%s)\n%s\n%s", rc, i2(err), out)
        # self.assertEqual(out, "starting\n")
        # self.assertEqual(rc, 1)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "sleepA 4"))
        self.assertFalse(greps(top, "sleepB")) # we do not start in parallel
        #
        cmd = F"{systemctl} is-system-running --quiet"
        out, err, rc = output3(cmd)
        logg.info("\n>>>(%s)\n%s\n%s", rc, i2(err), out)
        self.assertEqual(out, "")
        self.assertEqual(rc, 1)
        #
        for check in range(5):
            time.sleep(1)
            logg.info("[%s] wait for sleepB ------", check)
            top = _recent(output(_top_list))
            logg.info("\n>>>\n%s", top)
            if greps(top, "sleepB"):
                break
        logg.info("[!] wait for sleepB ------")
        cmd = F"{systemctl} is-system-running"
        out, err, rc = output3(cmd)
        logg.info("\n>>>(%s)\n%s\n%s", rc, i2(err), out)
        self.assertEqual(out, "running\n")
        self.assertEqual(rc, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "sleepA 5"))
        self.assertTrue(greps(top, "sleepB"))
        #
        # time.sleep(3) # InitLoopInterval+1
        # self.assertFalse(greps(top, "sleepA")) # failed state
        ## self.assertTrue(greps(top, "sleepB"))
        #
        logg.info("trying to send a 'halt'")
        logg.info("kill daemon at %s", init.pid)
        result = self.kill(init.pid)
        logg.info("kill daemon %s", "DONE" if result else "ERROR")
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        #
        log = reads(debug_log)
        logg.info("systemctl.debug.log>\n\t%s", oi22(log))
        self.assertTrue(greps(log, "interrupted - exit init-loop"))
        #
        cmd = F"{systemctl} is-system-running"
        out, err, rc = output3(cmd)
        logg.info("\n>>>(%s)\n%s\n%s", rc, i2(err), out)
        self.assertEqual(out, "stopping\n")
        self.assertEqual(rc, 1)
        #
        for attempt in range(10):
            time.sleep(1)
            logg.info("[%i] wait for sleepA and sleepB to die -----", attempt)
            top = _recent(output(_top_list))
            logg.info("\n>>>\n%s", top)
            if greps(top, "sleepA") or greps(top, "sleepB"):
                continue
            break
        logg.info("[!] wait for sleepA and sleepB to die -----")
        # atleast 1sec per ExecStop upon Halt # TODO?
        logg.info("===================== time to stop the subprocesses: %ss", attempt)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, "sleepA"))
        self.assertFalse(greps(top, "sleepB"))
        #
        self.rm_killall()
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        #
        log = reads(debug_log)
        logg.info("systemctl.debug.log>\n\t%s", oi22(log))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_28081_set_user_to_same(self) -> None:
        """ check that we can run a service with User= settings (for coverage) """
        self.begin()
        self.rm_testdir()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        systemctl += " -c INITLOOPSLEEP=2 -c EXEC_SPAWN=True"
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleepA = self.testname("sleepA")
        bindir = os_path(root, "/usr/bin")
        this_user=get_USER()
        this_group=get_GROUP()
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepA} 1
            User={this_user}
            [Install]
            WantedBy=multi-user.target
            """)
        #
        copy_tool(_bin_sleep, os_path(bindir, testsleepA))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        kill_testsleep = F"{systemctl} __killall {testsleepA} -vvvv"
        sx____(kill_testsleep)
        #
        cmd = F"{systemctl} start zza.service -vvvv"
        out, err, rc = output3(cmd)
        logg.info("\n>>>(%s)\n%s\n%s", rc, i2(err), out)
        self.assertEqual(rc, 0)
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_28082_set_user_and_group_to_same(self) -> None:
        """ check that we can run a service with User= Group= settings (for coverage) """
        self.begin()
        self.rm_testdir()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        systemctl += " -c INITLOOPSLEEP=2 -c EXEC_SPAWN=True"
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleepA = self.testname("sleepA")
        bindir = os_path(root, "/usr/bin")
        this_user=get_USER()
        this_group=get_GROUP()
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepA} 1
            User={this_user}
            Group={this_group}
            [Install]
            WantedBy=multi-user.target
            """)
        #
        copy_tool(_bin_sleep, os_path(bindir, testsleepA))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        kill_testsleep = F"{systemctl} __killall {testsleepA} -vvvv"
        sx____(kill_testsleep)
        #
        cmd = F"{systemctl} start zza.service -vvvv"
        out, err, rc = output3(cmd)
        logg.info("\n>>>(%s)\n%s\n%s", rc, i2(err), out)
        self.assertEqual(rc, 0)
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_28083_set_group_to_same(self) -> None:
        """ check that we can run a service with Group= settings (for coverage) """
        self.begin()
        self.rm_testdir()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        systemctl += " -c INITLOOPSLEEP=2 -c EXEC_SPAWN=True"
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleepA = self.testname("sleepA")
        bindir = os_path(root, "/usr/bin")
        this_user=get_USER()
        this_group=get_GROUP()
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepA} 1
            Group={this_group}
            [Install]
            WantedBy=multi-user.target
            """)
        #
        copy_tool(_bin_sleep, os_path(bindir, testsleepA))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        kill_testsleep = F"{systemctl} __killall {testsleepA} -vvvv"
        sx____(kill_testsleep)
        #
        cmd = F"{systemctl} start zza.service -vvvv"
        out, err, rc = output3(cmd)
        logg.info("\n>>>(%s)\n%s\n%s", rc, i2(err), out)
        self.assertEqual(rc, 0)
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_28084_set_user_and_supp_group_to_same(self) -> None:
        """ check that we can run a service with User= Group= SupplementaryGroups= settings (for coverage) """
        self.begin()
        self.rm_testdir()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        systemctl += " -c INITLOOPSLEEP=2 -c EXEC_SPAWN=True"
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleepA = self.testname("sleepA")
        bindir = os_path(root, "/usr/bin")
        this_user=get_USER()
        this_group=get_GROUP()
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepA} 1
            User={this_user}
            Group={this_group}
            SupplementaryGroups={this_group}
            [Install]
            WantedBy=multi-user.target
            """)
        #
        copy_tool(_bin_sleep, os_path(bindir, testsleepA))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        kill_testsleep = F"{systemctl} __killall {testsleepA} -vvvv"
        sx____(kill_testsleep)
        #
        cmd = F"{systemctl} start zza.service -vvvv"
        out, err, rc = output3(cmd)
        logg.info("\n>>>(%s)\n%s\n%s", rc, i2(err), out)
        self.assertEqual(rc, 0)
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_28085_set_user_and_supp_group_to_same(self) -> None:
        """ check that we can run a service with User= SupplementaryGroups= extra (for coverage) """
        self.begin()
        self.rm_testdir()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        systemctl += " -c INITLOOPSLEEP=2 -c EXEC_SPAWN=True"
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleepA = self.testname("sleepA")
        bindir = os_path(root, "/usr/bin")
        this_user=get_USER()
        this_group=get_GROUP()
        text_file(os_path(testdir, "zza.service"), F"""
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepA} 1
            User={this_user}
            SupplementaryGroups={this_group}
            [Install]
            WantedBy=multi-user.target
            """)
        #
        copy_tool(_bin_sleep, os_path(bindir, testsleepA))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        kill_testsleep = F"{systemctl} __killall {testsleepA} -vvvv"
        sx____(kill_testsleep)
        #
        cmd = F"{systemctl} start zza.service -vvvv"
        out, err, rc = output3(cmd)
        logg.info("\n>>>(%s)\n%s\n%s", rc, i2(err), out)
        self.assertEqual(rc, 0)
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_29000_unreadable_files_can_be_handled(self, real: bool=False) -> None:
        """ a file may exist but it is unreadable"""
        if not get_USER_ID(real):
            self.skipTest("chmod does not make a file unreadable for the root user")
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        testsleep = self.testname("sleep")
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        text_file(os_path(root, "/etc/systemd/system/zza.service"), F"""
            [Unit]
            Description=Testing A
            Requires=zzb.service
            [Service]
            Type=simple
            ExecStart={root}/bin/{testsleep} 10
            [Install]
            WantedBy=multi-user.target
            """)
        text_file(os_path(root, "/etc/systemd/system-preset/our.preset"), """
            enable zza.service
            disable zzb.service""")
        os.makedirs(os_path(root, "/var/run"))
        os.makedirs(os_path(root, "/var/log"))
        copy_tool(_bin_sleep, F"{root}/bin/{testsleep}")
        #
        os.chmod(os_path(root, "/etc/systemd/system/zza.service"), 0o222)
        #
        cmd = F"{systemctl} start zza"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = F"{systemctl} start zza.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertNotEqual(end, 0)
        cmd = F"{systemctl} stop zza.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertNotEqual(end, 0)
        cmd = F"{systemctl} reload zza.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertNotEqual(end, 0)
        cmd = F"{systemctl} restart zza.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertNotEqual(end, 0)
        cmd = F"{systemctl} try-restart zza.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertNotEqual(end, 0)
        cmd = F"{systemctl} reload-or-restart zza.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertNotEqual(end, 0)
        cmd = F"{systemctl} reload-or-try-restart zza.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertNotEqual(end, 0)
        cmd = F"{systemctl} kill zza.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertNotEqual(end, 0)
        #
        cmd = F"{systemctl} is-active zza.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertNotEqual(end, 0)
        self.assertTrue(greps(out, "unknown"))
        cmd = F"{systemctl} is-failed zza.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(out, "unknown"))
        #
        cmd = F"{systemctl} status zza.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertNotEqual(end, 0)
        self.assertTrue(greps(out, "zza.service - NOT-FOUND"))
        #
        cmd = F"{systemctl} show zza.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0) # shows not-found state ok
        self.assertTrue(greps(out, "LoadState=not-found"))
        #
        cmd = F"{systemctl} cat zza.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertNotEqual(end, 0)
        self.assertTrue(greps(out, "Unit zza.service is not-loaded"))
        #
        cmd = F"{systemctl} list-dependencies zza.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0) # always succeeds
        #
        cmd = F"{systemctl} enable zza.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertNotEqual(end, 0)
        cmd = F"{systemctl} disable zza.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertNotEqual(end, 0)
        cmd = F"{systemctl} is-enabled zza.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        #
        cmd = F"{systemctl} preset zza.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertNotEqual(end, 0)
        cmd = F"{systemctl} preset-all"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertNotEqual(end, 0)
        #
        cmd = F"{systemctl} daemon-reload"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0) # always succeeds
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_29001_unsupported_run_type_for_service(self) -> None:
        """ a service file may exist but the run type is not supported"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        testsleep = self.testname("sleep")
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        text_file(os_path(root, "/etc/systemd/system/zza.service"), F"""
            [Unit]
            Description=Testing A
            Requires=zzb.service
            [Service]
            Type=foo
            ExecStart={root}/bin/{testsleep} 10
            ExecStop=/bin/kill $MAINPID
            [Install]
            WantedBy=multi-user.target
            """)
        copy_tool(_bin_sleep, F"{root}/bin/{testsleep}")
        #
        cmd = F"{systemctl} start zza"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertNotEqual(end, 0)
        cmd = F"{systemctl} start zza.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertNotEqual(end, 0)
        cmd = F"{systemctl} stop zza.service -vv"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertNotEqual(end, 0)
        cmd = F"{systemctl} reload zza.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertNotEqual(end, 0)
        cmd = F"{systemctl} restart zza.service"
        out, end = output2(cmd)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertNotEqual(end, 0)
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()

if __name__ == "__main__":
    from optparse import OptionParser  # pylint: disable=deprecated-module
    _o = OptionParser("%prog [options] test*",
                      epilog=__doc__.strip().split("\n", 1)[0])
    _o.add_option("-v", "--verbose", action="count", default=0,
                  help="increase logging level [%default]")
    _o.add_option("--with", metavar="FILE", dest="systemctl_py", default=_systemctl_py,
                  help="systemctl.py file to be tested (%default)")
    _o.add_option("-p", "--python", metavar="EXE", default=_python,
                  help="use another python execution engine [%default]")
    _o.add_option("-G", "--coverage", action="count", default=0,
                  help="gather coverage.py data (use -GG for new set) [%default]")
    _o.add_option("-l", "--logfile", metavar="FILE", default="",
                  help="additionally save the output log to a file [%default]")
    _o.add_option("--keep", action="count", default=KEEP,
                  help="keep tempdir and other data after testcase [%default]")
    _o.add_option("--failfast", action="store_true", default=False,
                  help="Stop the test run on the first error or failure. [%default]")
    _o.add_option("--xmlresults", metavar="FILE", default=None,
                  help="capture results as a junit xml file [%default]")
    _o.add_option("--todo", action="store_true", default=TODO,
                  help="enable TODO outtakes [%default])")
    _o.add_option("-f", "--force", action="store_true", default=False,
                  help="enable the skipped IMAGE and PYTHON versions [%default])")
    _o.add_option("-C", "--chdir", metavar="PATH", default="",
                  help="change directory before running tests {%default}")
    opt, args = _o.parse_args()
    logging.basicConfig(level = logging.WARNING - opt.verbose * 5)
    SKIP = not opt.force
    TODO = opt.todo
    KEEP = opt.keep
    #
    _systemctl_py = opt.systemctl_py
    _python = opt.python
    #
    if opt.chdir:
        os.chdir(opt.chdir)
    #
    logfile = None
    if opt.logfile:
        if os.path.exists(opt.logfile):
            os.remove(opt.logfile)
        logfile = logging.FileHandler(opt.logfile)
        logfile.setFormatter(logging.Formatter("%(levelname)s:%(relativeCreated)d:%(message)s"))
        logging.getLogger().addHandler(logfile)
        logg.info("log diverted to %s", opt.logfile)
    #
    if opt.coverage:
        COVERAGE = "/"
        if opt.coverage > 1:
            if os.path.exists(".coverage"):
                logg.info("rm .coverage")
                os.remove(".coverage")
    # unittest.main()
    suite = unittest.TestSuite()
    if not args: args = ["test_*"]
    for arg in args:
        for classname in sorted(globals()):
            if not classname.endswith("Test"):
                continue
            testclass = globals()[classname]
            for method in sorted(dir(testclass)):
                if arg.endswith("/"):
                    arg = arg[:-1]
                if "*" not in arg:
                    arg += "*"
                if len(arg) > 2 and arg[1] == "_":
                    arg = "test" + arg[1:]
                if fnmatch(method, arg):
                    suite.addTest(testclass(method))
    # select runner
    xmlresults = None
    if opt.xmlresults:
        if os.path.exists(opt.xmlresults):
            os.remove(opt.xmlresults)
        xmlresults = open(opt.xmlresults, "w")
        logg.info("xml results into %s", opt.xmlresults)
    if not logfile:
        if xmlresults:
            import xmlrunner # type: ignore[import-error] # pylint: disable=import-error
            TestRunner = xmlrunner.XMLTestRunner
            testresult = TestRunner(xmlresults, verbosity=opt.verbose).run(suite)
        else:
            TestRunner = unittest.TextTestRunner
            testresult = TestRunner(verbosity=opt.verbose, failfast=opt.failfast).run(suite)
    else:
        TestRunner = unittest.TextTestRunner
        if xmlresults:
            import xmlrunner # type: ignore[import-error] # pylint: disable=import-error
            TestRunner = xmlrunner.XMLTestRunner
        testresult = TestRunner(logfile.stream, verbosity=opt.verbose).run(suite) # type: ignore
    if opt.coverage > 1:
        print(" " + coverage_tool() + " combine")
        print(" " + coverage_tool() + " report " + _systemctl_py)
        print(" " + coverage_tool() + " annotate " + _systemctl_py)
    if not testresult.wasSuccessful():
        sys.exit(1)
