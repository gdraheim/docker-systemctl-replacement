#! /usr/bin/env python3
""" Testcases for docker-systemctl-replacement functionality """

__copyright__ = "(C) Guido Draheim, licensed under the EUPL"""
__version__ = "1.5.8066"

# NOTE:
# The testcases 1000...4999 are using a --root=subdir environment
# The testcases 5000...9999 will start a docker container to work.

from typing import List, Dict, Tuple, Generator, Union, Optional, TextIO

import subprocess
import os
import os.path
import time
import errno
import datetime
import unittest
import shutil
import inspect
import types
import string
import random
import logging
import re
import sys
import collections
import signal
import shlex
from fnmatch import fnmatchcase as fnmatch
from glob import glob
import json

xrange = range
string_types = (str, bytes)

logg = logging.getLogger("TESTING")
_sed = "sed"
_docker = "docker"
_python = "/usr/bin/python3"
_python2 = "/usr/bin/python"
_systemctl_py = "files/docker/systemctl3.py"
_bin_sleep="/bin/sleep"
COVERAGE = "" # make it an image name = detect_local_system()
SKIP = True
TODO = False
KEEP = 0
LONGER = 2
KILLWAIT = 20

TestListen = False

CENTOSVER = {"7.3": "7.3.1611", "7.4": "7.4.1708", "7.5": "7.5.1804", "7.6": "7.6.1810", "7.7": "7.7.1908", "7.9": "7.9.2009", "8.0": "8.0.1905", "8.1": "8.1.1911", "8.3": "8.3.2011"}
TESTED_OS = ["centos:7.3.1611", "centos:7.4.1708", "centos:7.5.1804", "centos:7.6.1810", "centos:7.7.1908", "centos:7.9.2009", "centos:8.0.1905", "centos:8.1.1911", "centos:8.3.2011"]
TESTED_OS += ["almalinux:9.1", "centos:7.5"]
TESTED_OS += ["opensuse:42.2", "opensuse:42.3", "opensuse/leap:15.0", "opensuse/leap:15.1", "opensuse/leap:15.2", "opensuse/leap:15.5"]
TESTED_OS += ["ubuntu:14.04", "ubuntu:16.04", "ubuntu:18.04", "ubuntu:22.04"]

SAVETO = "localhost:5000/systemctl"
IMAGES = "localhost:5000/systemctl/testing"
IMAGE = ""
CENTOS = "centos:8.3.2011"
UBUNTU = "ubuntu:18.04"
OPENSUSE = "opensuse/leap:15.2"
SOMETIME = ""

QUICK = "-c DefaultMaximumTimeout=9"
DOCKER_SOCKET = "/var/run/docker.sock"
PSQL_TOOL = "/usr/bin/psql"

_maindir = os.path.dirname(sys.argv[0])
_mirror = os.path.join(_maindir, "docker_mirror.py")

realpath = os.path.realpath

_top_list = "ps -eo etime,pid,ppid,args --sort etime,pid"

def _recent(top_list: Union[str, List[str]]) -> str:
    result = []
    for line in lines(top_list):
        if "[kworker" in line: continue
        if " containerd-shim " in line: continue
        if " mplayer " in line: continue
        if " chrome " in line: continue
        if "/chrome" in line: continue
        if "/testsuite" in line: continue
        if "/xfce4" in line: continue
        if "/pulse" in line: continue
        if "/gvfs/" in line: continue
        if "/dbus-daemon" in line: continue
        if "/ibus/" in line: continue
        if "/lib/tracker" in line: continue
        if "/lib/gnome" in line: continue
        if "/lib/gdm" in line: continue
        if "signal-desktop/signal-desktop" in line: continue
        if "teams/teams" in line: continue
        if "slack/slack" in line: continue
        if "bin/telegram" in line: continue
        if "bin/nextcloud" in line: continue
        if _top_list in line: continue
        if " 1 [" in line: continue
        if " 2 [" in line: continue
        # matching on ELAPSED TIME up to 4 minutes
        if re.search("^\\s*[0]*[0123]:[0-9]*\\s", line):
            result.append(" "+line)
        if " ELAPSED " in line:
            result.append(" "+line)
    return "\n".join(result)

def package_tool(image: str, checks = False) -> str:
    if "opensuse" in image:
        if not checks:
            # --gpgcheck-strict / --no-gpg-checks
            # --gpgcheck-allow-unsigned( --gpgcheck-allow-unsigned-repo --gpgcheck-allow-unsigned-package)
            # return "zypper --gpgcheck-allow-unsigned-repo"
            return "zypper"
        return "zypper"
    if "ubuntu" in image:
        # sources.list:
        # deb [ allow-insecure=yes ] # disables but keeps warning
        # deb [ trusted=yes ] # disables GPG
        # --allow-unauthenticated
        # -o APT::Get::AllowUnauthenticated=true
        # -o Acquire::Check-Valid-Until=false
        # -o APT::Ignore::gpg-pubkey
        # -o Acquire::AllowInsecureRepositories=true
        # -o Acquire::AllowDowngradeToInsecureRepositories=true
        if not checks:
            return "apt-get -o Acquire::AllowInsecureRepositories=true"
        return "apt-get"
    if not checks:
        return "yum --setopt=repo_gpgcheck=false"
    return "yum"
def refresh_tool(image: str, checks = False) -> str:
    # https://github.com/openSUSE/docker-containers/issues/64
    #  {package} rr oss-update"
    #  {package} ar -f http://download.opensuse.org/update/leap/42.3/oss/openSUSE:Leap:42.3:Update.repo"
    if "opensuse:42.3" in image:
        cmds = [
            "zypper mr --no-gpgcheck oss-update",
            "zypper refresh"]
        return "bash -c '%s'" % (" && ".join(cmds))
    if "opensuse/leap:15." in image:
        cmds = [
            "zypper mr --no-gpgcheck --all",
            "zypper refresh"]
        return "bash -c '%s'" % (" && ".join(cmds))
    if "opensuse" in image:
        return "zypper refresh"
    if "ubuntu" in image:
        if not checks:
            return "apt-get -o Acquire::AllowInsecureRepositories=true update"
        return "apt-get update"
    if "almalinux" in image:
        cmds = ["echo sslverify=false >> /etc/yum.conf"]
        return "bash -c '%s'" % (" && ".join(cmds))
    return "true"
def python_package(python: str, image: Optional[str] = None) -> str:
    package = os.path.basename(python)
    if package.endswith("2"):
        if image and "centos:8" in image:
            return package
        if image and "ubuntu:2" in image:
            return package
        return package[:-1]
    return package
def coverage_tool(image: Optional[str] = None, python: Optional[str] = None) -> str:
    image = image or IMAGE
    python = python or _python
    if python.endswith("3"):
        return python + " -m coverage"
    else:
        if image and "centos:8" in image:
            return "coverage-2"
    return "coverage2"
def coverage_run(image: Optional[str] = None, python: Optional[str] = None, append: Optional[str] = None) -> str:
    append = append or "--append"
    options = " run '--omit=*/six.py,*/extern/*.py,*/unitconfparser.py' " + append
    return coverage_tool(image, python) + options + " -- "
def coverage_package(image: Optional[str] = None, python: Optional[str] = None) -> str:
    python = python or _python
    package = "python-coverage"
    if python.endswith("3"):
        package = "python3-coverage"
        if image and "centos:8" in image:
            package = "platform-python-coverage"
    else:
        if image and "centos:8" in image:
            package = "python2-coverage"
    logg.info("detect coverage_package for %s => %s (%s)", python, package, image)
    return package
def cover(image: Optional[str] = None, python: Optional[str] = None, append: Optional[str] = None) -> str:
    if not COVERAGE: return ""
    return coverage_run(image, python, append)

def decodes(text: Union[str, bytes, None]) -> str:
    if text is None: return ""
    if isinstance(text, bytes):
        encoded = sys.getdefaultencoding()
        if encoded in ["ascii"]:
            encoded = "utf-8"
        try:
            return text.decode(encoded)
        except:
            return text.decode("latin-1")
    return text
def sh____(cmd: Union[str, List[str]], shell: bool = True) -> int:
    if isinstance(cmd, string_types):
        logg.info(": %s", cmd)
    else:
        logg.info(": %s", " ".join(["'%s'" % item for item in cmd]))
    return subprocess.check_call(cmd, shell=shell)
def sx____(cmd: Union[str, List[str]], shell: bool = True) -> int:
    if isinstance(cmd, string_types):
        logg.info(": %s", cmd)
    else:
        logg.info(": %s", " ".join(["'%s'" % item for item in cmd]))
    return subprocess.call(cmd, shell=shell)
def output(cmd: Union[str, List[str]], shell: bool = True) -> str:
    if isinstance(cmd, string_types):
        logg.info(": %s", cmd)
    else:
        logg.info(": %s", " ".join(["'%s'" % item for item in cmd]))
    run = subprocess.Popen(cmd, shell=shell, stdout=subprocess.PIPE)
    out, err = run.communicate()
    return decodes(out)
def output2(cmd: Union[str, List[str]], shell: bool = True) -> Tuple[str, int]:
    if isinstance(cmd, string_types):
        logg.info(": %s", cmd)
    else:
        logg.info(": %s", " ".join(["'%s'" % item for item in cmd]))
    run = subprocess.Popen(cmd, shell=shell, stdout=subprocess.PIPE)
    out, err = run.communicate()
    return decodes(out), run.returncode
def output3(cmd: Union[str, List[str]], shell: bool = True) -> Tuple[str, str, int]:
    if isinstance(cmd, string_types):
        logg.info(": %s", cmd)
    else:
        logg.info(": %s", " ".join(["'%s'" % item for item in cmd]))
    run = subprocess.Popen(cmd, shell=shell, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    out, err = run.communicate()
    return decodes(out), decodes(err), run.returncode

BackgroundProcess = collections.namedtuple("BackgroundProcess", ["pid", "run", "log"])
def background(cmd: str, shell: bool = True) -> BackgroundProcess:
    log = open(os.devnull, "wb")
    exe = list(shlex.split(cmd))
    run = subprocess.Popen(exe, stdout=log, stderr=log)
    pid = run.pid
    logg.info("PID %s = %s", pid, cmd)
    return BackgroundProcess(pid, run, log)

def reads(filename: str) -> str:
    return decodes(open(filename, "rb").read())
def _lines(lines: Union[str, List[str], Generator[str, None, None], TextIO]) -> List[str]:
    if isinstance(lines, string_types):
        lines = decodes(lines).split("\n")
        if len(lines) and lines[-1] == "":
            lines = lines[:-1]
    return list(lines)
def lines(text: Union[str, List[str], Generator[str, None, None], TextIO]) -> List[str]:
    lines = []
    for line in _lines(text):
        lines.append(line.rstrip())
    return lines
def each_grep(pattern: str, lines: Union[str, List[str], TextIO]) -> Generator[str, None, None]:
    for line in _lines(lines):
        if re.search(pattern, line.rstrip()):
            yield line.rstrip()
def grep(pattern: str, lines: Union[str, List[str], TextIO]) -> List[str]:
    return list(each_grep(pattern, lines))
def greps(lines: Union[str, List[str], TextIO], pattern: str) -> List[str]:
    return list(each_grep(pattern, lines))
def running(lines: Union[str, List[str]]) -> List[str]:
    return list(each_non_runuser(each_non_defunct(lines)))
def each_non_defunct(lines: Union[str, List[str], Generator[str, None, None]]) -> Generator[str, None, None]:
    for line in _lines(lines):
        if '<defunct>' in line:
            continue
        yield line
def each_non_runuser(lines: Union[str, List[str], Generator[str, None, None]]) -> Generator[str, None, None]:
    for line in _lines(lines):
        if 'runuser -u' in line:
            continue
        yield line
def each_clean(lines: Union[str, List[str]]) -> Generator[str, None, None]:
    for line in _lines(lines):
        if '<defunct>' in line:
            continue
        if 'runuser -u' in line:
            continue
        if 'ps -eo pid,' in line:
            continue
        yield line
def clean(lines: Union[str, List[str]]) -> str:
    return " " + "\n ".join(each_clean(lines))

def i2(part: str, indent: str = "  ") -> str:
    if isinstance(part, string_types):
        if "\n" in part.strip():
            lines = part.strip().split("\n")
            text = indent
            newline = "\n" + indent
            text += newline.join(lines)
            if part.endswith("\n"):
                text += "\n"
            return text
    return part
def o22(part: str) -> str:
    return only22(part)
def oi22(part: str) -> str:
    return only22(part, indent="  ")
def only22(part: str, indent: str = "") -> str:
    if isinstance(part, string_types):
        if "\n" in part.strip():
            lines = part.strip().split("\n")
            if len(lines) <= 22:
                return part
            skipped = len(lines) - 22 + 3
            real = lines[:5] + ["...", "... (%s lines skipped)" % skipped, "..."] + lines[-14:]
            text = indent
            newline = "\n" + indent
            text += newline.join(real)
            if part.endswith("\n"):
                text += "\n"
            return text
    if isinstance(part, string_types):
        if len(part) <= 22:
            return part
        return part[:5] + "..." + part[-14:]
    if isinstance(part, list):
        if len(part) <= 22:
            return part
        skipped = len(part) - 22 + 3
        return part[:5] + ["...", "... (%s lines skipped)" % skipped, "..."] + part[-14:]
    return part

def get_USER_ID(root: bool = False) -> int:
    ID = 0
    if root: return ID
    return os.geteuid()
def get_USER(root: bool = False) -> str:
    if root: return "root"
    uid = os.geteuid()
    import pwd
    return pwd.getpwuid(uid).pw_name
def get_GROUP_ID(root: bool = False) -> int:
    ID = 0
    if root: return ID
    return os.getegid()
def get_GROUP(root: bool = False) -> str:
    if root: return "root"
    import grp
    gid = os.getegid()
    import grp
    return grp.getgrgid(gid).gr_name
def get_LASTGROUP_ID(root: bool = False) -> int:
    if root: return 0 # only there is
    current = os.getegid()
    lastgid = current
    for gid in os.getgroups():
        if gid != current:
            lastgid = gid
    return gid
def get_LASTGROUP(root: bool = False) -> str:
    if root: return "root" # only there is
    gid = get_LASTGROUP_ID(root)
    import grp
    return grp.getgrgid(gid).gr_name

def beep() -> None:
    if os.name == "nt":
        import winsound # type: ignore
        frequency = 2500
        duration = 1000
        winsound.Beep(frequency, duration)
    else:
        # using 'sox' on Linux as "\a" is usually disabled
        # sx___("play -n synth 0.1 tri  1000.0")
        sx____("play -V1 -q -n -c1 synth 0.1 sine 500")

def get_proc_started(pid: int) -> float:
    """ get time process started after boot in clock ticks"""
    proc = "/proc/%s/stat" % pid
    return path_proc_started(proc)
def path_proc_started(proc: str) -> float:
    """ get time process started after boot in clock ticks"""
    if not os.path.exists(proc):
        logg.error("no such file %s", proc)
        return 0
    else:
        with open(proc, "rb") as f:
            data = f.readline()
        f.closed
        stat_data = data.split()
        started_ticks = stat_data[21]
        # man proc(5): "(22) starttime = The time the process started after system boot."
        #    ".. the value is expressed in clock ticks (divide by sysconf(_SC_CLK_TCK))."
        # NOTE: for containers the start time is related to the boot time of host system.

        clkTickInt = os.sysconf_names['SC_CLK_TCK']
        clockTicksPerSec = os.sysconf(clkTickInt)
        started_secs = float(started_ticks) / clockTicksPerSec
        logg.debug("Proc started time: %.3f (%s)", started_secs, proc)
        # this value is the start time from the host system

        # Variant 1:
        system_uptime = "/proc/uptime"
        with open(system_uptime, "rb") as f:
            data = f.readline()
        f.closed
        uptime_data = decodes(data).split()
        uptime_secs = float(uptime_data[0])
        logg.debug("System uptime secs: %.3f (%s)", uptime_secs, system_uptime)

        # get time now
        now = time.time()
        started_time = now - (uptime_secs - started_secs)
        logg.debug("Proc has been running since: %s" % (datetime.datetime.fromtimestamp(started_time)))

        # Variant 2:
        system_stat = "/proc/stat"
        system_btime = 0.
        with open(system_stat, "rb") as f:
            for line in f:
                if line.startswith(b"btime"):
                    system_btime = float(decodes(line).split()[1])
        f.closed
        logg.debug("System btime secs: %.3f (%s)", system_btime, system_stat)

        started_btime = system_btime + started_secs
        logg.debug("Proc has been running since: %s" % (datetime.datetime.fromtimestamp(started_btime)))

        # return started_time
        return started_btime

def download(base_url: str, filename: str, into: str) -> None:
    if not os.path.isdir(into):
        os.makedirs(into)
    if not os.path.exists(os.path.join(into, filename)):
        sh____("cd {into} && wget {base_url}/{filename}".format(**locals()))
def text_file(filename: str, content: str) -> None:
    filedir = os.path.dirname(filename)
    if not os.path.isdir(filedir):
        os.makedirs(filedir)
    f = open(filename, "w")
    if content.startswith("\n"):
        x = re.match("(?s)\n( *)", content)
        assert x is not None
        indent = x.group(1)
        for line in content[1:].split("\n"):
            if line.startswith(indent):
                line = line[len(indent):]
            f.write(line+"\n")
    else:
        f.write(content)
    f.close()
    logg.info("::: made %s", filename)
def shell_file(filename: str, content: str) -> None:
    text_file(filename, content)
    os.chmod(filename, 0o775)
def copy_file(filename: str, target: str) -> None:
    targetdir = os.path.dirname(target)
    if not os.path.isdir(targetdir):
        os.makedirs(targetdir)
    shutil.copyfile(filename, target)
def copy_tool(filename: str, target: str) -> None:
    copy_file(filename, target)
    os.chmod(target, 0o755)

def get_caller_name() -> str:
    currentframe = inspect.currentframe()
    if not currentframe: return "global"
    frame = currentframe.f_back.f_back
    return frame.f_code.co_name
def get_caller_caller_name() -> str:
    currentframe = inspect.currentframe()
    if not currentframe: return "global"
    frame = currentframe.f_back.f_back.f_back
    return frame.f_code.co_name
# def os_path(root: Optional[str], path: Optional[str]) -> Optional[str]:
def os_path(root: Optional[str], path: str) -> str:
    if not root:
        return path
    if not path:
        return path
    while path.startswith(os.path.sep):
        path = path[1:]
    return os.path.join(root, path)
def os_getlogin() -> str:
    """ NOT using os.getlogin() """
    import pwd
    return pwd.getpwuid(os.geteuid()).pw_name
def os_remove(path: str) -> None:
    if os.path.exists(path):
        os.remove(path)
def get_runtime_dir() -> str:
    explicit = os.environ.get("XDG_RUNTIME_DIR", "")
    if explicit: return explicit
    user = os_getlogin()
    return "/tmp/run-"+user
def docname(path: str) -> str:
    return os.path.splitext(os.path.basename(path))[0]

SYSTEMCTL_DEBUG_LOG = "{LOG}/systemctl.debug.log"
SYSTEMCTL_EXTRA_LOG = "{LOG}/systemctl.log"

def get_home() -> str:
    return os.path.expanduser("~")              # password directory. << from docs(os.path.expanduser)
def get_HOME(root: bool = False) -> str:
    if root: return "/root"
    return get_home()
def get_RUNTIME_DIR(root: bool = False) -> str:
    RUN = "/run"
    if root: return RUN
    return os.environ.get("XDG_RUNTIME_DIR", get_runtime_dir())
def get_CONFIG_HOME(root: bool = False) -> str:
    CONFIG = "/etc"
    if root: return CONFIG
    HOME = get_HOME(root)
    return os.environ.get("XDG_CONFIG_HOME", HOME + "/.config")
def get_LOG_DIR(root: bool = False) -> str:
    LOGDIR = "/var/log"
    if root: return LOGDIR
    CONFIG = get_CONFIG_HOME(root)
    return os.path.join(CONFIG, "log")
def expand_path(path: str, root: bool = True) -> str:
    LOG = get_LOG_DIR(root)
    XDG_CONFIG_HOME=get_CONFIG_HOME(root)
    XDG_RUNTIME_DIR=get_RUNTIME_DIR(root)
    return os.path.expanduser(path.replace("${", "{").format(**locals()))

############ local mirror helpers #############
def ip_container(name: str) -> str:
    docker = _docker
    values = output("{docker} inspect {name}".format(**locals()))
    values = json.loads(values)
    if not values or "NetworkSettings" not in values[0]:
        logg.critical(" %s inspect %s => %s ", docker, name, values)
    return values[0]["NetworkSettings"]["IPAddress"] # type: ignore
def detect_local_system() -> str:
    """ checks the controller host (a real machine / your laptop)
        and returns a matching image name for it (docker style) """
    docker = _docker
    mirror = _mirror
    cmd = "{mirror} detect"
    out = output(cmd.format(**locals()))
    return decodes(out).strip()

############ the real testsuite ##############

class DockerSystemctlReplacementTest(unittest.TestCase):
    def caller_testname(self) -> str:
        name = get_caller_caller_name()
        x1 = name.find("_")
        if x1 < 0: return name
        x2 = name.find("_", x1+1)
        if x2 < 0: return name
        return name[:x2]
    def testname(self, suffix: Optional[str] = None) -> str:
        name = self.caller_testname()
        if suffix:
            return name + "_" + suffix
        return name
    def testport(self) -> int:
        testname = self.caller_testname()
        m = re.match("test_([0123456789]+)", testname)
        if m:
            port = int(m.group(1))
            if 4000 <= port and port <= 9999:
                return port
        seconds = int(str(int(time.time()))[-4:])
        return 6000 + (seconds % 2000)
    def testdir(self, testname: Optional[str] = None, keep: bool = False) -> str:
        testname = testname or self.caller_testname()
        newdir = "tmp/tmp."+testname
        if os.path.isdir(newdir) and not keep:
            shutil.rmtree(newdir)
        if not os.path.isdir(newdir):
            os.makedirs(newdir)
        return newdir
    def rm_testdir(self, testname: Optional[str] = None) -> str:
        testname = testname or self.caller_testname()
        newdir = "tmp/tmp."+testname
        if os.path.isdir(newdir):
            if not KEEP:
                shutil.rmtree(newdir)
        return newdir
    def rm_docker(self, testname: str) -> None:
        docker = _docker
        if not KEEP:
            sx____("{docker} stop -t 6 {testname}".format(**locals()))
            sx____("{docker} rm -f {testname}".format(**locals()))
    def killall(self, what: str, wait: Optional[int] = None, sig: Optional[int] = None, but: Optional[List[str]] = None) -> None:
        # logg.info("killall %s (but %s)", what, but)
        killed = 0
        if True:
            for nextpid in os.listdir("/proc"):
                try: pid = int(nextpid)
                except: continue
                cmdline = "/proc/{pid}/cmdline".format(**locals())
                try:
                    cmd = open(cmdline).read().replace("\0", " ")
                    if fnmatch(cmd, what):
                        found = [name for name in (but or []) if name in cmd]
                        if found: continue
                        logg.info(" kill {pid} # {cmd}".format(**locals()))
                        os.kill(pid, sig or signal.SIGINT)
                        killed += 1
                except IOError as e:
                    if e.errno != errno.ENOENT:
                        logg.info(" killing %s", e)
                except Exception as e:
                    logg.info(" killing %s", e)
        for checking in xrange(int(wait or KILLWAIT)):
            remaining = 0
            for nextpid in os.listdir("/proc"):
                try: pid = int(nextpid)
                except: continue
                cmdline = "/proc/{pid}/cmdline".format(**locals())
                try:
                    cmd = open(cmdline).read().replace("\0", " ")
                    if fnmatch(cmd, what):
                        found = [name for name in (but or []) if name in cmd]
                        if found: continue
                        remaining += 1
                except IOError as e:
                    if e.errno != errno.ENOENT:
                        logg.info(" killing %s", e)
                except Exception as e:
                    logg.info(" killing %s", e)
            if not remaining:
                return
            if checking % 2 == 0:
                logg.info("[%02is] remaining %s", checking, remaining)
            time.sleep(1)
        if True:
            for nextpid in os.listdir("/proc"):
                try: pid = int(nextpid)
                except: continue
                cmdline = "/proc/{pid}/cmdline".format(**locals())
                try:
                    cmd = open(cmdline).read().replace("\0", " ")
                    if fnmatch(cmd, what):
                        found = [name for name in (but or []) if name in cmd]
                        if found: continue
                        logg.info(" kill {pid} # {cmd}".format(**locals()))
                        os.kill(pid, sig or signal.SIGKILL)
                        killed += 1
                except IOError as e:
                    if e.errno != errno.ENOENT:
                        logg.info(" killing %s", e)
                except Exception as e:
                    logg.info(" killing %s", e)
    def rm_killall(self, testname: Optional[str] = None) -> None:
        self.killall("*systemctl*.py *", 10, but = ["edit ", "testsuite.py "])
        testname = testname or self.caller_testname()
        self.killall("*/{testname}_*".format(**locals()))
    def kill(self, pid: Union[str, int], wait: Optional[int] = None, sig: Optional[int] = None) -> bool:
        pid = int(pid)
        cmdline = "/proc/{pid}/cmdline".format(**locals())
        if True:
            try:
                if os.path.exists(cmdline):
                    cmd = open(cmdline).read().replace("\0", " ").strip()
                    logg.info(" kill {pid} # {cmd}".format(**locals()))
                    os.kill(pid, sig or signal.SIGINT)
            except IOError as e:
                if e.errno != errno.ENOENT:
                    logg.info(" killing %s", e)
            except Exception as e:
                logg.info(" killing %s", e)
        status = "/proc/{pid}/status".format(**locals())
        for checking in xrange(int(wait or KILLWAIT)):
            if not os.path.exists(cmdline):
                return True
            try:
                if os.path.exists(status):
                    for line in open(status):
                        if line.startswith("State:"):
                            if "(zombie)" in line:
                                return True
                            if checking % 2 == 0:
                                logg.info("[%02is] wait %s - %s", checking, pid, line.strip())
            except IOError as e:
                if e.errno != errno.ENOENT:
                    logg.info(" killing %s", e)
            except Exception as e:
                logg.info(" killing %s", e)
            time.sleep(1)
        logg.warning("not killed %s", pid)
        return False
    def makedirs(self, path: str) -> None:
        if not os.path.isdir(path):
            os.makedirs(path)
    def real_folders(self) -> Generator[str, None, None]:
        yield "/etc/systemd/system"
        yield "/var/run/systemd/system"
        yield "/usr/lib/systemd/system"
        yield "/lib/systemd/system"
        yield "/etc/init.d"
        yield "/var/run/init.d"
        yield "/var/run"
        yield "/etc/sysconfig"
        yield "/etc/systemd/system/multi-user.target.wants"
        yield "/usr/bin"
        yield "/bin"
    def rm_zzfiles(self, root: Optional[str]) -> None:
        for folder in self.real_folders():
            for item in glob(os_path(root, folder + "/zz*")):
                if os.path.isdir(item):
                    logg.info("rmtree %s", item)
                    shutil.rmtree(item)
                else:
                    logg.info("rm %s", item)
                    os.remove(item)
            for item in glob(os_path(root, folder + "/test_*")):
                if os.path.isdir(item):
                    logg.info("rmtree %s", item)
                    shutil.rmtree(item)
                else:
                    logg.info("rm %s", item)
                    os.remove(item)
    def coverage(self, testname: Optional[str] = None) -> None:
        testname = testname or self.caller_testname()
        newcoverage = ".coverage."+testname
        time.sleep(1)
        if os.path.isfile(".coverage"):
            # shutil.copy(".coverage", newcoverage)
            f = open(".coverage", "rb")
            text = f.read()
            f.close()
            text2 = re.sub(rb"(\]\}\})[^{}]*(\]\}\})$", rb"\1", text)
            f = open(newcoverage, "wb")
            f.write(text2)
            f.close()
    def root(self, testdir: str, real: bool = False) -> str:
        if real: return "/"
        root_folder = os.path.join(testdir, "root")
        if not os.path.isdir(root_folder):
            os.makedirs(root_folder)
        return os.path.abspath(root_folder)
    def socat(self) -> str:
        if False and os.path.exists("/usr/bin/socat"):
            return "/usr/bin/socat"
        else:
            here = os.path.abspath(os.path.dirname(sys.argv[0]))
            return os.path.join(here, "reply.py")
    def newpassword(self) -> str:
        out = "Password."
        out += random.choice(string.ascii_uppercase)
        out += random.choice(string.ascii_lowercase)
        out += random.choice(string.ascii_lowercase)
        out += random.choice(string.ascii_lowercase)
        out += random.choice(string.ascii_lowercase)
        out += random.choice(",.-+")
        out += random.choice("0123456789")
        out += random.choice("0123456789")
        return out
    def user(self) -> str:
        return os_getlogin()
    def ip_container(self, name: str) -> str:
        values = output("docker inspect "+name)
        values = json.loads(values)
        if not values or "NetworkSettings" not in values[0]:
            logg.critical(" docker inspect %s => %s ", name, values)
        return values[0]["NetworkSettings"]["IPAddress"] # type: ignore
    def local_image(self, image: str) -> str:
        """ attach local centos-repo / opensuse-repo to docker-start enviroment.
            Effectivly when it is required to 'docker start centos:x.y' then do
            'docker start centos-repo:x.y' before and extend the original to
            'docker start --add-host mirror...:centos-repo centos:x.y'. """
        if os.environ.get("NONLOCAL", ""):
            return image
        add_hosts = self.start_mirror(image)
        if add_hosts:
            return "{add_hosts} {image}".format(**locals())
        return image
    def local_addhosts(self, dockerfile: str) -> str:
        image = ""
        for line in open(dockerfile):
            m = re.match('[Ff][Rr][Oo][Mm] *"([^"]*)"', line)
            if m:
                image = m.group(1)
                break
            m = re.match("[Ff][Rr][Oo][Mm] *(\w[^ ]*)", line)
            if m:
                image = m.group(1).strip()
                break
        logg.debug("--\n-- '%s' FROM '%s'", dockerfile, image)
        if image:
            return self.start_mirror(image)
        return ""
    def start_mirror(self, image: str) -> str:
        docker = _docker
        mirror = _mirror
        cmd = "{mirror} start {image} --add-hosts"
        out = output(cmd.format(**locals()))
        return decodes(out).strip()
    def drop_container(self, name: str) -> None:
        docker = _docker
        sx____("{docker} rm --force {name}".format(**locals()))
    def drop_centos(self) -> None:
        self.drop_container("centos")
    def drop_ubuntu(self) -> None:
        self.drop_container("ubuntu")
    def drop_opensuse(self) -> None:
        self.drop_container("opensuse")
    def make_opensuse(self) -> None:
        self.make_container("opensuse", OPENSUSE)
    def make_ubuntu(self) -> None:
        self.make_container("ubuntu", UBUNTU)
    def make_centos(self) -> None:
        self.make_container("centos", CENTOS)
    def make_container(self, name: str, image: str) -> None:
        docker = _docker
        self.drop_container(name)
        local_image = self.local_image(image)
        cmd = "{docker} run --detach --name {name} {local_image} sleep 1000"
        sh____(cmd.format(**locals()))
        print("                 # {local_image}".format(**locals()))
        print("  {docker} exec -it {name} bash".format(**locals()))
    def begin(self) -> str:
        self._started = time.time()
        logg.info("[[%s]]", datetime.datetime.fromtimestamp(self._started).strftime("%H:%M:%S"))
        return "-vv"
    def end(self, maximum: int = 99) -> None:
        runtime = time.time() - self._started
        self.assertLess(runtime, maximum * LONGER)
    #
    # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
    #
    def test_1001_systemctl_testfile(self) -> None:
        """ the systemctl.py file to be tested does exist """
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        logg.info("...")
        logg.info("testname %s", testname)
        logg.info(" testdir %s", testdir)
        logg.info("and root %s", root)
        target = "/usr/bin/systemctl"
        target_folder = os_path(root, os.path.dirname(target))
        os.makedirs(target_folder)
        target_systemctl = os_path(root, target)
        shutil.copy(_systemctl_py, target_systemctl)
        self.assertTrue(os.path.isfile(target_systemctl))
        self.rm_testdir()
        self.coverage()
    def test_1002_systemctl_version(self) -> None:
        systemctl = cover() + _systemctl_py
        cmd = "{systemctl} --version"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, "systemd 219"))
        self.assertTrue(greps(out, "via systemctl.py"))
        self.assertTrue(greps(out, "[+]SYSVINIT"))
        self.coverage()
    def real_1002_systemctl_version(self) -> None:
        cmd = "systemctl --version"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"systemd [234]\d\d"))
        self.assertFalse(greps(out, "via systemctl.py"))
        self.assertTrue(greps(out, "[+]SYSVINIT"))
    def test_1003_systemctl_help(self) -> None:
        """ the '--help' option and 'help' command do work """
        systemctl = cover() + _systemctl_py
        cmd = "{systemctl} --help"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, "--root=PATH"))
        self.assertTrue(greps(out, "--verbose"))
        self.assertTrue(greps(out, "--init"))
        self.assertTrue(greps(out, "for more information"))
        self.assertFalse(greps(out, "reload-or-try-restart"))
        cmd = "{systemctl} help"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertFalse(greps(out, "--verbose"))
        self.assertTrue(greps(out, "reload-or-try-restart"))
        self.coverage()
    def test_1005_systemctl_help_command(self) -> None:
        """ for any command, 'help command' shows the documentation """
        systemctl = cover() + _systemctl_py
        cmd = "{systemctl} help list-unit-files"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s\n%s", cmd, out)
        self.assertEqual(end, 0)
        self.assertFalse(greps(out, "for more information"))
        self.assertTrue(greps(out, "--type=service"))
        self.coverage()
    def test_1006_systemctl_help_command_other(self) -> None:
        """ for a non-existant command, 'help command' just shows the list """
        systemctl = cover() + _systemctl_py
        cmd = "{systemctl} help list-foo"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s\n%s", cmd, out)
        self.assertEqual(end, 1)
        self.assertFalse(greps(out, "for more information"))
        self.assertFalse(greps(out, "reload-or-try-restart"))
        self.assertTrue(greps(out, "no such command"))
        self.coverage()
    def test_1009_systemctl_help_command_without_doc(self) -> None:
        """ for a command without doc, 'help command' is empty """
        systemctl = cover() + _systemctl_py
        cmd = "{systemctl} help __test_float -vvvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info("%s\n%s\n%s", cmd, out, err)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "")
        self.assertTrue(greps(err, "__doc__ of __test_float is none"))
        self.coverage()
    def test_1010_systemctl_daemon_reload(self) -> None:
        """ daemon-reload always succeeds (does nothing) """
        systemctl = cover() + _systemctl_py
        cmd = "{systemctl} daemon-reload"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(lines(out), [])
        self.assertEqual(end, 0)
        self.coverage()
    def real_1011_systemctl_daemon_reload_root_ignored(self) -> None:
        self.test_1011_systemctl_daemon_reload_root_ignored(True)
    def test_1011_systemctl_daemon_reload_root_ignored(self, real: bool = False) -> None:
        """ daemon-reload always succeeds (does nothing) """
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: systemctl = "/usr/bin/systemctl"
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            ExecStart=/bin/sleep 3
        """)
        #
        cmd = "{systemctl} daemon-reload"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(lines(out), [])
        self.assertEqual(end, 0)
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
    def test_1020_systemctl_with_systemctl_log(self) -> None:
        """ when /var/log/systemctl.log exists then print INFO messages into it"""
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/systemctl.log")
        text_file(logfile, "")
        #
        cmd = "{systemctl} daemon-reload"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        log = reads(logfile)
        logg.info("systemctl.log>>\n%s", log)
        self.assertEqual(end, 0)
        self.assertEqual(len(greps(log, " INFO ")), 1)
        self.assertEqual(len(greps(log, " DEBUG ")), 0)
        self.rm_testdir()
        self.coverage()
    def test_1021_systemctl_with_systemctl_debug_log(self) -> None:
        """ when /var/log/systemctl.debug.log exists then print DEBUG messages into it"""
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/systemctl.debug.log")
        text_file(logfile, "")
        #
        cmd = "{systemctl} daemon-reload"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        log = reads(logfile)
        logg.info("systemctl.log>>\n%s", log)
        self.assertEqual(end, 0)
        self.assertEqual(len(greps(log, " INFO ")), 1)
        self.assertEqual(len(greps(log, " DEBUG ")), 3)
        self.rm_testdir()
        self.coverage()
    def test_1022_systemctl_with_systemctl_debug_level(self) -> None:
        """ when /var/log/systemctl.debug.log exists then print DEBUG messages into it"""
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        systemctl += " -vvvv"
        logfile = os_path(root, "/var/log/systemctl.log")
        text_file(logfile, "")
        #
        cmd = "{systemctl} daemon-reload"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        log = lines(open(logfile))
        logg.info("LOG=>\n %s", "\n ".join(log))
        self.assertEqual(len(greps(open(logfile), " INFO ")), 1)
        self.assertEqual(len(greps(open(logfile), " DEBUG ")), 3)
        self.rm_testdir()
        self.coverage()
    def test_1030_systemctl_force_ipv4(self) -> None:
        """ we can force --ipv4 for /etc/hosts """
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/hosts"), """
            127.0.0.1 localhost localhost4
            ::1 localhost localhost6""")
        hosts = reads(os_path(root, "/etc/hosts"))
        self.assertEqual(len(lines(hosts)), 2)
        self.assertTrue(greps(hosts, "127.0.0.1.*localhost4"))
        self.assertTrue(greps(hosts, "::1.*localhost6"))
        self.assertTrue(greps(hosts, "127.0.0.1.*localhost "))
        self.assertTrue(greps(hosts, "::1.*localhost "))
        #
        cmd = "{systemctl} --ipv4 daemon-reload"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(lines(out), [])
        self.assertEqual(end, 0)
        hosts = reads(os_path(root, "/etc/hosts"))
        self.assertEqual(len(lines(hosts)), 2)
        self.assertTrue(greps(hosts, "127.0.0.1.*localhost4"))
        self.assertTrue(greps(hosts, "::1.*localhost6"))
        self.assertTrue(greps(hosts, "127.0.0.1.*localhost "))
        self.assertFalse(greps(hosts, "::1.*localhost "))
        self.rm_testdir()
        self.coverage()
    def test_1031_systemctl_force_ipv6(self) -> None:
        """ we can force --ipv6 for /etc/hosts """
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/hosts"), """
            127.0.0.1 localhost localhost4
            ::1 localhost localhost6""")
        hosts = reads(os_path(root, "/etc/hosts"))
        self.assertEqual(len(lines(hosts)), 2)
        self.assertTrue(greps(hosts, "127.0.0.1.*localhost4"))
        self.assertTrue(greps(hosts, "::1.*localhost6"))
        self.assertTrue(greps(hosts, "127.0.0.1.*localhost "))
        self.assertTrue(greps(hosts, "::1.*localhost "))
        #
        cmd = "{systemctl} --ipv6 daemon-reload"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(lines(out), [])
        self.assertEqual(end, 0)
        hosts = reads(os_path(root, "/etc/hosts"))
        self.assertEqual(len(lines(hosts)), 2)
        self.assertTrue(greps(hosts, "127.0.0.1.*localhost4"))
        self.assertTrue(greps(hosts, "::1.*localhost6"))
        self.assertFalse(greps(hosts, "127.0.0.1.*localhost "))
        self.assertTrue(greps(hosts, "::1.*localhost "))
        self.rm_testdir()
        self.coverage()
    def test_1040_systemctl_override_str_config(self) -> None:
        """ we can use -c name=something to override internals """
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            ExecStart=/bin/sleep 3
        """)
        #
        cmd = "{systemctl} daemon-reload -c SysInitTarget=network.target -vvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertEqual(lines(out), [])
        self.assertEqual(end, 0)
        self.assertEqual(len(greps(err, "SysInitTarget=network.target")), 2)
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
    def test_1041_systemctl_override_int_config(self) -> None:
        """ we can use -c name=something to override internals """
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            ExecStart=/bin/sleep 3
        """)
        #
        cmd = "{systemctl} daemon-reload -c InitLoopSleep=1 -vvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertEqual(lines(out), [])
        self.assertEqual(end, 0)
        self.assertEqual(len(greps(err, "InitLoopSleep=1")), 2)
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
    def test_1042_systemctl_override_num_config(self) -> None:
        """ we can use -c name=something to override internals """
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            ExecStart=/bin/sleep 3
        """)
        #
        cmd = "{systemctl} daemon-reload -c MinimumYield=0.7 -vvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertEqual(lines(out), [])
        self.assertEqual(end, 0)
        self.assertEqual(len(greps(err, "MinimumYield=0.7")), 2)
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
    def test_1043_systemctl_override_true_config(self) -> None:
        """ we can use -c name=something to override internals """
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            ExecStart=/bin/sleep 3
        """)
        #
        cmd = "{systemctl} daemon-reload -c _show_all=True -vvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertEqual(lines(out), [])
        self.assertEqual(end, 0)
        self.assertEqual(len(greps(err, "_show_all=True")), 2)
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
    def test_1044_systemctl_override_list_config(self) -> None:
        """ we can use -c name=something to override internals """
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            ExecStart=/bin/sleep 3
        """)
        #
        cmd = "{systemctl} daemon-reload -c _extra_vars=1,2 -vvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertEqual(lines(out), [])
        self.assertEqual(end, 0)
        self.assertEqual(len(greps(err, "_extra_vars=.'1', '2'.")), 1)
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
    def test_1045_systemctl_override_fail_unknown_config(self) -> None:
        """ we can use -c name=something to override internals """
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            ExecStart=/bin/sleep 3
        """)
        #
        cmd = "{systemctl} daemon-reload -c FooBar=1 -vvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertEqual(lines(out), [])
        self.assertEqual(end, 0)
        self.assertTrue(greps(err, "unknown target config -c 'FooBar'"))
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
    def test_1046_systemctl_override_fail_unknown_type(self) -> None:
        """ we can use -c name=something to override internals """
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            ExecStart=/bin/sleep 3
        """)
        #
        cmd = "{systemctl} daemon-reload -c target_requires=1 -vvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertEqual(lines(out), [])
        self.assertEqual(end, 0)
        self.assertTrue(greps(err, "unknown target type -c 'target_requires'.*'dict'>"))
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
    def test_1047_systemctl_override_fail_unknown_setting(self) -> None:
        """ we can use -c name=something to override internals """
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            ExecStart=/bin/sleep 3
        """)
        #
        cmd = "{systemctl} daemon-reload -c SomeNonsenseHere -vvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertEqual(lines(out), [])
        self.assertEqual(end, 0)
        self.assertTrue(greps(err, "unknown target config -c 'SomeNonsenseHere'"))
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
    def test_1050_can_create_a_test_service(self) -> None:
        """ check that a unit file can be created for testing """
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A""")
        textA = reads(os_path(root, "/etc/systemd/system/zza.service"))
        self.assertTrue(greps(textA, "Testing A"))
        self.assertIn("\nDescription", textA)
        self.rm_testdir()
        self.coverage()
    def test_1051_can_parse_the_service_file(self) -> None:
        """ check that a unit file can be parsed atleast for a description """
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A""")
        textA = reads(os_path(root, "/etc/systemd/system/zza.service"))
        self.assertTrue(greps(textA, "Testing A"))
        cmd = "{systemctl} __get_description zza.service"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s => \n%s", cmd, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, "Testing A"))
        self.rm_testdir()
        self.coverage()
    def test_1052_can_describe_a_pid_file(self) -> None:
        """ check that a unit file can have a specific pdi file """
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            PIDFile=/var/run/foo.pid
            """)
        textA = reads(os_path(root, "/etc/systemd/system/zza.service"))
        self.assertTrue(greps(textA, "Testing A"))
        self.assertTrue(greps(textA, "PIDFile="))
        cmd = "{systemctl} __get_pid_file zza.service"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s => \n%s", cmd, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, "/run/foo.pid"))
        self.rm_testdir()
        self.coverage()
    def test_1053_can_have_default_pid_file_for_simple_service(self) -> None:
        """ check that a unit file has a default pid file for simple services """
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            """)
        textA = reads(os_path(root, "/etc/systemd/system/zza.service"))
        self.assertTrue(greps(textA, "Testing A"))
        self.assertFalse(greps(textA, "PIDFile="))
        cmd = "{systemctl} __get_pid_file zza.service"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s => \n%s", cmd, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, "/run/zza.service.status"))
        self.rm_testdir()
        self.coverage()
    def test_1055_other_services_use_a_status_file(self) -> None:
        """ check that other unit files may have a default status file """
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=oneshot
            """)
        textA = reads(os_path(root, "/etc/systemd/system/zza.service"))
        self.assertTrue(greps(textA, "Testing A"))
        self.assertFalse(greps(textA, "PIDFile="))
        cmd = "{systemctl} __get_status_file zza.service"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s => \n%s", cmd, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, "/run/zza.service.status"))
        self.rm_testdir()
        self.coverage()
    def test_1060_can_have_shell_like_commments(self) -> None:
        """ check that a unit file can have comment lines with '#' """
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            #PIDFile=/var/run/zzfoo.pid
            """)
        textA = reads(os_path(root, "/etc/systemd/system/zza.service"))
        self.assertTrue(greps(textA, "Testing A"))
        self.assertTrue(greps(textA, "PIDFile="))
        cmd = "{systemctl} __get_pid_file zza.service"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s => \n%s", cmd, out)
        self.assertEqual(end, 0)
        self.assertFalse(greps(out, "/run/zzfoo.pid"))
        self.assertTrue(greps(out, "/run/zza.service.status"))
        self.rm_testdir()
        self.coverage()
    def test_1061_can_have_winini_like_commments(self) -> None:
        """ check that a unit file can have comment lines with ';' """
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            ;PIDFile=/var/run/zzfoo.pid
            """)
        textA = reads(os_path(root, "/etc/systemd/system/zza.service"))
        self.assertTrue(greps(textA, "Testing A"))
        self.assertTrue(greps(textA, "PIDFile="))
        cmd = "{systemctl} __get_pid_file zza.service"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s => \n%s", cmd, out)
        self.assertEqual(end, 0)
        self.assertFalse(greps(out, "/run/zzfoo.pid"))
        self.assertTrue(greps(out, "/run/zza.service.status"))
        self.rm_testdir()
        self.coverage()
    def test_1062_can_have_multi_line_settings_with_linebreak_mark(self) -> None:
        """ check that a unit file can have settings with '\\' at the line end """
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A \
                which is quite special
            [Service]
            PIDFile=/var/run/zzfoo.pid
            ExecStart=sleep \\
                2 \\

            """)
        textA = reads(os_path(root, "/etc/systemd/system/zza.service"))
        self.assertTrue(greps(textA, "Testing A"))
        self.assertTrue(greps(textA, "quite special"))
        self.assertTrue(greps(textA, "PIDFile="))
        self.assertTrue(greps(textA, "ExecStart="))
        cmd = "{systemctl} __get_description zza.service"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s => \n%s", cmd, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, "Testing A"))
        self.assertTrue(greps(out, "quite special"))
        cmd = "{systemctl} command zza.service"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s => \n%s", cmd, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(lines(out)), 3)
        self.assertTrue(greps(out, "sleep \\\\"))
        cmd = "{systemctl} __get_pid_file zza.service"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s => \n%s", cmd, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, "/run/zzfoo.pid"))
        self.rm_testdir()
        self.coverage()
    def test_1063_but_a_missing_linebreak_is_a_syntax_error(self) -> None:
        """ check that a unit file can have 'bad ini' lines throwing an exception """
        # the original systemd daemon would ignore services with syntax errors
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
                which is quite special
            [Service]
            PIDFile=/var/run/zzfoo.pid
            """)
        textA = reads(os_path(root, "/etc/systemd/system/zza.service"))
        self.assertTrue(greps(textA, "Testing A"))
        self.assertTrue(greps(textA, "quite special"))
        self.assertTrue(greps(textA, "PIDFile="))
        cmd = "{systemctl} __get_description zza.service"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s => \n%s", cmd, out)
        self.assertEqual(end, 0)
        self.assertFalse(greps(out, "Testing A"))
        self.assertFalse(greps(out, "quite special"))
        cmd = "{systemctl} __get_pid_file zza.service"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s => \n%s", cmd, out)
        self.assertEqual(end, 0)
        self.assertFalse(greps(out, "/run/zzfoo.pid"))
        self.rm_testdir()
        self.coverage()
    def test_1070_external_env_files_can_be_parsed(self) -> None:
        """ check that a unit file can have a valid EnvironmentFile for settings """
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
                which is quite special
            [Service]
            EnvironmentFile=/etc/sysconfig/zza.conf
            """)
        text_file(os_path(root, "/etc/sysconfig/zza.conf"), """
            CONF1=a1
            CONF2="b2"
            CONF3='c3'
            #CONF4=b4
            """)
        cmd = "{systemctl} __read_env_file /etc/sysconfig/zza.conf -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s => \n%s", cmd, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, "CONF1"))
        self.assertTrue(greps(out, "CONF2"))
        self.assertTrue(greps(out, "CONF3"))
        self.assertFalse(greps(out, "CONF4"))
        self.assertTrue(greps(out, "a1"))
        self.assertTrue(greps(out, "b2"))
        self.assertTrue(greps(out, "c3"))
        self.assertFalse(greps(out, '"b2"'))
        self.assertFalse(greps(out, "'c3'"))
        self.rm_testdir()
        self.coverage()
    def test_1080_preset_files_can_be_parsed(self) -> None:
        """ check that preset files do work internally"""
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzc.service"), """
            [Unit]
            Description=Testing C
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system-preset/our.preset"), """
            enable zzb.service
            disable zzc.service""")
        #
        cmd = "{systemctl} __load_preset_files"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"^our.preset"))
        self.assertEqual(len(lines(out)), 1)
        #
        cmd = "{systemctl} get-preset zza.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        # self.assertTrue(greps(out, r"^our.preset"))
        self.assertEqual(len(lines(out)), 0)
        #
        cmd = "{systemctl} get-preset zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"^enable"))
        self.assertEqual(len(lines(out)), 1)
        #
        cmd = "{systemctl} get-preset zzc.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"^disable"))
        self.assertEqual(len(lines(out)), 1)
        self.rm_testdir()
        self.coverage()
    def test_1090_check_syntax_errors_are_shown_on_daemon_reload(self) -> None:
        """ check that syntax errors are shown"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=foo
            ExecStart=runA
            ExecReload=runB
            ExecStop=runC
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzc.service"), """
            [Unit]
            Description=Testing C
            [Service]
            Type=simple
            ExecReload=/bin/kill -SIGHUP $MAINPID
            ExecStop=/bin/kill $MAINPID
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzd.service"), """
            [Unit]
            Description=Testing D
            [Service]
            Type=forking
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzg.service"), """
            [Unit]
            Description=Testing G
            [Service]
            Type=foo
            ExecStart=runA
            ExecStart=runA2
            ExecReload=runB
            ExecReload=runB2
            ExecStop=runC
            ExecStop=runC2
            [Install]
            WantedBy=multi-user.target""")
        #
        cmd = "{systemctl} daemon-reload -vv 2>&1"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"a.service:.* file without .Service. section"))
        self.assertTrue(greps(out, r"Failed to parse service type, ignoring: foo"))
        self.assertTrue(greps(out, r"b.service:.* Executable path is not absolute"))
        self.assertTrue(greps(out, r"c.service: Service has no ExecStart"))
        self.assertTrue(greps(out, r"d.service: Service lacks both ExecStart and ExecStop"))
        self.assertTrue(greps(out, r"g.service: there may be only one Service ExecStart statement"))
        self.assertTrue(greps(out, r"c.service: the use of /bin/kill is not recommended"))
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_1090_syntax_errors_are_shown_in_journal_after_try_start(self) -> None:
        """ check the real syntax errors"""
        testname = self.testname()
        root = ""
        systemctl = "/usr/bin/systemctl"
        sx____("rm /etc/systemd/system/zz*")
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=foo
            ExecStart=runA
            ExecReload=runB
            ExecStop=runC
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzc.service"), """
            [Unit]
            Description=Testing C
            [Service]
            Type=simple
            ExecReload=/bin/kill -SIGHUP $MAINPID
            ExecStop=/bin/kill $MAINPID
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzd.service"), """
            [Unit]
            Description=Testing D
            [Service]
            Type=forking
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzg.service"), """
            [Unit]
            Description=Testing G
            [Service]
            Type=foo
            ExecStart=runA
            ExecStart=runA2
            ExecReload=runB
            ExecReload=runB2
            ExecStop=runC
            ExecStop=runC2
            [Install]
            WantedBy=multi-user.target""")
        #
        cmd = "{systemctl} daemon-reload 2>&1"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        # there is not direct output
        self.assertFalse(greps(out, r"a.service:.* file without .Service. section"))
        self.assertFalse(greps(out, r"b.service:.* Executable path is not absolute"))
        self.assertFalse(greps(out, r"c.service:.* Service has no ExecStart"))
        self.assertFalse(greps(out, r"d.service:.* Service lacks both ExecStart and ExecStop"))
        self.assertFalse(greps(out, r"g.service:.* there may be only one ExecStart statement"))
        self.assertFalse(greps(out, r"g.service:.* there may be only one ExecStop statement"))
        self.assertFalse(greps(out, r"g.service:.* there may be only one ExecReload statement"))
        self.assertFalse(greps(out, r"c.service:.* the use of /bin/kill is not recommended"))
        # but let's try to start the services
        #
        cmd = "{systemctl} start zza zzb zzc zzd zzg 2>&1"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertNotEqual(end, 0) # fails to start
        self.assertTrue(greps(out, r"failed to load: Invalid argument. See system logs and 'systemctl status zz\w.service' for details."))
        cmd = "journalctl -xe --lines=50 2>&1"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertFalse(greps(out, r"a.service:.* file without .Service. section")) # systemctl.py special
        self.assertTrue(greps(out, r"Failed to parse service type, ignoring: foo"))
        self.assertTrue(greps(out, r"b.service:.* Executable path is not absolute"))
        self.assertTrue(greps(out, r"c.service:.* Service has no ExecStart"))
        self.assertTrue(greps(out, r"d.service:.* Service lacks both ExecStart= and ExecStop="))
        self.assertFalse(greps(out, r"g.service:.* there may be only one Service ExecStart statement")) # systemctl.py special
        self.assertFalse(greps(out, r"g.service:.* there may be only one Service ExecStop statement")) # systemctl.py special
        self.assertFalse(greps(out, r"g.service:.* there may be only one Service ExecReload statement")) # systemctl.py special
        self.assertFalse(greps(out, r"c.service:.* the use of /bin/kill is not recommended")) # systemctl.py special
        sh____("rm /etc/systemd/system/zz*")
    def test_1091_check_syntax_errors_on_start_service(self) -> None:
        """ check that checks are done before a start of a service"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=foo
            ExecStart=runA
            ExecReload=runB
            ExecStop=runC
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzc.service"), """
            [Unit]
            Description=Testing C
            [Service]
            Type=simple
            ExecReload=/bin/kill -SIGHUP $MAINPID
            ExecStop=/bin/kill $MAINPID
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzd.service"), """
            [Unit]
            Description=Testing D
            [Service]
            Type=forking
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzg.service"), """
            [Unit]
            Description=Testing G
            [Service]
            Type=foo
            ExecStart=runA
            ExecStart=runA2
            ExecReload=runB
            ExecReload=runB2
            ExecStop=runC
            ExecStop=runC2
            [Install]
            WantedBy=multi-user.target""")
        #
        cmd = "{systemctl} daemon-reload -vv 2>&1"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"a.service:.* file without .Service. section"))
        self.assertTrue(greps(out, r"Failed to parse service type, ignoring: foo"))
        self.assertTrue(greps(out, r"b.service:.* Executable path is not absolute"))
        self.assertTrue(greps(out, r"c.service: Service has no ExecStart"))
        self.assertTrue(greps(out, r"d.service: Service lacks both ExecStart and ExecStop"))
        self.assertTrue(greps(out, r"g.service: there may be only one Service ExecStart statement"))
        self.assertTrue(greps(out, r"c.service: the use of /bin/kill is not recommended"))
        #
        cmd = "{systemctl} start --no-reload zza zzb zzc zzd zzg -vv 2>&1"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(out, r"a.service:.* file without .Service. section"))
        self.assertTrue(greps(out, r"Failed to parse service type, ignoring: foo"))
        self.assertTrue(greps(out, r"b.service:.* Executable path is not absolute"))
        self.assertTrue(greps(out, r"c.service: Service has no ExecStart"))
        self.assertTrue(greps(out, r"d.service: Service lacks both ExecStart and ExecStop"))
        self.assertTrue(greps(out, r"g.service: there may be only one Service ExecStart statement"))
        self.assertTrue(greps(out, r"c.service: the use of /bin/kill is not recommended"))
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_1092_check_exec_errors_on_start_service(self) -> None:
        """ check that executable checks are done before a start of a service"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=foo
            ExecStart=/usr/bin/zza
            ExecReload=/usr/bin/zzb""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=foo
            ExecStart=-/usr/bin/zza
            ExecReload=-/usr/bin/zzb
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzc.service"), """
            [Unit]
            Description=Testing C
            [Service]
            Type=simple
            ExecStart=/usr/bin/zza
            ExecReload=/usr/bin/zzb
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzd.service"), """
            [Unit]
            Description=Testing D
            [Service]
            Type=simple
            ExecStartPre=/usr/bin/zza
            ExecStart=/usr/bin/false
            ExecStopPost=/usr/bin/zza
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzg.socket"), """
            [Unit]
            Description=Testing G
            [Socket]
            ExecStartPre=/usr/bin/zza
            ExecStopPost=/usr/bin/zzb
            Service=zzd.service
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzp.service"), """
            [Unit]
            Description=Testing P
            [Service]
            ExecStart=/usr/bin/false
            ExecStartPre=foo
            PrivateTmp=yes
            RuntimeDirectory=foo
            [Install]
            WantedBy=multi-user.target""")
        #
        cmd = "{systemctl} daemon-reload -vv 2>&1"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"Failed to parse service type, ignoring: foo"))
        #
        logg.info("========================= zza ========")
        cmd = "{systemctl} start --no-reload zza -vv 2>&1"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(out, r"Failed to parse service type, ignoring: foo"))
        self.assertTrue(greps(out, r"a.service: Exec command does not exist.*ExecStart"))
        self.assertTrue(greps(out, r"a.service: Exec command does not exist.*ExecReload"))
        self.assertTrue(greps(out, r"Oops"))
        #
        logg.info("========================= zzb ========")
        cmd = "{systemctl} start --no-reload zzb -vv 2>&1"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(out, r"Failed to parse service type, ignoring: foo"))
        self.assertTrue(greps(out, r"b.service: Exec command does not exist.*ExecStart"))
        self.assertTrue(greps(out, r"b.service: Exec command does not exist.*ExecReload"))
        self.assertFalse(greps(out, r"Oops"))
        #
        logg.info("========================= zzc ========")
        cmd = "{systemctl} start --no-reload zzc -vv 2>&1"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        self.assertFalse(greps(out, r"Failed to parse service type, ignoring: foo"))
        self.assertTrue(greps(out, r"c.service: Exec command does not exist.*ExecStart"))
        self.assertTrue(greps(out, r"c.service: Exec command does not exist.*ExecReload"))
        self.assertTrue(greps(out, r"Oops"))
        #
        logg.info("========================= zzd ========")
        cmd = "{systemctl} start --no-reload zzd -vv 2>&1"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        self.assertFalse(greps(out, r"Failed to parse service type, ignoring: foo"))
        self.assertTrue(greps(out, r"d.service: Exec command does not exist.*ExecStartPre"))
        self.assertTrue(greps(out, r"d.service: Exec command does not exist.*ExecStopPost"))
        self.assertTrue(greps(out, r"Oops"))
        #
        logg.info("========================= zzg ========")
        cmd = "{systemctl} start --no-reload zzg.socket -vv 2>&1"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        self.assertFalse(greps(out, r"Failed to parse service type, ignoring: foo"))
        self.assertTrue(greps(out, r"g.socket: Exec command does not exist.*ExecStartPre"))
        self.assertTrue(greps(out, r"g.socket: Exec command does not exist.*ExecStopPost"))
        self.assertTrue(greps(out, r"Oops"))
        #
        logg.info("========================= zzp ========")
        cmd = "{systemctl} start --no-reload zzp.service -vv 2>&1"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        self.assertFalse(greps(out, r"zzp.service: Service directory path not implemented: RuntimeDirectory=foo"))
        self.assertTrue(greps(out, r"zzp.service: Service private directory option is ignored: PrivateTmp=yes"))
        self.assertFalse(greps(out, r"unsupported directory settings"))
        self.assertTrue(greps(out, r"Note, 1 private directory settings"))
        #
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_1093_check_user_group_errors_on_start_service(self) -> None:
        """ check that user and groups are checks are done before a start of a service"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=foo
            ExecStart=/usr/bin/false
            User=god""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=foo
            ExecStart=-/usr/bin/false
            User=god
            Group=bar
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzc.service"), """
            [Unit]
            Description=Testing C
            [Service]
            Type=foo
            ExecStart=/usr/bin/false
            Group=bar
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzd.service"), """
            [Unit]
            Description=Testing D
            [Service]
            Type=foo
            ExecStart=/usr/bin/false
            User=god
            Group=bar
            SupplementaryGroups=zap
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzg.socket"), """
            [Unit]
            Description=Testing G
            [Socket]
            Service=zzd.service
            SocketUser=devil
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzf.socket"), """
            [Unit]
            Description=Testing F
            [Socket]
            Service=zzd.service
            SocketUser=devil
            SocketGroup=hell
            [Install]
            WantedBy=multi-user.target""")
        #
        cmd = "{systemctl} daemon-reload -vv 2>&1"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"Failed to parse service type, ignoring: foo"))
        #
        logg.info("========================= zza ========")
        cmd = "{systemctl} start --no-reload zza -vv 2>&1"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(out, r"Failed to parse service type, ignoring: foo"))
        self.assertTrue(greps(out, r"a.service: User does not exist: god"))
        self.assertFalse(greps(out, r"b.service: Group does not exist: bar"))
        self.assertTrue(greps(out, r"Oops"))
        #
        logg.info("========================= zzb ========")
        cmd = "{systemctl} start --no-reload zzb -vv 2>&1"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(out, r"Failed to parse service type, ignoring: foo"))
        self.assertTrue(greps(out, r"b.service: User does not exist: god"))
        self.assertTrue(greps(out, r"b.service: Group does not exist: bar"))
        self.assertTrue(greps(out, r"Oops"))
        #
        logg.info("========================= zzc ========")
        cmd = "{systemctl} start --no-reload zzc -vv 2>&1"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(out, r"Failed to parse service type, ignoring: foo"))
        self.assertFalse(greps(out, r"c.service: User does not exist: god"))
        self.assertTrue(greps(out, r"c.service: Group does not exist: bar"))
        self.assertTrue(greps(out, r"Oops"))
        #
        logg.info("========================= zzd ========")
        cmd = "{systemctl} start --no-reload zzd -vv 2>&1"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(out, r"Failed to parse service type, ignoring: foo"))
        self.assertTrue(greps(out, r"d.service: User does not exist: god"))
        self.assertTrue(greps(out, r"d.service: Group does not exist: bar"))
        self.assertTrue(greps(out, r"Oops"))
        #
        logg.info("========================= zzg ========")
        cmd = "{systemctl} start --no-reload zzg.socket -vv 2>&1"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        self.assertFalse(greps(out, r"Failed to parse service type, ignoring: foo"))
        self.assertTrue(greps(out, r"g.socket: User does not exist: devil"))
        self.assertFalse(greps(out, r"g.socket: Group does not exist: hell"))
        self.assertTrue(greps(out, r"Oops"))
        #
        logg.info("========================= zzf ========")
        cmd = "{systemctl} start --no-reload zzf.socket -vv 2>&1"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        self.assertFalse(greps(out, r"Failed to parse service type, ignoring: foo"))
        self.assertTrue(greps(out, r"f.socket: User does not exist: devil"))
        self.assertTrue(greps(out, r"f.socket: Group does not exist: hell"))
        self.assertTrue(greps(out, r"Oops"))
        #
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_1099_errors_message_on_dot_include(self) -> None:
        """ check that '.include' is accepted but marked deprecated"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            .include /etc/systemd/system/zzb.service
            [Unit]
            Description=Testing A""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=foo
            ExecStart=runA
            ExecReload=runB
            ExecStop=runC
            [Install]
            WantedBy=multi-user.target""")
        cmd = "{systemctl} status zza.service"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        # self.assertEqual(end, 0)
        self.assertTrue(greps(err, r"deprecated"))
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_1101_get_bad_command(self) -> None:
        self.test_1101_bad_command(True)
    def test_1101_bad_command(self, real: bool = False) -> None:
        """ check that unknown commands work"""
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        self.rm_zzfiles(root)
        #
        cmd = "{systemctl} incorrect"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertTrue(greps(err, "Unknown operation incorrect"))
        self.assertFalse(greps(out, "units listed."))
        self.assertEqual(end, 1)
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
    def real_1111_default_command(self) -> None:
        self.test_1111_default_command(True)
    def test_1111_default_command(self, real: bool = False) -> None:
        """ check that default commands work"""
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        self.rm_zzfiles(root)
        #
        cmd = "{systemctl}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertTrue(greps(out, "units listed."))
        self.assertTrue(greps(out, "To show all installed unit files use 'systemctl list-unit-files'."))
        self.assertEqual(end, 0)
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
    def real_1201_get_default(self) -> None:
        self.test_1201_get_default(True)
    def test_1201_get_default(self, real: bool = False) -> None:
        """ check that get-default works"""
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        self.rm_zzfiles(root)
        #
        cmd = "{systemctl} get-default"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        if real: self.assertTrue(greps(out, "graphical.target"))
        else: self.assertTrue(greps(out, "multi-user.target"))
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
    def real_1211_set_default(self) -> None:
        self.test_1211_set_default(True)
    def test_1211_set_default(self, real: bool = False) -> None:
        """ check that set-default works"""
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        self.rm_zzfiles(root)
        if not real:
            text_file(os_path(root, "/etc/systemd/system/basic.target"), """
            [Unit]
            Description=Basic Runlevel
            Requires=sockets.target""")
            text_file(os_path(root, "/etc/systemd/system/multi-user.target"), """
            [Unit]
            Description=Basic Runlevel
            Requires=basic.target""")
            text_file(os_path(root, "/etc/systemd/system/graphical.target"), """
            [Unit]
            Description=Basic Runlevel
            Requires=multi-user.target""")
        #
        cmd = "{systemctl} get-default"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        old = out.strip()
        self.assertIn(old, ["graphical.target", "multi-user.target"])
        runlevel = "basic.target"
        cmd = "{systemctl} set-default {runlevel}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = "{systemctl} get-default"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, runlevel)) # <<<<<<<<<<
        cmd = "{systemctl} set-default {old}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = "{systemctl} get-default"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(out.strip(), old)
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
    def test_1218_set_default_empty(self, real: bool = False) -> None:
        """ check that set-default works with no runleven given"""
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        self.rm_zzfiles(root)
        #
        cmd = "{systemctl} set-default "
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(out.strip(), "Too few arguments")
        self.assertEqual(end, 1)
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
    def test_1219_set_default_bad(self, real: bool = False) -> None:
        """ check that set-default works with a bad runlevel"""
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        self.rm_zzfiles(root)
        #
        cmd = "{systemctl} set-default wrong"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(out.strip(), "No such runlevel wrong")
        self.assertEqual(end, 3)
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
    def test_2001_can_create_test_services(self) -> None:
        """ check that two unit files can be created for testing """
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B""")
        textA = reads(os_path(root, "/etc/systemd/system/zza.service"))
        textB = reads(os_path(root, "/etc/systemd/system/zzb.service"))
        self.assertTrue(greps(textA, "Testing A"))
        self.assertTrue(greps(textB, "Testing B"))
        self.assertIn("\nDescription", textA)
        self.assertIn("\nDescription", textB)
        self.rm_testdir()
        self.coverage()
    def test_2002_list_units(self) -> None:
        """ check that two unit files can be found for 'list-units' """
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B""")
        cmd = "{systemctl} list-units"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"zza.service\s+loaded inactive dead\s+.*Testing A"))
        self.assertTrue(greps(out, r"zzb.service\s+loaded inactive dead\s+.*Testing B"))
        self.assertIn("loaded units listed.", out)
        self.assertIn("To show all installed unit files use", out)
        self.assertEqual(len(lines(out)), 5)
        cmd = "{systemctl} --no-legend list-units"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"zza.service\s+loaded inactive dead\s+.*Testing A"))
        self.assertTrue(greps(out, r"zzb.service\s+loaded inactive dead\s+.*Testing B"))
        self.assertNotIn("loaded units listed.", out)
        self.assertNotIn("To show all installed unit files use", out)
        self.assertEqual(len(lines(out)), 2)
        self.rm_testdir()
        self.coverage()
    def test_2003_list_unit_files(self) -> None:
        """ check that two unit service files can be found for 'list-unit-files' """
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B""")
        cmd = "{systemctl} --type=service list-unit-files"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"zza.service\s+static"))
        self.assertTrue(greps(out, r"zzb.service\s+static"))
        self.assertIn("unit files listed.", out)
        self.assertEqual(len(lines(out)), 5)
        cmd = "{systemctl} --no-legend --type=service list-unit-files"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"zza.service\s+static"))
        self.assertTrue(greps(out, r"zzb.service\s+static"))
        self.assertNotIn("unit files listed.", out)
        self.assertEqual(len(lines(out)), 2)
        self.rm_testdir()
        self.coverage()
    def test_2004_list_unit_files_wanted(self) -> None:
        """ check that two unit files can be found for 'list-unit-files'
            with an enabled status """
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Install]
            WantedBy=multi-user.target""")
        cmd = "{systemctl} --type=service list-unit-files"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"zza.service\s+static"))
        self.assertTrue(greps(out, r"zzb.service\s+disabled"))
        self.assertIn("unit files listed.", out)
        self.assertEqual(len(lines(out)), 5)
        cmd = "{systemctl} --no-legend --type=service list-unit-files"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"zza.service\s+static"))
        self.assertTrue(greps(out, r"zzb.service\s+disabled"))
        self.assertNotIn("unit files listed.", out)
        self.assertEqual(len(lines(out)), 2)
        self.rm_testdir()
        self.coverage()
    def test_2006_list_unit_files_wanted_and_unknown_type(self) -> None:
        """ check that two unit files can be found for 'list-unit-files'
            with an enabled status plus handling unkonwn services"""
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Install]
            WantedBy=multi-user.target""")
        cmd = "{systemctl} --type=foo list-unit-files"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertIn("0 unit files listed.", out)
        self.assertEqual(len(lines(out)), 3)
        self.rm_testdir()
        self.coverage()
    def test_2008_list_unit_files_locations(self) -> None:
        """ check that unit files can be found for 'list-unit-files'
            in different standard locations on disk. """
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/usr/lib/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/lib/systemd/system/zzc.service"), """
            [Unit]
            Description=Testing C
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/var/run/systemd/system/zzd.service"), """
            [Unit]
            Description=Testing D
            [Install]
            WantedBy=multi-user.target""")
        cmd = "{systemctl} --type=service list-unit-files"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"zza.service\s+disabled"))
        self.assertTrue(greps(out, r"zzb.service\s+disabled"))
        self.assertTrue(greps(out, r"zzc.service\s+disabled"))
        self.assertTrue(greps(out, r"zzd.service\s+disabled"))
        self.assertIn("4 unit files listed.", out)
        self.assertEqual(len(lines(out)), 7)
        #
        cmd = "{systemctl} enable zza.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = "{systemctl} enable zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = "{systemctl} enable zzc.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = "{systemctl} enable zzd.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} --type=service list-unit-files"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"zza.service\s+enabled"))
        self.assertTrue(greps(out, r"zzb.service\s+enabled"))
        self.assertTrue(greps(out, r"zzc.service\s+enabled"))
        self.assertTrue(greps(out, r"zzd.service\s+enabled"))
        self.assertIn("4 unit files listed.", out)
        self.assertEqual(len(lines(out)), 7)
        #
        self.rm_testdir()
        self.coverage()
    def test_2010_list_unit_files_locations_user_mode(self) -> None:
        """ check that unit files can be found for 'list-unit-files'
            in different standard locations on disk for --user mode """
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/usr/lib/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/lib/systemd/system/zzc.service"), """
            [Unit]
            Description=Testing C
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/var/run/systemd/system/zzd.service"), """
            [Unit]
            Description=Testing D
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/user/zzu.service"), """
            [Unit]
            Description=Testing U
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/usr/lib/systemd/user/zzv.service"), """
            [Unit]
            Description=Testing V
            [Install]
            WantedBy=multi-user.target""")
        cmd = "{systemctl} --type=service list-unit-files --user"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertFalse(greps(out, r"zza.service\s+disabled"))
        self.assertFalse(greps(out, r"zzb.service\s+disabled"))
        self.assertFalse(greps(out, r"zzc.service\s+disabled"))
        self.assertFalse(greps(out, r"zzd.service\s+disabled"))
        self.assertTrue(greps(out, r"zzu.service\s+disabled"))
        self.assertTrue(greps(out, r"zzv.service\s+disabled"))
        self.assertIn("2 unit files listed.", out)
        self.assertEqual(len(lines(out)), 5)
        #
        cmd = "{systemctl} enable zza.service --user -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        cmd = "{systemctl} enable zzb.service --user -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        cmd = "{systemctl} enable zzu.service --user"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = "{systemctl} enable zzv.service --user"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} --type=service list-unit-files --user"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"zzu.service\s+enabled"))
        self.assertTrue(greps(out, r"zzv.service\s+enabled"))
        self.assertIn("2 unit files listed.", out)
        self.assertEqual(len(lines(out)), 5)
        #
        self.rm_testdir()
        self.coverage()
    def test_2014_list_unit_files_locations_user_extra(self) -> None:
        """ check that unit files can be found for 'list-unit-files'
            in different standard locations on disk for --user mode
            with some system files to be pinned on our user. """
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        user = self.user()
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            User={user}
            [Install]
            WantedBy=multi-user.target""".format(**locals()))
        text_file(os_path(root, "/usr/lib/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Sevice]
            User={user}
            [Install]
            WantedBy=multi-user.target""".format(**locals()))
        text_file(os_path(root, "/lib/systemd/system/zzc.service"), """
            [Unit]
            Description=Testing C
            [Sevice]
            User={user}
            [Install]
            WantedBy=multi-user.target""".format(**locals()))
        text_file(os_path(root, "/var/run/systemd/system/zzd.service"), """
            [Unit]
            Description=Testing D
            [Sevice]
            User={user}
            [Install]
            WantedBy=multi-user.target""".format(**locals()))
        text_file(os_path(root, "/etc/systemd/user/zzu.service"), """
            [Unit]
            Description=Testing U
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/usr/lib/systemd/user/zzv.service"), """
            [Unit]
            Description=Testing V
            [Install]
            WantedBy=multi-user.target""")
        cmd = "{systemctl} --type=service list-unit-files --user"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"zza.service\s+disabled"))
        self.assertFalse(greps(out, r"zzb.service\s+disabled"))
        self.assertFalse(greps(out, r"zzc.service\s+disabled"))
        self.assertFalse(greps(out, r"zzd.service\s+disabled"))
        self.assertTrue(greps(out, r"zzu.service\s+disabled"))
        self.assertTrue(greps(out, r"zzv.service\s+disabled"))
        self.assertIn("3 unit files listed.", out)
        self.assertEqual(len(lines(out)), 6)
        #
        cmd = "{systemctl} enable zza.service --user -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = "{systemctl} enable zzb.service --user -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        cmd = "{systemctl} enable zzu.service --user"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = "{systemctl} enable zzv.service --user"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} --type=service list-unit-files --user"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"zza.service\s+enabled"))
        self.assertTrue(greps(out, r"zzu.service\s+enabled"))
        self.assertTrue(greps(out, r"zzv.service\s+enabled"))
        self.assertIn("3 unit files listed.", out)
        self.assertEqual(len(lines(out)), 6)
        #
        logg.info("enabled services for User=%s", user)
        self.rm_testdir()
        self.coverage()
    def test_2043_list_unit_files_common_targets(self) -> None:
        """ check that some unit target files can be found for 'list-unit-files' """
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B""")
        cmd = "{systemctl} --no-legend --type=service list-unit-files"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"zza.service\s+static"))
        self.assertTrue(greps(out, r"zzb.service\s+static"))
        self.assertFalse(greps(out, r"multi-user.target\s+enabled"))
        self.assertEqual(len(lines(out)), 2)
        cmd = "{systemctl} --no-legend --type=target list-unit-files"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertFalse(greps(out, r"zza.service\s+static"))
        self.assertFalse(greps(out, r"zzb.service\s+static"))
        self.assertTrue(greps(out, r"multi-user.target\s+enabled"))
        self.assertGreater(len(lines(out)), 10)
        num_targets = len(lines(out))
        cmd = "{systemctl} --no-legend list-unit-files"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"zza.service\s+static"))
        self.assertTrue(greps(out, r"zzb.service\s+static"))
        self.assertTrue(greps(out, r"multi-user.target\s+enabled"))
        self.assertEqual(len(lines(out)), num_targets + 2)
        self.rm_testdir()
        self.coverage()
    def test_2044_list_unit_files_now(self) -> None:
        """ check that 'list-unit-files --now' presents a special debug list """
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B""")
        cmd = "{systemctl} --no-legend --now list-unit-files"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"zza.service\s+SysD\s+.*systemd/system/zza.service"))
        self.assertTrue(greps(out, r"zzb.service\s+SysD\s+.*systemd/system/zzb.service"))
        self.assertFalse(greps(out, r"multi-user.target"))
        self.assertFalse(greps(out, r"enabled"))
        self.assertEqual(len(lines(out)), 2)
        self.rm_testdir()
        self.coverage()
    def test_2140_show_environment_from_parts(self) -> None:
        """ check that the result of 'environment UNIT' can
            list the settings from different locations."""
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/sysconfig/zzb.conf"), """
            DEF1='def1'
            DEF2="def2"
            DEF3=def3
            """)
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            EnvironmentFile=/etc/sysconfig/zzb.conf
            Environment=DEF5=def5
            Environment=DEF6=def6
            ExecStart=/usr/bin/printf $DEF1 $DEF2 \
                                $DEF3 $DEF4 $DEF5
            [Install]
            WantedBy=multi-user.target""")
        cmd = "{systemctl} environment zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"^DEF1=def1"))
        self.assertTrue(greps(out, r"^DEF2=def2"))
        self.assertTrue(greps(out, r"^DEF3=def3"))
        self.assertFalse(greps(out, r"^DEF4=def4"))
        self.assertTrue(greps(out, r"^DEF5=def5"))
        self.assertTrue(greps(out, r"^DEF6=def6"))
        self.assertFalse(greps(out, r"^DEF7=def7"))
        a_lines = len(lines(out))
        #
        self.rm_testdir()
        self.coverage()
    def real_2147_show_environment_from_some_parts(self) -> None:
        self.test_2147_show_environment_from_some_parts(True)
    def test_2147_show_environment_from_some_parts(self, real: bool = False) -> None:
        """ check that the result of 'environment UNIT' can
            list the settings from different locations."""
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: systemctl = "/usr/bin/systemctl"
        text_file(os_path(root, "/etc/sysconfig/zzb.conf"), """
            DEF1='def1'
            DEF2="def2"
            DEF3=def3
            """)
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            EnvironmentFile=/etc/sysconfig/zzb.conf
            EnvironmentFile=-/etc/sysconfig/zz-not-existant.conf
            Environment=DEF5=def5
            Environment=DEF6=def6
            ExecStart=/usr/bin/printf $DEF1 $DEF2 \
                                $DEF3 $DEF4 $DEF5
            [Install]
            WantedBy=multi-user.target""")
        cmd = "{systemctl} environment zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"^DEF1=def1"))
        self.assertTrue(greps(out, r"^DEF2=def2"))
        self.assertTrue(greps(out, r"^DEF3=def3"))
        self.assertFalse(greps(out, r"^DEF4=def4"))
        self.assertTrue(greps(out, r"^DEF5=def5"))
        self.assertTrue(greps(out, r"^DEF6=def6"))
        self.assertFalse(greps(out, r"^DEF7=def7"))
        a_lines = len(lines(out))
        #
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
    def real_2148_show_environment_from_some_bad_parts(self) -> None:
        self.test_2148_show_environment_from_some_bad_parts(True)
    def test_2148_show_environment_from_some_bad_parts(self, real: bool = False) -> None:
        """ check that the result of 'environment UNIT' can
            list the settings from different locations."""
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: systemctl = "/usr/bin/systemctl"
        text_file(os_path(root, "/etc/sysconfig/zzb.conf"), """
            DEF1='def1'
            DEF2="def2"
            DEF3=def3
            """)
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            EnvironmentFile=/etc/sysconfig/zzb.conf
            EnvironmentFile=/etc/sysconfig/zz-not-existant.conf
            Environment=DEF5=def5
            Environment=DEF6=def6
            ExecStart=/usr/bin/printf $DEF1 $DEF2 \
                                $DEF3 $DEF4 $DEF5
            [Install]
            WantedBy=multi-user.target""")
        cmd = "{systemctl} environment zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"^DEF1=def1"))
        self.assertTrue(greps(out, r"^DEF2=def2"))
        self.assertTrue(greps(out, r"^DEF3=def3"))
        self.assertFalse(greps(out, r"^DEF4=def4"))
        self.assertTrue(greps(out, r"^DEF5=def5"))
        self.assertTrue(greps(out, r"^DEF6=def6"))
        self.assertFalse(greps(out, r"^DEF7=def7"))
        a_lines = len(lines(out))
        #
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
    def test_2150_have_environment_with_multiple_parts(self) -> None:
        """ check that the result of 'environment UNIT' can
            list the assignements that are crammed into one line."""
        # https://www.freedesktop.org/software/systemd/man/systemd.exec.html#Environment=
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/sysconfig/zzb.conf"), """
            DEF1='def1'
            DEF2="def2"
            DEF3=def3
            """)
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            EnvironmentFile=/etc/sysconfig/zzb.conf
            Environment="VAR1=word1 word2" VAR2=word3 "VAR3=$word 5 6"
            ExecStart=/usr/bin/printf $DEF1 $DEF2 \
                                $VAR1 $VAR2 $VAR3
            [Install]
            WantedBy=multi-user.target""")
        cmd = "{systemctl} environment zzb.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"^DEF1=def1"))
        self.assertTrue(greps(out, r"^DEF2=def2"))
        self.assertTrue(greps(out, r"^DEF3=def3"))
        self.assertTrue(greps(out, r"^VAR1=word1 word2"))
        self.assertTrue(greps(out, r"^VAR2=word3"))
        self.assertTrue(greps(out, r"^VAR3=\$word 5 6"))
        a_lines = len(lines(out))
        #
        self.rm_testdir()
        self.coverage()
    def test_2220_show_unit_is_parseable(self) -> None:
        """ check that 'show UNIT' is machine-readable """
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A""")
        cmd = "{systemctl} show zza.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"^Id="))
        self.assertTrue(greps(out, r"^Names="))
        self.assertTrue(greps(out, r"^Description="))
        self.assertFalse(greps(out, r"^MainPID="))
        self.assertTrue(greps(out, r"^LoadState="))
        self.assertTrue(greps(out, r"^ActiveState="))
        self.assertTrue(greps(out, r"^SubState="))
        self.assertTrue(greps(out, r"^UnitFileState="))
        num_lines = len(lines(out))
        #
        cmd = "{systemctl} --all show zza.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"^Id="))
        self.assertTrue(greps(out, r"^Names="))
        self.assertTrue(greps(out, r"^Description="))
        self.assertTrue(greps(out, r"^MainPID="))
        self.assertTrue(greps(out, r"^LoadState="))
        self.assertTrue(greps(out, r"^ActiveState="))
        self.assertTrue(greps(out, r"^SubState="))
        self.assertTrue(greps(out, r"^UnitFileState="))
        self.assertTrue(greps(out, r"^PIDFile="))
        self.assertGreater(len(lines(out)), num_lines)
        #
        for line in lines(out):
            m = re.match(r"^\w+=", line)
            if not m:
                # found non-machine readable property line
                self.assertEqual("word=value", line)
        self.rm_testdir()
        self.coverage()
    def test_2221_show_unit_can_be_restricted_to_one_property(self) -> None:
        """ check that 'show UNIT' may return just one value if asked for"""
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A""")
        cmd = "{systemctl} show zza.service --property=Description"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"^Description="))
        self.assertEqual(len(lines(out)), 1)
        #
        cmd = "{systemctl} show zza.service --property=Description --all"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"^Description="))
        self.assertEqual(len(lines(out)), 1)
        #
        cmd = "{systemctl} show zza.service --property=PIDFile"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"^PIDFile="))
        self.assertEqual(len(lines(out)), 1)
        #
        cmd = "{systemctl} show zza.service --property=PIDFile --all"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"^PIDFile="))
        self.assertEqual(len(lines(out)), 1)
        #
        self.assertEqual(lines(out), ["PIDFile="])
        self.rm_testdir()
        self.coverage()
    def test_2225_show_unit_for_multiple_matches(self) -> None:
        """ check that the result of 'show UNIT' for multiple services is
            concatenated but still machine readable. """
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Install]
            WantedBy=multi-user.target""")
        cmd = "{systemctl} show zza.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"^Id="))
        self.assertTrue(greps(out, r"^Names="))
        self.assertTrue(greps(out, r"^Description="))
        self.assertFalse(greps(out, r"^MainPID="))
        self.assertTrue(greps(out, r"^LoadState="))
        self.assertTrue(greps(out, r"^ActiveState="))
        self.assertTrue(greps(out, r"^SubState="))
        self.assertTrue(greps(out, r"^UnitFileState="))
        a_lines = len(lines(out))
        #
        cmd = "{systemctl} show zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"^Id="))
        self.assertTrue(greps(out, r"^Names="))
        self.assertTrue(greps(out, r"^Description="))
        self.assertFalse(greps(out, r"^MainPID="))
        self.assertTrue(greps(out, r"^LoadState="))
        self.assertTrue(greps(out, r"^ActiveState="))
        self.assertTrue(greps(out, r"^SubState="))
        self.assertTrue(greps(out, r"^UnitFileState="))
        b_lines = len(lines(out))
        #
        cmd = "{systemctl} show zza.service zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"^Id="))
        self.assertTrue(greps(out, r"^Names="))
        self.assertTrue(greps(out, r"^Description="))
        self.assertFalse(greps(out, r"^MainPID="))
        self.assertTrue(greps(out, r"^LoadState="))
        self.assertTrue(greps(out, r"^ActiveState="))
        self.assertTrue(greps(out, r"^SubState="))
        self.assertTrue(greps(out, r"^UnitFileState="))
        all_lines = len(lines(out))
        #
        self.assertGreater(all_lines, a_lines + b_lines)
        #
        for line in lines(out):
            if not line.strip():
                # empty lines are okay now
                continue
            m = re.match(r"^\w+=", line)
            if not m:
                # found non-machine readable property line
                self.assertEqual("word=value", line)
        self.rm_testdir()
        self.coverage()
    def test_2227_show_unit_for_oneshot_service(self) -> None:
        """ check that 'show UNIT' is machine-readable """
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=oneshot
            ExecStart=/bin/echo foo
            ExecStop=/bin/echo bar
            """)
        cmd = "{systemctl} show zza.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"^Id="))
        self.assertTrue(greps(out, r"^Names="))
        self.assertTrue(greps(out, r"^Description="))
        self.assertFalse(greps(out, r"^MainPID="))
        self.assertTrue(greps(out, r"^LoadState="))
        self.assertTrue(greps(out, r"^ActiveState="))
        self.assertTrue(greps(out, r"^SubState="))
        self.assertTrue(greps(out, r"^UnitFileState="))
        num_lines = len(lines(out))
        #
        cmd = "{systemctl} --all show zza.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"^Id="))
        self.assertTrue(greps(out, r"^Names="))
        self.assertTrue(greps(out, r"^Description="))
        self.assertTrue(greps(out, r"^MainPID="))
        self.assertTrue(greps(out, r"^LoadState="))
        self.assertTrue(greps(out, r"^ActiveState="))
        self.assertTrue(greps(out, r"^SubState="))
        self.assertTrue(greps(out, r"^UnitFileState=static"))
        self.assertTrue(greps(out, r"^PIDFile="))
        self.assertGreater(len(lines(out)), num_lines)
        #
        for line in lines(out):
            m = re.match(r"^\w+=", line)
            if not m:
                # found non-machine readable property line
                self.assertEqual("word=value", line)
        self.rm_testdir()
        self.coverage()
    def test_2230_show_unit_display_parsed_timeouts(self) -> None:
        """ check that 'show UNIT' show parsed timeoutss """
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            TimeoutStartSec=29
            TimeoutStopSec=60
            """)
        cmd = "{systemctl} show zza.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        rep = lines(out)
        self.assertIn("TimeoutStartUSec=29s", rep)
        self.assertIn("TimeoutStopUSec=1min", rep)
        ##
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing A
            [Service]
            TimeoutStartSec=1m
            TimeoutStopSec=2min
            """)
        cmd = "{systemctl} show zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        rep = lines(out)
        self.assertIn("TimeoutStartUSec=1min", rep)
        self.assertIn("TimeoutStopUSec=2min", rep)
        ##
        text_file(os_path(root, "/etc/systemd/system/zzc.service"), """
            [Unit]
            Description=Testing C
            [Service]
            TimeoutStartSec=1s
            TimeoutStopSec=2000ms
            """)
        cmd = "{systemctl} show zzc.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        rep = lines(out)
        self.assertIn("TimeoutStartUSec=1s", rep)
        self.assertIn("TimeoutStopUSec=2s", rep)
        #
        self.rm_testdir()
        self.coverage()
        ##
        text_file(os_path(root, "/etc/systemd/system/zzd.service"), """
            [Unit]
            Description=Testing D
            [Service]
            TimeoutStartSec=90s
            TimeoutStopSec=2250ms
            """)
        cmd = "{systemctl} show zzd.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        rep = lines(out)
        self.assertIn("TimeoutStartUSec=1min 30s", rep)
        self.assertIn("TimeoutStopUSec=2s 250ms", rep)
        ##
        text_file(os_path(root, "/etc/systemd/system/zze.service"), """
            [Unit]
            Description=Testing E
            [Service]
            TimeoutStartSec=90s 250ms
            TimeoutStopSec=3m 25ms
            """)
        cmd = "{systemctl} show zze.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        rep = lines(out)
        self.assertIn("TimeoutStartUSec=1min 30s 250ms", rep)
        self.assertIn("TimeoutStopUSec=3min 25ms", rep)
        ##
        text_file(os_path(root, "/etc/systemd/system/zzf.service"), """
            [Unit]
            Description=Testing F
            [Service]
            TimeoutStartSec=180
            TimeoutStopSec=182
            """)
        cmd = "{systemctl} show zzf.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        rep = lines(out)
        self.assertIn("TimeoutStartUSec=3min", rep)
        self.assertIn("TimeoutStopUSec=3min 2s", rep)
        #
        self.rm_testdir()
        self.coverage()
    def real_2240_show_environment_from_parts(self) -> None:
        self.test_2240_show_environment_from_parts(True)
    def test_2240_show_environment_from_parts(self, real: bool = False) -> None:
        """ check that the result of 'show -p Environment UNIT' can
            list the settings from different locations."""
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: systemctl = "/usr/bin/systemctl"
        text_file(os_path(root, "/etc/sysconfig/zzb.conf"), """
            DEF1='def1'
            DEF2="def2"
            DEF3=def3
            """)
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            EnvironmentFile=/etc/sysconfig/zzb.conf
            Environment=DEF5=def5
            Environment=DEF6=def6
            ExecStart=/usr/bin/printf $DEF1 $DEF2 \
                                $DEF3 $DEF4 $DEF5
            [Install]
            WantedBy=multi-user.target""")
        cmd = "{systemctl} show -p Environment zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertFalse(greps(out, r"DEF1=def1"))
        self.assertFalse(greps(out, r"DEF2=def2"))
        self.assertFalse(greps(out, r"DEF3=def3"))
        self.assertFalse(greps(out, r"DEF4=def4"))
        self.assertTrue(greps(out, r"DEF5=def5"))
        self.assertTrue(greps(out, r"DEF6=def6"))
        self.assertFalse(greps(out, r"DEF7=def7"))
        a_lines = len(lines(out))
        #
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
    def real_2250_show_environment_max_depth(self) -> None:
        self.test_2250_show_environment_max_depth(True)
    def test_2250_show_environment_max_depth(self, real: bool = False) -> None:
        """ check that the result of 'show -p Environment UNIT' can
            list the settings from different locations."""
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: systemctl = "/usr/bin/systemctl"
        text_file(os_path(root, "/etc/sysconfig/zzb.conf"), """
            DEF1='def1'
            DEF2="def2"
            DEF3=def3
            """)
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            EnvironmentFile=/etc/sysconfig/zzb.conf
            Environment=DEF5=def5
            Environment=DEF6=$DEF5
            ExecStart=/usr/bin/printf x.$DEF1.$DEF2.$DEF3.$DEF4.$DEF5
            [Install]
            WantedBy=multi-user.target""")
        cmd = "{systemctl} daemon-reload"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = "{systemctl} show -p Environment zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertFalse(greps(out, r"DEF1=def1"))
        self.assertFalse(greps(out, r"DEF2=def2"))
        self.assertFalse(greps(out, r"DEF3=def3"))
        self.assertFalse(greps(out, r"DEF4=def4"))
        self.assertTrue(greps(out, r"DEF5=def5"))
        self.assertTrue(greps(out, r"DEF6=[$]DEF5"))
        self.assertFalse(greps(out, r"DEF7=def7"))
        a_lines = len(lines(out))
        cmd = "{systemctl} show -p EnvironmentFile zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = "{systemctl} stop zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = "{systemctl} start zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = "{systemctl} stop zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = "{systemctl} status zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        #
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()

    def real_2300_override_environment_extras(self) -> None:
        self.test_2300_override_environment_extras(True)
    def test_2300_override_environment_extras(self, real: bool = False) -> None:
        """ check that the result of 'show -p Environment UNIT' can
            list the settings when using override file extras"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        text_file(os_path(root, "/etc/sysconfig/zzb.conf"), """
            DEF1='def1'
            DEF2="def2"
            DEF3=def3
            """)
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            EnvironmentFile=/etc/sysconfig/zzb.conf
            Environment=DEF5=def5
            Environment=DEF6=$DEF5
            ExecStart=/usr/bin/printf x.$DEF1.$DEF2.$DEF3.$DEF4.$DEF5
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service.d/extra.conf"), """
            [Service]
            Environment=DEF7=def7
            Environment=DEF8=$DEF5
            ExecStartPre=/usr/bin/printf y.$DEF7.$DEF8
            """)
        cmd = "{systemctl} daemon-reload"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = "{systemctl} show -p Environment zzb.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertFalse(greps(out, r"DEF1=def1"))
        self.assertFalse(greps(out, r"DEF2=def2"))
        self.assertFalse(greps(out, r"DEF3=def3"))
        self.assertFalse(greps(out, r"DEF4=def4"))
        self.assertTrue(greps(out, r"DEF5=def5"))
        self.assertTrue(greps(out, r"DEF6=[$]DEF5"))
        self.assertTrue(greps(out, r"DEF7=def7"))
        self.assertTrue(greps(out, r"DEF8=[$]DEF5"))
        self.assertFalse(greps(out, r"DEF9=def9"))
        a_lines = len(lines(out))
        cmd = "{systemctl} show -p EnvironmentFile zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = "{systemctl} stop zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = "{systemctl} start zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = "{systemctl} stop zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = "{systemctl} status zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        #
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
    def real_2310_override_environment_by_extras(self) -> None:
        self.test_2310_override_environment_by_extras(True)
    def test_2310_override_environment_by_extras(self, real: bool = False) -> None:
        """ check that the result of 'show -p Environment UNIT' can
            list the settings when using override file extras"""
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: systemctl = "/usr/bin/systemctl"
        text_file(os_path(root, "/etc/sysconfig/zzb.conf"), """
            DEF1='def1'
            DEF2="def2"
            DEF3=def3
            """)
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            EnvironmentFile=/etc/sysconfig/zzb.conf
            Environment=DEF5=def5
            Environment=DEF6=$DEF5
            ExecStart=/usr/bin/printf x.$DEF1.$DEF2.$DEF3.$DEF4.$DEF5
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service.d/extra.conf"), """
            [Service]
            Environment=DEF5=def7
            """)
        cmd = "{systemctl} daemon-reload"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = "{systemctl} show -p Environment zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertFalse(greps(out, r"DEF1=def1"))
        self.assertFalse(greps(out, r"DEF2=def2"))
        self.assertFalse(greps(out, r"DEF3=def3"))
        self.assertFalse(greps(out, r"DEF4=def4"))
        self.assertTrue(greps(out, r"DEF5=def7"))
        self.assertTrue(greps(out, r"DEF6=[$]DEF5"))
        self.assertFalse(greps(out, r"DEF7=def7"))
        a_lines = len(lines(out))
        cmd = "{systemctl} show -p EnvironmentFile zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = "{systemctl} stop zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = "{systemctl} start zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = "{systemctl} stop zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = "{systemctl} status zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        #
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
    def real_2320_override_environment_by_usrlib_extras(self) -> None:
        self.test_2320_override_environment_by_usrlib_extras(True)
    def test_2320_override_environment_by_usrlib_extras(self, real: bool = False) -> None:
        """ check that the result of 'show -p Environment UNIT' can
            list the settings when using override file extras"""
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: systemctl = "/usr/bin/systemctl"
        text_file(os_path(root, "/etc/sysconfig/zzb.conf"), """
            DEF1='def1'
            DEF2="def2"
            DEF3=def3
            """)
        text_file(os_path(root, "/usr/lib/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            EnvironmentFile=/etc/sysconfig/zzb.conf
            Environment=DEF5=def5
            Environment=DEF6=$DEF5
            ExecStart=/usr/bin/printf x.$DEF1.$DEF2.$DEF3.$DEF4.$DEF5
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/usr/lib/systemd/system/zzb.service.d/extra.conf"), """
            [Service]
            Environment=DEF5=def7
            """)
        cmd = "{systemctl} daemon-reload"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = "{systemctl} show -p Environment zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertFalse(greps(out, r"DEF1=def1"))
        self.assertFalse(greps(out, r"DEF2=def2"))
        self.assertFalse(greps(out, r"DEF3=def3"))
        self.assertFalse(greps(out, r"DEF4=def4"))
        self.assertTrue(greps(out, r"DEF5=def7"))
        self.assertTrue(greps(out, r"DEF6=[$]DEF5"))
        self.assertFalse(greps(out, r"DEF7=def7"))
        a_lines = len(lines(out))
        cmd = "{systemctl} show -p EnvironmentFile zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = "{systemctl} stop zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = "{systemctl} start zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = "{systemctl} stop zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = "{systemctl} status zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        #
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
    def real_2330_override_environment_by_usrlib_etc_extras(self) -> None:
        self.test_2330_override_environment_by_usrlib_etc_extras(True)
    def test_2330_override_environment_by_usrlib_etc_extras(self, real: bool = False) -> None:
        """ check that the result of 'show -p Environment UNIT' can
            list the settings when using override file extras"""
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: systemctl = "/usr/bin/systemctl"
        text_file(os_path(root, "/etc/sysconfig/zzb.conf"), """
            DEF1='def1'
            DEF2="def2"
            DEF3=def3
            """)
        text_file(os_path(root, "/usr/lib/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            EnvironmentFile=/etc/sysconfig/zzb.conf
            Environment=DEF5=def5
            Environment=DEF6=$DEF5
            ExecStart=/usr/bin/printf x.$DEF1.$DEF2.$DEF3.$DEF4.$DEF5
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service.d/extra.conf"), """
            [Service]
            Environment=DEF5=def7
            """)
        cmd = "{systemctl} daemon-reload"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = "{systemctl} show -p Environment zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertFalse(greps(out, r"DEF1=def1"))
        self.assertFalse(greps(out, r"DEF2=def2"))
        self.assertFalse(greps(out, r"DEF3=def3"))
        self.assertFalse(greps(out, r"DEF4=def4"))
        self.assertTrue(greps(out, r"DEF5=def7"))
        self.assertTrue(greps(out, r"DEF6=[$]DEF5"))
        self.assertFalse(greps(out, r"DEF7=def7"))
        a_lines = len(lines(out))
        cmd = "{systemctl} show -p EnvironmentFile zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = "{systemctl} stop zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = "{systemctl} start zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = "{systemctl} stop zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = "{systemctl} status zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        #
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
    def real_2340_override_environment_by_multiple_extras(self) -> None:
        self.test_2340_override_environment_by_multiple_extras(True)
    def test_2340_override_environment_by_multiple_extras(self, real: bool = False) -> None:
        """ check that the result of 'show -p Environment UNIT' can
            list the settings when using override file extras"""
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: systemctl = "/usr/bin/systemctl"
        text_file(os_path(root, "/etc/sysconfig/zzb.conf"), """
            DEF1='def1'
            DEF2="def2"
            DEF3=def3
            """)
        text_file(os_path(root, "/usr/lib/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            EnvironmentFile=/etc/sysconfig/zzb.conf
            Environment=DEF5=def5
            Environment=DEF6=$DEF5
            ExecStart=/usr/bin/printf x.$DEF1.$DEF2.$DEF3.$DEF4.$DEF5
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/usr/lib/systemd/system/zzb.service.d/base.conf"), """
            [Service]
            Environment=DEF5=def6
            Environment=DEF7=def6
            """)
        text_file(os_path(root, "/etc/systemd/system/zzb.service.d/extra.conf"), """
            [Service]
            Environment=DEF5=def7
            """)
        cmd = "{systemctl} daemon-reload"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = "{systemctl} show -p Environment zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertFalse(greps(out, r"DEF1=def1"))
        self.assertFalse(greps(out, r"DEF2=def2"))
        self.assertFalse(greps(out, r"DEF3=def3"))
        self.assertFalse(greps(out, r"DEF4=def4"))
        self.assertTrue(greps(out, r"DEF5=def7"))
        self.assertTrue(greps(out, r"DEF6=[$]DEF5"))
        self.assertTrue(greps(out, r"DEF7=def"))
        a_lines = len(lines(out))
        cmd = "{systemctl} show -p EnvironmentFile zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = "{systemctl} stop zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = "{systemctl} start zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = "{systemctl} stop zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = "{systemctl} status zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        #
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
    def real_2350_override_environment_by_multiple_same_extras(self) -> None:
        self.test_2350_override_environment_by_multiple_same_extras(True)
    def test_2350_override_environment_by_multiple_same_extras(self, real: bool = False) -> None:
        """ check that the result of 'show -p Environment UNIT' can
            list the settings when using override file extras"""
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: systemctl = "/usr/bin/systemctl"
        text_file(os_path(root, "/etc/sysconfig/zzb.conf"), """
            DEF1='def1'
            DEF2="def2"
            DEF3=def3
            """)
        text_file(os_path(root, "/usr/lib/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            EnvironmentFile=/etc/sysconfig/zzb.conf
            Environment=DEF5=def5
            Environment=DEF6=$DEF5
            ExecStart=/usr/bin/printf x.$DEF1.$DEF2.$DEF3.$DEF4.$DEF5
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/usr/lib/systemd/system/zzb.service.d/extra.conf"), """
            [Service]
            Environment=DEF5=def6
            Environment=DEF7=def6
            """)
        text_file(os_path(root, "/etc/systemd/system/zzb.service.d/extra.conf"), """
            [Service]
            Environment=DEF5=def7
            """)
        cmd = "{systemctl} daemon-reload"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = "{systemctl} show -p Environment zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertFalse(greps(out, r"DEF1=def1"))
        self.assertFalse(greps(out, r"DEF2=def2"))
        self.assertFalse(greps(out, r"DEF3=def3"))
        self.assertFalse(greps(out, r"DEF4=def4"))
        self.assertTrue(greps(out, r"DEF5=def7"))
        self.assertTrue(greps(out, r"DEF6=[$]DEF5"))
        self.assertFalse(greps(out, r"DEF7=def")) # <<< difference to previous!!
        a_lines = len(lines(out))
        cmd = "{systemctl} show -p EnvironmentFile zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = "{systemctl} stop zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = "{systemctl} start zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = "{systemctl} stop zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = "{systemctl} status zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        #
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
    def real_2360_override_environment_by_multiple_same_extras(self) -> None:
        self.test_2360_override_environment_by_multiple_same_extras(True)
    def test_2360_override_environment_by_multiple_same_extras(self, real: bool = False) -> None:
        """ check that the result of 'show -p Environment UNIT' can
            list the settings when using override file extras"""
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: systemctl = "/usr/bin/systemctl"
        text_file(os_path(root, "/etc/sysconfig/zzb.conf"), """
            DEF1='def1'
            DEF2="def2"
            DEF3=def3
            """)
        text_file(os_path(root, "/usr/lib/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            EnvironmentFile=/etc/sysconfig/zzb.conf
            Environment=DEF5=def5
            Environment=DEF6=$DEF5
            ExecStart=/usr/bin/printf x.$DEF1.$DEF2.$DEF3.$DEF4.$DEF5
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/usr/lib/systemd/system/zzb.service.d/extra.conf"), """
            [Service]
            Environment=DEF5=def6
            Environment=DEF7=def6
            """)
        text_file(os_path(root, "/etc/systemd/system/zzb.service.d/base.conf"), """
            [Service]
            Environment=DEF5=def7
            """)
        cmd = "{systemctl} daemon-reload"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = "{systemctl} show -p Environment zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertFalse(greps(out, r"DEF1=def1"))
        self.assertFalse(greps(out, r"DEF2=def2"))
        self.assertFalse(greps(out, r"DEF3=def3"))
        self.assertFalse(greps(out, r"DEF4=def4"))
        self.assertTrue(greps(out, r"DEF5=def6")) # <<< difference to (pre)previous
        self.assertTrue(greps(out, r"DEF6=[$]DEF5"))
        self.assertTrue(greps(out, r"DEF7=def"))
        a_lines = len(lines(out))
        cmd = "{systemctl} show -p EnvironmentFile zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = "{systemctl} stop zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = "{systemctl} start zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = "{systemctl} stop zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = "{systemctl} status zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        #
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
    def real_2390_override_environment_with_zero_out_extras(self) -> None:
        self.test_2390_override_environment_with_zero_out_extras(True)
    def test_2390_override_environment_with_zero_out_extras(self, real: bool = False) -> None:
        """ check that the result of 'show -p Environment UNIT' can
            list the settings when using override file extras"""
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: systemctl = "/usr/bin/systemctl"
        text_file(os_path(root, "/etc/sysconfig/zzb.conf"), """
            DEF1='def1'
            DEF2="def2"
            DEF3=def3
            """)
        text_file(os_path(root, "/usr/lib/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            EnvironmentFile=/etc/sysconfig/zzb.conf
            Environment=DEF5=def5
            Environment=DEF6=$DEF5
            ExecStart=/usr/bin/printf x.$DEF1.$DEF2.$DEF3.$DEF4.$DEF5
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/usr/lib/systemd/system/zzb.service.d/extra.conf"), """
            [Service]
            Environment=
            Environment=DEF5=def6
            Environment=DEF7=def6
            """)
        text_file(os_path(root, "/etc/systemd/system/zzb.service.d/base.conf"), """
            [Service]
            Environment=DEF5=def7
            Environment=DEF8=def8
            """)
        cmd = "{systemctl} daemon-reload"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = "{systemctl} show -p Environment zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertFalse(greps(out, r"DEF1=def1"))
        self.assertFalse(greps(out, r"DEF2=def2"))
        self.assertFalse(greps(out, r"DEF3=def3"))
        self.assertFalse(greps(out, r"DEF4=def4"))
        self.assertTrue(greps(out, r"DEF5=def6"))
        self.assertFalse(greps(out, r"DEF6=")) # <<< zero-out
        self.assertTrue(greps(out, r"DEF7=def"))
        self.assertFalse(greps(out, r"DEF8=")) # <<< zero-out
        a_lines = len(lines(out))
        cmd = "{systemctl} show -p EnvironmentFile zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = "{systemctl} stop zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = "{systemctl} start zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = "{systemctl} stop zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = "{systemctl} status zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        #
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
    def test_2610_show_unit_not_found(self) -> None:
        """ check when 'show UNIT' not found  """
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            TimeoutStartSec=29
            TimeoutStopSec=60
            """)
        cmd = "{systemctl} show zz-not-existing.service"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        rep = lines(out)
        self.assertIn("LoadState=not-found", rep)
        self.assertIn("ActiveState=inactive", rep)
        self.assertIn("SubState=dead", rep)
        self.assertIn("Id=zz-not-existing.service", rep)
        self.rm_testdir()
        self.coverage()
        ##
    def real_2612_show_unit_property_not_found(self) -> None:
        self.test_2612_show_unit_property_not_found(True)
    def test_2612_show_unit_property_not_found(self, real: bool = False) -> None:
        """ check when 'show UNIT' not found  """
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: systemctl = "/usr/bin/systemctl"
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            TimeoutStartSec=29
            TimeoutStopSec=60
            """)
        cmd = "{systemctl} daemon-reload"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = "{systemctl} show -p WeirdOption zza.service"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
        ##
    def real_2614_show_multiple_unit_property(self) -> None:
        self.test_2614_show_multiple_unit_property(True)
    def test_2614_show_multiple_unit_property(self, real: bool = False) -> None:
        """ check when 'show UNIT' with multiple -p (as used by Chef) """
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: systemctl = "/usr/bin/systemctl"
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            TimeoutStartSec=29
            TimeoutStopSec=60
            """)
        cmd = "{systemctl} daemon-reload"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = "{systemctl} show -p TimeoutStartUSec -p TimeoutStopUSec zza.service"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        rep = lines(out)
        self.assertEqual(len(rep), 2)
        self.assertIn("TimeoutStartUSec=29s", rep)
        self.assertIn("TimeoutStopUSec=1min", rep)
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
        ##
    def test_2701_create_runtime(self) -> None:
        """ check when create and clean RuntimeDirectory  """
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            TimeoutStartSec=29
            TimeoutStopSec=60
            RuntimeDirectory=foo/bar aaa
            ExecStart=/bin/sleep 3
            """)
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing A
            [Service]
            TimeoutStartSec=29
            TimeoutStopSec=60
            RuntimeDirectory=foo/bar bbb
            RuntimeDirectoryPreserve=yes
            ExecStart=/bin/sleep 3
            """)
        path1 = os_path(root, "/run/foo/bar")
        path2 = os_path(root, "/run/aaa")
        self.assertFalse(os.path.isdir(path1))
        self.assertFalse(os.path.isdir(path2))
        cmd = "{systemctl} start zza.service -vvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = "{systemctl} stop zza.service -vvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertFalse(os.path.isdir(path1))
        self.assertFalse(os.path.isdir(path2))
        #
        path1 = os_path(root, "/run/foo/bar")
        path2 = os_path(root, "/run/bbb")
        self.assertFalse(os.path.isdir(path1))
        self.assertFalse(os.path.isdir(path2))
        cmd = "{systemctl} start zzb.service -vvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = "{systemctl} stop zzb.service -vvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = "{systemctl} clean zzb.service -vvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertFalse(os.path.isdir(path1))
        self.assertFalse(os.path.isdir(path2))
        #
        path1 = os_path(root, "/run/foo/bar")
        path2 = os_path(root, "/run/bbb")
        self.assertFalse(os.path.isdir(path1))
        self.assertFalse(os.path.isdir(path2))
        cmd = "{systemctl} start zzb.service -vvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = "{systemctl} clean zzb.service -vvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = "{systemctl} stop zzb.service -vvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = "{systemctl} clean zzb.service --what=state -vvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = "{systemctl} clean zzb.service --what=runtime -vvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertFalse(os.path.isdir(path1))
        self.assertFalse(os.path.isdir(path2))
        #
        self.rm_testdir()
        self.coverage()
        ##
    def test_2702_create_state(self) -> None:
        """ check when create and clean StateDirectory  """
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            TimeoutStartSec=29
            TimeoutStopSec=60
            StateDirectory=foo/bar aaa
            ExecStart=/bin/sleep 3
            """)
        path1 = os_path(root, "/var/lib/foo/bar")
        path2 = os_path(root, "/var/lib/aaa")
        self.assertFalse(os.path.isdir(path1))
        self.assertFalse(os.path.isdir(path2))
        #
        cmd = "{systemctl} start zza.service -vvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = "{systemctl} stop zza.service -vvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = "{systemctl} clean zza.service --what=all -vvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertFalse(os.path.isdir(path1))
        self.assertFalse(os.path.isdir(path2))
        #
        cmd = "{systemctl} start zza.service -vvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = "{systemctl} clean zza.service -vvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = "{systemctl} stop zza.service -vvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = "{systemctl} clean zza.service --what=runtime -vvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = "{systemctl} clean zza.service --what=state -vvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertFalse(os.path.isdir(path1))
        self.assertFalse(os.path.isdir(path2))
        #
        self.rm_testdir()
        self.coverage()
        ##
    def test_2703_create_cache(self) -> None:
        """ check when create and clean CacheDirectory  """
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            TimeoutStartSec=29
            TimeoutStopSec=60
            CacheDirectory=foo/bar aaa
            ExecStart=/bin/sleep 3
            """)
        path1 = os_path(root, "/var/cache/foo/bar")
        path2 = os_path(root, "/var/cache/aaa")
        self.assertFalse(os.path.isdir(path1))
        self.assertFalse(os.path.isdir(path2))
        cmd = "{systemctl} start zza.service -vvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = "{systemctl} stop zza.service -vvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = "{systemctl} clean zza.service --what=all -vvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertFalse(os.path.isdir(path1))
        self.assertFalse(os.path.isdir(path2))
        #
        cmd = "{systemctl} start zza.service -vvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = "{systemctl} clean zza.service -vvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = "{systemctl} stop zza.service -vvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = "{systemctl} clean zza.service --what=state -vvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = "{systemctl} clean zza.service --what=cache -vvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertFalse(os.path.isdir(path1))
        self.assertFalse(os.path.isdir(path2))
        #
        self.rm_testdir()
        self.coverage()
    def test_2704_create_logs(self) -> None:
        """ check when create and clean LogsDirectory  """
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            TimeoutStartSec=29
            TimeoutStopSec=60
            LogsDirectory=foo/bar aaa
            ExecStart=/bin/sleep 3
            """)
        path1 = os_path(root, "/var/log/foo/bar")
        path2 = os_path(root, "/var/log/aaa")
        self.assertFalse(os.path.isdir(path1))
        self.assertFalse(os.path.isdir(path2))
        #
        cmd = "{systemctl} start zza.service -vvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = "{systemctl} stop zza.service -vvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = "{systemctl} clean zza.service --what=all -vvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertFalse(os.path.isdir(path1))
        self.assertFalse(os.path.isdir(path2))
        #
        cmd = "{systemctl} start zza.service -vvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = "{systemctl} clean zza.service -vvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = "{systemctl} stop zza.service -vvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = "{systemctl} clean zza.service --what=runtime -vvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = "{systemctl} clean zza.service --what=logs -vvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertFalse(os.path.isdir(path1))
        self.assertFalse(os.path.isdir(path2))
        #
        self.rm_testdir()
        self.coverage()
        ##
    def test_2705_create_configuraiton(self) -> None:
        """ check when create and clean ConfigurationDirectory  """
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            TimeoutStartSec=29
            TimeoutStopSec=60
            ConfigurationDirectory=foo/bar aaa
            ExecStart=/bin/sleep 3
            """)
        path1 = os_path(root, "/etc/foo/bar")
        path2 = os_path(root, "/etc/aaa")
        self.assertFalse(os.path.isdir(path1))
        self.assertFalse(os.path.isdir(path2))
        #
        cmd = "{systemctl} start zza.service -vvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = "{systemctl} stop zza.service -vvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = "{systemctl} clean zza.service --what=all -vvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertFalse(os.path.isdir(path1))
        self.assertFalse(os.path.isdir(path2))
        #
        cmd = "{systemctl} start zza.service -vvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = "{systemctl} clean zza.service -vvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = "{systemctl} stop zza.service -vvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = "{systemctl} clean zza.service --what=runtime -vvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = "{systemctl} clean zza.service --what=configuration -vvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertFalse(os.path.isdir(path1))
        self.assertFalse(os.path.isdir(path2))
        #
        self.rm_testdir()
        self.coverage()
        ##
    def test_2715_create_mode_configuration(self) -> None:
        """ check when create and clean ConfigurationDirectory with Mode settings """
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            TimeoutStartSec=29
            TimeoutStopSec=60
            ConfigurationDirectory=foo/bar aaa
            ExecStart=/bin/sleep 3
            """)
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing A
            [Service]
            TimeoutStartSec=29
            TimeoutStopSec=60
            ConfigurationDirectory=foo/bar aaa
            ConfigurationDirectoryMode=0700
            ExecStart=/bin/sleep 3
            """)
        path1 = os_path(root, "/etc/foo/bar")
        path2 = os_path(root, "/etc/aaa")
        self.assertFalse(os.path.isdir(path1))
        self.assertFalse(os.path.isdir(path2))
        #
        cmd = "{systemctl} start zza.service -vvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = "ls -ld {path1}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertIn("drwxr-x", out)
        out_a = out
        #
        cmd = "{systemctl} stop zza.service -vvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = "{systemctl} clean zza.service --what=all -vvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertFalse(os.path.isdir(path1))
        self.assertFalse(os.path.isdir(path2))
        #
        cmd = "{systemctl} start zzb.service -vvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = "ls -ld {path1}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertIn("drwx---", out)
        out_b = out
        #
        cmd = "{systemctl} stop zzb.service -vvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = "{systemctl} clean zzb.service --what=all -vvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertFalse(os.path.isdir(path1))
        self.assertFalse(os.path.isdir(path2))
        #
        self.rm_testdir()
        self.coverage()
        ##
    def test_2716_create_same_user_state(self) -> None:
        """ check when create and clean StateDirectory with User= settings """
        # actually it should not try to change any uid/gid bits on the file
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        this_user = get_USER()
        this_group = get_GROUP()
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            TimeoutStartSec=29
            TimeoutStopSec=60
            StateDirectory=foo/bar aaa
            User={this_user}
            ExecStart=/bin/sleep 3
            """.format(**locals()))
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            TimeoutStartSec=29
            TimeoutStopSec=60
            StateDirectory=foo/bar aaa
            Group={this_group}
            ExecStart=/bin/sleep 3
            """.format(**locals()))
        path1 = os_path(root, "/var/lib/foo/bar")
        path2 = os_path(root, "/var/lib/aaa")
        self.assertFalse(os.path.isdir(path1))
        self.assertFalse(os.path.isdir(path2))
        #
        cmd = "{systemctl} start zza.service -vvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = "ls -ld {path1}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        out_a = out
        #
        cmd = "{systemctl} stop zza.service -vvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = "{systemctl} clean zza.service --what=all -vvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertFalse(os.path.isdir(path1))
        self.assertFalse(os.path.isdir(path2))
        #
        cmd = "{systemctl} start zzb.service -vvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = "ls -ld {path1}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        out_b = out
        #
        cmd = "{systemctl} stop zzb.service -vvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = "{systemctl} clean zzb.service --what=all -vvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertFalse(os.path.isdir(path1))
        self.assertFalse(os.path.isdir(path2))
        #
        A = re.sub("\\d+:\\d*", "XX:XX", out_a.strip())
        B = re.sub("\\d+:\\d*", "XX:XX", out_b.strip())
        logg.info("A = %s", A)
        logg.info("B = %s", B)
        self.assertEqual(A, B)
        #
        self.rm_testdir()
        self.coverage()
        ##
    def test_2717_create_other_group_state(self) -> None:
        """ check when create and clean StateDirectory with Group= settings """
        # if not running as 'root' then it may actually change the directory group
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        this_group = get_GROUP()
        last_group = get_LASTGROUP()
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            StateDirectory=foo/bar aaa
            Group={this_group}
            ExecStart=/bin/sleep 3
            """.format(**locals()))
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            StateDirectory=foo/bar aaa
            Group={last_group}
            ExecStart=/bin/sleep 4
            """.format(**locals()))
        path1 = os_path(root, "/var/lib/foo/bar")
        path2 = os_path(root, "/var/lib/aaa")
        self.assertFalse(os.path.isdir(path1))
        self.assertFalse(os.path.isdir(path2))
        #
        cmd = "{systemctl} start zza.service -vvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = "ls -ld {path1}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        out_a = out
        #
        cmd = "{systemctl} stop zza.service -vvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = "{systemctl} clean zza.service --what=all -vvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertFalse(os.path.isdir(path1))
        self.assertFalse(os.path.isdir(path2))
        #
        cmd = "{systemctl} start zzb.service -vvvvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        # mayfail# self.assertEqual(end, 0)
        # mayfail# self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = "ls -ld {path1}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        out_b = out
        #
        cmd = "{systemctl} stop zzb.service -vvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = "{systemctl} clean zzb.service --what=all -vvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertFalse(os.path.isdir(path1))
        self.assertFalse(os.path.isdir(path2))
        #
        logg.info("this group '%s' vs '%s' last group", this_group, last_group)
        A = re.sub("\\d+:\\d*", "XX:XX", out_a.strip())
        B = re.sub("\\d+:\\d*", "XX:XX", out_b.strip())
        logg.info("A = %s", A)
        logg.info("B = %s", B)
        if os.geteuid():
            self.assertNotEqual(A, B)
        else:
            self.assertEqual(A, B) # when "root"
        #
        self.rm_testdir()
        self.coverage()
        ##
    def test_2718_create_other_group_configuration(self) -> None:
        """ check when create and clean ConfigurationDirectory with Group= settings """
        # if not running as 'root' then it may actually change the directory group
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        this_group = get_GROUP()
        last_group = get_LASTGROUP()
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            ConfigurationDirectory=foo/bar aaa
            Group={this_group}
            ExecStart=/bin/sleep 3
            """.format(**locals()))
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            ConfigurationDirectory=foo/bar aaa
            Group={last_group}
            ExecStart=/bin/sleep 4
            """.format(**locals()))
        path1 = os_path(root, "/etc/foo/bar")
        path2 = os_path(root, "/etc/aaa")
        self.assertFalse(os.path.isdir(path1))
        self.assertFalse(os.path.isdir(path2))
        #
        cmd = "{systemctl} start zza.service -vvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = "ls -ld {path1}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        out_a = out
        #
        cmd = "{systemctl} stop zza.service -vvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = "{systemctl} clean zza.service --what=all -vvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertFalse(os.path.isdir(path1))
        self.assertFalse(os.path.isdir(path2))
        #
        cmd = "{systemctl} start zzb.service -vvvvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        # mayfail# self.assertEqual(end, 0)
        # mayfail# self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = "ls -ld {path1}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        out_b = out
        #
        cmd = "{systemctl} stop zzb.service -vvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertTrue(os.path.isdir(path1))
        self.assertTrue(os.path.isdir(path2))
        #
        cmd = "{systemctl} clean zzb.service --what=all -vvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(out.strip()), 0)
        self.assertFalse(os.path.isdir(path1))
        self.assertFalse(os.path.isdir(path2))
        #
        logg.info("this group '%s' vs '%s' last group", this_group, last_group)
        A = re.sub("\\d+:\\d*", "XX:XX", out_a.strip())
        B = re.sub("\\d+:\\d*", "XX:XX", out_b.strip())
        logg.info("A = %s", A)
        logg.info("B = %s", B)
        self.assertEqual(A, B) # no chown if directory did exist
        #
        self.rm_testdir()
        self.coverage()
        ##
    def test_2900_class_UnitConfParser(self) -> None:
        """ using systemctl.py as a helper library for
            the UnitConfParser functions."""
        python_exe = _python
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl_py_dir = os.path.dirname(realpath(_systemctl_py))
        unitconfparser_py = os_path(root, "/usr/bin/unitconfparser.py")
        service_file = os_path(root, "/etc/systemd/system/zzb.service")
        defaults = {"a1": "default1"}
        systemctl = os.path.splitext(os.path.basename(_systemctl_py))[0]
        shell_file(unitconfparser_py, """
            #! {python_exe}
            from __future__ import print_function
            import sys
            sys.path += [ "{systemctl_py_dir}" ]
            import {systemctl}
            data = {systemctl}.UnitConfParser({defaults})
            conf = {systemctl}.SystemctlConf(data)
            print("DEFAULTS", conf.data.defaults())
            print("FILENAME", conf.filename())
            data.read(sys.argv[1])
            print("filename=", conf.filename())
            print("sections=", conf.data.sections())
            print("has.Foo.Bar=", conf.data.has_option("Foo", "Bar"))
            print("has.Unit.Foo=", conf.data.has_option("Unit", "Foo"))
            try:
               conf.data.get("Foo", "Bar")
            except Exception as e:
               print("get.Foo.Bar:", str(e))
            try:
               conf.data.get("Unit", "Foo")
            except Exception as e:
               print("get.Unit.Foo:", str(e))
            try:
               conf.data.getlist("Foo", "Bar")
            except Exception as e:
               print("getlist.Foo.Bar:", str(e))
            try:
               conf.data.getlist("Unit", "Foo")
            except Exception as e:
               print("getlist.Unit.Foo:", str(e))
            print("get.none.Foo.Bar=", conf.data.get("Foo", "Bar", allow_no_value = True))
            print("get.none.Unit.Foo=", conf.data.get("Unit", "Foo", allow_no_value = True))
            print("getlist.none.Foo.Bar=", conf.data.getlist("Foo", "Bar", allow_no_value = True))
            print("getlist.none.Unit.Foo=", conf.data.getlist("Unit", "Foo", allow_no_value = True))
            print("get.defs.Foo.Bar=", conf.data.get("Foo", "Bar", "def1"))
            print("get.defs.Unit.Foo=", conf.data.get("Unit", "Foo", "def2"))
            print("getlist.defs.Foo.Bar=", conf.data.getlist("Foo", "Bar", ["def3"]))
            print("getlist.defs.Unit.Foo=", conf.data.getlist("Unit", "Foo", ["def4"]))
            data.set("Unit", "After", "network.target")
            print("getlist.unit.after1=", conf.data.getlist("Unit", "After"))
            print("getitem.unit.after1=", conf.data.get("Unit", "After"))
            data.set("Unit", "After", "postgres.service")
            print("getlist.unit.after2=", conf.data.getlist("Unit", "After"))
            print("getitem.unit.after2=", conf.data.get("Unit", "After"))
            data.set("Unit", "After", None)
            print("getlist.unit.after0=", conf.data.getlist("Unit", "After"))
            print("getitem.unit.after0=", conf.data.get("Unit", "After", allow_no_value = True))
            print("getlist.environment=", conf.data.getlist("Service", "Environment"))
            print("get.environment=", conf.data.get("Service", "Environment"))
            print("get.execstart=", conf.data.get("Service", "ExecStart"))
            """.format(**locals()))
        text_file(service_file, """
            [Unit]
            Description=Testing B
            [Service]
            EnvironmentFile=/etc/sysconfig/zzb.conf
            Environment=DEF5=def5
            Environment=DEF6=def6
            ExecStart=/usr/bin/printf $DEF1 $DEF2 \\
                                $DEF3 $DEF4 $DEF5 \\
                                $DEF6 $DEF7
            [Install]
            WantedBy=multi-user.target""")
        testrun = cover() + unitconfparser_py
        cmd = "{testrun} {service_file}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, "DEFAULTS {'a1': 'default1'}"))
        self.assertTrue(greps(out, "FILENAME None"))
        self.assertTrue(greps(out, "filename= .*"+service_file))
        self.assertTrue(greps(out, "sections= \\['Unit', 'Service', 'Install'\\]"))
        self.assertTrue(greps(out, "has.Foo.Bar= False"))
        self.assertTrue(greps(out, "has.Unit.Foo= False"))
        self.assertTrue(greps(out, "get.Foo.Bar: section Foo does not exist"))
        self.assertTrue(greps(out, "get.Unit.Foo: option Foo in Unit does not exist"))
        self.assertTrue(greps(out, "getlist.Foo.Bar: section Foo does not exist"))
        self.assertTrue(greps(out, "getlist.Unit.Foo: option Foo in Unit does not exist"))
        self.assertTrue(greps(out, "get.none.Foo.Bar= None"))
        self.assertTrue(greps(out, "get.none.Unit.Foo= None"))
        self.assertTrue(greps(out, "getlist.none.Foo.Bar= \\[\\]"))
        self.assertTrue(greps(out, "getlist.none.Unit.Foo= \\[\\]"))
        self.assertTrue(greps(out, "get.defs.Foo.Bar= def1"))
        self.assertTrue(greps(out, "get.defs.Unit.Foo= def2"))
        self.assertTrue(greps(out, "getlist.defs.Foo.Bar= \\['def3'\\]"))
        self.assertTrue(greps(out, "getlist.defs.Unit.Foo= \\['def4'\\]"))
        self.assertTrue(greps(out, "getlist.unit.after1= \\['network.target'\\]"))
        self.assertTrue(greps(out, "getlist.unit.after2= \\['network.target', 'postgres.service'\\]"))
        self.assertTrue(greps(out, "getlist.unit.after0= \\[\\]"))
        self.assertTrue(greps(out, "getitem.unit.after1= network.target"))
        self.assertTrue(greps(out, "getitem.unit.after2= network.target"))
        self.assertTrue(greps(out, "getitem.unit.after0= None"))
        self.assertTrue(greps(out, "getlist.environment= \\['DEF5=def5', 'DEF6=def6'\\]"))
        self.assertTrue(greps(out, "get.environment= DEF5=def5"))
        self.assertTrue(greps(out, "get.execstart= /usr/bin/printf \\$DEF1 \\$DEF2 \\\\$"))
        self.assertTrue(greps(out, "      \\$DEF3 \\$DEF4 \\$DEF5"))
        self.assertTrue(greps(out, "      \\$DEF6 \\$DEF7"))
        #
        self.rm_testdir()
        self.coverage()
    def real_3002_enable_service_creates_a_symlink(self) -> None:
        self.test_3002_enable_service_creates_a_symlink(True)
    def test_3002_enable_service_creates_a_symlink(self, real: bool = False) -> None:
        """ check that a service can be enabled """
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        self.rm_zzfiles(root)
        #
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            ExecStart=/bin/sleep 2
            [Install]
            WantedBy=multi-user.target""")
        cmd = "{systemctl} daemon-reload"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = "{systemctl} enable zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        enabled_file = os_path(root, "/etc/systemd/system/multi-user.target.wants/zzb.service")
        self.assertTrue(os.path.islink(enabled_file))
        textB = reads(enabled_file)
        self.assertTrue(greps(textB, "Testing B"))
        self.assertIn("\nDescription", textB)
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_3003_disable_service_removes_the_symlink(self) -> None:
        self.test_3003_disable_service_removes_the_symlink(True)
    def test_3003_disable_service_removes_the_symlink(self, real: bool = False) -> None:
        """ check that a service can be enabled and disabled """
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        self.rm_zzfiles(root)
        #
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            ExecStart=/bin/sleep 2
            [Install]
            WantedBy=multi-user.target""")
        cmd = "{systemctl} daemon-reload"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = "{systemctl} enable zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        enabled_file = os_path(root, "/etc/systemd/system/multi-user.target.wants/zzb.service")
        self.assertTrue(os.path.islink(enabled_file))
        textB = reads(enabled_file)
        self.assertTrue(greps(textB, "Testing B"))
        self.assertIn("\nDescription", textB)
        #
        cmd = "{systemctl} enable zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        enabled_file = os_path(root, "/etc/systemd/system/multi-user.target.wants/zzb.service")
        self.assertTrue(os.path.islink(enabled_file))
        #
        cmd = "{systemctl} enable zz-other.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertNotEqual(end, 0)
        enabled_file = os_path(root, "/etc/systemd/system/multi-user.target.wants/zz-other.service")
        self.assertFalse(os.path.islink(enabled_file))
        #
        cmd = "{systemctl} disable zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        enabled_file = os_path(root, "/etc/systemd/system/multi-user.target.wants/zzb.service")
        self.assertFalse(os.path.exists(enabled_file))
        #
        cmd = "{systemctl} disable zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        enabled_file = os_path(root, "/etc/systemd/system/multi-user.target.wants/zzb.service")
        self.assertFalse(os.path.exists(enabled_file))
        #
        cmd = "{systemctl} disable zz-other.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertNotEqual(end, 0)
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_3004_list_unit_files_when_enabled(self) -> None:
        self.test_3004_list_unit_files_when_enabled(True)
    def test_3004_list_unit_files_when_enabled(self, real: bool = False) -> None:
        """ check that two unit files can be found for 'list-unit-files'
            with an enabled status """
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        self.rm_zzfiles(root)
        #
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            ExecStart=/bin/sleep 2
            [Install]
            WantedBy=multi-user.target""")
        cmd = "{systemctl} daemon-reload"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = "{systemctl} --no-legend --type=service list-unit-files"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"zza.service\s+static"))
        self.assertTrue(greps(out, r"zzb.service\s+disabled"))
        self.assertEqual(len(greps(out, "^zz")), 2)
        #
        cmd = "{systemctl} --no-legend enable zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        enabled_file = os_path(root, "/etc/systemd/system/multi-user.target.wants/zzb.service")
        self.assertTrue(os.path.islink(enabled_file))
        #
        cmd = "{systemctl} --no-legend --type=service list-unit-files"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"zza.service\s+static"))
        self.assertTrue(greps(out, r"zzb.service\s+enabled"))
        self.assertEqual(len(greps(out, "^zz")), 2)
        #
        cmd = "{systemctl} --no-legend disable zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        enabled_file = os_path(root, "/etc/systemd/system/multi-user.target.wants/zzb.service")
        self.assertFalse(os.path.exists(enabled_file))
        #
        cmd = "{systemctl} --no-legend --type=service list-unit-files"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"zza.service\s+static"))
        self.assertTrue(greps(out, r"zzb.service\s+disabled"))
        self.assertEqual(len(greps(out, "^zz")), 2)
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_3005_is_enabled_result_when_enabled(self) -> None:
        self.test_3005_is_enabled_result_when_enabled(True)
    def test_3005_is_enabled_result_when_enabled(self, real: bool = False) -> None:
        """ check that 'is-enabled' reports correctly for enabled/disabled """
        self.begin()
        vv = "-vv"
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        self.rm_zzfiles(root)
        #
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            ExecStart=/bin/sleep 2
            [Install]
            WantedBy=multi-user.target""")
        #
        cmd = "{systemctl} daemon-reload"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = "{systemctl} is-enabled zza.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"^static"))
        self.assertEqual(len(lines(out)), 1)
        cmd = "{systemctl} is-enabled zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(out, r"^disabled"))
        self.assertEqual(len(lines(out)), 1)
        #
        cmd = "{systemctl} --no-legend enable zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} is-enabled zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"^enabled"))
        self.assertEqual(len(lines(out)), 1)
        #
        cmd = "{systemctl} --no-legend disable zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} is-enabled zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^disabled"))
        self.assertEqual(len(lines(out)), 1)
        self.assertEqual(end, 1)
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3006_is_enabled_is_true_when_any_is_enabled(self) -> None:
        """ check that 'is-enabled' reports correctly for enabled/disabled """
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            ExecStart=/bin/sleep 2
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzc.service"), """
            [Unit]
            Description=Testing C
            [Service]
            ExecStart=/bin/sleep 2
            [Install]
            WantedBy=multi-user.target""")
        #
        cmd = "{systemctl} is-enabled zza.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"^static"))
        self.assertEqual(len(lines(out)), 1)
        cmd = "{systemctl} is-enabled zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(out, r"^disabled"))
        self.assertEqual(len(lines(out)), 1)
        cmd = "{systemctl} is-enabled zzc.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(out, r"^disabled"))
        self.assertEqual(len(lines(out)), 1)
        cmd = "{systemctl} is-enabled zzb.service zzc.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(out, r"^disabled"))
        self.assertFalse(greps(out, r"^enabled"))
        self.assertEqual(len(lines(out)), 2)
        cmd = "{systemctl} is-enabled zza.service zzb.service zzc.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"^disabled"))
        self.assertFalse(greps(out, r"^enabled"))
        self.assertEqual(len(lines(out)), 3)
        #
        cmd = "{systemctl} --no-legend enable zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} is-enabled zzb.service zzc.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"^disabled"))
        self.assertTrue(greps(out, r"^enabled"))
        self.assertEqual(len(lines(out)), 2)
        #
        cmd = "{systemctl} is-enabled zzb.service zza.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"^static"))
        self.assertTrue(greps(out, r"^enabled"))
        self.assertEqual(len(lines(out)), 2)
        #
        cmd = "{systemctl} is-enabled zzc.service zza.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"^static"))
        self.assertTrue(greps(out, r"^disabled"))
        self.assertEqual(len(lines(out)), 2)
        #
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3008_is_enabled_for_nonexistant_service(self) -> None:
        """ check that 'is-enabled' reports correctly for non-existant services """
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zzc.service"), """
            [Unit]
            Description=Testing C
            [Service]
            ExecStart=/bin/sleep 2
            [Install]
            WantedBy=multi-user.target""")
        #
        cmd = "{systemctl} is-enabled zz-not-existing.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        self.assertFalse(greps(out, r"^static"))
        self.assertEqual(len(lines(out)), 0)
        cmd = "{systemctl} is-enabled zz-not-existing-service.service zzc.service"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(out, r"^disabled"))
        self.assertFalse(greps(out, r"^enabled"))
        self.assertEqual(len(lines(out)), 1)
        self.assertTrue(greps(err, "Unit zz-not-existing-service.service not found."))
        #
        cmd = "{systemctl} --no-legend enable zz-not-existing-service.service"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zz-not-existing-service.service not found."))
        #
        cmd = "{systemctl} --no-legend disable zz-not-existing-service.service"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zz-not-existing-service.service not found."))
        #
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3009_sysv_service_enable(self) -> None:
        """ check that we manage SysV services in a root env
            with basic enable/disable commands, also being
            able to check its status."""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        logfile = os_path(root, "/var/log/"+testsleep+".log")
        bindir = os_path(root, "/usr/bin")
        os.makedirs(os_path(root, "/var/run"))
        text_file(logfile, "created\n")
        begin = "{"
        ends = "}"
        shell_file(os_path(testdir, "xxx.init"), """
            #! /bin/bash
            ### BEGIN INIT INFO
            # Required-Start: $local_fs $remote_fs $syslog $network
            # Required-Stop:  $local_fs $remote_fs $syslog $network
            # Default-Start:  3 5
            # Default-Stop:   0 1 2 6
            # Short-Description: Testing Z
            # Description:    Allows for SysV testing
            ### END INIT INFO
        """)
        shell_file(os_path(testdir, "zzz.init"), """
            #! /bin/bash
            ### BEGIN INIT INFO
            # Required-Start: $local_fs $remote_fs $syslog $network
            # Required-Stop:  $local_fs $remote_fs $syslog $network
            # Default-Start:  3 5
            # Default-Stop:   0 1 2 6
            # Short-Description: Testing Z
            # Description:    Allows for SysV testing
            ### END INIT INFO
            logfile={logfile}
            sleeptime=111
            start() {begin}
               [ -d /var/run ] || mkdir -p /var/run
               ({bindir}/{testsleep} $sleeptime 0<&- &>/dev/null &
                echo $! > {root}/var/run/zzz.init.pid
               ) &
               wait %1
               # ps -o pid,ppid,args
               cat "RUNNING `cat {root}/var/run/zzz.init.pid`"
            {ends}
            stop() {begin}
               killall {testsleep}
            {ends}
            case "$1" in start)
               date "+START.%T" >> $logfile
               start >> $logfile 2>&1
               date "+start.%T" >> $logfile
            ;; stop)
               date "+STOP.%T" >> $logfile
               stop >> $logfile 2>&1
               date "+stop.%T" >> $logfile
            ;; restart)
               date "+RESTART.%T" >> $logfile
               stop >> $logfile 2>&1
               start >> $logfile 2>&1
               date "+.%T" >> $logfile
            ;; reload)
               date "+RELOAD.%T" >> $logfile
               echo "...." >> $logfile 2>&1
               date "+reload.%T" >> $logfile
            ;; esac
            echo "done$1" >&2
            exit 0
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_tool(os_path(testdir, "xxx.init"), os_path(root, "/etc/init.d/xxx"))
        copy_tool(os_path(testdir, "zzz.init"), os_path(root, "/etc/init.d/zzz"))
        #
        cmd = "{systemctl} is-enabled zzz.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^disabled"))
        self.assertEqual(len(lines(out)), 1)
        self.assertEqual(end, 1)
        #
        cmd = "{systemctl} enable xxx.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = "{systemctl} enable xxx.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} --no-legend enable zzz.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} is-enabled zzz.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"^enabled"))
        self.assertEqual(len(lines(out)), 1)
        #
        cmd = "{systemctl} default-services"
        out, end = output2(cmd.format(**locals()))
        self.assertEqual(end, 0)
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines(out)), 2)
        #
        cmd = "{systemctl} --no-legend disable zzz.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} is-enabled zzz.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(out, r"^disabled"))
        self.assertEqual(len(lines(out)), 1)
        #
        cmd = "{systemctl} disable xxx.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = "{systemctl} disable xxx.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} default-services"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(len(lines(out)), 0)
        #
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3010_check_preset_all(self) -> None:
        """ check that 'is-enabled' reports correctly after 'preset-all' """
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            ExecStart=/bin/sleep 2
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzc.service"), """
            [Unit]
            Description=Testing C
            [Service]
            ExecStart=/bin/sleep 2
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system-preset/our.preset"), """
            enable zzb.service
            disable zzc.service""")
        #
        cmd = "{systemctl} is-enabled zza.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^static"))
        self.assertEqual(len(lines(out)), 1)
        self.assertEqual(end, 0)
        cmd = "{systemctl} is-enabled zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^disabled"))
        self.assertEqual(len(lines(out)), 1)
        self.assertEqual(end, 1)
        cmd = "{systemctl} is-enabled zzc.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^disabled"))
        self.assertEqual(len(lines(out)), 1)
        self.assertEqual(end, 1)
        #
        cmd = "{systemctl} preset-all"
        logg.info(" %s", cmd.format(**locals()))
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines(out)), 0)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} is-enabled zza.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^static"))
        self.assertEqual(len(lines(out)), 1)
        self.assertEqual(end, 0)
        cmd = "{systemctl} is-enabled zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^enabled"))
        self.assertEqual(len(lines(out)), 1)
        self.assertEqual(end, 0)
        cmd = "{systemctl} is-enabled zzc.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^disabled"))
        self.assertEqual(len(lines(out)), 1)
        self.assertEqual(end, 1)
        #
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3011_check_preset_one(self) -> None:
        """ check that 'is-enabled' reports correctly after 'preset service' """
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            ExecStart=/bin/sleep 2
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzc.service"), """
            [Unit]
            Description=Testing C
            [Service]
            ExecStart=/bin/sleep 2
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system-preset/our.preset"), """
            enable zzb.service
            disable zzc.service""")
        #
        cmd = "{systemctl} is-enabled zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^disabled"))
        self.assertEqual(len(lines(out)), 1)
        self.assertEqual(end, 1)
        cmd = "{systemctl} is-enabled zzc.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^disabled"))
        self.assertEqual(len(lines(out)), 1)
        self.assertEqual(end, 1)
        #
        cmd = "{systemctl} preset zzc.service -vv"
        logg.info(" %s", cmd.format(**locals()))
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines(out)), 0)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} is-enabled zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^disabled"))
        self.assertEqual(len(lines(out)), 1)
        self.assertEqual(end, 1)
        cmd = "{systemctl} is-enabled zzc.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^disabled"))
        self.assertEqual(len(lines(out)), 1)
        self.assertEqual(end, 1)
        #
        cmd = "{systemctl} preset zzb.service"
        logg.info(" %s", cmd.format(**locals()))
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines(out)), 0)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} is-enabled zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^enabled"))
        self.assertEqual(len(lines(out)), 1)
        self.assertEqual(end, 0)
        cmd = "{systemctl} is-enabled zzc.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^disabled"))
        self.assertEqual(len(lines(out)), 1)
        self.assertEqual(end, 1)
        #
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3012_check_preset_to_reset_one(self) -> None:
        """ check that 'enable' and 'preset service' are counterparts """
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            ExecStart=/bin/sleep 2
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzc.service"), """
            [Unit]
            Description=Testing C
            [Service]
            ExecStart=/bin/sleep 2
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system-preset/our.preset"), """
            enable zzb.service
            disable zzc.service""")
        #
        cmd = "{systemctl} is-enabled zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^disabled"))
        self.assertEqual(len(lines(out)), 1)
        self.assertEqual(end, 1)
        cmd = "{systemctl} is-enabled zzc.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^disabled"))
        self.assertEqual(len(lines(out)), 1)
        self.assertEqual(end, 1)
        self.assertEqual(end, 1)
        #
        cmd = "{systemctl} preset zzb.service"
        logg.info(" %s", cmd.format(**locals()))
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines(out)), 0)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} preset zzc.service"
        logg.info(" %s", cmd.format(**locals()))
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines(out)), 0)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} is-enabled zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^enabled"))
        self.assertEqual(len(lines(out)), 1)
        self.assertEqual(end, 0)
        cmd = "{systemctl} is-enabled zzc.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^disabled"))
        self.assertEqual(len(lines(out)), 1)
        self.assertEqual(end, 1)
        #
        cmd = "{systemctl} disable zzb.service"
        logg.info(" %s", cmd.format(**locals()))
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines(out)), 0)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} enable zzc.service"
        logg.info(" %s", cmd.format(**locals()))
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines(out)), 0)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} is-enabled zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^disabled"))
        self.assertEqual(len(lines(out)), 1)
        self.assertEqual(end, 1)
        cmd = "{systemctl} is-enabled zzc.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^enabled"))
        self.assertEqual(len(lines(out)), 1)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} preset zzb.service"
        logg.info(" %s", cmd.format(**locals()))
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines(out)), 0)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} preset zzc.service"
        logg.info(" %s", cmd.format(**locals()))
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines(out)), 0)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} is-enabled zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^enabled"))
        self.assertEqual(len(lines(out)), 1)
        self.assertEqual(end, 0)
        cmd = "{systemctl} is-enabled zzc.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^disabled"))
        self.assertEqual(len(lines(out)), 1)
        self.assertEqual(end, 1)
        #
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3013_check_preset_to_reset_some(self) -> None:
        """ check that 'enable' and 'preset services..' are counterparts """
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            ExecStart=/bin/sleep 2
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzc.service"), """
            [Unit]
            Description=Testing C
            [Service]
            ExecStart=/bin/sleep 2
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system-preset/our.preset"), """
            enable zzb.service
            disable zzc.service""")
        #
        cmd = "{systemctl} is-enabled zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^disabled"))
        self.assertEqual(len(lines(out)), 1)
        self.assertEqual(end, 1)
        cmd = "{systemctl} is-enabled zzc.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^disabled"))
        self.assertEqual(len(lines(out)), 1)
        self.assertEqual(end, 1)
        self.assertEqual(end, 1)
        #
        cmd = "{systemctl} preset zzb.service zzc.service"
        logg.info(" %s", cmd.format(**locals()))
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines(out)), 0)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} is-enabled zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^enabled"))
        self.assertEqual(len(lines(out)), 1)
        self.assertEqual(end, 0)
        cmd = "{systemctl} is-enabled zzc.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^disabled"))
        self.assertEqual(len(lines(out)), 1)
        self.assertEqual(end, 1)
        #
        cmd = "{systemctl} disable zzb.service"
        logg.info(" %s", cmd.format(**locals()))
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines(out)), 0)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} enable zzc.service"
        logg.info(" %s", cmd.format(**locals()))
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines(out)), 0)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} is-enabled zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^disabled"))
        self.assertEqual(len(lines(out)), 1)
        self.assertEqual(end, 1)
        cmd = "{systemctl} is-enabled zzc.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^enabled"))
        self.assertEqual(len(lines(out)), 1)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} preset zzb.service zzc.service"
        logg.info(" %s", cmd.format(**locals()))
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines(out)), 0)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} is-enabled zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^enabled"))
        self.assertEqual(len(lines(out)), 1)
        self.assertEqual(end, 0)
        cmd = "{systemctl} is-enabled zzc.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^disabled"))
        self.assertEqual(len(lines(out)), 1)
        self.assertEqual(end, 1)
        #
        cmd = "{systemctl} preset zzb.service zzc.service other.service"
        logg.info(" %s", cmd.format(**locals()))
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines(out)), 0)
        self.assertEqual(end, 1)
        #
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3015_check_preset_all_only_enable(self) -> None:
        """ check that 'preset-all' works with --preset-mode=enable """
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            ExecStart=/bin/sleep 2
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzc.service"), """
            [Unit]
            Description=Testing C
            [Service]
            ExecStart=/bin/sleep 2
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system-preset/our.preset"), """
            enable zzb.service
            disable zzc.service""")
        #
        cmd = "{systemctl} is-enabled zza.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^static"))
        self.assertEqual(len(lines(out)), 1)
        self.assertEqual(end, 0)
        cmd = "{systemctl} is-enabled zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^disabled"))
        self.assertEqual(len(lines(out)), 1)
        self.assertEqual(end, 1)
        cmd = "{systemctl} is-enabled zzc.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^disabled"))
        self.assertEqual(len(lines(out)), 1)
        self.assertEqual(end, 1)
        #
        cmd = "{systemctl} disable zzb.service"
        logg.info(" %s", cmd.format(**locals()))
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines(out)), 0)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} enable zzc.service"
        logg.info(" %s", cmd.format(**locals()))
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines(out)), 0)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} is-enabled zza.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^static"))
        self.assertEqual(len(lines(out)), 1)
        self.assertEqual(end, 0)
        cmd = "{systemctl} is-enabled zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^disabled"))
        self.assertEqual(len(lines(out)), 1)
        self.assertEqual(end, 1)
        cmd = "{systemctl} is-enabled zzc.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^enabled"))
        self.assertEqual(len(lines(out)), 1)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} preset-all --preset-mode=enable"
        logg.info(" %s", cmd.format(**locals()))
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines(out)), 0)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} is-enabled zza.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^static"))
        self.assertEqual(len(lines(out)), 1)
        self.assertEqual(end, 0)
        cmd = "{systemctl} is-enabled zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^enabled"))
        self.assertEqual(len(lines(out)), 1)
        self.assertEqual(end, 0)
        cmd = "{systemctl} is-enabled zzc.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^enabled"))
        self.assertEqual(len(lines(out)), 1)
        self.assertEqual(end, 0)
        #
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3016_check_preset_all_only_disable(self) -> None:
        """ check that 'preset-all' works with --preset-mode=disable """
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            ExecStart=/bin/sleep 2
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzc.service"), """
            [Unit]
            Description=Testing C
            [Service]
            ExecStart=/bin/sleep 2
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system-preset/our.preset"), """
            enable zzb.service
            disable zzc.service""")
        #
        cmd = "{systemctl} is-enabled zza.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^static"))
        self.assertEqual(len(lines(out)), 1)
        self.assertEqual(end, 0)
        cmd = "{systemctl} is-enabled zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^disabled"))
        self.assertEqual(len(lines(out)), 1)
        self.assertEqual(end, 1)
        cmd = "{systemctl} is-enabled zzc.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^disabled"))
        self.assertEqual(len(lines(out)), 1)
        self.assertEqual(end, 1)
        #
        cmd = "{systemctl} disable zzb.service"
        logg.info(" %s", cmd.format(**locals()))
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines(out)), 0)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} enable zzc.service"
        logg.info(" %s", cmd.format(**locals()))
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines(out)), 0)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} is-enabled zza.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^static"))
        self.assertEqual(len(lines(out)), 1)
        self.assertEqual(end, 0)
        cmd = "{systemctl} is-enabled zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^disabled"))
        self.assertEqual(len(lines(out)), 1)
        self.assertEqual(end, 1)
        cmd = "{systemctl} is-enabled zzc.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^enabled"))
        self.assertEqual(len(lines(out)), 1)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} preset-all --preset-mode=disable"
        logg.info(" %s", cmd.format(**locals()))
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines(out)), 0)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} is-enabled zza.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^static"))
        self.assertEqual(len(lines(out)), 1)
        self.assertEqual(end, 0)
        cmd = "{systemctl} is-enabled zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^disabled"))
        self.assertEqual(len(lines(out)), 1)
        self.assertEqual(end, 1)
        cmd = "{systemctl} is-enabled zzc.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, r"^disabled"))
        self.assertEqual(len(lines(out)), 1)
        self.assertEqual(end, 1)
        #
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3020_default_services(self) -> None:
        """ check the 'default-services' to know the enabled services """
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            ExecStart=/bin/sleep 2
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzc.service"), """
            [Unit]
            Description=Testing C
            [Service]
            ExecStart=/bin/sleep 2
            [Install]
            WantedBy=multi-user.target""")
        #
        cmd = "{systemctl} default-services"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines(out)), 0)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} --no-legend enable zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} default-services"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines(out)), 1)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} --no-legend enable zzc.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} default-services"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines(out)), 2)
        self.assertEqual(end, 0)
        #
        self.assertFalse(greps(out, "a.service"))
        self.assertTrue(greps(out, "b.service"))
        self.assertTrue(greps(out, "c.service"))
        #
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3021_default_services(self) -> None:
        """ check that 'default-services' skips some known services """
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            ExecStart=/bin/sleep 2
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzc.service"), """
            [Unit]
            Description=Testing C
            [Service]
            ExecStart=/bin/sleep 2
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/mount-disks.service"), """
            [Unit]
            Description=Testing C
            [Service]
            ExecStart=/bin/sleep 2
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/network.service"), """
            [Unit]
            Description=Testing C
            [Service]
            ExecStart=/bin/sleep 2
            [Install]
            WantedBy=multi-user.target""")
        #
        cmd = "{systemctl} default-services"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines(out)), 0)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} --no-legend enable zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} --no-legend enable zzc.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} --no-legend enable mount-disks.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} --no-legend enable network.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} default-services"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines(out)), 2)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} default-services --all"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines(out)), 3)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} default-services --all --force"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines(out)), 4)
        self.assertEqual(end, 0)
        #
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_3022_default_services_with_force(self) -> None:
        self.test_3022_default_services_with_force(True)
    def test_3022_default_services_with_force(self, real: bool = False) -> None:
        """ check that 'enable' can force services and targets """
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real:
            vv, systemctl = "", "systemctl"
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            ExecStart=/bin/sleep 2
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzc.service"), """
            [Unit]
            Description=Testing C
            Requires=zzx.target
            [Service]
            ExecStart=/bin/sleep 2
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzx.target"), """
            [Unit]
            Description=Testing X
            """)
        #
        cmd = "{systemctl} default-services"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines(out)), 0)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} --no-legend enable zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} --no-legend enable zzc.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} default-services"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines(out)), 2)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} --no-legend enable zza.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        #
        cmd = "{systemctl} default-services"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines(out)), 2)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} --no-legend enable zzx.target"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        #
        cmd = "{systemctl} default-services"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines(out)), 2)
        self.assertEqual(end, 0)
        ####
        cmd = "{systemctl} is-enabled zza.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(out.strip(), "static")
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} is-enabled zzx.target"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(out.strip(), "static")
        self.assertEqual(end, 0)
        ####
        #
        cmd = "{systemctl} --no-legend enable zza.service --force"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} default-services"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines(out)), 3)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} --no-legend enable zzx.target --force {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} default-services"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines(out)), 4)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} is-enabled zza.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(out.strip(), "enabled")
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} is-enabled zzx.target"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(out.strip(), "enabled")
        self.assertEqual(end, 0)
        #
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3025_default_user_services(self) -> None:
        """ check the 'default-services' to know the enabled services """
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        user = self.user()
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            ExecStart=/bin/sleep 2
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzc.service"), """
            [Unit]
            Description=Testing C
            [Service]
            ExecStart=/bin/sleep 2
            User={user}
            [Install]
            WantedBy=multi-user.target""".format(**locals()))
        configs = os.path.expanduser("~/.config")
        text_file(os_path(root, configs+"/systemd/user/zzd.service"), """
            [Unit]
            Description=Testing D
            [Service]
            ExecStart=/bin/sleep 2
            [Install]
            WantedBy=multi-user.target""".format(**locals()))
        #
        cmd = "{systemctl} list-unit-files --user"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertGreater(len(lines(out)), 4)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} default-services --user"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines(out)), 0)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} --no-legend enable zzc.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} default-services --user"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines(out)), 1)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} --no-legend enable zzd.service --user"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} default-services --user -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines(out)), 2)
        self.assertEqual(end, 0)
        #
        self.assertFalse(greps(out, "a.service"))
        self.assertFalse(greps(out, "b.service"))
        self.assertTrue(greps(out, "c.service"))
        self.assertTrue(greps(out, "d.service"))
        #
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3026_default_services_for_different_target(self, real: bool = False) -> None:
        """ check that 'default-services' changes when modifing default-target """
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            ExecStart=/bin/sleep 2
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzc.service"), """
            [Unit]
            Description=Testing C
            [Service]
            ExecStart=/bin/sleep 2
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzd.service"), """
            [Unit]
            Description=Testing D
            [Service]
            ExecStart=/bin/sleep 2
            [Install]
            WantedBy=graphical.target""")
        if not real:
            text_file(os_path(root, "/etc/systemd/system/basic.target"), """
            [Unit]
            Description=Basic Runlevel
            Requires=sockets.target""")
            text_file(os_path(root, "/etc/systemd/system/multi-user.target"), """
            [Unit]
            Description=Basic Runlevel
            Requires=basic.target""")
            text_file(os_path(root, "/etc/systemd/system/graphical.target"), """
            [Unit]
            Description=Basic Runlevel
            Requires=multi-user.target""")
        #
        cmd = "{systemctl} default-services"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines(out)), 0)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} --no-legend enable zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} --no-legend enable zzc.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} default-services"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines(out)), 2)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} get-default"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(out.strip(), "multi-user.target")
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} set-default graphical.target"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} get-default"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(out.strip(), "graphical.target")
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} --no-legend enable zzd.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} default-services -vvvv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines(out)), 3)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} set-default multi-user.target"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} default-services -vvvv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines(out)), 2)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} set-default basic.target"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} default-services -vvvv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines(out)), 0)
        self.assertEqual(end, 0)
        #
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3027_default_services_for_invented_target(self, real: bool = False) -> None:
        """ check that 'default-services' changes when modifing default-target """
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            ExecStart=/bin/sleep 2
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzc.service"), """
            [Unit]
            Description=Testing C
            [Service]
            ExecStart=/bin/sleep 2
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zzd.service"), """
            [Unit]
            Description=Testing D
            [Service]
            ExecStart=/bin/sleep 2
            [Install]
            WantedBy=graphical.target""")
        text_file(os_path(root, "/etc/systemd/system/zze.service"), """
            [Unit]
            Description=Testing E
            [Service]
            ExecStart=/bin/sleep 2
            [Install]
            WantedBy=zz-invented.target""")
        text_file(os_path(root, "/etc/systemd/system/zzi.service"), """
            [Unit]
            Description=Testing E
            [Service]
            ExecStart=/bin/sleep 2
            [Install]
            WantedBy=zz-isolated.target""")
        text_file(os_path(root, "/etc/systemd/system/zz-invented.target"), """
            [Unit]
            Description=Invented Runlevel
            Requires=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/zz-isolated.target"), """
            [Unit]
            Description=Isolated Runlevel""")
        if not real:
            text_file(os_path(root, "/etc/systemd/system/basic.target"), """
            [Unit]
            Description=Basic Runlevel
            Requires=sockets.target""")
            text_file(os_path(root, "/etc/systemd/system/multi-user.target"), """
            [Unit]
            Description=Basic Runlevel
            Requires=basic.target""")
            text_file(os_path(root, "/etc/systemd/system/graphical.target"), """
            [Unit]
            Description=Basic Runlevel
            Requires=multi-user.target""")
        #
        cmd = "{systemctl} list-unit-files --type=target"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertGreater(len(lines(out)), 6)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, "zz-invented.target"))
        #
        cmd = "{systemctl} default-services"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines(out)), 0)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} --no-legend enable zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} --no-legend enable zzc.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} default-services"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines(out)), 2)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} get-default"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(out.strip(), "multi-user.target")
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} set-default graphical.target"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} get-default"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(out.strip(), "graphical.target")
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} --no-legend enable zzd.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} default-services -vvvv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines(out)), 3)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} set-default multi-user.target"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} default-services -vvvv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines(out)), 2)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} set-default zz-nonexistant.target"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertTrue(greps(out, "No such runlevel"))
        #
        cmd = "{systemctl} set-default zz-invented.target"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} default-services -vvvv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines(out)), 2)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} --no-legend enable zze.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} default-services -vvvv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines(out)), 3)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} set-default zz-isolated.target"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} default-services -vvvv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines(out)), 0)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} --no-legend enable zzi.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} default-services -vvvv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines(out)), 1)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} set-default zz-invented.target"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} default-services -vvvv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines(out)), 3)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} --no-legend disable zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} default-services -vvvv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines(out)), 2)
        self.assertEqual(end, 0)
        #
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3030_systemctl_py_start_simple(self) -> None:
        """ check that we can start simple services with root env"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleep} 111
            ExecStop=/usr/bin/killall {testsleep}
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        #
        cmd = "{systemctl} enable zzz.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = "{systemctl} --version"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = "{systemctl} default-services -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, "zzz.service"))
        self.assertEqual(len(lines(out)), 1)
        #
        cmd = "{systemctl} start zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        #
        cmd = "{systemctl} stop zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        kill_testsleep = "{systemctl} __killall {testsleep}"
        sx____(kill_testsleep.format(**locals()))
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3031_systemctl_py_start_extra_simple(self) -> None:
        """ check that we can start extra simple services with root env"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleep} 111
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        #
        cmd = "{systemctl} enable zzz.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = "{systemctl} --version"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = "{systemctl} default-services -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, "zzz.service"))
        self.assertEqual(len(lines(out)), 1)
        #
        cmd = "{systemctl} start zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        #
        cmd = "{systemctl} stop zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        kill_testsleep = "{systemctl} __killall {testsleep}"
        sx____(kill_testsleep.format(**locals()))
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3032_systemctl_py_start_forking(self) -> None:
        """ check that we can start forking services with root env"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        os.makedirs(os_path(root, "/var/run"))
        shell_file(os_path(testdir, "zzz.init"), """
            #! /bin/bash
            case "$1" in start)
               [ -d /var/run ] || mkdir -p /var/run
               ({bindir}/{testsleep} 111 0<&- &>/dev/null &
                echo $! > {root}/var/run/zzz.init.pid
               ) &
               wait %1
               ps -o pid,ppid,args
            ;; stop)
               killall {testsleep}
            ;; esac
            echo "done$1" >&2
            exit 0
            """.format(**locals()))
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            [Service]
            Type=forking
            PIDFile={root}/var/run/zzz.init.pid
            ExecStart={root}/usr/bin/zzz.init start
            ExeeStop={root}/usr/bin/zzz.init stop
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_tool(os_path(testdir, "zzz.init"), os_path(root, "/usr/bin/zzz.init"))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        #
        cmd = "{systemctl} enable zzz.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = "{systemctl} --version"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = "{systemctl} default-services -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, "zzz.service"))
        self.assertEqual(len(lines(out)), 1)
        #
        cmd = "{systemctl} start zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        #
        cmd = "{systemctl} stop zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        kill_testsleep = "{systemctl} __killall {testsleep}"
        sx____(kill_testsleep.format(**locals()))
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3033_systemctl_py_start_forking_without_pid_file(self) -> None:
        """ check that we can start forking services with root env without PIDFile"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        os.makedirs(os_path(root, "/var/run"))
        shell_file(os_path(testdir, "zzz.init"), """
            #! /bin/bash
            case "$1" in start)
               ({bindir}/{testsleep} 111 0<&- &>/dev/null &) &
               wait %1
               # ps -o pid,ppid,args >&2
            ;; stop)
               killall {testsleep}
               echo killed all {testsleep} >&2
               sleep 1
            ;; esac
            echo "done$1" >&2
            exit 0
            """.format(**locals()))
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            [Service]
            Type=forking
            ExecStart={root}/usr/bin/zzz.init start
            ExecStop={root}/usr/bin/zzz.init stop
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_tool(os_path(testdir, "zzz.init"), os_path(root, "/usr/bin/zzz.init"))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        #
        cmd = "{systemctl} enable zzz.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = "{systemctl} --version"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = "{systemctl} default-services -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, "zzz.service"))
        self.assertEqual(len(lines(out)), 1)
        #
        cmd = "{systemctl} start zzz.service -vvvv 2>&1"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        #
        cmd = "{systemctl} stop zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        kill_testsleep = "{systemctl} __killall {testsleep}"
        sx____(kill_testsleep.format(**locals()))
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3040_systemctl_py_start_simple_bad_stop(self) -> None:
        """ check that we can start simple services with root env"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleep} 111
            ExecStop=/usr/bin/killall -q z-not-existing
            TimeoutStopSec=4
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        #
        cmd = "{systemctl} enable zzz.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = "{systemctl} --version"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = "{systemctl} default-services -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, "zzz.service"))
        self.assertEqual(len(lines(out)), 1)
        #
        cmd = "{systemctl} start zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        #
        cmd = "{systemctl} stop zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        kill_testsleep = "{systemctl} __killall {testsleep}"
        sx____(kill_testsleep.format(**locals()))
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3041_systemctl_py_start_extra_simple_bad_start(self) -> None:
        """ check that we can start extra simple services with root env"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleep} foo
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        #
        cmd = "{systemctl} enable zzz.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = "{systemctl} --version"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = "{systemctl} default-services -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, "zzz.service"))
        self.assertEqual(len(lines(out)), 1)
        #
        cmd = "{systemctl} start zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        #
        cmd = "{systemctl} stop zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        kill_testsleep = "{systemctl} __killall {testsleep}"
        sx____(kill_testsleep.format(**locals()))
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3042_systemctl_py_start_forking_bad_stop(self) -> None:
        """ check that we can start forking services with root env"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        os.makedirs(os_path(root, "/var/run"))
        shell_file(os_path(testdir, "zzz.init"), """
            #! /bin/bash
            case "$1" in start)
               [ -d /var/run ] || mkdir -p /var/run
               ({bindir}/{testsleep} 111 0<&- &>/dev/null &
                echo $! > {root}/var/run/zzz.init.pid
               ) &
               wait %1
               ps -o pid,ppid,args
            ;; stop)
               killall {testsleep}
               exit 1
            ;; esac
            echo "done$1" >&2
            exit 0
            """.format(**locals()))
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            [Service]
            Type=forking
            PIDFile={root}/var/run/zzz.init.pid
            ExecStart={root}/usr/bin/zzz.init start
            ExeeStop={root}/usr/bin/zzz.init stop
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_tool(os_path(testdir, "zzz.init"), os_path(root, "/usr/bin/zzz.init"))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        #
        cmd = "{systemctl} enable zzz.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = "{systemctl} --version"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = "{systemctl} default-services -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, "zzz.service"))
        self.assertEqual(len(lines(out)), 1)
        #
        cmd = "{systemctl} start zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        #
        cmd = "{systemctl} stop zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        kill_testsleep = "{systemctl} __killall {testsleep}"
        sx____(kill_testsleep.format(**locals()))
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3043_systemctl_py_start_forking_bad_start(self) -> None:
        """ check that we can start forking services with root env without PIDFile"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        os.makedirs(os_path(root, "/var/run"))
        shell_file(os_path(testdir, "zzz.init"), """
            #! /bin/bash
            case "$1" in start)
               ({bindir}/{testsleep} 111 0<&- &>/dev/null &) &
               wait %1
               # ps -o pid,ppid,args >&2
            ;; stop)
               killall {testsleep}
               echo killed all {testsleep} >&2
               sleep 1
            ;; esac
            echo "done$1" >&2
            exit 1
            """.format(**locals()))
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            [Service]
            Type=forking
            ExecStart={root}/usr/bin/zzz.init start
            ExecStop={root}/usr/bin/zzz.init stop
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_tool(os_path(testdir, "zzz.init"), os_path(root, "/usr/bin/zzz.init"))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        #
        cmd = "{systemctl} enable zzz.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = "{systemctl} --version"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = "{systemctl} default-services -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, "zzz.service"))
        self.assertEqual(len(lines(out)), 1)
        #
        cmd = "{systemctl} start zzz.service -vvvv 2>&1"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        #
        cmd = "{systemctl} stop zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        kill_testsleep = "{systemctl} __killall {testsleep}"
        sx____(kill_testsleep.format(**locals()))
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3049_systemctl_py_run_default_services_in_testenv(self) -> None:
        """ check that we can enable services in a test env to be run as default-services"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A""")
        text_file(os_path(testdir, "zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleep} 99
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zzc.service"), """
            [Unit]
            Description=Testing C
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleep} 111
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        copy_file(os_path(testdir, "zzc.service"), os_path(root, "/etc/systemd/system/zzc.service"))
        #
        cmd = "{systemctl} enable zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = "{systemctl} enable zzc.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = "{systemctl} --version"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = "{systemctl} default-services -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, "zzb.service"))
        self.assertEqual(len(lines(out)), 2)
        #
        cmd = "{systemctl} default -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep+" 99"))
        self.assertTrue(greps(top, testsleep+" 111"))
        #
        cmd = "{systemctl} halt -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        #
        kill_testsleep = "{systemctl} __killall {testsleep}"
        sx____(kill_testsleep.format(**locals()))
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_3050_systemctl_py_check_is_active(self) -> None:
        self.test_3050_systemctl_py_check_is_active(True)
    def test_3050_systemctl_py_check_is_active(self, real: bool = False) -> None:
        """ check is_active behaviour"""
        self.begin()
        vv = "-vv"
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A""")
        text_file(os_path(testdir, "zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleep} 99
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zzc.service"), """
            [Unit]
            Description=Testing C
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleep} 111
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        sx____(_systemctl_py+" __killall {testsleep}".format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        copy_file(os_path(testdir, "zzc.service"), os_path(root, "/etc/systemd/system/zzc.service"))
        sh____("{systemctl} daemon-reload".format(**locals()))
        #
        enable_A = "{systemctl} enable zza.service"
        enable_B = "{systemctl} enable zzb.service"
        enable_C = "{systemctl} enable zzc.service"
        enable_D = "{systemctl} enable zzd.service"
        doneA, exitA = output2(enable_A.format(**locals()))
        doneB, exitB = output2(enable_B.format(**locals()))
        doneC, exitC = output2(enable_C.format(**locals()))
        doneD, exitD = output2(enable_D.format(**locals()))
        if TODO or real: self.assertEqual(exitA, 0)
        else: self.assertEqual(exitA, 1)
        self.assertEqual(exitB, 0)
        self.assertEqual(exitC, 0)
        self.assertEqual(exitD, 1)
        #
        is_active_A = "{systemctl} is-active zza.service"
        is_active_B = "{systemctl} is-active zzb.service"
        is_active_C = "{systemctl} is-active zzc.service"
        is_active_D = "{systemctl} is-active zzd.service"
        actA, exitA = output2(is_active_A.format(**locals()))
        actB, exitB = output2(is_active_B.format(**locals()))
        actC, exitC = output2(is_active_C.format(**locals()))
        actD, exitD = output2(is_active_D.format(**locals()))
        self.assertEqual(actA.strip(), "inactive")
        self.assertEqual(actB.strip(), "inactive")
        self.assertEqual(actC.strip(), "inactive")
        self.assertEqual(exitA, 3)
        self.assertEqual(exitB, 3)
        self.assertEqual(exitC, 3)
        self.assertEqual(exitD, 3)
        #
        cmd = "{systemctl} start zzb.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        is_active_A = "{systemctl} is-active zza.service"
        is_active_B = "{systemctl} is-active zzb.service"
        is_active_C = "{systemctl} is-active zzc.service"
        is_active_D = "{systemctl} is-active zzd.service"
        actA, exitA = output2(is_active_A.format(**locals()))
        actB, exitB = output2(is_active_B.format(**locals()))
        actC, exitC = output2(is_active_C.format(**locals()))
        actD, exitD = output2(is_active_D.format(**locals()))
        self.assertEqual(actA.strip(), "inactive")
        self.assertEqual(actB.strip(), "active")
        self.assertEqual(actC.strip(), "inactive")
        self.assertEqual(actD.strip(), "inactive")
        self.assertNotEqual(exitA, 0)
        self.assertEqual(exitB, 0)
        self.assertNotEqual(exitC, 0)
        self.assertNotEqual(exitD, 0)
        #
        logg.info("== checking with --quiet")
        is_active_A = "{systemctl} is-active zza.service --quiet"
        is_active_B = "{systemctl} is-active zzb.service --quiet"
        actA, exitA = output2(is_active_A.format(**locals()))
        actB, exitB = output2(is_active_B.format(**locals()))
        self.assertEqual(actA, "")
        self.assertEqual(actB, "")
        self.assertNotEqual(exitA, 0)
        self.assertEqual(exitB, 0)
        #
        logg.info("== checking combinations of arguments")
        is_active_BC = "{systemctl} is-active zzb.service zzc.service "
        is_active_CD = "{systemctl} is-active zzc.service zzd.service"
        is_active_BD = "{systemctl} is-active zzb.service zzd.service"
        is_active_BCD = "{systemctl} is-active zzb.service zzc.service zzd.service"
        actBC, exitBC = output2(is_active_BC.format(**locals()))
        actCD, exitCD = output2(is_active_CD.format(**locals()))
        actBD, exitBD = output2(is_active_BD.format(**locals()))
        actBCD, exitBCD = output2(is_active_BCD.format(**locals()))
        self.assertEqual(actBC.split("\n"), ["active", "inactive", ""])
        self.assertEqual(actCD.split("\n"), ["inactive", "inactive", ""])
        self.assertEqual(actBD.split("\n"), ["active", "inactive", ""])
        self.assertEqual(actBCD.split("\n"), ["active", "inactive", "inactive", ""])
        if not real:
            self.assertNotEqual(exitBC, 0)  # TODO
            self.assertNotEqual(exitCD, 0)
            self.assertNotEqual(exitBD, 0)
            self.assertNotEqual(exitBCD, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep+" 99"))
        #
        cmd = "{systemctl} start zzc.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        actBC, exitBC = output2(is_active_BC.format(**locals()))
        self.assertEqual(actBC.split("\n"), ["active", "active", ""])
        self.assertEqual(exitBC, 0)
        #
        cmd = "{systemctl} stop zzb.service zzc.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        actBC, exitBC = output2(is_active_BC.format(**locals()))
        self.assertEqual(actBC.split("\n"), ["inactive", "inactive", ""])
        self.assertNotEqual(exitBC, 0)
        #
        kill_testsleep = _systemctl_py+" __killall {testsleep}"
        sx____(kill_testsleep.format(**locals()))
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
        self.end()
    def real_3051_systemctl_py_check_is_failed(self) -> None:
        self.test_3051_systemctl_py_check_is_failed(True)
    def test_3051_systemctl_py_check_is_failed(self, real: bool = False) -> None:
        """ check is_failed behaviour"""
        self.begin()
        vv = "-vv"
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A""")
        text_file(os_path(testdir, "zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleep} 99
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zzc.service"), """
            [Unit]
            Description=Testing C
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleep} 111
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        sx____(_systemctl_py+" __killall {testsleep}".format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        copy_file(os_path(testdir, "zzc.service"), os_path(root, "/etc/systemd/system/zzc.service"))
        sh____("{systemctl} daemon-reload".format(**locals()))
        #
        enable_A = "{systemctl} enable zza.service"
        enable_B = "{systemctl} enable zzb.service"
        enable_C = "{systemctl} enable zzc.service"
        enable_D = "{systemctl} enable zzd.service"
        doneA, exitA = output2(enable_A.format(**locals()))
        doneB, exitB = output2(enable_B.format(**locals()))
        doneC, exitC = output2(enable_C.format(**locals()))
        doneD, exitD = output2(enable_D.format(**locals()))
        if TODO or real: self.assertEqual(exitA, 0)
        else: self.assertEqual(exitA, 1)
        self.assertEqual(exitB, 0)
        self.assertEqual(exitC, 0)
        self.assertEqual(exitD, 1)
        #
        is_active_A = "{systemctl} is-failed zza.service"
        is_active_B = "{systemctl} is-failed zzb.service"
        is_active_C = "{systemctl} is-failed zzc.service"
        is_active_D = "{systemctl} is-failed zzd.service"
        actA, exitA = output2(is_active_A.format(**locals()))
        actB, exitB = output2(is_active_B.format(**locals()))
        actC, exitC = output2(is_active_C.format(**locals()))
        actD, exitD = output2(is_active_D.format(**locals()))
        self.assertEqual(actA.strip(), "inactive")
        self.assertEqual(actB.strip(), "inactive")
        self.assertEqual(actC.strip(), "inactive")
        self.assertEqual(actD.strip(), "inactive")
        self.assertEqual(exitA, 1)
        self.assertEqual(exitB, 1)
        self.assertEqual(exitC, 1)
        self.assertEqual(exitD, 1)
        #
        cmd = "{systemctl} start zzb.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        is_active_A = "{systemctl} is-failed zza.service"
        is_active_B = "{systemctl} is-failed zzb.service"
        is_active_C = "{systemctl} is-failed zzc.service"
        is_active_D = "{systemctl} is-failed zzd.service"
        actA, exitA = output2(is_active_A.format(**locals()))
        actB, exitB = output2(is_active_B.format(**locals()))
        actC, exitC = output2(is_active_C.format(**locals()))
        actD, exitD = output2(is_active_D.format(**locals()))
        self.assertEqual(actA.strip(), "inactive")
        self.assertEqual(actB.strip(), "active")
        self.assertEqual(actC.strip(), "inactive")
        self.assertEqual(actD.strip(), "inactive")
        self.assertEqual(exitA, 1)
        self.assertEqual(exitB, 1)
        self.assertEqual(exitC, 1)
        self.assertEqual(exitD, 1)
        #
        logg.info("== checking with --quiet")
        is_active_A = "{systemctl} is-failed zza.service --quiet"
        is_active_B = "{systemctl} is-failed zzb.service --quiet"
        actA, exitA = output2(is_active_A.format(**locals()))
        actB, exitB = output2(is_active_B.format(**locals()))
        self.assertEqual(actA, "")
        self.assertEqual(actB, "")
        self.assertEqual(exitA, 1)
        self.assertEqual(exitB, 1)
        #
        logg.info("== checking combinations of arguments")
        is_active_BC = "{systemctl} is-failed zzb.service zzc.service {vv}"
        is_active_CD = "{systemctl} is-failed zzc.service zzd.service {vv}"
        is_active_BD = "{systemctl} is-failed zzb.service zzd.service {vv}"
        is_active_BCD = "{systemctl} is-failed zzb.service zzc.service zzd.service {vv}"
        is_active_BCDX = "{systemctl} is-failed zzb.service zzc.service zzd.service --quiet {vv}"
        actBC, exitBC = output2(is_active_BC.format(**locals()))
        actCD, exitCD = output2(is_active_CD.format(**locals()))
        actBD, exitBD = output2(is_active_BD.format(**locals()))
        actBCD, exitBCD = output2(is_active_BCD.format(**locals()))
        actBCDX, exitBCDX = output2(is_active_BCDX.format(**locals()))
        self.assertEqual(actBC.split("\n"), ["active", "inactive", ""])
        self.assertEqual(actCD.split("\n"), ["inactive", "inactive", ""])
        self.assertEqual(actBD.split("\n"), ["active", "inactive", ""])
        self.assertEqual(actBCD.split("\n"), ["active", "inactive", "inactive", ""])
        self.assertEqual(actBCDX.split("\n"), [""])
        if not real:
            self.assertNotEqual(exitBC, 0)
            self.assertNotEqual(exitCD, 0)
            self.assertNotEqual(exitBD, 0)
            self.assertNotEqual(exitBCD, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep+" 99"))
        #
        cmd = "{systemctl} start zzc.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        actBC, exitBC = output2(is_active_BC.format(**locals()))
        self.assertEqual(actBC.split("\n"), ["active", "active", ""])
        self.assertNotEqual(exitBC, 0)
        #
        actBC, exitBC = output2(is_active_BC.format(**locals()))
        self.assertEqual(actBC.split("\n"), ["active", "active", ""])
        self.assertNotEqual(exitBC, 0)
        #
        kill_testsleep = "{systemctl} __killall {testsleep}"
        sx____(kill_testsleep.format(**locals()))
        #
        actBC, exitBC = output2(is_active_BC.format(**locals()))
        if real:
            self.assertEqual(exitBC, 1)
            self.assertEqual(actBC.split("\n"), ["active", "active", ""])
        else:
            self.assertEqual(exitBC, 0)
            self.assertEqual(actBC.split("\n"), ["failed", "failed", ""])
        #
        cmd = "{systemctl} stop zzb.service zzc.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        actBC, exitBC = output2(is_active_BC.format(**locals()))
        self.assertEqual(actBC.split("\n"), ["inactive", "inactive", ""])
        self.assertNotEqual(exitBC, 0)
        #
        kill_testsleep = _systemctl_py+" __killall {testsleep}"
        sx____(kill_testsleep.format(**locals()))
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_3060_is_active_for_forking(self) -> None:
        self.test_3060_is_active_for_forking(True)
    def test_3060_is_active_for_forking(self, real: bool = False) -> None:
        """ check that we can start forking services and have them is-active"""
        self.begin()
        vv = "-vv"
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        bindir = os_path(root, "/usr/bin")
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        testsleep = self.testname("sleep")
        self.makedirs(os_path(root, "/var/run"))
        shell_file(os_path(testdir, "zzz.init"), """
            #! /bin/bash
            case "$1" in start)
               [ -d /var/run ] || mkdir -p /var/run
               ({bindir}/{testsleep} 111 0<&- &>/dev/null &
                echo $! > {root}/var/run/zzz.init.pid
               ) &
               wait %1
               ps -o pid,ppid,args
            ;; stop)
               killall {testsleep}
            ;; esac
            echo "done$1" >&2
            exit 0
            """.format(**locals()))
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            [Service]
            Type=forking
            PIDFile={root}/var/run/zzz.init.pid
            ExecStart={root}/usr/bin/zzz.init start
            ExecStop={root}/usr/bin/zzz.init stop
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_tool(os_path(testdir, "zzz.init"), os_path(root, "/usr/bin/zzz.init"))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        cmd = "{systemctl} daemon-reload"
        sh____(cmd.format(**locals()))
        #
        cmd = "{systemctl} is-active zzz.service {vv}"
        actZX, exitZX = output2(cmd.format(**locals()))
        self.assertEqual(actZX.split("\n"), ["inactive", ""])
        self.assertEqual(exitZX, 3)
        #
        cmd = "{systemctl} enable zzz.service {vv}"
        sh____(cmd.format(**locals()))
        cmd = "{systemctl} is-active zzz.service {vv}"
        actZX, exitZX = output2(cmd.format(**locals()))
        self.assertEqual(actZX.split("\n"), ["inactive", ""])
        self.assertEqual(exitZX, 3)
        #
        cmd = "{systemctl} start zzz.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        #
        is_active_ZX = "{systemctl} is-active zzz.service {vv}"
        actZX, exitZX = output2(is_active_ZX.format(**locals()))
        self.assertEqual(actZX.split("\n"), ["active", ""])
        self.assertEqual(exitZX, 0)
        #
        cmd = "{systemctl} stop zzz.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        #
        is_active_ZX = "{systemctl} is-active zzz.service {vv}"
        actZX, exitZX = output2(is_active_ZX.format(**locals()))
        self.assertEqual(actZX.split("\n"), ["inactive", ""])
        self.assertEqual(exitZX, 3)
        #
        kill_testsleep = "{systemctl} __killall {testsleep}"
        sx____(kill_testsleep.format(**locals()))
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
        self.end()
    def real_3061_is_failed_for_forking(self) -> None:
        self.test_3061_is_failed_for_forking(True)
    def test_3061_is_failed_for_forking(self, real: bool = False) -> None:
        """ check that we can start forking services and have them is-failed"""
        self.begin()
        vv = "-vv"
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        bindir = os_path(root, "/usr/bin")
        testsleep = self.testname("sleep")
        self.makedirs(os_path(root, "/var/run"))
        shell_file(os_path(testdir, "zzz.init"), """
            #! /bin/bash
            case "$1" in start)
               [ -d /var/run ] || mkdir -p /var/run
               ({bindir}/{testsleep} 111 0<&- &>/dev/null &
                echo $! > {root}/var/run/zzz.init.pid
               ) &
               wait %1
               ps -o pid,ppid,args
            ;; stop)
               killall {testsleep}
            ;; esac
            echo "done$1" >&2
            exit 0
            """.format(**locals()))
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            [Service]
            Type=forking
            PIDFile={root}/var/run/zzz.init.pid
            ExecStart={root}/usr/bin/zzz.init start
            ExecStop={root}/usr/bin/zzz.init stop
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_tool(os_path(testdir, "zzz.init"), os_path(root, "/usr/bin/zzz.init"))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        sh____("{systemctl} daemon-reload".format(**locals()))
        #
        cmd = "{systemctl} is-failed zzz.service {vv}"
        actZX, exitZX = output2(cmd.format(**locals()))
        self.assertEqual(actZX.split("\n"), ["inactive", ""])
        self.assertEqual(exitZX, 1)
        #
        cmd = "{systemctl} enable zzz.service"
        sh____(cmd.format(**locals()))
        cmd = "{systemctl} is-failed zzz.service {vv}"
        actZX, exitZX = output2(cmd.format(**locals()))
        self.assertEqual(actZX.split("\n"), ["inactive", ""])
        self.assertEqual(exitZX, 1)
        #
        cmd = "{systemctl} start zzz.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        #
        is_active_ZX = "{systemctl} is-failed zzz.service {vv}"
        actZX, exitZX = output2(is_active_ZX.format(**locals()))
        self.assertEqual(actZX.split("\n"), ["active", ""])
        self.assertEqual(exitZX, 1)
        #
        cmd = "{systemctl} stop zzz.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        #
        is_active_ZX = "{systemctl} is-failed zzz.service {vv}"
        actZX, exitZX = output2(is_active_ZX.format(**locals()))
        self.assertEqual(actZX.split("\n"), ["inactive", ""])
        self.assertEqual(exitZX, 1)
        #
        kill_testsleep = "{systemctl} __killall {testsleep}"
        sx____(kill_testsleep.format(**locals()))
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
        self.end()
    def real_3063_is_active_for_forking_delayed(self) -> None:
        self.test_3063_is_active_for_forking_delayed(True)
    def test_3063_is_active_for_forking_delayed(self, real: bool = False) -> None:
        """ check that we can start forking services and have them is-active,
            even when the pid-file is created later because startup waits
            for its existance."""
        self.begin()
        vv = "-vv"
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        self.makedirs(os_path(root, "/var/run"))
        shell_file(os_path(testdir, "zzz.init"), """
            #! /bin/bash
            case "$1" in start)
               [ -d /var/run ] || mkdir -p /var/run
               ({bindir}/{testsleep} 111 0<&- &>/dev/null &
                sleep 4
                echo $! > {root}/var/run/zzz.init.pid
               ) &
               sleep 1
               ps -o pid,ppid,args
            ;; stop)
               killall {testsleep}
            ;; esac
            echo "done$1" >&2
            exit 0
            """.format(**locals()))
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            [Service]
            Type=forking
            PIDFile={root}/var/run/zzz.init.pid
            ExecStart={root}/usr/bin/zzz.init start
            ExecStop={root}/usr/bin/zzz.init stop
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_tool(os_path(testdir, "zzz.init"), os_path(root, "/usr/bin/zzz.init"))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        sh____("{systemctl} daemon-reload".format(**locals()))
        #
        cmd = "{systemctl} is-active zzz.service {vv}"
        actZX, exitZX = output2(cmd.format(**locals()))
        self.assertEqual(actZX.split("\n"), ["inactive", ""])
        self.assertEqual(exitZX, 3)
        #
        cmd = "{systemctl} enable zzz.service"
        sh____(cmd.format(**locals()))
        cmd = "{systemctl} is-active zzz.service {vv}"
        actZX, exitZX = output2(cmd.format(**locals()))
        self.assertEqual(actZX.split("\n"), ["inactive", ""])
        self.assertEqual(exitZX, 3)
        #
        cmd = "{systemctl} start zzz.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        #
        is_active_ZX = "{systemctl} is-active zzz.service {vv}"
        actZX, exitZX = output2(is_active_ZX.format(**locals()))
        self.assertEqual(actZX.split("\n"), ["active", ""])
        self.assertEqual(exitZX, 0)
        self.assertTrue(os.path.exists(os_path(root, "/var/run/zzz.init.pid")))
        time.sleep(4)
        self.assertTrue(os.path.exists(os_path(root, "/var/run/zzz.init.pid")))
        #
        cmd = "{systemctl} stop zzz.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        #
        is_active_ZX = "{systemctl} is-active zzz.service {vv}"
        actZX, exitZX = output2(is_active_ZX.format(**locals()))
        self.assertEqual(actZX.split("\n"), ["inactive", ""])
        self.assertEqual(exitZX, 3)
        #
        kill_testsleep = "{systemctl} __killall {testsleep}"
        sx____(kill_testsleep.format(**locals()))
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
        self.end()
    def real_3070_check_prestart_is_activating(self) -> None:
        self.test_3070_check_prestart_is_activating(True)
    def test_3070_check_prestart_is_activating(self, real: bool = False) -> None:
        """ consider a situation where a 'systemctl start <service>' is
            taking a bit longer to start. Especially some pre-start
            must be blocking while being in state 'activating'"""
        self.begin()
        vv = "-vv"
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir, real)
        systemctl = cover() + realpath(_systemctl_py) + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        logfile = os.path.join(os.path.abspath(testdir), "zzz.log")
        self.makedirs(os_path(root, "/var/run"))
        shell_file(os_path(testdir, "zzz.init"), """
            #! /bin/bash
            case "$1" in start)
               [ -d /var/run ] || mkdir -p /var/run
               (
                mkdir -p {root}/var/log
                echo `date +%M:%S` starting pid >{logfile}
                {bindir}/{testsleep} 111 0<&- &>/dev/null &
                echo $! > {root}/var/run/zzz.init.pid
                echo `date +%M:%S` started pid >>{logfile}
                sleep 2
                echo `date +%M:%S` starting zza >>{logfile}
                {systemctl} start zza.service {vv} >>{logfile} 2>&1
                echo `date +%M:%S` started zza >>{logfile}
               ) &
               sleep 1
               ps -o pid,ppid,args
            ;; stop)
               killall {testsleep}
            ;; esac
            echo "done$1" >&2
            exit 0
            """.format(**locals()))
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            [Service]
            Type=forking
            PIDFile={root}/var/run/zzz.init.pid
            ExecStart={root}/usr/bin/zzz.init start
            ExecStop={root}/usr/bin/zzz.init stop
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStartPre={bindir}/{testsleep}pre 5
            ExecStart={bindir}/{testsleep}now 10
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_tool(_bin_sleep, os_path(bindir, testsleep+"pre"))
        copy_tool(_bin_sleep, os_path(bindir, testsleep+"now"))
        copy_tool(os_path(testdir, "zzz.init"), os_path(root, "/usr/bin/zzz.init"))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        sh____("{systemctl} daemon-reload".format(**locals()))
        #
        cmd = "{systemctl} enable zza.service zzz.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = "{systemctl} start zzz.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        logg.info("===== [0] just started")
        top = greps(_recent(output(_top_list)), testsleep)
        logg.info("top>>>\n| %s", "\n| ".join(top))
        self.assertFalse(greps(top, testsleep+"pre"))
        self.assertFalse(greps(top, testsleep+"now"))
        log0 = lines(open(logfile))
        logg.info("zzz.log>\n\t%s", "\n\t".join(log0))
        time.sleep(2)
        logg.info("===== [1] after start")
        cmd = "{systemctl} is-active zza.service zzz.service {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        top = greps(_recent(output(_top_list)), testsleep)
        logg.info("top>>>\n| %s", "\n| ".join(top))
        self.assertTrue(greps(top, testsleep+"pre"))
        self.assertFalse(greps(top, testsleep+"now"))
        log1 = lines(open(logfile))
        logg.info("zzz.log>\n\t%s", "\n\t".join(log1))
        time.sleep(2)
        #
        logg.info("===== [2] some later")
        cmd = "{systemctl} is-active zza.service zzz.service {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        top = greps(_recent(output(_top_list)), testsleep)
        logg.info("top>>>\n| %s", "\n| ".join(top))
        self.assertTrue(greps(top, testsleep+"pre"))
        self.assertFalse(greps(top, testsleep+"now"))
        log2 = lines(open(logfile))
        logg.info("zzz.log>\n\t%s", "\n\t".join(log2))
        time.sleep(2)
        #
        logg.info("===== [3] some more later")
        cmd = "{systemctl} is-active zza.service zzz.service {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        top = greps(_recent(output(_top_list)), testsleep)
        logg.info("top>>>\n| %s", "\n| ".join(top))
        time.sleep(2)
        top = greps(_recent(output(_top_list)), testsleep)
        logg.info("top>>>\n| %s", "\n| ".join(top))
        self.assertFalse(greps(top, testsleep+"pre"))
        self.assertTrue(greps(top, testsleep+"now"))
        log3 = lines(open(logfile))
        logg.info("zzz.log>\n\t%s", "\n\t".join(log3))
        time.sleep(3)
        logg.info("===== [4] even more later")
        cmd = "{systemctl} is-active zza.service zzz.service {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        top = greps(_recent(output(_top_list)), testsleep)
        logg.info("top>>>\n| %s", "\n| ".join(top))
        self.assertFalse(greps(top, testsleep+"pre"))
        self.assertTrue(greps(top, testsleep+"now"))
        log4 = lines(open(logfile))
        logg.info("zzz.log>\n\t%s", "\n\t".join(log4))
        #
        kill_testsleep = "{systemctl} __killall {testsleep}"
        sx____(kill_testsleep.format(**locals()))
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
        self.end()
    def real_3080_two_service_starts_in_parallel(self) -> None:
        self.test_3080_two_service_starts_in_parallel(True)
    def test_3080_two_service_starts_in_parallel(self, real: bool = False) -> None:
        """ consider a situation where a 'systemctl start <service>' is
            done from two programs at the same time. Ensure that there
            is a locking that disallow then to run in parallel."""
        self.begin()
        vv = "-vv"
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir, real)
        systemctl = cover() + realpath(_systemctl_py) + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        logfile = os.path.join(os.path.abspath(testdir), "zzz.log")
        self.makedirs(os_path(root, "/var/run"))
        shell_file(os_path(testdir, "zzz.init"), """
            #! /bin/bash
            case "$1" in start)
               [ -d /var/run ] || mkdir -p /var/run
               (
                mkdir -p {root}/var/log
                echo `date +%M:%S` starting pid >{logfile}
                {bindir}/{testsleep} 111 0<&- &>/dev/null &
                echo $! > {root}/var/run/zzz.init.pid
                echo `date +%M:%S` started pid >>{logfile}
                sleep 2
                echo `date +%M:%S` starting zza >>{logfile}
                {systemctl} start zza.service {vv} >>{logfile} 2>&1
                echo `date +%M:%S` started zza >>{logfile}
               ) &
               sleep 1
               ps -o pid,ppid,args
            ;; stop)
               killall {testsleep}
            ;; esac
            echo "done$1" >&2
            exit 0
            """.format(**locals()))
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            [Service]
            Type=forking
            PIDFile={root}/var/run/zzz.init.pid
            ExecStart={root}/usr/bin/zzz.init start
            ExecStop={root}/usr/bin/zzz.init stop
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStartPre={bindir}/{testsleep}pre 5
            ExecStart={bindir}/{testsleep}now 10
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_tool(_bin_sleep, os_path(bindir, testsleep+"pre"))
        copy_tool(_bin_sleep, os_path(bindir, testsleep+"now"))
        copy_tool(os_path(testdir, "zzz.init"), os_path(root, "/usr/bin/zzz.init"))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        sh____("{systemctl} daemon-reload".format(**locals()))
        #
        cmd = "{systemctl} enable zza.service zzz.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = "{systemctl} start zzz.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        logg.info("===== [0] just started")
        top = greps(_recent(output(_top_list)), testsleep)
        logg.info("top>>>\n| %s", "\n| ".join(top))
        self.assertTrue(greps(top, testsleep))
        log1 = lines(open(logfile))
        logg.info("zzz.log>\n\t%s", "\n\t".join(log1))
        time.sleep(3)
        logg.info("===== [1] after start")
        top = greps(_recent(output(_top_list)), testsleep)
        logg.info("top>>>\n| %s", "\n| ".join(top))
        self.assertTrue(greps(top, testsleep))
        log1 = lines(open(logfile))
        logg.info("zzz.log>\n\t%s", "\n\t".join(log1))
        #
        logg.info("====== [2] start next")
        cmd = "{systemctl} is-active zza.service zzz.service {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        cmd = "{systemctl} start zza.service {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertEqual(end, 0)
        top = greps(_recent(output(_top_list)), testsleep)
        logg.info("top>>>\n| %s", "\n| ".join(top))
        self.assertTrue(greps(top, testsleep))
        log1 = lines(open(logfile))
        logg.info("zzz.log>\n\t%s", "\n\t".join(log1))
        #
        self.assertTrue(greps(err, "1. systemctl locked by"))
        self.assertTrue(greps(err, "the service is already running on PID")) # FIXME: may not be?
        #
        kill_testsleep = "{systemctl} __killall {testsleep}"
        sx____(kill_testsleep.format(**locals()))
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
        self.end()
    def test_3081_two_service_starts_in_parallel_with_lockfile_remove(self, real: bool = False) -> None:
        """ consider a situation where a 'systemctl start <service>' is
            done from two programs at the same time. Ensure that there
            is a locking that disallows them to run in parallel. In this
            scenario we test what happens if the lockfile is deleted in between."""
        self.begin()
        vv = "-vv"
        removelockfile="-c REMOVE_LOCK_FILE=True -c DEBUG_FLOCK=True"
        timeouts = "-c MinimumTimeoutStartSec=7 -c MinimumTimeoutStopSec=7"
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir, real)
        systemctl = cover() + realpath(_systemctl_py) + " --root=" + root
        if real: vv, removelockfile, systemctl = "", "", "/usr/bin/systemctl"
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        logfile = os.path.join(os.path.abspath(testdir), "zzz.log")
        self.makedirs(os_path(root, "/var/run"))
        if os.path.exists(logfile):
            os.remove(logfile)
        shell_file(os_path(testdir, "zzz.init"), """
            #! /bin/bash
            case "$1" in start)
               [ -d /var/run ] || mkdir -p /var/run
               (
                mkdir -p {root}/var/log
                echo zzz `date +%M:%S` "[$$]" starting pid >>{logfile}
                {bindir}/{testsleep} 111 0<&- &>/dev/null &
                echo $! > {root}/var/run/zzz.init.pid
                echo zzz `date +%M:%S` "[$$]" started pid >>{logfile}
                sleep 2
                echo zzz `date +%M:%S` "[$$]" starting zza >>{logfile}
                {systemctl} start zza.service {vv} {vv} {removelockfile} {timeouts} >>{logfile} 2>&1
                echo zzz `date +%M:%S` "[$$]" started zza >>{logfile}
               ) &
               sleep 1
               ps -o pid,ppid,args
            ;; stop)
               killall {testsleep}
            ;; esac
            echo "done$1" >&2
            exit 0
            """.format(**locals()))
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            [Service]
            Type=forking
            PIDFile={root}/var/run/zzz.init.pid
            ExecStart={root}/usr/bin/zzz.init start
            ExecStop={root}/usr/bin/zzz.init stop
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStartPre={bindir}/{testsleep}pre 5
            ExecStart={bindir}/{testsleep}now 10
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_tool(_bin_sleep, os_path(bindir, testsleep+"pre"))
        copy_tool(_bin_sleep, os_path(bindir, testsleep+"now"))
        copy_tool(os_path(testdir, "zzz.init"), os_path(root, "/usr/bin/zzz.init"))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        sh____("{systemctl} daemon-reload".format(**locals()))
        #
        cmd = "{systemctl} enable zza.service zzz.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = "{systemctl} start zzz.service {vv} {removelockfile} {timeouts}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        logg.info("===== [0] just started")
        top = greps(_recent(output(_top_list)), testsleep)
        logg.info("top>>>\n| %s", "\n| ".join(top))
        self.assertTrue(greps(top, testsleep))
        log1 = lines(open(logfile))
        logg.info("zzz.log>\n\t%s", "\n\t".join(log1))
        time.sleep(2)
        logg.info("===== [1] after start")
        top = greps(_recent(output(_top_list)), testsleep)
        logg.info("top>>>\n| %s", "\n| ".join(top))
        self.assertTrue(greps(top, testsleep))
        log1 = lines(open(logfile))
        logg.info("zzz.log>\n\t%s", "\n\t".join(log1))
        #
        logg.info("====== start next")
        # cmd = "{systemctl} is-active zza.service zzz.service {vv}"
        # out, err, end = output3(cmd.format(**locals()))
        # logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        cmd = "{systemctl} start zza.service {vv} {vv} {removelockfile} {timeouts}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        top = greps(_recent(output(_top_list)), testsleep)
        logg.info("top>>>\n| %s", "\n| ".join(top))
        self.assertTrue(greps(top, testsleep))
        #
        self.assertTrue(greps(err, "1. systemctl locked by"))
        self.assertTrue(greps(err, "the service is already running on PID"))
        self.assertTrue(greps(err, "lock got deleted, trying again"))
        self.assertTrue(greps(err, "lock got deleted, trying again"))
        #
        log1 = lines(open(logfile))
        logg.info("zzz.log>\n\t%s", "\n\t".join(log1))
        #
        kill_testsleep = "{systemctl} __killall {testsleep}"
        sx____(kill_testsleep.format(**locals()))
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
        self.end()
    def real_3100_mask_service_creates_empty_file(self) -> None:
        self.test_3100_mask_service_creates_empty_file(True)
    def test_3100_mask_service_creates_empty_file(self, real: bool = False) -> None:
        """ check that a service can be masked """
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        vv = "-vv"
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        self.rm_zzfiles(root)
        #
        text_file(os_path(root, "/usr/lib/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A""")
        text_file(os_path(root, "/usr/lib/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            ExecStart=/bin/sleep 2
            [Install]
            WantedBy=multi-user.target""")
        cmd = "{systemctl} daemon-reload"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = "{systemctl} enable zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        enabled_file = os_path(root, "/etc/systemd/system/multi-user.target.wants/zzb.service")
        self.assertTrue(os.path.islink(enabled_file))
        textB = reads(enabled_file)
        self.assertTrue(greps(textB, "Testing B"))
        self.assertIn("\nDescription", textB)
        cmd = "{systemctl} status zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, "enabled"))
        self.assertFalse(greps(out, "masked"))
        # .........................................
        cmd = "{systemctl} mask zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = "{systemctl} status zzb.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertFalse(greps(out, "enabled"))
        self.assertTrue(greps(out, "masked"))
        if real: self.assertTrue(greps(out, "/dev/null"))
        else: self.assertTrue(greps(out, "None, "))
        mask_file = os_path(root, "/etc/systemd/system/zzb.service")
        self.assertTrue(os.path.islink(mask_file))
        target = os.readlink(mask_file)
        self.assertEqual(target, "/dev/null")
        cmd = "{systemctl} show zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, oi22(out))
        self.assertTrue(greps(out, "LoadState=masked"))
        self.assertTrue(greps(out, "UnitFileState=masked"))
        self.assertTrue(greps(out, "Id=zzb.service"))
        self.assertTrue(greps(out, "Names=zzb.service"))
        cmd = "{systemctl} is-active zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        if real: self.assertTrue(greps(out, "inactive"))
        cmd = "{systemctl} is-enabled zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, "masked"))
        #
        # second mask
        #
        cmd = "{systemctl} mask zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = "{systemctl} status zzb.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertFalse(greps(out, "enabled"))
        self.assertTrue(greps(out, "masked"))
        self.assertEqual(end, 3)
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_3101_unmask_service_removes_empty_file(self) -> None:
        self.test_3101_unmask_service_removes_empty_file(True)
    def test_3101_unmask_service_removes_empty_file(self, real: bool = False) -> None:
        """ check that a service can be unmasked """
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        vv = "-vv"
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        self.rm_zzfiles(root)
        #
        text_file(os_path(root, "/usr/lib/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A""")
        text_file(os_path(root, "/usr/lib/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            ExecStart=/bin/sleep 2
            [Install]
            WantedBy=multi-user.target""")
        cmd = "{systemctl} daemon-reload"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = "{systemctl} enable zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        enabled_file = os_path(root, "/etc/systemd/system/multi-user.target.wants/zzb.service")
        self.assertTrue(os.path.islink(enabled_file))
        textB = reads(enabled_file)
        self.assertTrue(greps(textB, "Testing B"))
        self.assertIn("\nDescription", textB)
        cmd = "{systemctl} status zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, "enabled"))
        self.assertFalse(greps(out, "masked"))
        # .........................................
        cmd = "{systemctl} mask zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = "{systemctl} status zzb.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertFalse(greps(out, "enabled"))
        self.assertTrue(greps(out, "masked"))
        if real: self.assertTrue(greps(out, "/dev/null"))
        else: self.assertTrue(greps(out, "None, "))
        mask_file = os_path(root, "/etc/systemd/system/zzb.service")
        self.assertTrue(os.path.islink(mask_file))
        target = os.readlink(mask_file)
        self.assertEqual(target, "/dev/null")
        cmd = "{systemctl} show zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, oi22(out))
        self.assertTrue(greps(out, "LoadState=masked"))
        self.assertTrue(greps(out, "UnitFileState=masked"))
        self.assertTrue(greps(out, "Id=zzb.service"))
        self.assertTrue(greps(out, "Names=zzb.service"))
        # .................................................
        cmd = "{systemctl} unmask zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = "{systemctl} status zzb.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, "enabled"))
        self.assertFalse(greps(out, "masked"))
        mask_file = os_path(root, "/etc/systemd/system/zzb.service")
        self.assertFalse(os.path.exists(mask_file))
        cmd = "{systemctl} show zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, oi22(out))
        self.assertTrue(greps(out, "LoadState=loaded"))
        self.assertTrue(greps(out, "Id=zzb.service"))
        self.assertTrue(greps(out, "Names=zzb.service"))
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_3102_testing_user_mask_unmask_service(self) -> None:
        self.test_3102_testing_user_mask_unmask_service(True)
    def test_3102_testing_user_mask_unmask_service(self, real: bool = False) -> None:
        """ check that a service can be unmasked """
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        vv = "-vv"
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        self.rm_zzfiles(root)
        #
        text_file(os_path(root, "/usr/lib/systemd/user/zza.service"), """
            [Unit]
            Description=Testing A""")
        text_file(os_path(root, "/usr/lib/systemd/user/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            ExecStart=/bin/sleep 2
            [Install]
            WantedBy=multi-user.target""")
        cmd = "{systemctl} daemon-reload"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = "{systemctl} enable --user zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = "{systemctl} status --user zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, "enabled"))
        self.assertFalse(greps(out, "masked"))
        # .........................................
        cmd = "{systemctl} mask --user zzb.service {vv} {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = "{systemctl} status --user zzb.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertFalse(greps(out, "enabled"))
        self.assertTrue(greps(out, "masked"))
        if real: self.assertTrue(greps(out, "/dev/null"))
        else: self.assertTrue(greps(out, "None, "))
        xdg_config = os.path.expanduser("~/.config")
        mask_file = os_path(root, xdg_config + "/systemd/user/zzb.service")
        self.assertTrue(os.path.islink(mask_file))
        target = os.readlink(mask_file)
        self.assertEqual(target, "/dev/null")
        cmd = "{systemctl} show --user zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, oi22(out))
        self.assertTrue(greps(out, "LoadState=masked"))
        self.assertTrue(greps(out, "UnitFileState=masked"))
        self.assertTrue(greps(out, "Id=zzb.service"))
        self.assertTrue(greps(out, "Names=zzb.service"))
        # .................................................
        cmd = "{systemctl} unmask --user zzb.service {vv} {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = "{systemctl} status --user zzb.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertTrue(greps(out, "enabled"))
        self.assertFalse(greps(out, "masked"))
        xdg_config = os.path.expanduser("~/.config")
        mask_file = os_path(root, xdg_config + "/systemd/system/zzb.service")
        self.assertFalse(os.path.exists(mask_file))
        cmd = "{systemctl} show --user zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, oi22(out))
        self.assertTrue(greps(out, "LoadState=loaded"))
        self.assertTrue(greps(out, "Id=zzb.service"))
        self.assertTrue(greps(out, "Names=zzb.service"))
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3105_is_masked_for_nonexistant_service(self) -> None:
        """ check that mask/unmask reports correctly for non-existant services """
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/systemd/system/zzc.service"), """
            [Unit]
            Description=Testing C
            [Service]
            ExecStart=/bin/sleep 2
            [Install]
            WantedBy=multi-user.target""")
        #
        cmd = "{systemctl} is-enabled zz-not-existing.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        self.assertFalse(greps(out, r"^static"))
        self.assertEqual(len(lines(out)), 0)
        cmd = "{systemctl} is-enabled zz-not-existing-service.service zzc.service"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(out, r"^disabled"))
        self.assertFalse(greps(out, r"^enabled"))
        self.assertEqual(len(lines(out)), 1)
        self.assertTrue(greps(err, "Unit zz-not-existing-service.service not found."))
        #
        cmd = "{systemctl} --no-legend mask zz-not-existing-service.service"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 5)
        self.assertTrue(greps(err, "Unit zz-not-existing-service.service not found."))
        #
        cmd = "{systemctl} --no-legend unmask zz-not-existing-service.service"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 5)
        self.assertTrue(greps(err, "Unit zz-not-existing-service.service not found."))
        #
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3106_can_not_mask_sysv_services(self) -> None:
        """ check that mask/unmask reports correctly for sysv services """
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/etc/init.d/zzz"), """
            #! /bin/bash
            ### BEGIN INIT INFO
            # Required-Start: $local_fs $remote_fs $syslog $network
            # Required-Stop:  $local_fs $remote_fs $syslog $network
            # Default-Start:  3 5
            # Default-Stop:   0 1 2 6
            # Short-Description: Testing Z
            # Description:    Allows for SysV testing
            ### END INIT INFO
            echo OK
            """)
        #
        cmd = "{systemctl} is-enabled zzz.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        self.assertFalse(greps(out, r"^static"))
        self.assertEqual(len(lines(out)), 1)
        #
        cmd = "{systemctl} --no-legend mask zzz"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Initscript zzz.service can not be masked"))
        #
        cmd = "{systemctl} --no-legend unmask zzz.service -vv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Initscript zzz.service can not be un/masked"))
        #
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3107_unusual_operations_for__mask_folder(self) -> None:
        """ check that mask/unmask folder is working correctly """
        self.begin()
        real, vv = False, "-vv"
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/usr/lib/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            ExecStart=/bin/sleep 2
            [Install]
            WantedBy=multi-user.target""")
        #
        cmd = "{systemctl} is-enabled zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        self.assertEqual(out.strip(), "disabled")
        #
        # .........................................
        cmd = "{systemctl} mask zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = "{systemctl} status zzb.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertFalse(greps(out, "enabled"))
        self.assertTrue(greps(out, "masked"))
        if real: self.assertTrue(greps(out, "/dev/null"))
        else: self.assertTrue(greps(out, "None, "))
        mask_file = os_path(root, "/etc/systemd/system/zzb.service")
        self.assertTrue(os.path.islink(mask_file))
        target = os.readlink(mask_file)
        self.assertEqual(target, "/dev/null")
        # .........................................
        cmd = "{systemctl} mask zzb.service {vv} {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\%s", cmd, end, out, err)
        self.assertEqual(end, 0)
        self.assertTrue(greps(err, "mask symlink does already exist"))
        cmd = "{systemctl} mask -f zzb.service {vv} {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\%s", cmd, end, out, err)
        self.assertEqual(end, 0)
        self.assertFalse(greps(err, "mask symlink does already exist"))
        #
        cmd = "{systemctl} unmask zzb.service {vv} {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\%s", cmd, end, out, err)
        self.assertEqual(end, 0)
        cmd = "{systemctl} unmask zzb.service {vv} {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\%s", cmd, end, out, err)
        self.assertEqual(end, 0)
        self.assertTrue(greps(err, "Symlink did not exist anymore"))
        #
        text_file(mask_file, "#")
        cmd = "{systemctl} mask zzb.service {vv} {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\%s", cmd, end, out, err)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "mask target does already exist"))
        cmd = "{systemctl} unmask zzb.service {vv} {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\%s", cmd, end, out, err)
        self.assertEqual(end, 0)
        self.assertTrue(greps(err, "target is not a symlink"))
        #
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3120_start_default_target(self, real: bool = False) -> None:
        """ check the 'default-services' to know the enabled services """
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            ExecStart={root}/bin/{testsleep} 2
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(root, "/etc/systemd/system/zzc.service"), """
            [Unit]
            Description=Testing C
            [Service]
            ExecStart={root}/bin/{testsleep} 2
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        if not real:
            text_file(os_path(root, "/etc/systemd/system/basic.target"), """
            [Unit]
            Description=Basic Runlevel
            Requires=sockets.target""")
            text_file(os_path(root, "/etc/systemd/system/multi-user.target"), """
            [Unit]
            Description=Basic Runlevel
            Requires=basic.target""")
            text_file(os_path(root, "/etc/systemd/system/graphical.target"), """
            [Unit]
            Description=Basic Runlevel
            Requires=multi-user.target""")
        copy_tool(_bin_sleep, "{root}/bin/{testsleep}".format(**locals()))
        #
        cmd = "{systemctl} default-services"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines(out)), 0)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} --no-legend enable zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} default-services"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines(out)), 1)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} --no-legend enable zzc.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} default-services"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines(out)), 2)
        self.assertEqual(end, 0)
        #
        self.assertFalse(greps(out, "a.service"))
        self.assertTrue(greps(out, "b.service"))
        self.assertTrue(greps(out, "c.service"))
        #
        cmd = "{systemctl} start multi-user.target"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        top = greps(_recent(output(_top_list)), testsleep)
        logg.info("top>>>\n| %s", "\n| ".join(top))
        self.assertEqual(len(greps(top, testsleep)), 2)
        #
        cmd = "{systemctl} stop multi-user.target"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        top = greps(_recent(output(_top_list)), testsleep)
        logg.info("top>>>\n| %s", "\n| ".join(top))
        self.assertEqual(len(greps(top, testsleep)), 0)
        #
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3126_default_services_for_different_target(self, real: bool = False) -> None:
        """ check that 'default-services' changes when modifing default-target """
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep=self.testname("sleep")
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A""".format(**locals()))
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            ExecStart={root}/bin/{testsleep} 2
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(root, "/etc/systemd/system/zzc.service"), """
            [Unit]
            Description=Testing C
            [Service]
            ExecStart={root}/bin/{testsleep} 2
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(root, "/etc/systemd/system/zzd.service"), """
            [Unit]
            Description=Testing D
            [Service]
            ExecStart={root}/bin/{testsleep} 2
            [Install]
            WantedBy=graphical.target
            """.format(**locals()))
        if not real:
            text_file(os_path(root, "/etc/systemd/system/basic.target"), """
            [Unit]
            Description=Basic Runlevel
            Requires=sockets.target""")
            text_file(os_path(root, "/etc/systemd/system/multi-user.target"), """
            [Unit]
            Description=Basic Runlevel
            Requires=basic.target""")
            text_file(os_path(root, "/etc/systemd/system/graphical.target"), """
            [Unit]
            Description=Basic Runlevel
            Requires=multi-user.target""")
        copy_tool(_bin_sleep, "{root}/bin/{testsleep}".format(**locals()))
        #
        cmd = "{systemctl} default-services"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines(out)), 0)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} --no-legend enable zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} --no-legend enable zzc.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} default-services"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines(out)), 2)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} get-default"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(out.strip(), "multi-user.target")
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} set-default graphical.target"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} get-default"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(out.strip(), "graphical.target")
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} --no-legend enable zzd.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} default-services -vvvv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines(out)), 3)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} set-default multi-user.target"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} default-services -vvvv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines(out)), 2)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} set-default basic.target"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} default-services -vvvv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines(out)), 0)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} default-services multi-user.target -vvvv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines(out)), 2)
        self.assertEqual(end, 0)
        #
        ###############################################
        #
        cmd = "{systemctl} start multi-user.target -vvvv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        top = greps(_recent(output(_top_list)), testsleep)
        logg.info("top>>>\n| %s", "\n| ".join(top))
        self.assertEqual(len(greps(top, testsleep)), 2)
        #
        cmd = "{systemctl} stop multi-user.target"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        top = greps(_recent(output(_top_list)), testsleep)
        logg.info("top>>>\n| %s", "\n| ".join(top))
        self.assertEqual(len(greps(top, testsleep)), 0)
        #
        cmd = "{systemctl} start graphical.target"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        top = greps(_recent(output(_top_list)), testsleep)
        logg.info("top>>>\n| %s", "\n| ".join(top))
        self.assertEqual(len(greps(top, testsleep)), 3)
        #
        cmd = "{systemctl} stop graphical.target"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        top = greps(_recent(output(_top_list)), testsleep)
        logg.info("top>>>\n| %s", "\n| ".join(top))
        self.assertEqual(len(greps(top, testsleep)), 0)
        #
        cmd = "{systemctl} start graphical.target"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        top = greps(_recent(output(_top_list)), testsleep)
        logg.info("top>>>\n| %s", "\n| ".join(top))
        self.assertEqual(len(greps(top, testsleep)), 3)
        #
        cmd = "{systemctl} stop multi-user.target"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        top = greps(_recent(output(_top_list)), testsleep)
        logg.info("top>>>\n| %s", "\n| ".join(top))
        self.assertEqual(len(greps(top, testsleep)), 1)
        #
        cmd = "{systemctl} stop graphical.target"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        top = greps(_recent(output(_top_list)), testsleep)
        logg.info("top>>>\n| %s", "\n| ".join(top))
        self.assertEqual(len(greps(top, testsleep)), 0)
        #
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3127_default_services_for_invented_target(self, real: bool = False) -> None:
        """ check that 'default-services' changes when modifing default-target """
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep=self.testname("sleep")
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A""")
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            ExecStart={root}/bin/{testsleep} 4
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(root, "/etc/systemd/system/zzc.service"), """
            [Unit]
            Description=Testing C
            [Service]
            ExecStart={root}/bin/{testsleep} 4
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(root, "/etc/systemd/system/zzd.service"), """
            [Unit]
            Description=Testing D
            [Service]
            ExecStart={root}/bin/{testsleep} 4
            [Install]
            WantedBy=graphical.target
            """.format(**locals()))
        text_file(os_path(root, "/etc/systemd/system/zze.service"), """
            [Unit]
            Description=Testing E
            [Service]
            ExecStart={root}/bin/{testsleep} 4
            [Install]
            WantedBy=invented.target
            """.format(**locals()))
        text_file(os_path(root, "/etc/systemd/system/zzi.service"), """
            [Unit]
            Description=Testing E
            [Service]
            ExecStart={root}/bin/{testsleep} 4
            [Install]
            WantedBy=isolated.target"""
                  .format(**locals()))
        text_file(os_path(root, "/etc/systemd/system/invented.target"), """
            [Unit]
            Description=Invented Runlevel
            Requires=multi-user.target""")
        text_file(os_path(root, "/etc/systemd/system/isolated.target"), """
            [Unit]
            Description=Isolated Runlevel""")
        if not real:
            text_file(os_path(root, "/etc/systemd/system/basic.target"), """
            [Unit]
            Description=Basic Runlevel
            Requires=sockets.target""")
            text_file(os_path(root, "/etc/systemd/system/multi-user.target"), """
            [Unit]
            Description=Basic Runlevel
            Requires=basic.target""")
            text_file(os_path(root, "/etc/systemd/system/graphical.target"), """
            [Unit]
            Description=Basic Runlevel
            Requires=multi-user.target""")
        copy_tool(_bin_sleep, "{root}/bin/{testsleep}".format(**locals()))
        #
        cmd = "{systemctl} list-unit-files --type=target"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertGreater(len(lines(out)), 6)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, "invented.target"))
        #
        cmd = "{systemctl} default-services"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines(out)), 0)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} --no-legend enable zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} --no-legend enable zzc.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} default-services"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines(out)), 2)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} get-default"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(out.strip(), "multi-user.target")
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} set-default graphical.target"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} get-default"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(out.strip(), "graphical.target")
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} --no-legend enable zzd.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} default-services -vvvv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines(out)), 3)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} set-default multi-user.target"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} default-services -vvvv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines(out)), 2)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} set-default nonexistant.target"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertTrue(greps(out, "No such runlevel"))
        #
        cmd = "{systemctl} set-default invented.target"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} default-services -vvvv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines(out)), 2)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} --no-legend enable zze.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} default-services -vvvv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines(out)), 3)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} set-default isolated.target"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} default-services -vvvv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines(out)), 0)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} --no-legend enable zzi.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} default-services -vvvv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines(out)), 1)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} set-default invented.target"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} default-services -vvvv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines(out)), 3)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} --no-legend disable zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} default-services -vvvv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines(out)), 2)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} default-services multi-user.target -vvvv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines(out)), 1)
        self.assertEqual(end, 0)
        #
        ###############################################
        #
        cmd = "{systemctl} start multi-user.target"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        top = greps(_recent(output(_top_list)), testsleep)
        logg.info("top>>>\n| %s", "\n| ".join(top))
        self.assertEqual(len(greps(top, testsleep)), 1)
        #
        cmd = "{systemctl} stop multi-user.target"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        top = greps(_recent(output(_top_list)), testsleep)
        logg.info("top>>>\n| %s", "\n| ".join(top))
        self.assertEqual(len(greps(top, testsleep)), 0)
        #
        cmd = "{systemctl} start invented.target"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        top = greps(_recent(output(_top_list)), testsleep)
        logg.info("top>>>\n| %s", "\n| ".join(top))
        self.assertEqual(len(greps(top, testsleep)), 2)
        #
        cmd = "{systemctl} stop invented.target"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        top = greps(_recent(output(_top_list)), testsleep)
        logg.info("top>>>\n| %s", "\n| ".join(top))
        self.assertEqual(len(greps(top, testsleep)), 0)
        #
        cmd = "{systemctl} start isolated.target"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        top = greps(_recent(output(_top_list)), testsleep)
        logg.info("top>>>\n| %s", "\n| ".join(top))
        self.assertEqual(len(greps(top, testsleep)), 1)
        #
        cmd = "{systemctl} reload isolated.target"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        top = greps(_recent(output(_top_list)), testsleep)
        logg.info("top>>>\n| %s", "\n| ".join(top))
        self.assertEqual(len(greps(top, testsleep)), 1)
        #
        cmd = "{systemctl} restart isolated.target -vvvv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        time.sleep(1)
        #
        top = greps(_recent(output(_top_list)), testsleep)
        logg.info("top>>>\n| %s", "\n| ".join(top))
        self.assertEqual(len(greps(top, testsleep)), 1)
        #
        cmd = "{systemctl} stop isolated.target"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        top = greps(_recent(output(_top_list)), testsleep)
        logg.info("top>>>\n| %s", "\n| ".join(top))
        self.assertEqual(len(greps(top, testsleep)), 0)
        #
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3201_missing_environment_file_makes_service_ignored(self) -> None:
        """ check that a missing EnvironmentFile spec makes the service to be ignored"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            [Service]
            Type=simple
            EnvironmentFile=/foo.conf
            ExecStart={bindir}/{testsleep} 111
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        #
        start_service = "{systemctl} start zzz.service -vv"
        end = sx____(start_service.format(**locals()))
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        self.assertGreater(end, 0)
        #
        stop_service = "{systemctl} stop zzz.service -vv"
        end = sx____(stop_service.format(**locals()))
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        self.assertGreater(end, 0)
        #
        kill_testsleep = "{systemctl} __killall {testsleep}"
        sx____(kill_testsleep.format(**locals()))
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3211_environment_files_are_included(self) -> None:
        """ check that environment specs are read correctly"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        logfile = os_path(root, "/var/log/test.log")
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            [Service]
            Type=simple
            EnvironmentFile=/etc/sysconfig/zzz.conf
            Environment=CONF4=dd4
            ExecStart={bindir}/zzz.sh
            ExecStop=/usr/bin/killall {testsleep}
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zzz.sh"), """
            #! /bin/sh
            echo "WITH CONF1=$CONF1" >> {logfile}
            echo "WITH CONF2=$CONF2" >> {logfile}
            echo "WITH CONF3=$CONF3" >> {logfile}
            echo "WITH CONF4=$CONF4" >> {logfile}
            {bindir}/{testsleep} 4
            """.format(**locals()))
        text_file(os_path(testdir, "zzz.conf"), """
            CONF1=aa1
            CONF2="bb2"
            CONF3='cc3'
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_tool(os_path(testdir, "zzz.sh"), os_path(bindir, "zzz.sh"))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        copy_file(os_path(testdir, "zzz.conf"), os_path(root, "/etc/sysconfig/zzz.conf"))
        #
        start_service = "{systemctl} start zzz.service -vv"
        end = sx____(start_service.format(**locals()))
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        self.assertEqual(end, 0)
        #
        log = lines(open(logfile))
        logg.info("LOG \n| %s", "\n| ".join(log))
        self.assertTrue(greps(log, "WITH CONF1=aa1"))
        self.assertTrue(greps(log, "WITH CONF2=bb2"))
        self.assertTrue(greps(log, "WITH CONF3=cc3"))
        self.assertTrue(greps(log, "WITH CONF4=dd4"))
        os.remove(logfile)
        #
        stop_service = "{systemctl} stop zzz.service -vv"
        end = sx____(stop_service.format(**locals()))
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        #
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3240_may_expand_environment_variables(self) -> None:
        """ check that different styles of environment
            variables get expanded."""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        print_sh = os_path(root, "/usr/bin/print.sh")
        logfile = os_path(root, "/var/log/print_sh.log")
        text_file(os_path(root, "/etc/sysconfig/b.conf"), """
            DEF1='def1'
            DEF2="def2 def3"
            DEF4="$DEF1 ${DEF2}"
            DEF5="$DEF1111 def5 ${DEF2222}"
            """)
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Environment=DEF2=foo
            EnvironmentFile=/etc/sysconfig/b.conf
            ExecStart=/bin/sleep 3
            ExecStartPost=%s A $DEF1 $DEF2
            ExecStartPost=%s B ${DEF1} ${DEF2}
            ExecStartPost=%s C $DEF1$DEF2
            ExecStartPost=%s D ${DEF1}${DEF2}
            ExecStartPost=%s E ${DEF4}
            ExecStartPost=%s F ${DEF5}
            [Install]
            WantedBy=multi-user.target"""
                  % (print_sh, print_sh, print_sh, print_sh,
                     print_sh, print_sh,))
        text_file(logfile, "")
        shell_file(print_sh, """
            #! /bin/sh
            logfile='{logfile}'
            echo "'$1' '$2' '$3' '$4' '$5'" >> "$logfile"
            """.format(**locals()))
        cmd = "{systemctl} environment zzb.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, r"^DEF1=def1"))
        self.assertTrue(greps(out, r"^DEF2=def2 def3"))
        #
        cmd = "{systemctl} start zzb.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        log = lines(open(logfile))
        logg.info("LOG \n%s", log)
        A="'A' 'def1' 'def2' 'def3' ''"   # A $DEF1 $DEF2
        B="'B' 'def1' 'def2 def3' '' ''"  # B ${DEF1} ${DEF2}
        C="'C' 'def1def2' 'def3' '' ''"   # C $DEF1$DEF2
        D="'D' 'def1def2 def3' '' '' ''"  # D ${DEF1}${DEF2} ??TODO??
        E="'E' 'def1 def2 def3' '' '' ''" # E ${DEF4}
        # F="'F' ' def5 ' '' '' ''"       # F ${DEF5}
        F="'F' '$DEF1111 def5 ${DEF2222}' '' '' ''"
        self.assertIn(A, log)
        self.assertIn(B, log)
        self.assertIn(C, log)
        self.assertIn(D, log)
        self.assertIn(E, log)
        self.assertIn(F, log)
        #
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_3250_nonlazy_expand_variables(self) -> None:
        self.test_3250_nonlazy_expand_variables(True)
    def test_3250_nonlazy_expand_variables(self, real: bool = False) -> None:
        """ check that variables can contain variables that get (not?) expanded."""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        print_sh = os_path(root, "/usr/bin/zz_print.sh")
        logfile = os_path(root, "/var/log/zz_print_sh.log")
        text_file(os_path(root, "/etc/sysconfig/zz_b.conf"), """
            DEF1='def1'
            DEF3="${DEF4}.${DEF5}"
            DEF4="${DEF1}.${DEF2}"
            DEF5="${DEF1111}.def5.${DEF2222}"
            DEF6="${DEF3}.${DEF3}"
            """)
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Environment=DEF2=def2.def3
            EnvironmentFile=/etc/sysconfig/zz_b.conf
            ExecStart=/bin/sleep 3
            ExecStartPost=%s A.${DEF1}
            ExecStartPost=%s B.${DEF2}
            ExecStartPost=%s C.${DEF3}
            ExecStartPost=%s D.${DEF4}
            ExecStartPost=%s E.${DEF5}
            ExecStartPost=%s F.${DEF6}
            [Install]
            WantedBy=multi-user.target"""
                  % (print_sh, print_sh, print_sh, print_sh,
                     print_sh, print_sh,))
        text_file(logfile, "")
        shell_file(print_sh, """
            #! /bin/sh
            logfile='{logfile}'
            echo "'$1'" >> "$logfile"
            """.format(**locals()))
        #
        cmd = "{systemctl} start zzb.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        log = lines(open(logfile))
        logg.info("LOG \n%s", log)
        if real:
            A="'A.def1'"
            B="'B.def2.def3'"
            C="'C.${DEF4}.${DEF5}'"
            D="'D.${DEF1}.${DEF2}'"  # TODO
            E="'E.${DEF1111}.def5.${DEF2222}'"
            F="'F.${DEF3}.${DEF3}'"  # TODO
        else:
            A="'A.def1'"
            B="'B.def2.def3'"
            C="'C.${DEF4}.${DEF5}'"
            D="'D.def1.def2.def3'"
            E="'E.${DEF1111}.def5.${DEF2222}'"
            F="'F.def1.def2.def3.${DEF1111}.def5.${DEF2222}.def1.def2.def3.${DEF1111}.def5.${DEF2222}'"
        # so effectivly both systemctl.py and sysd-systemctl do no lazy expansion
        # here - but sysd-systemctl will keep the unkonwn value in the text.
        self.assertIn(A, log)
        self.assertIn(B, log)
        self.assertIn(C, log)
        self.assertIn(D, log)
        self.assertIn(E, log)
        self.assertIn(F, log)
        #
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3251_nonlazy_expand_variables_empty_vars(self, real: bool = False) -> None:
        """ check that variables can contain variables that get (not?) expanded.
            Here we show the oldstyle result (up to systemctl.py v1.4)"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        systemctl += " -c EXPAND_KEEP_VARS=no"
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        print_sh = os_path(root, "/usr/bin/zz_print.sh")
        logfile = os_path(root, "/var/log/zz_print_sh.log")
        text_file(os_path(root, "/etc/sysconfig/zz_b.conf"), """
            DEF1='def1'
            DEF3="${DEF4}.${DEF5}"
            DEF4="${DEF1}.${DEF2}"
            DEF5="${DEF1111}.def5.${DEF2222}"
            DEF6="${DEF3}.${DEF3}"
            """)
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Environment=DEF2=def2.def3
            EnvironmentFile=/etc/sysconfig/zz_b.conf
            ExecStart=/bin/sleep 3
            ExecStartPost=%s A.${DEF1}
            ExecStartPost=%s B.${DEF2}
            ExecStartPost=%s C.${DEF3}
            ExecStartPost=%s D.${DEF4}
            ExecStartPost=%s E.${DEF5}
            ExecStartPost=%s F.${DEF6}
            [Install]
            WantedBy=multi-user.target"""
                  % (print_sh, print_sh, print_sh, print_sh,
                     print_sh, print_sh,))
        text_file(logfile, "")
        shell_file(print_sh, """
            #! /bin/sh
            logfile='{logfile}'
            echo "'$1'" >> "$logfile"
            """.format(**locals()))
        #
        cmd = "{systemctl} start zzb.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        log = lines(open(logfile))
        logg.info("LOG \n%s", log)
        if real:
            A="'A.def1'"
            B="'B.def2.def3'"
            C="'C.${DEF4}.${DEF5}'"
            D="'D.${DEF1}.${DEF2}'"
            E="'E.${DEF1111}.def5.${DEF2222}'"
            F="'F.${DEF3}.${DEF3}'"
        else:
            A="'A.def1'"
            B="'B.def2.def3'"
            C="'C..'"
            D="'D.def1.def2.def3'"
            E="'E..def5.'"
            F="'F....'"
        # so effectivly both systemctl.py and sysd-systemctl do no lazy expansion
        # here - but sysd-systemctl will keep the unkonwn value in the text.
        self.assertIn(A, log)
        self.assertIn(B, log)
        self.assertIn(C, log)
        self.assertIn(D, log)
        self.assertIn(E, log)
        self.assertIn(F, log)
        #
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_3260_recursive_expand_variables(self) -> None:
        self.test_3260_recursive_expand_variables(True)
    def test_3260_recursive_expand_variables(self, real: bool = False) -> None:
        """ check that variables can contain variables that get (not?) expanded."""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        systemctl += " -c EXPAND_VARS_MAXDEPTH=5"
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        print_sh = os_path(root, "/usr/bin/zz_print.sh")
        logfile = os_path(root, "/var/log/zz_print_sh.log")
        text_file(os_path(root, "/etc/sysconfig/zz_b.conf"), """
            DEF1='def1'
            DEF3="${DEF4}.def3"
            DEF4="${DEF1}.${${DEF2}}"
            DEF5="${DEF1}.${${DEF3}}"
            DEF6="${DEF3}.${DEF3}"
            """)
        text_file(os_path(root, "/etc/systemd/system/zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Environment=DEF2=DEF3
            EnvironmentFile=/etc/sysconfig/zz_b.conf
            ExecStart=/bin/sleep 3
            ExecStartPost=%s A.${DEF1}
            ExecStartPost=%s B.${DEF2}
            ExecStartPost=%s C.${DEF3}
            ExecStartPost=%s D.${DEF4}
            ExecStartPost=%s E.${DEF5}
            ExecStartPost=%s F.${DEF6}
            [Install]
            WantedBy=multi-user.target"""
                  % (print_sh, print_sh, print_sh, print_sh,
                     print_sh, print_sh,))
        text_file(logfile, "")
        shell_file(print_sh, """
            #! /bin/sh
            logfile='{logfile}'
            echo "'$1'" >> "$logfile"
            """.format(**locals()))
        #
        cmd = "{systemctl} start zzb.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        log = lines(open(logfile))
        logg.info("LOG \n%s", log)
        if real:
            A="'A.def1'"
            B="'B.DEF3'"
            C="'C.${DEF4}.def3'"
            D="'D.${DEF1}.${${DEF2}}'"  # todo?
            E="'E.${DEF1}.${${DEF3}}'"  # todo?
            F="'F.${DEF3}.${DEF3}'"     # todo?
        else:
            A="'A.def1'"
            B="'B.DEF3'"
            C="'C.${DEF4}.def3'"
            D="'D.def1.${DEF4}.def3'"
            E="'E.def1.${def1.def1.def1.def1.${DEF4}.def3.def3.def3.def3.def3}'"
            F="'F.def1.def1.def1.def1.${DEF4}.def3.def3.def3.def3.def3.def1.def1.def1.def1.${DEF4}.def3.def3.def3.def3.def3'"
        # so effectivly sysd-systemctl does not have a recursive expansion #TODO?
        self.assertIn(A, log)
        self.assertIn(B, log)
        self.assertIn(C, log)
        self.assertIn(D, log)
        self.assertIn(E, log)
        self.assertIn(F, log)
        #
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_3270_env_may_expand_special_variables(self) -> None:
        self.test_3270_env_may_expand_special_variables(True)
    def test_3270_env_may_expand_special_variables(self, real: bool = False) -> None:
        """ check that different flavours for special
            variables get expanded."""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        vv = "-vv"
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        print_sh = os_path(root, "/usr/bin/zzprint.sh")
        logfile = os_path(root, "/var/log/zzprint_sh.log")
        service_file = os_path(root, "/etc/systemd/system/zzb_zzc.service")
        text_file(service_file, """
            [Unit]
            Description=Testing B
            [Service]
            Environment=X=x1
            Environment="Y=y2 y3"
            ExecStart=/bin/sleep 3
            ExecStartPost=%s _N_ %%N $X ${Y}
            ExecStartPost=%s _n_ %%n $X ${Y}
            ExecStartPost=%s _f_ %%f $X ${Y}
            ExecStartPost=%s _t_ %%t $X ${Y}
            ExecStartPost=%s _P_ %%P $X ${Y}
            ExecStartPost=%s _p_ %%p $X ${Y}
            ExecStartPost=%s _I_ %%I $X ${Y}
            ExecStartPost=%s _i_ %%i $X ${Y} $FOO
            ExecStartPost=%s _T_ %%T $X ${Y}
            ExecStartPost=%s _V_ %%V $X ${Y}
            ExecStartPost=%s _Z_ %%Z $X ${Y} ${FOO}
            [Install]
            WantedBy=multi-user.target"""
                  % (print_sh, print_sh, print_sh, print_sh,
                     print_sh, print_sh, print_sh, print_sh,
                     print_sh, print_sh, print_sh))
        text_file(logfile, "")
        shell_file(print_sh, """
            #! /bin/sh
            logfile='{logfile}'
            echo "'$1' '$2' '$3' '$4' '$5'" >> "$logfile"
            """.format(**locals()))
        #
        RUN = "/run" # for system-mode
        cmd = "{systemctl} start 'zzb_zzc.service' {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        log = lines(open(logfile))
        logg.info("LOG \n%s", log)
        _N_="'_N_' 'zzb_zzc' 'x1' 'y2 y3' ''"
        _n_="'_n_' 'zzb_zzc.service' 'x1' 'y2 y3' ''"
        _f_="'_f_' '/zzb_zzc' 'x1' 'y2 y3' ''"
        _t_="'_t_' '%s' 'x1' 'y2 y3' ''" % os_path(root, RUN)
        _P_="'_P_' 'zzb_zzc' 'x1' 'y2 y3' ''"
        _p_="'_p_' 'zzb_zzc' 'x1' 'y2 y3' ''"
        _I_="'_I_' '' 'x1' 'y2 y3' ''"
        _i_="'_i_' '' 'x1' 'y2 y3' ''"
        _T_="'_T_' '%s' 'x1' 'y2 y3' ''" % os_path(root, "/tmp")
        _V_="'_V_' '%s' 'x1' 'y2 y3' ''" % os_path(root, "/var/tmp")
        _Z_="'_Z_' '' 'x1' 'y2 y3' ''"
        self.assertIn(_N_, log)
        self.assertIn(_n_, log)
        self.assertIn(_f_, log)
        self.assertIn(_t_, log)
        self.assertIn(_P_, log)
        self.assertIn(_p_, log)
        self.assertIn(_I_, log)
        self.assertIn(_i_, log)
        if not real:
            self.assertIn(_T_, log)
            self.assertIn(_V_, log)
            self.assertIn(_Z_, log)
        #
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
        self.end()
    def real_3275_env_may_expand_special_variables(self) -> None:
        self.test_3275_env_may_expand_special_variables(True)
    def test_3275_env_may_expand_special_variables(self, real: bool = False) -> None:
        """ check that different flavours for special
            variables get expanded."""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        vv = "-vv"
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        print_sh = os_path(root, "/usr/bin/zzprint.sh")
        logfile = os_path(root, "/var/log/zzprint_sh.log")
        service_file = os_path(root, "/etc/systemd/system/zzb\\x20zzc.service")
        text_file(service_file, """
            [Unit]
            Description=Testing B
            [Service]
            Environment=X=x1
            Environment="Y=y2 y3"
            ExecStart=/bin/sleep 3
            ExecStartPost=%s _N_ %%N $X ${Y}
            ExecStartPost=%s _n_ %%n $X ${Y}
            ExecStartPost=%s _f_ %%f $X ${Y}
            ExecStartPost=%s _t_ %%t $X ${Y}
            ExecStartPost=%s _P_ %%P $X ${Y}
            ExecStartPost=%s _p_ %%p $X ${Y}
            ExecStartPost=%s _I_ %%I $X ${Y}
            ExecStartPost=%s _i_ %%i $X ${Y} $FOO
            ExecStartPost=%s _T_ %%T $X ${Y}
            ExecStartPost=%s _V_ %%V $X ${Y}
            ExecStartPost=%s _Z_ %%Z $X ${Y} ${FOO}
            [Install]
            WantedBy=multi-user.target"""
                  % (print_sh, print_sh, print_sh, print_sh,
                     print_sh, print_sh, print_sh, print_sh,
                     print_sh, print_sh, print_sh))
        text_file(logfile, "")
        shell_file(print_sh, """
            #! /bin/sh
            logfile='{logfile}'
            echo "'$1' '$2' '$3' '$4' '$5'" >> "$logfile"
            """.format(**locals()))
        #
        RUN = "/run" # for system-mode
        cmd = "{systemctl} start 'zzb\\x20zzc.service' {vv}"
        if real: cmd = "{systemctl} start 'zzb zzc.service' {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        log = lines(open(logfile))
        logg.info("LOG \n%s", log)
        _N_="'_N_' 'zzb\\x20zzc' 'x1' 'y2 y3' ''"
        _n_="'_n_' 'zzb\\x20zzc.service' 'x1' 'y2 y3' ''"
        _f_="'_f_' '/zzb zzc' 'x1' 'y2 y3' ''"
        _t_="'_t_' '%s' 'x1' 'y2 y3' ''" % os_path(root, RUN)
        _P_="'_P_' 'zzb zzc' 'x1' 'y2 y3' ''"
        _p_="'_p_' 'zzb\\x20zzc' 'x1' 'y2 y3' ''"
        _I_="'_I_' '' 'x1' 'y2 y3' ''"
        _i_="'_i_' '' 'x1' 'y2 y3' ''"
        _T_="'_T_' '%s' 'x1' 'y2 y3' ''" % os_path(root, "/tmp")
        _V_="'_V_' '%s' 'x1' 'y2 y3' ''" % os_path(root, "/var/tmp")
        _Z_="'_Z_' '' 'x1' 'y2 y3' ''"
        self.assertIn(_N_, log)
        self.assertIn(_n_, log)
        self.assertIn(_f_, log)
        self.assertIn(_t_, log)
        self.assertIn(_P_, log)
        self.assertIn(_p_, log)
        self.assertIn(_I_, log)
        self.assertIn(_i_, log)
        if not real:
            self.assertIn(_T_, log)
            self.assertIn(_V_, log)
            self.assertIn(_Z_, log)
        #
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
        self.end()
    def test_3280_user_mode_env_may_expand_special_variables(self, real: bool = False) -> None:
        """ check that different flavours for special
            variables get expanded. Differently in --user mode."""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        print_sh = os_path(root, "/usr/bin/print.sh")
        logfile = os_path(root, "/var/log/print_sh.log")
        service_file = os_path(root, "/etc/systemd/user/zzb zzc.service")
        text_file(service_file, """
            [Unit]
            Description=Testing B
            [Service]
            Environment=X=x1
            Environment="Y=y2 y3"
            ExecStart=/bin/sleep 3
            ExecStartPost=%s _N_ %%N $X ${Y}
            ExecStartPost=%s _n_ %%n $X ${Y}
            ExecStartPost=%s _f_ %%f $X ${Y}
            ExecStartPost=%s _t_ %%t $X ${Y}
            ExecStartPost=%s _P_ %%P $X ${Y}
            ExecStartPost=%s _p_ %%p $X ${Y}
            ExecStartPost=%s _I_ %%I $X ${Y}
            ExecStartPost=%s _i_ %%i $X ${Y} $FOO
            ExecStartPost=%s _T_ %%T $X ${Y}
            ExecStartPost=%s _V_ %%V $X ${Y}
            ExecStartPost=%s _Z_ %%Z $X ${Y} ${FOO}
            [Install]
            WantedBy=multi-user.target"""
                  % (print_sh, print_sh, print_sh, print_sh,
                     print_sh, print_sh, print_sh, print_sh,
                     print_sh, print_sh, print_sh))
        text_file(logfile, "")
        shell_file(print_sh, """
            #! /bin/sh
            logfile='{logfile}'
            echo "'$1' '$2' '$3' '$4' '$5'" >> "$logfile"
            """.format(**locals()))
        #
        RUN = "/run" # for system-mode
        RUN = get_runtime_dir()
        cmd = "{systemctl} --user start 'zzb zzc.service' -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        log = lines(open(logfile))
        logg.info("LOG \n%s", log)
        _N_="'_N_' 'zzb zzc' 'x1' 'y2 y3' ''"
        _n_="'_n_' 'zzb zzc.service' 'x1' 'y2 y3' ''"
        _f_="'_f_' '/zzb zzc' 'x1' 'y2 y3' ''"
        _t_="'_t_' '%s' 'x1' 'y2 y3' ''" % os_path(root, RUN)
        _P_="'_P_' 'zzb zzc' 'x1' 'y2 y3' ''"
        _p_="'_p_' 'zzb zzc' 'x1' 'y2 y3' ''"
        _I_="'_I_' '' 'x1' 'y2 y3' ''"
        _i_="'_i_' '' 'x1' 'y2 y3' ''"
        _T_="'_T_' '%s' 'x1' 'y2 y3' ''" % os_path(root, "/tmp")
        _V_="'_V_' '%s' 'x1' 'y2 y3' ''" % os_path(root, "/var/tmp")
        _Z_="'_Z_' '' 'x1' 'y2 y3' ''"
        self.assertIn(_N_, log)
        self.assertIn(_n_, log)
        self.assertIn(_f_, log)
        self.assertIn(_t_, log)
        self.assertIn(_P_, log)
        self.assertIn(_p_, log)
        self.assertIn(_I_, log)
        self.assertIn(_i_, log)
        if not real:
            self.assertIn(_T_, log)
            self.assertIn(_V_, log)
            self.assertIn(_Z_, log)
        #
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3290_may_override_environment_from_commandline(self) -> None:
        """ check that --extra-vars can be given on the commandline
            to override settings in Environment= and EnvironmentFile=."""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        print_sh = os_path(root, "/usr/bin/print.sh")
        logfile = os_path(root, "/var/log/print_sh.log")
        service_file = os_path(root, "/etc/systemd/system/zzb zzc.service")
        env_file = "/etc/sysconfig/my.conf"
        extra_vars_file = "/etc/sysconfig/extra.conf"
        env_text_file = os_path(root, env_file)
        extra_vars_text_file = os_path(root, extra_vars_file)
        text_file(env_text_file, """
            M="emm a"
            N='enn i'
        """)
        text_file(extra_vars_text_file, """
            R="rob o"
            Y='knew it'
        """)
        text_file(service_file, """
            [Unit]
            Description=Testing B
            [Service]
            Environment=X=x1
            Environment="Y=y2 y3"
            EnvironmentFile=%s
            ExecStart=/bin/sleep 3
            ExecStartPost=%s X: $X ${X}
            ExecStartPost=%s Y: $Y ${Y}
            ExecStartPost=%s M: $M ${M}
            ExecStartPost=%s N: $N ${N}
            ExecStartPost=%s R: $R ${R}
            ExecStartPost=%s S: $S ${S}
            ExecStartPost=%s T: $T ${T}
            [Install]
            WantedBy=multi-user.target"""
                  % (env_file, print_sh, print_sh, print_sh,
                     print_sh, print_sh, print_sh, print_sh, ))
        text_file(logfile, "")
        shell_file(print_sh, """
            #! /bin/sh
            logfile='{logfile}'
            echo "'$1' '$2' '$3' '$4' '$5'" >> "$logfile"
            """.format(**locals()))
        #
        cmd = "{systemctl} start 'zzb zzc.service' -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        log = lines(open(logfile))
        logg.info("LOG \n%s", log)
        X="'X:' 'x1' 'x1' '' ''"  #
        Y="'Y:' 'y2' 'y3' 'y2 y3' ''"
        M="'M:' 'emm' 'a' 'emm a' ''"
        N="'N:' 'enn' 'i' 'enn i' ''"
        R="'R:' '' '' '' ''"
        S="'S:' '' '' '' ''"
        T="'T:' '' '' '' ''"
        self.assertIn(X, log)
        self.assertIn(Y, log)
        self.assertIn(M, log)
        self.assertIn(N, log)
        self.assertIn(R, log)
        self.assertIn(S, log)
        self.assertIn(T, log)
        #
        cmd = "{systemctl} stop 'zzb zzc.service'"
        out, end = output2(cmd.format(**locals()))
        time.sleep(1)
        cmd = "{systemctl} start 'zzb zzc.service' -vv -e X=now --environment 'M=more N=from' --extra-vars @" + extra_vars_file
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        log = lines(open(logfile))
        logg.info("LOG \n%s", log)
        X="'X:' 'now' 'now' '' ''"  #
        Y="'Y:' 'knew' 'it' 'knew it' ''"
        M="'M:' 'more' 'more' '' ''"
        N="'N:' 'from' 'from' '' ''"
        R="'R:' 'rob' 'o' 'rob o' ''"
        S="'S:' '' '' '' ''"
        T="'T:' '' '' '' ''"
        self.assertIn(X, log)
        self.assertIn(Y, log)
        self.assertIn(M, log)
        self.assertIn(N, log)
        self.assertIn(R, log)
        self.assertIn(S, log)
        self.assertIn(T, log)
        #
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3301_service_config_show(self) -> None:
        """ check that a named service config can show its properties"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        logfile = os_path(root, "/var/log/test.log")
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zzs.service"), """
            [Unit]
            Description=Testing S
            After=foo.service
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleep} 99
            ExecStop=/usr/bin/killall {testsleep}
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzs.service"), os_path(root, "/etc/systemd/system/zzs.service"))
        #
        cmd = "{systemctl} show zzs.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        data = lines(out)
        self.assertTrue(greps(data, "Id=zzs.service"))
        self.assertTrue(greps(data, "Names=zzs.service"))
        self.assertTrue(greps(data, "Description=Testing"))
        self.assertFalse(greps(data, "MainPID=0"))
        self.assertTrue(greps(data, "SubState=dead"))
        self.assertTrue(greps(data, "ActiveState=inactive"))
        self.assertTrue(greps(data, "LoadState=loaded"))
        self.assertTrue(greps(data, "UnitFileState=disabled"))
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} enable zzs.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} show zzs.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        data = lines(out)
        self.assertTrue(greps(data, "Id=zzs.service"))
        self.assertTrue(greps(data, "Names=zzs.service"))
        self.assertTrue(greps(data, "Description=Testing"))
        self.assertFalse(greps(data, "MainPID=0"))
        self.assertTrue(greps(data, "SubState=dead"))
        self.assertTrue(greps(data, "ActiveState=inactive"))
        self.assertTrue(greps(data, "LoadState=loaded"))
        self.assertTrue(greps(data, "UnitFileState=enabled")) # <<<
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} start zzs.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} show zzs.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        data = lines(out)
        self.assertTrue(greps(data, "Id=zzs.service"))
        self.assertTrue(greps(data, "Names=zzs.service"))
        self.assertTrue(greps(data, "Description=Testing"))
        self.assertTrue(greps(data, "MainPID=[123456789][1234567890]*")) # <<<<
        self.assertTrue(greps(data, "SubState=running")) # <<<
        self.assertTrue(greps(data, "ActiveState=active")) # <<<<
        self.assertTrue(greps(data, "LoadState=loaded"))
        self.assertTrue(greps(data, "UnitFileState=enabled"))
        self.assertEqual(end, 0)
        #
        # cleanup
        kill_testsleep = "{systemctl} __killall {testsleep}"
        sx____(kill_testsleep.format(**locals()))
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3302_service_config_show_single_properties(self) -> None:
        """ check that a named service config can show a single properties"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        logfile = os_path(root, "/var/log/test.log")
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zzs.service"), """
            [Unit]
            Description=Testing S
            After=foo.service
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleep} 99
            ExecStop=/usr/bin/killall {testsleep}
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzs.service"), os_path(root, "/etc/systemd/system/zzs.service"))
        #
        cmd = "{systemctl} show zzs.service -vv -p ActiveState"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        data = lines(out)
        self.assertTrue(greps(data, "ActiveState=inactive"))
        self.assertEqual(len(data), 1)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} start zzs.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} show zzs.service -vv -p ActiveState"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        data = lines(out)
        self.assertTrue(greps(data, "ActiveState=active"))
        self.assertEqual(len(data), 1)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} show zzs.service -vv -p 'MainPID'"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        data = lines(out)
        self.assertTrue(greps(data, "MainPID=[123456789][1234567890]*")) # <<<<
        self.assertEqual(len(data), 1)
        self.assertEqual(end, 0)
        #
        # cleanup
        kill_testsleep = "{systemctl} __killall {testsleep}"
        sx____(kill_testsleep.format(**locals()))
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3303_service_config_show_single_properties_plus_unknown(self) -> None:
        """ check that a named service config can show a single properties"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        logfile = os_path(root, "/var/log/test.log")
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zzs.service"), """
            [Unit]
            Description=Testing S
            After=foo.service
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleep} 99
            ExecStop=/usr/bin/killall {testsleep}
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzs.service"), os_path(root, "/etc/systemd/system/zzs.service"))
        #
        cmd = "{systemctl} show zzs.service -vv -p ActiveState"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        data = lines(out)
        self.assertTrue(greps(data, "ActiveState=inactive"))
        self.assertEqual(len(data), 1)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} start zzs.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} show zzs.service other.service -vv -p ActiveState"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        data = lines(out)
        self.assertTrue(greps(data, "ActiveState=active"))
        self.assertEqual(len(data), 3)
        #
        cmd = "{systemctl} show zzs.service other.service -vv -p 'MainPID'"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        data = lines(out)
        self.assertTrue(greps(data, "MainPID=[123456789][1234567890]*")) # <<<<
        self.assertEqual(len(data), 3)
        #
        # cleanup
        kill_testsleep = "{systemctl} __killall {testsleep}"
        sx____(kill_testsleep.format(**locals()))
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3401_service_status_show(self) -> None:
        """ check that a named service config can show its status"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        logfile = os_path(root, "/var/log/test.log")
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zzs.service"), """
            [Unit]
            Description=Testing S
            After=foo.service
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleep} 99
            ExecStop=/usr/bin/killall {testsleep}
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzs.service"), os_path(root, "/etc/systemd/system/zzs.service"))
        #
        cmd = "{systemctl} status zzs.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertNotEqual(end, 0)
        data = lines(out)
        self.assertTrue(greps(data, "zzs.service - Testing"))
        self.assertTrue(greps(data, "Loaded: loaded"))
        self.assertTrue(greps(data, "Active: inactive"))
        self.assertTrue(greps(data, "[(]dead[)]"))
        self.assertTrue(greps(data, "disabled[)]"))
        #
        cmd = "{systemctl} enable zzs.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} start zzs.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} status zzs.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        data = lines(out)
        self.assertTrue(greps(data, "zzs.service - Testing"))
        self.assertTrue(greps(data, "Loaded: loaded"))
        self.assertTrue(greps(data, "Active: active"))
        self.assertTrue(greps(data, "[(]running[)]"))
        self.assertTrue(greps(data, "enabled[)]"))
        #
        # cleanup
        kill_testsleep = "{systemctl} __killall {testsleep}"
        sx____(kill_testsleep.format(**locals()))
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3403_service_status_show_plus_unknown(self) -> None:
        """ check that a named service config can show its status"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        logfile = os_path(root, "/var/log/test.log")
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zzs.service"), """
            [Unit]
            Description=Testing S
            After=foo.service
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleep} 99
            ExecStop=/usr/bin/killall {testsleep}
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzs.service"), os_path(root, "/etc/systemd/system/zzs.service"))
        #
        cmd = "{systemctl} status zzs.service other.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertNotEqual(end, 0)
        data = lines(out)
        self.assertTrue(greps(data, "zzs.service - Testing"))
        self.assertTrue(greps(data, "Loaded: loaded"))
        self.assertTrue(greps(data, "Active: inactive"))
        self.assertTrue(greps(data, "[(]dead[)]"))
        self.assertTrue(greps(data, "disabled[)]"))
        #
        cmd = "{systemctl} enable zzs.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} start zzs.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} status zzs.service other.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertNotEqual(end, 0)
        data = lines(out)
        self.assertTrue(greps(data, "zzs.service - Testing"))
        self.assertTrue(greps(data, "Loaded: loaded"))
        self.assertTrue(greps(data, "Active: active"))
        self.assertTrue(greps(data, "[(]running[)]"))
        self.assertTrue(greps(data, "enabled[)]"))
        #
        # cleanup
        kill_testsleep = "{systemctl} __killall {testsleep}"
        sx____(kill_testsleep.format(**locals()))
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3530_systemctl_py_default_workingdirectory_is_root(self) -> None:
        """ check that services without WorkingDirectory start in / """
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        logfile = os_path(root, "/var/log/test.log")
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            [Service]
            Type=simple
            ExecStart={bindir}/zzz.sh
            ExecStop=/usr/bin/killall {testsleep}
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        shell_file(os_path(testdir, "zzz.sh"), """
            #! /bin/sh
            log={logfile}
            date > "$log"
            pwd >> "$log"
            exec {bindir}/{testsleep} 111
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        copy_tool(os_path(testdir, "zzz.sh"), os_path(root, "/usr/bin/zzz.sh"))
        #
        cmd = "{systemctl} start zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        #
        log = lines(reads(logfile))
        logg.info("LOG %s\n| %s", logfile, "\n| ".join(log))
        self.assertIn(root, log) # <<<<<<<<<< CHECK
        #
        cmd = "{systemctl} stop zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        kill_testsleep = "{systemctl} __killall {testsleep}"
        sx____(kill_testsleep.format(**locals()))
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3531_systemctl_py_simple_in_workingdirectory(self) -> None:
        """ check that we can start simple services with a WorkingDirectory"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        logfile = os_path(root, "/var/log/test.log")
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        workingdir = "/var/testsleep"
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            [Service]
            Type=simple
            WorkingDirectory={workingdir}
            ExecStart={bindir}/zzz.sh
            ExecStop=/usr/bin/killall {testsleep}
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        shell_file(os_path(testdir, "zzz.sh"), """
            #! /bin/sh
            log={logfile}
            date > "$log"
            pwd >> "$log"
            exec {bindir}/{testsleep} 111
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        copy_tool(os_path(testdir, "zzz.sh"), os_path(root, "/usr/bin/zzz.sh"))
        os.makedirs(os_path(root, workingdir))
        #
        cmd = "{systemctl} start zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        #
        log = lines(reads(logfile))
        logg.info("LOG %s\n| %s", logfile, "\n| ".join(log))
        self.assertIn(os_path(root, workingdir), log) # <<<<<<<<<< CHECK
        #
        cmd = "{systemctl} stop zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        kill_testsleep = "{systemctl} __killall {testsleep}"
        sx____(kill_testsleep.format(**locals()))
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3532_systemctl_py_with_bad_workingdirectory(self) -> None:
        """ check that we can start simple services with a bad WorkingDirectory"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        logfile = os_path(root, "/var/log/test.log")
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        workingdir = "/var/testsleep"
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            [Service]
            Type=simple
            WorkingDirectory={workingdir}
            ExecStart={bindir}/zzz.sh
            ExecStop=/usr/bin/killall {testsleep}
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        shell_file(os_path(testdir, "zzz.sh"), """
            #! /bin/sh
            log={logfile}
            date > "$log"
            pwd >> "$log"
            exec {bindir}/{testsleep} 111
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        copy_tool(os_path(testdir, "zzz.sh"), os_path(root, "/usr/bin/zzz.sh"))
        # os.makedirs(os_path(root, workingdir)) <<<
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        text_file(debug_log, "")
        #
        cmd = "{systemctl} start zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        #
        log = reads(debug_log)
        logg.info("systemctl.debug.log:\n%s", i2(log))
        self.assertTrue(greps(log, "ERROR chdir workingdir.*such file or directory"))
        self.assertTrue(greps(log, "bad workingdir"))
        #
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out, "failed\n")
        #
        kill_testsleep = "{systemctl} __killall {testsleep}"
        sx____(kill_testsleep.format(**locals()))
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3533_systemctl_py_with_bad_workingdirectory(self) -> None:
        """ check that we can start simple services with a bad WorkingDirectory with '-'"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        logfile = os_path(root, "/var/log/test.log")
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        workingdir = "/var/testsleep"
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            [Service]
            Type=simple
            WorkingDirectory=-{workingdir}
            ExecStart={bindir}/zzz.sh
            ExecStop=/usr/bin/killall {testsleep}
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        shell_file(os_path(testdir, "zzz.sh"), """
            #! /bin/sh
            log={logfile}
            date > "$log"
            pwd >> "$log"
            exec {bindir}/{testsleep} 111
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        copy_tool(os_path(testdir, "zzz.sh"), os_path(root, "/usr/bin/zzz.sh"))
        # os.makedirs(os_path(root, workingdir)) <<<
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        text_file(debug_log, "")
        if COVERAGE:
            systemctl += " -c EXEC_SPAWN=True"
        #
        cmd = "{systemctl} start zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        #
        log = reads(debug_log)
        logg.info("systemctl.debug.log:\n%s", i2(log))
        self.assertTrue(greps(log, "DEBUG chdir workingdir.*such file or directory"))
        self.assertFalse(greps(log, "bad workingdir"))
        #
        log = reads(logfile)
        logg.info("LOG %s\n %s", logfile, i2(log))
        self.assertNotIn(os_path(root, workingdir), log) # <<<<<<<<<< CHECK
        self.assertIn(root, log)
        #
        cmd = "{systemctl} stop zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        kill_testsleep = "{systemctl} __killall {testsleep}"
        sx____(kill_testsleep.format(**locals()))
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3601_non_absolute_ExecStopPost(self) -> None:
        """ check that we get a strong warning when not using absolute paths in ExecCommands"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleep} 111
            ExecStop=/usr/bin/killall {testsleep}
            ExecStopPost=killall {testsleep}
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        #
        cmd = "{systemctl} start zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} stop zzz.service -vv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertTrue(greps(err, "Exec is not an absolute"))
        #
        kill_testsleep = "{systemctl} __killall {testsleep}"
        sx____(kill_testsleep.format(**locals()))
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3602_non_absolute_ExecStop(self) -> None:
        """ check that we get a strong warning when not using absolute paths in ExecCommands"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        quick = QUICK
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleep} 111
            ExecStop=killall {testsleep}
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        #
        cmd = "{systemctl} start zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} stop zzz.service -vv {quick}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertTrue(greps(err, "Exec is not an absolute"))
        #
        kill_testsleep = "{systemctl} __killall {testsleep}"
        sx____(kill_testsleep.format(**locals()))
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3603_non_absolute_ExecReload(self) -> None:
        """ check that we get a strong warning when not using absolute paths in ExecCommands"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleep} 111
            ExecReload=killall {testsleep}
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        #
        cmd = "{systemctl} start zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} reload zzz.service -vv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertTrue(greps(err, "Exec is not an absolute"))
        #
        cmd = "{systemctl} stop zzz.service -vv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        #
        kill_testsleep = "{systemctl} __killall {testsleep}"
        sx____(kill_testsleep.format(**locals()))
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3604_non_absolute_ExecStartPost(self) -> None:
        """ check that we get a strong warning when not using absolute paths in ExecCommands"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleep} 111
            ExecStartPost=echo OK
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        #
        cmd = "{systemctl} start zzz.service -vv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(err, "Exec is not an absolute"))
        #
        cmd = "{systemctl} stop zzz.service -vv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        #
        kill_testsleep = "{systemctl} __killall {testsleep}"
        sx____(kill_testsleep.format(**locals()))
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3605_non_absolute_ExecStartPre(self) -> None:
        """ check that we get a strong warning when not using absolute paths in ExecCommands"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            [Service]
            Type=simple
            ExecStartPre=echo OK
            ExecStart={bindir}/{testsleep} 111
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        #
        cmd = "{systemctl} start zzz.service -vv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Exec is not an absolute"))
        #
        cmd = "{systemctl} stop zzz.service -vv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        #
        kill_testsleep = "{systemctl} __killall {testsleep}"
        sx____(kill_testsleep.format(**locals()))
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3606_non_absolute_ExecStart(self) -> None:
        """ check that we get a strong warning when not using absolute paths in ExecCommands"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            [Service]
            Type=simple
            ExecStart=sleep 111
            TimeoutSec=10
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        #
        cmd = "{systemctl} start zzz.service -vv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Exec is not an absolute"))
        #
        cmd = "{systemctl} stop zzz.service -vv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        #
        kill_testsleep = "{systemctl} __killall {testsleep}"
        sx____(kill_testsleep.format(**locals()))
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_3609_exitcode_from_ExecReload(self) -> None:
        self.test_3609_exitcode_from_ExecReload(True)
    def test_3609_exitcode_from_ExecReload(self, real: bool = False) -> None:
        """ check that we get a warning when ExecReload has an error"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir, real)
        vv = "-vv"
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleep} 111
            ExecReload=/usr/bin/killall -q some-unknown-program
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        cmd = "{systemctl} start zzz.service {vv}"
        sx____("{systemctl} daemon-reload".format(**locals()))
        #
        cmd = "{systemctl} start zzz.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} reload zzz.service {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertTrue(greps(err, "Job for zzz.service failed because the control process exited with error code."))
        #
        cmd = "{systemctl} is-active zzz.service {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        #
        cmd = "{systemctl} stop zzz.service {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        #
        kill_testsleep = "{systemctl} __killall {testsleep}"
        sx____(kill_testsleep.format(**locals()))
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
        self.end()
    def real_3660_start_timer_unit(self) -> None:
        self.test_3660_start_timer_unit(True)
    def test_3660_start_timer_unit(self, real: bool = False) -> None:
        """ check that we get a warning when a timer is started"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir, real)
        vv = "-vv"
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zzt.timer"), """
            [Unit]
            Description=Timer T
            [Timer]
            OnCalendar=daily
            AccuracySec=12h
            Persistent=true
            [Install]
            WantedBy=timers.target
            """.format(**locals()))
        text_file(os_path(testdir, "zzt.service"), """
            [Unit]
            Description=Testing T
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleep} 11
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzt.timer"), os_path(root, "/etc/systemd/system/zzt.timer"))
        copy_file(os_path(testdir, "zzt.service"), os_path(root, "/etc/systemd/system/zzt.service"))
        sx____("{systemctl} daemon-reload".format(**locals()))
        #
        cmd = "{systemctl} enable zzt.timer {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(os.path.exists(os_path(root, "/etc/systemd/system/timers.target.wants/zzt.timer")))
        #
        cmd = "{systemctl} start zzt.timer {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\%s", cmd, end, out, err)
        if real:
            self.assertEqual(end, 0)
        else:
            self.assertEqual(end, 1)
            self.assertTrue(greps(err, "not implemented"))
        #
        cmd = "{systemctl} reload zzt.timer {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertTrue(greps(err, "not implemented"))
        #
        cmd = "{systemctl} is-active zzt.timer {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertEqual(out.strip(), "unknown")
        #
        cmd = "{systemctl} stop zzt.timer {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertTrue(greps(err, "not implemented"))
        #
        cmd = "{systemctl} restart zzt.timer {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertTrue(greps(err, "not implemented"))
        #
        cmd = "{systemctl} listen zzt.timer {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, err, out)
        self.assertTrue(greps(err, "not implemented"))
        #
        kill_testsleep = "{systemctl} __killall {testsleep}"
        sx____(kill_testsleep.format(**locals()))
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
        self.end()
    def test_3700_systemctl_py_default_init_loop_in_testenv(self) -> None:
        """ check that we can enable services in a test env to be run by an init-loop.
            We expect here that the init-loop ends when all services are dead. """
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A""")
        text_file(os_path(testdir, "zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStartPre=/bin/echo starting B
            ExecStart={bindir}/{testsleep} 10
            ExecStartPost=/bin/echo running B
            ExecStopPost=/bin/echo stopping B
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zzc.service"), """
            [Unit]
            Description=Testing C
            [Service]
            Type=simple
            ExecStartPre=/bin/echo starting C
            ExecStart={bindir}/{testsleep} 15
            ExecStartPost=/bin/echo running C
            ExecStopPost=/bin/echo stopping C
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        copy_file(os_path(testdir, "zzc.service"), os_path(root, "/etc/systemd/system/zzc.service"))
        #
        cmd = "{systemctl} enable zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = "{systemctl} enable zzc.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = "{systemctl} --version"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = "{systemctl} default-services -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, "zzb.service"))
        self.assertEqual(len(lines(out)), 2)
        #
        log_stdout = os.path.join(root, "systemctl.stdout.log")
        log_stderr = os.path.join(root, "systemctl.stderr.log")
        pid = os.fork()
        if not pid:
            new_stdout = os.open(log_stdout, os.O_WRONLY |os.O_CREAT |os.O_TRUNC)
            new_stderr = os.open(log_stderr, os.O_WRONLY |os.O_CREAT |os.O_TRUNC)
            os.dup2(new_stdout, 1)
            os.dup2(new_stderr, 2)
            systemctl_cmd = [_systemctl_py, "--root="+root, "--init", "default", "-vv"]
            env = os.environ.copy()
            systemctl_cmd += ["-c", "ExitWhenNoMoreServices=yes"]
            systemctl_cmd += ["-c", "InitLoopSleep=2"]
            os.execve(_systemctl_py, systemctl_cmd, env)
        time.sleep(2)
        logg.info("all services running [systemctl.py PID %s]", pid)
        txt_stdout = lines(open(log_stdout))
        txt_stderr = lines(open(log_stderr))
        logg.info("-- %s>\n\t%s", log_stdout, "\n\t".join(txt_stdout))
        logg.info("-- %s>\n\t%s", log_stderr, "\n\t".join(txt_stderr))
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = "{systemctl} is-active zzb.service zzc.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, "^active"))
        self.assertFalse(greps(out, "inactive"))
        self.assertFalse(greps(out, "failed"))
        for check in xrange(9):
            time.sleep(3)
            top = _recent(output(_top_list))
            logg.info("[%s] checking for testsleep procs: \n>>>\n%s",
                      check, greps(top, testsleep))
            if not greps(top, testsleep):
                break
        time.sleep(2)
        logg.info("all services dead [systemctl.py PID %s]", pid)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = "{systemctl} is-active zzb.service zzc.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertFalse(greps(out, "^active"))
        self.assertTrue(greps(out, "inactive"))
        self.assertFalse(greps(out, "failed"))
        #
        os.kill(pid, 2) # SIGINT (clean up zombie?)
        txt_stdout = lines(open(log_stdout))
        txt_stderr = lines(open(log_stderr))
        logg.info("-- %s>\n\t%s", log_stdout, "\n\t".join(txt_stdout))
        logg.info("-- %s>\n\t%s", log_stderr, "\n\t".join(txt_stderr))
        self.assertTrue(greps(txt_stderr, "no more services - exit init-loop"))
        self.assertTrue(greps(txt_stderr, "system is down"))
        self.assertTrue(greps(txt_stdout, "starting B"))
        self.assertTrue(greps(txt_stdout, "starting C"))
        #
        kill_testsleep = "{systemctl} __killall {testsleep}"
        sx____(kill_testsleep.format(**locals()))
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3710_systemctl_py_init_explicit_loop_in_testenv(self) -> None:
        """ check that we can init services in a test env to be run by an init-loop.
            We expect here that the init-loop ends when those services are dead. """
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A""")
        text_file(os_path(testdir, "zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStartPre=/bin/echo starting B
            ExecStart={bindir}/{testsleep} 10
            ExecStartPost=/bin/echo running B
            ExecStopPost=/bin/echo stopping B
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zzc.service"), """
            [Unit]
            Description=Testing C
            [Service]
            Type=simple
            ExecStartPre=/bin/echo starting C
            ExecStart={bindir}/{testsleep} 15
            ExecStartPost=/bin/echo running C
            ExecStopPost=/bin/echo stopping C
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        copy_file(os_path(testdir, "zzc.service"), os_path(root, "/etc/systemd/system/zzc.service"))
        #
        cmd = "{systemctl} enable zzb.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = "{systemctl} enable zzc.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = "{systemctl} --version"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = "{systemctl} default-services -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, "zzb.service"))
        self.assertEqual(len(lines(out)), 2)
        #
        log_stdout = os.path.join(root, "systemctl.stdout.log")
        log_stderr = os.path.join(root, "systemctl.stderr.log")
        pid = os.fork()
        if not pid:
            new_stdout = os.open(log_stdout, os.O_WRONLY |os.O_CREAT |os.O_TRUNC)
            new_stderr = os.open(log_stderr, os.O_WRONLY |os.O_CREAT |os.O_TRUNC)
            os.dup2(new_stdout, 1)
            os.dup2(new_stderr, 2)
            systemctl_cmd = [_systemctl_py, "--root="+root, "init", "zzb.service", "zzc.service", "-vv"]
            env = os.environ.copy()
            systemctl_cmd += ["-c", "InitLoopSleep=2"]
            os.execve(_systemctl_py, systemctl_cmd, env)
        time.sleep(3)
        logg.info("all services running [systemctl.py PID %s]", pid)
        txt_stdout = lines(open(log_stdout))
        txt_stderr = lines(open(log_stderr))
        logg.info("-- %s>\n\t%s", log_stdout, "\n\t".join(txt_stdout))
        logg.info("-- %s>\n\t%s", log_stderr, "\n\t".join(txt_stderr))
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = "{systemctl} is-active zzb.service zzc.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(out, "^active"))
        self.assertFalse(greps(out, "inactive"))
        self.assertFalse(greps(out, "failed"))
        for check in xrange(9):
            time.sleep(3)
            top = _recent(output(_top_list))
            logg.info("[%s] checking for testsleep procs: \n>>>\n%s",
                      check, greps(top, testsleep))
            if not greps(top, testsleep):
                break
        time.sleep(2)
        logg.info("all services dead [systemctl.py PID %s]", pid)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = "{systemctl} is-active zzb.service zzc.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertFalse(greps(out, "^active"))
        self.assertTrue(greps(out, "inactive"))
        self.assertFalse(greps(out, "failed"))
        #
        os.kill(pid, 2) # SIGINT (clean up zombie?)
        txt_stdout = lines(open(log_stdout))
        txt_stderr = lines(open(log_stderr))
        logg.info("-- %s>\n\t%s", log_stdout, "\n\t".join(txt_stdout))
        logg.info("-- %s>\n\t%s", log_stderr, "\n\t".join(txt_stderr))
        self.assertTrue(greps(txt_stderr, "no more services - exit init-loop"))
        self.assertTrue(greps(txt_stderr, "init is done"))
        self.assertTrue(greps(txt_stdout, "starting B"))
        self.assertTrue(greps(txt_stdout, "starting C"))
        #
        kill_testsleep = "{systemctl} __killall {testsleep}"
        sx____(kill_testsleep.format(**locals()))
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_3801_start_some_unknown(self) -> None:
        self.test_3801_start_some_unknown(True)
    def test_3801_start_some_unknown(self, real: bool = False) -> None:
        """ check start some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____("{systemctl} daemon-reload".format(**locals()))
        cmd = "{systemctl} start zz-unknown.service {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 5)
        self.assertTrue(greps(err, "Unit zz-unknown.service not found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_3802_stop_some_unknown(self) -> None:
        self.test_3802_stop_some_unknown(True)
    def test_3802_stop_some_unknown(self, real: bool = False) -> None:
        """ check stop some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____("{systemctl} daemon-reload".format(**locals()))
        cmd = "{systemctl} stop zz-unknown.service {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 5)
        if real: self.assertTrue(greps(err, "Unit zz-unknown.service not loaded."))
        else: self.assertTrue(greps(err, "Unit zz-unknown.service not found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_3803_restart_some_unknown(self) -> None:
        self. test_3803_restart_some_unknown(True)
    def test_3803_restart_some_unknown(self, real: bool = False) -> None:
        """ check restart some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____("{systemctl} daemon-reload".format(**locals()))
        cmd = "{systemctl} restart zz-unknown.service {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 5)
        self.assertTrue(greps(err, "Unit zz-unknown.service not found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_3804_reload_some_unknown(self) -> None:
        self. test_3804_reload_some_unknown(True)
    def test_3804_reload_some_unknown(self, real: bool = False) -> None:
        """ check reload some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____("{systemctl} daemon-reload".format(**locals()))
        cmd = "{systemctl} reload zz-unknown.service {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 5)
        self.assertTrue(greps(err, "Unit zz-unknown.service not found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_3805_reload_or_restart_some_unknown(self) -> None:
        self. test_3805_reload_or_restart_some_unknown(True)
    def test_3805_reload_or_restart_some_unknown(self, real: bool = False) -> None:
        """ check reload-or-restart some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____("{systemctl} daemon-reload".format(**locals()))
        cmd = "{systemctl} reload-or-restart zz-unknown.service {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 5)
        self.assertTrue(greps(err, "Unit zz-unknown.service not found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_3806_reload_or_try_restart_some_unknown(self) -> None:
        self. test_3806_reload_or_try_restart_some_unknown(True)
    def test_3806_reload_or_try_restart_some_unknown(self, real: bool = False) -> None:
        """ check reload-or-try-restart some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____("{systemctl} daemon-reload".format(**locals()))
        cmd = "{systemctl} reload-or-try-restart zz-unknown.service {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 5)
        self.assertTrue(greps(err, "Unit zz-unknown.service not found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_3807_try_restart_some_unknown(self) -> None:
        self. test_3807_try_restart_some_unknown(True)
    def test_3807_try_restart_some_unknown(self, real: bool = False) -> None:
        """ check try-restart some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____("{systemctl} daemon-reload".format(**locals()))
        cmd = "{systemctl} try-restart zz-unknown.service {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 5)
        self.assertTrue(greps(err, "Unit zz-unknown.service not found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_3808_kill_some_unknown(self) -> None:
        self. test_3808_kill_some_unknown(True)
    def test_3808_kill_some_unknown(self, real: bool = False) -> None:
        """ check kill some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____("{systemctl} daemon-reload".format(**locals()))
        cmd = "{systemctl} kill zz-unknown.service {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        if real:
            self.assertTrue(greps(err, "Unit zz-unknown.service is not loaded."))
        else:
            self.assertTrue(greps(err, "Unit zz-unknown.service not found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_3809_reset_failed_some_unknown(self) -> None:
        self. test_3809_reset_failed_some_unknown(True)
    def test_3809_reset_failed_some_unknown(self, real: bool = False) -> None:
        """ check reset_failed some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____("{systemctl} daemon-reload".format(**locals()))
        cmd = "{systemctl} reset-failed zz-unknown.service {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        if real:
            self.assertTrue(greps(err, "Unit zz-unknown.service is not loaded."))
        else:
            self.assertTrue(greps(err, "Unit zz-unknown.service not found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_3811_mask_some_unknown(self) -> None:
        self. test_3811_mask_some_unknown(True)
    def test_3811_mask_some_unknown(self, real: bool = False) -> None:
        """ check mask some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____("{systemctl} daemon-reload".format(**locals()))
        cmd = "{systemctl} mask zz-unknown.service {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        if real:
            self.assertEqual(end, 0)
            self.assertTrue(greps(err, "Unit zz-unknown.service does not exist, proceeding anyway."))  # TODO
            self.assertTrue(greps(err, "Created symlink /etc/systemd/system/zz-unknown.service .* /dev/null"))
        else:
            self.assertEqual(end, 5)
            self.assertTrue(greps(err, "Unit zz-unknown.service not found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_3812_unmask_some_unknown(self) -> None:
        self. test_3812_unmask_some_unknown(True)
    def test_3812_unmask_some_unknown(self, real: bool = False) -> None:
        """ check unmask some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____("{systemctl} daemon-reload".format(**locals()))
        cmd = "{systemctl} unmask zz-unknown.service {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        if real:
            self.assertEqual(end, 0)
            self.assertTrue(greps(err, "Unit zz-unknown.service does not exist, proceeding anyway."))  # TODO
        else:
            self.assertEqual(end, 5)
            self.assertTrue(greps(err, "Unit zz-unknown.service not found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_3813_enable_some_unknown(self) -> None:
        self. test_3813_enable_some_unknown(True)
    def test_3813_enable_some_unknown(self, real: bool = False) -> None:
        """ check enable some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____("{systemctl} daemon-reload".format(**locals()))
        cmd = "{systemctl} enable zz-unknown.service {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        if real:
            self.assertTrue(greps(err, "Failed to enable unit: Unit file zz-unknown.service does not exist."))  # TODO
        else:
            self.assertTrue(greps(err, "Unit zz-unknown.service not found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_3814_disable_some_unknown(self) -> None:
        self. test_3814_disable_some_unknown(True)
    def test_3814_disable_some_unknown(self, real: bool = False) -> None:
        """ check disable some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____("{systemctl} daemon-reload".format(**locals()))
        cmd = "{systemctl} disable zz-unknown.service {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        if real:
            self.assertTrue(greps(err, "Failed to disable unit: Unit file zz-unknown.service does not exist."))  # TODO
        else:
            self.assertTrue(greps(err, "Unit zz-unknown.service not found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_3815_is_enabled_some_unknown(self) -> None:
        self. test_3815_is_enabled_some_unknown(True)
    def test_3815_is_enabled_some_unknown(self, real: bool = False) -> None:
        """ check is-enabled some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____("{systemctl} daemon-reload".format(**locals()))
        cmd = "{systemctl} is-enabled zz-unknown.service {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        if real:
            self.assertTrue(greps(err, "Failed to get unit file state for zz-unknown.service: No such file or directory"))  # TODO
        else:
            self.assertTrue(greps(err, "Unit zz-unknown.service not found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_3816_is_failed_some_unknown(self) -> None:
        self. test_3816_is_failed_some_unknown(True)
    def test_3816_is_failed_some_unknown(self, real: bool = False) -> None:
        """ check is-failed some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____("{systemctl} daemon-reload".format(**locals()))
        cmd = "{systemctl} is-failed zz-unknown.service {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertEqual(out, "inactive\n")
        if not real:
            self.assertTrue(greps(err, "Unit zz-unknown.service not found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_3817_is_active_some_unknown(self) -> None:
        self. test_3817_is_active_some_unknown(True)
    def test_3817_is_active_some_unknown(self, real: bool = False) -> None:
        """ check is-active some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____("{systemctl} daemon-reload".format(**locals()))
        cmd = "{systemctl} is-active zz-unknown.service {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 3)
        if not real:
            self.assertTrue(greps(err, "Unit zz-unknown.service not found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_3818_cat_some_unknown(self) -> None:
        self. test_3818_cat_some_unknown(True)
    def test_3818_cat_some_unknown(self, real: bool = False) -> None:
        """ check cat some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____("{systemctl} daemon-reload".format(**locals()))
        cmd = "{systemctl} cat zz-unknown.service {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        if real:
            self.assertTrue(greps(err, "No files found for zz-unknown.service."))
        else:
            self.assertTrue(greps(err, "Unit zz-unknown.service could not be found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_3819_status_some_unknown(self) -> None:
        self. test_3819_status_some_unknown(True)
    def test_3819_status_some_unknown(self, real: bool = False) -> None:
        """ check status some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____("{systemctl} daemon-reload".format(**locals()))
        cmd = "{systemctl} status zz-unknown.service {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 4)
        self.assertTrue(greps(err, "Unit zz-unknown.service could not be found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_3820_preset_some_unknown(self) -> None:
        self. test_3820_preset_some_unknown(True)
    def test_3820_preset_some_unknown(self, real: bool = False) -> None:
        """ check preset some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____("{systemctl} daemon-reload".format(**locals()))
        cmd = "{systemctl} preset zz-unknown.service {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        if real:
            self.assertTrue(greps(err, "Failed to preset unit: Unit file zz-unknown.service does not exist."))
        if not real:
            self.assertTrue(greps(err, "Unit zz-unknown.service could not be found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    # def real_3821_get_preset_some_unknown(self) -> None:
    #     self. test_3821_get_preset_some_unknown(True)
    def test_3821_get_preset_some_unknown(self, real: bool = False) -> None:
        """ check get-preset some unknown unit fails okay"""
        self.skipTest("get-preset currently not exported")
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____("{systemctl} daemon-reload".format(**locals()))
        cmd = "{systemctl} get-preset zz-unknown.service {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        if not real:
            self.assertTrue(greps(err, "Unit zz-unknown.service not found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_3822_show_some_unknown(self) -> None:
        self. test_3822_show_some_unknown(True)
    def test_3822_show_some_unknown(self, real: bool = False) -> None:
        """ check show some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____("{systemctl} daemon-reload".format(**locals()))
        cmd = "{systemctl} show zz-unknown.service {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        if not real:
            self.assertTrue(greps(err, "Unit zz-unknown.service could not be found."))
            self.assertTrue(greps(out, "Description=NOT-FOUND zz-unknown.service"))
            self.assertTrue(greps(out, "UnitFileState=static"))
        self.assertTrue(greps(out, "Id=zz-unknown.service"))
        self.assertTrue(greps(out, "Names=zz-unknown.service"))
        self.assertFalse(greps(out, "MainPID=0"))
        self.assertTrue(greps(out, "SubState=dead"))
        self.assertTrue(greps(out, "ActiveState=inactive"))
        self.assertTrue(greps(out, "LoadState=not-found"))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3824_show_environment_some_unknown(self, real: bool = False) -> None:
        """ check show-environment some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____("{systemctl} daemon-reload".format(**locals()))
        cmd = "{systemctl} environment zz-unknown.service {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 4)
        if not real:
            self.assertTrue(greps(err, "Unit zz-unknown.service could not be found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3829_preset_all_user_some_unknown(self, real: bool = False) -> None:
        """ check prset-all --user some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____("{systemctl} daemon-reload".format(**locals()))
        cmd = "{systemctl} preset-all --user {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        self.assertTrue(greps(err, "preset-all makes no sense in --user mode"))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3831_API_start_some_unknown(self, real: bool = False) -> None:
        """ check API start some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____("{systemctl} daemon-reload".format(**locals()))
        cmd = "{systemctl} __start_unit zz-unknown.service {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zz-unknown.service not found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3832_API_stop_some_unknown(self, real: bool = False) -> None:
        """ check API stop some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____("{systemctl} daemon-reload".format(**locals()))
        cmd = "{systemctl} __stop_unit zz-unknown.service {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zz-unknown.service not found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3833_API_restart_some_unknown(self, real: bool = False) -> None:
        """ check API restart some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____("{systemctl} daemon-reload".format(**locals()))
        cmd = "{systemctl} __restart_unit zz-unknown.service {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zz-unknown.service not found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3834_API_reload_some_unknown(self, real: bool = False) -> None:
        """ check API reload some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____("{systemctl} daemon-reload".format(**locals()))
        cmd = "{systemctl} __reload_unit zz-unknown.service {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zz-unknown.service not found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3835_API_reload_or_restart_some_unknown(self, real: bool = False) -> None:
        """ check API reload_or_restart some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____("{systemctl} daemon-reload".format(**locals()))
        cmd = "{systemctl} __reload_or_restart_unit zz-unknown.service {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zz-unknown.service not found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3836_API_reload_or_try_restart_some_unknown(self, real: bool = False) -> None:
        """ check API reload_or_try_restart some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____("{systemctl} daemon-reload".format(**locals()))
        cmd = "{systemctl} __reload_or_try_restart_unit zz-unknown.service {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zz-unknown.service not found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3837_API_try_restart_some_unknown(self, real: bool = False) -> None:
        """ check API try_restart some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____("{systemctl} daemon-reload".format(**locals()))
        cmd = "{systemctl} __try_restart_unit zz-unknown.service {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zz-unknown.service not found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3838_API_kill_some_unknown(self, real: bool = False) -> None:
        """ check API kill some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____("{systemctl} daemon-reload".format(**locals()))
        cmd = "{systemctl} __kill_unit zz-unknown.service {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zz-unknown.service not found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3839_API_reset_failed_some_unknown(self, real: bool = False) -> None:
        """ check API reset_failed some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____("{systemctl} daemon-reload".format(**locals()))
        cmd = "{systemctl} __reset_failed_unit zz-unknown.service {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zz-unknown.service not found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3841_API_mask_some_unknown(self, real: bool = False) -> None:
        """ check API mask some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____("{systemctl} daemon-reload".format(**locals()))
        cmd = "{systemctl} __mask_unit zz-unknown.service {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zz-unknown.service not found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3842_API_unmask_some_unknown(self, real: bool = False) -> None:
        """ check API unmask some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____("{systemctl} daemon-reload".format(**locals()))
        cmd = "{systemctl} __unmask_unit zz-unknown.service {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zz-unknown.service not found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3843_API_enable_some_unknown(self, real: bool = False) -> None:
        """ check API enable some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____("{systemctl} daemon-reload".format(**locals()))
        cmd = "{systemctl} __enable_unit zz-unknown.service {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zz-unknown.service not found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3844_API_disable_some_unknown(self, real: bool = False) -> None:
        """ check API disable some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____("{systemctl} daemon-reload".format(**locals()))
        cmd = "{systemctl} __disable_unit zz-unknown.service {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zz-unknown.service not found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3845_API_is_enabled_some_unknown(self, real: bool = False) -> None:
        """ check API is_enabled some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____("{systemctl} daemon-reload".format(**locals()))
        cmd = "{systemctl} __is_enabled zz-unknown.service {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zz-unknown.service not found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3847_API_get_active_some_unknown(self, real: bool = False) -> None:
        """ check API get_active some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____("{systemctl} daemon-reload".format(**locals()))
        cmd = "{systemctl} __get_active_unit zz-unknown.service {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 0)
        if not real:
            self.assertTrue(greps(err, "Unit zz-unknown.service not found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3848_API_cat_some_unknown(self, real: bool = False) -> None:
        """ check API cat some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____("{systemctl} daemon-reload".format(**locals()))
        cmd = "{systemctl} __cat_unit zz-unknown.service {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "No files found for zz-unknown.service"))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3850_API_preset_all_some_unknown(self, real: bool = False) -> None:
        """ check API preset_all some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____("{systemctl} daemon-reload".format(**locals()))
        cmd = "{systemctl} __system_preset_all zz-unknown.service {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        # self.assertTrue(greps(err, "Unit zz-unknown.service could not be found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3851_API_get_preset_some_unknown(self, real: bool = False) -> None:
        """ check API get_preset some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____("{systemctl} daemon-reload".format(**locals()))
        cmd = "{systemctl} __get_preset_of_unit zz-unknown.service {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        # self.assertTrue(greps(err, "Unit zz-unknown.service not found."))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3852_API_show_some_unknown(self, real: bool = False) -> None:
        """ check API show some unknown unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        #
        sh____("{systemctl} daemon-reload".format(**locals()))
        cmd = "{systemctl} __show_unit_items zz-unknown.service {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        # self.assertTrue(greps(err, "Unit zz-unknown.service could not be found."))
        self.assertTrue(greps(out, "Description.*NOT-FOUND zz-unknown.service"))
        self.assertTrue(greps(out, "UnitFileState.*static"))
        self.assertTrue(greps(out, "Id.*zz-unknown.service"))
        self.assertTrue(greps(out, "Names.*zz-unknown.service"))
        self.assertTrue(greps(out, "MainPID\\s*"))
        self.assertTrue(greps(out, "SubState.*dead"))
        self.assertTrue(greps(out, "ActiveState.*inactive"))
        self.assertTrue(greps(out, "LoadState.*not-found"))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3880_start_some_empty_file_problem(self, real: bool = False) -> None:
        """ check start some empty file unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        text_file(os_path(root, "/etc/systemd/system/zz-empty.service"), "")
        #
        sh____("{systemctl} daemon-reload".format(**locals()))
        cmd = "{systemctl} start zz-empty.service {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        # self.assertTrue(greps(err, "Unit zz-empty.service not found."))
        self.assertTrue(greps(err, "zz-empty.service: .* file without .Service. section"))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3881_start_some_syntax_problem(self, real: bool = False) -> None:
        """ check start some syntax problem unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        text_file(os_path(root, "/etc/systemd/system/zz-empty.service"), "()")
        #
        sh____("{systemctl} daemon-reload".format(**locals()))
        cmd = "{systemctl} start zz-empty.service {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zz-empty.service not found."))
        self.assertTrue(greps(err, "zz-empty.service not loaded.*bad ini line"))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3882_start_some_inaccessible(self, real: bool = False) -> None:
        """ check start some inaccessible unit fails okay"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        root = self.root(testdir, real)
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        text_file(os_path(root, "/etc/systemd/system/zz-empty.service"), "()")
        os.chmod(os_path(root, "/etc/systemd/system/zz-empty.service"), 111)
        #
        sh____("{systemctl} daemon-reload".format(**locals()))
        cmd = "{systemctl} start zz-empty.service {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zz-empty.service not found."))
        self.assertTrue(greps(err, "zz-empty.service not loaded.*Permission denied"))
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()

    def test_3901_service_config_cat(self) -> None:
        """ check that a name service config can be printed as-is"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        logfile = os_path(root, "/var/log/test.log")
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zzs.service"), """
            [Unit]
            Description=Testing S
            After=foo.service
            [Service]
            Type=simple
            ExecStart={bindir}{testsleep} 99
            ExecStop=/usr/bin/killall {testsleep}
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzs.service"), os_path(root, "/etc/systemd/system/zzs.service"))
        #
        cmd = "{systemctl} cat zzs.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        orig = lines(open(os_path(root, "/etc/systemd/system/zzs.service")))
        data = lines(out)
        self.assertEqual(orig + [""], data)
        #
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_3903_service_config_cat_plus_unknown(self) -> None:
        """ check that a name service config can be printed as-is"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        logfile = os_path(root, "/var/log/test.log")
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zzs.service"), """
            [Unit]
            Description=Testing S
            After=foo.service
            [Service]
            Type=simple
            ExecStart={bindir}{testsleep} 99
            ExecStop=/usr/bin/killall {testsleep}
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzs.service"), os_path(root, "/etc/systemd/system/zzs.service"))
        #
        cmd = "{systemctl} cat zzs.service unknown.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 1)
        orig = lines(open(os_path(root, "/etc/systemd/system/zzs.service")))
        data = lines(out)
        self.assertEqual(orig + [""], data)
        #
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_3900_start_false_execpre(self) -> None:
        self.test_3900_start_false_execpre(True)
    def test_3900_start_false_execpre(self, real: bool = False) -> None:
        """ check that a failed execpre is handled"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir, real)
        logfile = os_path(root, "/var/log/test.log")
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        self.rm_testdir()
        self.rm_zzfiles(root)
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            After=foo.service
            [Service]
            Type=simple
            ExecStartPre="/bin/false"
            ExecStart={bindir}/{testsleep} 9
            ExecStop=/usr/bin/killall {testsleep}
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        sx____("{systemctl} reset-failed zzz.service".format(**locals()))
        sh____("{systemctl} daemon-reload".format(**locals()))
        #
        cmd = "{systemctl} enable zzz.service {vv}"
        sh____(cmd.format(**locals()))
        cmd = "{systemctl} is-active zzz.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== try to 'start' the service  ")
        cmd = "{systemctl} start zzz.service {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, i2(err))
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "control process exited with error code"))
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "failed")
        #
        cmd = "{systemctl} reset-failed zzz.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = "{systemctl} is-active zzz.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
        self.end()
    def real_3901_start_false_exec_simple(self) -> None:
        self.test_3901_start_false_exec_simple(True)
    def test_3901_start_false_exec_simple(self, real: bool = False) -> None:
        """ check that a failed exec is handled"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir, real)
        logfile = os_path(root, "/var/log/test.log")
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        self.rm_testdir()
        self.rm_zzfiles(root)
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            After=foo.service
            [Service]
            Type=simple
            ExecStart="/bin/false"
            ExecStop=/usr/bin/killall {testsleep}
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        sx____("{systemctl} reset-failed zzz.service".format(**locals()))
        sh____("{systemctl} daemon-reload".format(**locals()))
        #
        cmd = "{systemctl} enable zzz.service {vv}"
        sh____(cmd.format(**locals()))
        cmd = "{systemctl} is-active zzz.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== try to 'start' the service  ")
        cmd = "{systemctl} start zzz.service {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, i2(err))
        if real: self.assertEqual(end, 0)
        else: self.assertEqual(end, 1) # TODO: simple Exec should not wait_testpid!!
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "failed")
        #
        cmd = "{systemctl} reset-failed zzz.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = "{systemctl} is-active zzz.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
        self.end()
    def real_3902_start_false_exec_notify(self) -> None:
        self.test_3902_start_false_exec_notify(True)
    def test_3902_start_false_exec_notify(self, real: bool = False) -> None:
        """ check that a failed exec is handled"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir, real)
        logfile = os_path(root, "/var/log/test.log")
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        self.rm_testdir()
        self.rm_zzfiles(root)
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            After=foo.service
            [Service]
            Type=notify
            ExecStart="/bin/false"
            ExecStop=/usr/bin/killall {testsleep}
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        sx____("{systemctl} reset-failed zzz.service".format(**locals()))
        sh____("{systemctl} daemon-reload".format(**locals()))
        #
        cmd = "{systemctl} enable zzz.service {vv}"
        sh____(cmd.format(**locals()))
        cmd = "{systemctl} is-active zzz.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== try to 'start' the service  ")
        cmd = "{systemctl} start zzz.service {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, i2(err))
        self.assertEqual(end, 1)
        if real:
            self.assertTrue(greps(err, "because the control process exited with error code."))
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "failed")
        #
        cmd = "{systemctl} reset-failed zzz.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = "{systemctl} is-active zzz.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_3903_start_false_exec_oneshot(self) -> None:
        self.test_3903_start_false_exec_oneshot(True)
    def test_3903_start_false_exec_oneshot(self, real: bool = False) -> None:
        """ check that a failed exec is handled"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir, real)
        logfile = os_path(root, "/var/log/test.log")
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        self.rm_testdir()
        self.rm_zzfiles(root)
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            After=foo.service
            [Service]
            Type=oneshot
            ExecStart="/bin/false"
            ExecStop=/usr/bin/killall {testsleep}
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        sx____("{systemctl} reset-failed zzz.service".format(**locals()))
        sh____("{systemctl} daemon-reload".format(**locals()))
        #
        cmd = "{systemctl} enable zzz.service {vv}"
        sh____(cmd.format(**locals()))
        cmd = "{systemctl} is-active zzz.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== try to 'start' the service  ")
        cmd = "{systemctl} start zzz.service {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, i2(err))
        self.assertEqual(end, 1)
        if real:
            self.assertTrue(greps(err, "because the control process exited with error code."))
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "failed")
        #
        cmd = "{systemctl} reset-failed zzz.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = "{systemctl} is-active zzz.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
        self.end()
    def real_3904_start_false_exec_forking(self) -> None:
        self.test_3904_start_false_exec_forking(True)
    def test_3904_start_false_exec_forking(self, real: bool = False) -> None:
        """ check that a failed exec is handled"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir, real)
        logfile = os_path(root, "/var/log/test.log")
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        self.rm_testdir()
        self.rm_zzfiles(root)
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            After=foo.service
            [Service]
            Type=forking
            ExecStart="/bin/false"
            ExecStop=/usr/bin/killall {testsleep}
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        sx____("{systemctl} reset-failed zzz.service".format(**locals()))
        sh____("{systemctl} daemon-reload".format(**locals()))
        #
        cmd = "{systemctl} enable zzz.service {vv}"
        sh____(cmd.format(**locals()))
        cmd = "{systemctl} is-active zzz.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== try to 'start' the service  ")
        cmd = "{systemctl} start zzz.service {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, i2(err))
        self.assertEqual(end, 1)
        if real:
            self.assertTrue(greps(err, "because the control process exited with error code."))
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "failed")
        #
        cmd = "{systemctl} reset-failed zzz.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = "{systemctl} is-active zzz.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
        self.end()
    def real_3935_start_false_exec_notify(self) -> None:
        self.test_3935_start_false_exec_notify(True)
    def test_3935_start_false_exec_notify(self, real: bool = False) -> None:
        """ check that we manage notify services in a root env
            and false handling."""
        socat = self.socat()
        if not os.path.exists(socat):
            self.skipTest("missing "+socat)
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = testname+"_sleep"
        logfile = os_path(root, "/var/log/"+testsleep+".log")
        bindir = os_path(root, "/usr/bin")
        os.makedirs(os_path(root, "/var/run"))
        text_file(logfile, "created\n")
        shell_file(os_path(testdir, "zzz.init"), """
            #! /bin/bash
            case "$1" in start)
                ls -l  $NOTIFY_SOCKET
                {bindir}/{testsleep} 3 0<&- &>/dev/null &
                echo "MAINPID=$!" | {socat} -v -d - UNIX-CLIENT:$NOTIFY_SOCKET
                echo "READY=1" | {socat} -v -d - UNIX-CLIENT:$NOTIFY_SOCKET
                wait %1
                # ps -o pid,ppid,args
            ;; stop)
                killall {testsleep}
            ;; esac
            echo "done$1" >&2
            exit 0
            """.format(**locals()))
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            [Service]
            Type=notify
            # PIDFile={root}/var/run/zzz.init.pid
            ExecStart={root}/usr/bin/zzz.init start
            ExecStop={root}/usr/bin/zzz.init stop
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        zzz_service = "/etc/systemd/system/zzz.service".format(**locals())
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_tool(os_path(testdir, "zzz.init"), os_path(root, "/usr/bin/zzz.init"))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, zzz_service))
        #
        cmd = "{systemctl} enable zzz.service -vv"
        sh____(cmd.format(**locals()))
        #
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'start' shall start a service that is NOT is-active ")
        cmd = "{systemctl} start zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        #
        time.sleep(4)
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "failed")
        #
        cmd = "{systemctl} reset-failed zzz.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = "{systemctl} is-active zzz.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("LOG\n%s", " "+reads(logfile).replace("\n", "\n "))
        self.rm_testdir()
        self.end()
    def real_3936_start_false_exec_notify(self) -> None:
        self.test_3936_start_false_exec_notify(True)
    def test_3936_start_false_exec_notify(self, real: bool = False) -> None:
        """ check that we manage notify services in a root env
            and false handling."""
        socat = self.socat()
        if not os.path.exists(socat):
            self.skipTest("missing "+socat)
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = testname+"_sleep"
        logfile = os_path(root, "/var/log/"+testsleep+".log")
        bindir = os_path(root, "/usr/bin")
        os.makedirs(os_path(root, "/var/run"))
        text_file(logfile, "created\n")
        shell_file(os_path(testdir, "zzz.init"), """
            #! /bin/bash
            case "$1" in start)
                ls -l  $NOTIFY_SOCKET
                {bindir}/{testsleep} 3 0<&- &>/dev/null &
                echo "$!" > {root}/var/run/zzz.init.pid
                echo "READY=1" | {socat} -v -d - UNIX-CLIENT:$NOTIFY_SOCKET
                wait %1
                # ps -o pid,ppid,args
            ;; stop)
                killall {testsleep}
            ;; esac
            echo "done$1" >&2
            exit 0
            """.format(**locals()))
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            [Service]
            Type=notify
            PIDFile={root}/var/run/zzz.init.pid
            ExecStart={root}/usr/bin/zzz.init start
            ExecStop={root}/usr/bin/zzz.init stop
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        zzz_service = "/etc/systemd/system/zzz.service".format(**locals())
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_tool(os_path(testdir, "zzz.init"), os_path(root, "/usr/bin/zzz.init"))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, zzz_service))
        #
        cmd = "{systemctl} enable zzz.service -vv"
        sh____(cmd.format(**locals()))
        #
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'start' shall start a service that is NOT is-active ")
        cmd = "{systemctl} start zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        #
        time.sleep(4)
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "failed")
        #
        logg.info("LOG\n%s", " "+reads(logfile).replace("\n", "\n "))
        self.rm_testdir()
        self.end()
    def real_3937_start_false_exec_notify(self) -> None:
        self.test_3937_start_false_exec_notify(True)
    def test_3937_start_false_exec_notify(self, real: bool = False) -> None:
        """ check that we manage notify services in a root env
            and false handling."""
        socat = self.socat()
        if not os.path.exists(socat):
            self.skipTest("missing "+socat)
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = testname+"_sleep"
        logfile = os_path(root, "/var/log/"+testsleep+".log")
        bindir = os_path(root, "/usr/bin")
        os.makedirs(os_path(root, "/var/run"))
        text_file(logfile, "created\n")
        shell_file(os_path(testdir, "zzz.init"), """
            #! /bin/bash
            case "$1" in start)
                ls -l  $NOTIFY_SOCKET
                {bindir}/{testsleep} 3 0<&- &>/dev/null &
                echo "$!" > {root}/var/run/zzz.init.pid
                echo "READY=1" | {socat} -v -d - UNIX-CLIENT:$NOTIFY_SOCKET
                wait %1
                # ps -o pid,ppid,args
            ;; stop)
                killall {testsleep}
            ;; esac
            echo "done$1" >&2
            exit 0
            """.format(**locals()))
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            [Service]
            Type=notify
            PIDFile={root}/var/run/zzz.init.pid
            ExecStart={root}/usr/bin/zzz.init start
            ExecStop={root}/usr/bin/zzz.init stop
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        zzz_service = "/etc/systemd/system/zzz.service".format(**locals())
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_tool(os_path(testdir, "zzz.init"), os_path(root, "/usr/bin/zzz.init"))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, zzz_service))
        #
        cmd = "{systemctl} enable zzz.service -vv"
        sh____(cmd.format(**locals()))
        #
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'start' shall start a service that is NOT is-active ")
        cmd = "{systemctl} start zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        #
        os.remove(os_path(root, "/var/run/zzz.init.pid"))
        time.sleep(4)
        #
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("LOG\n%s", " "+reads(logfile).replace("\n", "\n "))
        self.rm_testdir()
        self.end()
    def real_3938_start_slow_exec_notify(self) -> None:
        self.test_3938_start_slow_exec_notify(True)
    def test_3938_start_slow_exec_notify(self, real: bool = False) -> None:
        """ check that we manage notify services in a root env
            and slow handling."""
        socat = self.socat()
        if not os.path.exists(socat):
            self.skipTest("missing "+socat)
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = testname+"_sleep"
        logfile = os_path(root, "/var/log/"+testsleep+".log")
        bindir = os_path(root, "/usr/bin")
        os.makedirs(os_path(root, "/var/run"))
        text_file(logfile, "created\n")
        shell_file(os_path(testdir, "zzz.init"), """
            #! /bin/bash
            case "$1" in start)
                ls -l  $NOTIFY_SOCKET
                {bindir}/{testsleep} 13 0<&- &>/dev/null &
                PID="$!"
                sleep 1
                echo "" > {root}/var/run/zzz.init.pid
                sleep 1
                echo "$PID" > {root}/var/run/zzz.init.pid
                sleep 1
                echo "READY=1" | {socat} -v -d - UNIX-CLIENT:$NOTIFY_SOCKET
                wait %1
                # ps -o pid,ppid,args
            ;; stop)
                killall {testsleep}
            ;; esac
            echo "done$1" >&2
            exit 0
            """.format(**locals()))
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            [Service]
            Type=notify
            PIDFile={root}/var/run/zzz.init.pid
            ExecStart={root}/usr/bin/zzz.init start
            ExecStop={root}/usr/bin/zzz.init stop
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        zzz_service = "/etc/systemd/system/zzz.service".format(**locals())
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_tool(os_path(testdir, "zzz.init"), os_path(root, "/usr/bin/zzz.init"))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, zzz_service))
        #
        cmd = "{systemctl} enable zzz.service {vv}"
        sh____(cmd.format(**locals()))
        #
        cmd = "{systemctl} is-active zzz.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'start' shall start a service that is NOT is-active ")
        cmd = "{systemctl} start zzz.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        #
        os.remove(os_path(root, "/var/run/zzz.init.pid"))
        time.sleep(4)
        #
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("LOG\n%s", " "+reads(logfile).replace("\n", "\n "))
        self.rm_testdir()
        self.end()
    def real_3939_start_slowe_exec_forking(self) -> None:
        self.test_3939_start_slow_exec_forking(True)
    def test_3939_start_slow_exec_forking(self, real: bool = False) -> None:
        """ check that we manage forking services in a root env
            and slow handling."""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = testname+"_sleep"
        logfile = os_path(root, "/var/log/"+testsleep+".log")
        bindir = os_path(root, "/usr/bin")
        os.makedirs(os_path(root, "/var/run"))
        text_file(logfile, "created\n")
        shell_file(os_path(testdir, "zzz.init"), """
            #! /bin/bash
            case "$1" in start)
                ls -l  $NOTIFY_SOCKET
               ({bindir}/{testsleep} 11 0<&- &>/dev/null &
                PID="$!"
                sleep 1
                echo "" > {root}/var/run/zzz.init.pid
                sleep 1
                echo "$PID" > {root}/var/run/zzz.init.pid
                sleep 1
               ) &
                wait %1
                # ps -o pid,ppid,args
            ;; stop)
                killall {testsleep}
            ;; esac
            echo "done$1" >&2
            exit 0
            """.format(**locals()))
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            [Service]
            Type=forking
            PIDFile={root}/var/run/zzz.init.pid
            ExecStart={root}/usr/bin/zzz.init start
            ExecStop={root}/usr/bin/zzz.init stop
            StartTimeoutSec=5
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        zzz_service = "/etc/systemd/system/zzz.service".format(**locals())
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_tool(os_path(testdir, "zzz.init"), os_path(root, "/usr/bin/zzz.init"))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, zzz_service))
        #
        cmd = "{systemctl} enable zzz.service {vv}"
        sh____(cmd.format(**locals()))
        #
        cmd = "{systemctl} is-active zzz.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'start' shall start a service that is NOT is-active ")
        cmd = "{systemctl} start zzz.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        #
        time.sleep(1)
        #
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        #
        time.sleep(1)
        pid = reads(os_path(root, "/var/run/zzz.init.pid"))
        os.kill(int(pid), signal.SIGTERM)
        #
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "failed")
        #
        cmd = "{systemctl} reset-failed zzz.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("LOG\n%s", " "+reads(logfile).replace("\n", "\n "))
        self.rm_testdir()
        self.end()
    def real_3941_stop_false_exec_simple(self) -> None:
        self.test_3941_stop_false_exec_simple(True)
    def test_3941_stop_false_exec_simple(self, real: bool = False) -> None:
        """ check that a failed exec is handled"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir, real)
        logfile = os_path(root, "/var/log/test.log")
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        self.rm_testdir()
        self.rm_zzfiles(root)
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            After=foo.service
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleep} 3
            ExecStop="/bin/false"
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        sx____("{systemctl} reset-failed zzz.service".format(**locals()))
        sh____("{systemctl} daemon-reload".format(**locals()))
        #
        cmd = "{systemctl} enable zzz.service {vv}"
        sh____(cmd.format(**locals()))
        cmd = "{systemctl} is-active zzz.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== try to 'start' the service  ")
        cmd = "{systemctl} start zzz.service {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, i2(err))
        self.assertEqual(end, 0)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        #
        logg.info("== try to 'stop' the service  ")
        cmd = "{systemctl} stop zzz.service {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, i2(err))
        self.assertEqual(end, 1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        sx____("{systemctl} reset-failed zzz.service".format(**locals()))
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
        self.end()
    def real_3943_stop_false_exec_oneshot(self) -> None:
        self.test_3943_stop_false_exec_oneshot(True)
    def test_3943_stop_false_exec_oneshot(self, real: bool = False) -> None:
        """ check that a failed exec is handled"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir, real)
        logfile = os_path(root, "/var/log/test.log")
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        self.rm_testdir()
        self.rm_zzfiles(root)
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            After=foo.service
            [Service]
            Type=oneshot
            ExecStart={bindir}/{testsleep} 3
            ExecStop="/bin/false"
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        sx____("{systemctl} reset-failed zzz.service".format(**locals()))
        sh____("{systemctl} daemon-reload".format(**locals()))
        #
        cmd = "{systemctl} enable zzz.service {vv}"
        sh____(cmd.format(**locals()))
        cmd = "{systemctl} is-active zzz.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== try to 'start' the service  ")
        cmd = "{systemctl} start zzz.service {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, i2(err))
        self.assertEqual(end, 0)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        #
        logg.info("== try to 'stop' the service  ")
        cmd = "{systemctl} stop zzz.service {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, i2(err))
        self.assertEqual(end, 1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "failed")
        #
        sx____("{systemctl} reset-failed zzz.service".format(**locals()))
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
        self.end()
    def real_3944_stop_false_exec_forking(self) -> None:
        self.test_3944_stop_false_exec_forking(True)
    def test_3944_stop_false_exec_forking(self, real: bool = False) -> None:
        """ check that a failed exec is handled"""
        vv = self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir, real)
        logfile = os_path(root, "/var/log/test.log")
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        self.rm_testdir()
        self.rm_zzfiles(root)
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            After=foo.service
            [Service]
            Type=forking
            ExecStart={bindir}/{testsleep} 3
            ExecStop="/bin/false"
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        sx____("{systemctl} reset-failed zzz.service".format(**locals()))
        sh____("{systemctl} daemon-reload".format(**locals()))
        #
        cmd = "{systemctl} enable zzz.service {vv}"
        sh____(cmd.format(**locals()))
        cmd = "{systemctl} is-active zzz.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== try to 'start' the service  ")
        cmd = "{systemctl} start zzz.service {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, i2(err))
        self.assertEqual(end, 0)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        #
        logg.info("== try to 'stop' the service  ")
        cmd = "{systemctl} stop zzz.service {vv}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, i2(err))
        self.assertEqual(end, 1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "failed")
        #
        sx____("{systemctl} reset-failed zzz.service".format(**locals()))
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
        self.end()
    def test_4030_simple_service_functions_system(self) -> None:
        """ check that we manage simple services in a root env
            with commands like start, restart, stop, etc"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        self.simple_service_functions("system", testname, testdir)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4031_simple_service_functions_user(self) -> None:
        """ check that we manage simple services in a root env
            with commands like start, restart, stop, etc"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        self.simple_service_functions("user", testname, testdir)
        self.rm_testdir()
        self.coverage()
        self.end()
    def simple_service_functions(self, system: str, testname: str, testdir: str) -> None:
        """ check that we manage simple services in a root env
            with commands like start, restart, stop, etc"""
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        systemctl += " --{system}".format(**locals())
        testsleep = testname+"_testsleep"
        testscript = testname+"_testscript.sh"
        logfile = os_path(root, "/var/log/test.log")
        bindir = os_path(root, "/usr/bin")
        begin = "{"
        ends = "}"
        text_file(logfile, "")
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            [Service]
            Type=simple
            ExecStartPre=/bin/echo %n
            ExecStart={bindir}/{testscript} 111
            ExecStartPost=/bin/echo started $MAINPID
            ExecStop=/bin/kill -3 $MAINPID
            ExecStopPost=/bin/echo stopped $MAINPID
            ExecStopPost=/bin/sleep 2
            ExecReload=/bin/kill -10 $MAINPID
            KillSignal=SIGQUIT
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        shell_file(os_path(bindir, testscript), """
            #! /bin/sh
            date +%T,enter > {logfile}
            stops () {begin}
              date +%T,stopping >> {logfile}
              killall {testsleep}
              date +%T,stopped >> {logfile}
            {ends}
            reload () {begin}
              date +%T,reloading >> {logfile}
              date +%T,reloaded >> {logfile}
            {ends}
            trap "stops" 3   # SIGQUIT
            trap "reload" 10 # SIGUSR1
            date +%T,starting >> {logfile}
            {bindir}/{testsleep} $1 >> {logfile} 2>&1 &
            while kill -0 $!; do
               # use 'kill -0' to check the existance of the child
               date +%T,waiting >> {logfile}
               # use 'wait' for children AND external signals
               wait
            done
            date +%T,leaving >> {logfile}
            trap - 3 10 # SIGQUIT SIGUSR1
            date +%T,leave >> {logfile}
        """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        zzz_service = "/etc/systemd/{system}/zzz.service".format(**locals())
        copy_file(os_path(testdir, "zzz.service"), os_path(root, zzz_service))
        #
        cmd = "{systemctl} enable zzz.service -vv"
        sh____(cmd.format(**locals()))
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'start' shall start a service that is NOT is-active ")
        cmd = "{systemctl} start zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        #
        logg.info("== 'stop' shall stop a service that is-active")
        cmd = "{systemctl} stop zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        # inspect the service's log
        log = lines(open(logfile))
        logg.info("LOG\n %s", "\n ".join(log))
        self.assertTrue(greps(log, "enter"))
        self.assertTrue(greps(log, "leave"))
        self.assertTrue(greps(log, "starting"))
        self.assertTrue(greps(log, "stopped"))
        self.assertFalse(greps(log, "reload"))
        os.remove(logfile)
        #
        logg.info("== 'restart' shall start a service that NOT is-active")
        cmd = "{systemctl} restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top1= top
        #
        # inspect the service's log
        log = lines(open(logfile))
        logg.info("LOG\n %s", "\n ".join(log))
        self.assertTrue(greps(log, "enter"))
        self.assertFalse(greps(log, "leave"))
        self.assertTrue(greps(log, "starting"))
        self.assertFalse(greps(log, "stopped"))
        self.assertFalse(greps(log, "reload"))
        os.remove(logfile)
        #
        logg.info("== 'restart' shall restart a service that is-active")
        cmd = "{systemctl} restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top2 = top
        #
        logg.info("-- and we check that there is a new PID for the service process")
        def find_pids(ps_output: Union[str, List[str]], command: str) -> List[str]:
            pids = []
            for line in _lines(ps_output):
                if command not in line: continue
                m = re.match(r"\s*[\d:]*\s+(\S+)\s+(\S+)\s+(.*)", line)
                if not m: continue
                pid, ppid, args = m.groups()
                # logg.info("  %s | %s | %s", pid, ppid, args)
                pids.append(pid)
            return pids
        ps1 = find_pids(top1, testsleep)
        ps2 = find_pids(top2, testsleep)
        logg.info("found PIDs %s and %s", ps1, ps2)
        self.assertTrue(len(ps1), 1)
        self.assertTrue(len(ps2), 1)
        self.assertNotEqual(ps1[0], ps2[0])
        #
        # inspect the service's log
        log = lines(open(logfile))
        logg.info("LOG\n %s", "\n ".join(log))
        self.assertTrue(greps(log, "enter"))
        self.assertTrue(greps(log, "starting"))
        self.assertFalse(greps(log, "reload"))
        os.remove(logfile)
        #
        #
        logg.info("== 'reload' will NOT restart a service that is-active")
        cmd = "{systemctl} reload zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top3 = top
        #
        logg.info("-- and we check that there is NO new PID for the service process")
        ps3 = find_pids(top3, testsleep)
        logg.info("found PIDs %s and %s", ps2, ps3)
        self.assertTrue(len(ps2), 1)
        self.assertTrue(len(ps3), 1)
        self.assertEqual(ps2[0], ps3[0])
        #
        # inspect the service's log
        log = lines(open(logfile))
        logg.info("LOG\n %s", "\n ".join(log))
        self.assertFalse(greps(log, "enter"))
        self.assertFalse(greps(log, "leave"))
        self.assertFalse(greps(log, "starting"))
        self.assertFalse(greps(log, "stopped"))
        self.assertTrue(greps(log, "reload"))
        os.remove(logfile)
        #
        logg.info("== 'reload-or-restart' will restart a service that is-active (if ExecReload)")
        cmd = "{systemctl} reload-or-restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top4 = top
        #
        logg.info("-- and we check that there is NO new PID for the service process (if ExecReload)")
        ps4 = find_pids(top4, testsleep)
        logg.info("found PIDs %s and %s", ps3, ps4)
        self.assertTrue(len(ps3), 1)
        self.assertTrue(len(ps4), 1)
        self.assertEqual(ps3[0], ps4[0])
        #
        logg.info("== 'kill' will bring is-active non-active as well (when the PID is known)")
        cmd = "{systemctl} kill zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'stop' will turn 'failed' to 'inactive' (when the PID is known)")
        cmd = "{systemctl} stop zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertNotEqual(end, 0) # no PID known so 'kill $MAINPID' fails
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'reload-or-try-restart' will not start a not-active service")
        cmd = "{systemctl} reload-or-try-restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'try-restart' will not start a not-active service")
        cmd = "{systemctl} try-restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'reload-or-restart' will start a not-active service")
        cmd = "{systemctl} reload-or-restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top5 = top
        #
        logg.info("== 'reload-or-try-restart' will NOT restart an is-active service (with ExecReload)")
        cmd = "{systemctl} reload-or-try-restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top6 = top
        #
        logg.info("-- and we check that there is NO new PID for the service process (if ExecReload)")
        ps5 = find_pids(top5, testsleep)
        ps6 = find_pids(top6, testsleep)
        logg.info("found PIDs %s and %s", ps5, ps6)
        self.assertTrue(len(ps5), 1)
        self.assertTrue(len(ps6), 1)
        self.assertEqual(ps5[0], ps6[0])
        #
        logg.info("== 'try-restart' will restart an is-active service")
        cmd = "{systemctl} try-restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top7 = top
        #
        logg.info("-- and we check that there is a new PID for the service process")
        ps7 = find_pids(top7, testsleep)
        logg.info("found PIDs %s and %s", ps6, ps7)
        self.assertTrue(len(ps6), 1)
        self.assertTrue(len(ps7), 1)
        self.assertNotEqual(ps6[0], ps7[0])

        #
        # cleanup
        kill_testsleep = "{systemctl} __killall {testsleep}"
        sx____(kill_testsleep.format(**locals()))
        time.sleep(1)
    def test_4032_forking_service_functions_system(self) -> None:
        """ check that we manage forking services in a root env
            with basic run-service commands: start, stop, restart,
            reload, try-restart, reload-or-restart, kill and
            reload-or-try-restart."""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        self.forking_service_functions("system", testname, testdir)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4033_forking_service_functions_user(self) -> None:
        """ check that we manage forking services in a root env
            with basic run-service commands: start, stop, restart,
            reload, try-restart, reload-or-restart, kill and
            reload-or-try-restart."""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        self.forking_service_functions("user", testname, testdir)
        self.rm_testdir()
        self.coverage()
        self.end()
    def forking_service_functions(self, system: str, testname: str, testdir: str) -> None:
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        systemctl += " --{system}".format(**locals())
        testsleep = testname+"_sleep"
        logfile = os_path(root, "/var/log/"+testsleep+".log")
        bindir = os_path(root, "/usr/bin")
        os.makedirs(os_path(root, "/var/run"))
        text_file(logfile, "created\n")
        begin = "{"
        ends = "}"
        shell_file(os_path(testdir, "zzz.init"), """
            #! /bin/bash
            logfile={logfile}
            start() {begin}
               [ -d /var/run ] || mkdir -p /var/run
               ({bindir}/{testsleep} 111 0<&- &>/dev/null &
                echo $! > {root}/var/run/zzz.init.pid
               ) &
               wait %1
               # ps -o pid,ppid,args
            {ends}
            stop() {begin}
               killall {testsleep}
            {ends}
            case "$1" in start)
               date "+START.%T" >> $logfile
               start >> $logfile 2>&1
               date "+start.%T" >> $logfile
            ;; stop)
               date "+STOP.%T" >> $logfile
               stop >> $logfile 2>&1
               date "+stop.%T" >> $logfile
            ;; restart)
               date "+RESTART.%T" >> $logfile
               stop >> $logfile 2>&1
               start >> $logfile 2>&1
               date "+.%T" >> $logfile
            ;; reload)
               date "+RELOAD.%T" >> $logfile
               echo "...." >> $logfile 2>&1
               date "+reload.%T" >> $logfile
            ;; esac
            echo "done$1" >&2
            exit 0
            """.format(**locals()))
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            [Service]
            Type=forking
            PIDFile={root}/var/run/zzz.init.pid
            ExecStart={root}/usr/bin/zzz.init start
            ExecStop={root}/usr/bin/zzz.init stop
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        zzz_service = "/etc/systemd/{system}/zzz.service".format(**locals())
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_tool(os_path(testdir, "zzz.init"), os_path(root, "/usr/bin/zzz.init"))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, zzz_service))
        #
        cmd = "{systemctl} enable zzz.service -vv"
        sh____(cmd.format(**locals()))
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'start' shall start a service that is NOT is-active ")
        cmd = "{systemctl} start zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        #
        logg.info("== 'stop' shall stop a service that is-active")
        cmd = "{systemctl} stop zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'restart' shall start a service that NOT is-active")
        cmd = "{systemctl} restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top1= top
        #
        logg.info("== 'restart' shall restart a service that is-active")
        cmd = "{systemctl} restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top2 = top
        #
        logg.info("-- and we check that there is a new PID for the service process")
        def find_pids(ps_output: Union[str, List[str]], command: str) -> List[str]:
            pids = []
            for line in _lines(ps_output):
                if command not in line: continue
                m = re.match(r"\s*[\d:]*\s+(\S+)\s+(\S+)\s+(.*)", line)
                if not m: continue
                pid, ppid, args = m.groups()
                # logg.info("  %s | %s | %s", pid, ppid, args)
                pids.append(pid)
            return pids
        ps1 = find_pids(top1, testsleep)
        ps2 = find_pids(top2, testsleep)
        logg.info("found PIDs %s and %s", ps1, ps2)
        self.assertTrue(len(ps1), 1)
        self.assertTrue(len(ps2), 1)
        self.assertNotEqual(ps1[0], ps2[0])
        #
        logg.info("== 'reload' will NOT restart a service that is-active")
        cmd = "{systemctl} reload zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top3 = top
        #
        logg.info("-- and we check that there is NO new PID for the service process")
        ps3 = find_pids(top3, testsleep)
        logg.info("found PIDs %s and %s", ps2, ps3)
        self.assertTrue(len(ps2), 1)
        self.assertTrue(len(ps3), 1)
        self.assertEqual(ps2[0], ps3[0])
        #
        logg.info("== 'reload-or-restart' will restart a service that is-active (if no ExecReload)")
        cmd = "{systemctl} reload-or-restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top4 = top
        #
        logg.info("-- and we check that there is a new PID for the service process (if no ExecReload)")
        ps4 = find_pids(top4, testsleep)
        logg.info("found PIDs %s and %s", ps3, ps4)
        self.assertTrue(len(ps3), 1)
        self.assertTrue(len(ps4), 1)
        self.assertNotEqual(ps3[0], ps4[0])
        #
        logg.info("== 'kill' will bring is-active non-active as well (when the PID is known)")
        cmd = "{systemctl} kill zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "failed")
        #
        logg.info("== 'stop' will turn 'failed' to 'inactive' (when the PID is known)")
        cmd = "{systemctl} stop zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'reload-or-try-restart' will not start a not-active service")
        cmd = "{systemctl} reload-or-try-restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'try-restart' will not start a not-active service")
        cmd = "{systemctl} try-restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'reload-or-restart' will start a not-active service")
        cmd = "{systemctl} reload-or-restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top5 = top
        #
        logg.info("== 'reload-or-try-restart' will restart an is-active service (with no ExecReload)")
        cmd = "{systemctl} try-restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top6 = top
        #
        logg.info("-- and we check that there is a new PID for the service process (if no ExecReload)")
        ps5 = find_pids(top5, testsleep)
        ps6 = find_pids(top6, testsleep)
        logg.info("found PIDs %s and %s", ps5, ps6)
        self.assertTrue(len(ps5), 1)
        self.assertTrue(len(ps6), 1)
        self.assertNotEqual(ps5[0], ps6[0])
        #
        logg.info("== 'try-restart' will restart an is-active service")
        cmd = "{systemctl} try-restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top7 = top
        #
        logg.info("-- and we check that there is a new PID for the service process")
        ps7 = find_pids(top7, testsleep)
        logg.info("found PIDs %s and %s", ps6, ps7)
        self.assertTrue(len(ps6), 1)
        self.assertTrue(len(ps7), 1)
        self.assertNotEqual(ps6[0], ps7[0])
        #
        logg.info("LOG\n%s", " "+reads(logfile).replace("\n", "\n "))
    def test_4034_notify_service_functions_system(self) -> None:
        """ check that we manage notify services in a root env
            with basic run-service commands: start, stop, restart,
            reload, try-restart, reload-or-restart, kill and
            reload-or-try-restart."""
        self.begin()
        socat = self.socat()
        if not os.path.exists(socat):
            self.skipTest("missing "+socat)
        testname = self.testname()
        testdir = self.testdir()
        self.notify_service_functions("system", testname, testdir)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4035_notify_service_functions_user(self) -> None:
        """ check that we manage notify services in a root env
            with basic run-service commands: start, stop, restart,
            reload, try-restart, reload-or-restart, kill and
            reload-or-try-restart."""
        self.begin()
        socat = self.socat()
        if not os.path.exists(socat):
            self.skipTest("missing "+socat)
        testname = self.testname()
        testdir = self.testdir()
        self.notify_service_functions("user", testname, testdir)
        self.rm_testdir()
        self.coverage()
        self.end()
    def notify_service_functions(self, system: str, testname: str, testdir: str) -> None:
        socat = self.socat()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        systemctl += " --{system}".format(**locals())
        testsleep = testname+"_sleep"
        logfile = os_path(root, "/var/log/"+testsleep+".log")
        bindir = os_path(root, "/usr/bin")
        os.makedirs(os_path(root, "/var/run"))
        text_file(logfile, "created\n")
        begin = "{"
        ends = "}"
        shell_file(os_path(testdir, "zzz.init"), """
            #! /bin/bash
            logfile={logfile}
            start() {begin}
                ls -l  $NOTIFY_SOCKET
                {bindir}/{testsleep} 111 0<&- &>/dev/null &
                echo "MAINPID=$!" | {socat} -v -d - UNIX-CLIENT:$NOTIFY_SOCKET
                echo "READY=1" | {socat} -v -d - UNIX-CLIENT:$NOTIFY_SOCKET
                wait %1
                # ps -o pid,ppid,args
            {ends}
            stop() {begin}
                killall {testsleep}
            {ends}
            case "$1" in start)
               date "+START.%T" >> $logfile
               start >> $logfile 2>&1
               date "+start.%T" >> $logfile
            ;; stop)
               date "+STOP.%T" >> $logfile
               stop >> $logfile 2>&1
               date "+stop.%T" >> $logfile
            ;; restart)
               date "+RESTART.%T" >> $logfile
               stop >> $logfile 2>&1
               start >> $logfile 2>&1
               date "+.%T" >> $logfile
            ;; reload)
               date "+RELOAD.%T" >> $logfile
               echo "...." >> $logfile 2>&1
               date "+reload.%T" >> $logfile
            ;; esac
            echo "done$1" >&2
            exit 0
            """.format(**locals()))
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            [Service]
            Type=notify
            # PIDFile={root}/var/run/zzz.init.pid
            ExecStart={root}/usr/bin/zzz.init start
            ExecStop={root}/usr/bin/zzz.init stop
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        zzz_service = "/etc/systemd/{system}/zzz.service".format(**locals())
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_tool(os_path(testdir, "zzz.init"), os_path(root, "/usr/bin/zzz.init"))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, zzz_service))
        #
        cmd = "{systemctl} enable zzz.service -vv"
        sh____(cmd.format(**locals()))
        #
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'start' shall start a service that is NOT is-active ")
        cmd = "{systemctl} start zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        #
        logg.info("== 'stop' shall stop a service that is-active")
        cmd = "{systemctl} stop zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'restart' shall start a service that NOT is-active")
        cmd = "{systemctl} restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top1= top
        #
        logg.info("== 'restart' shall restart a service that is-active")
        cmd = "{systemctl} restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top2 = top
        #
        logg.info("-- and we check that there is a new PID for the service process")
        def find_pids(ps_output: Union[str, List[str]], command: str) -> List[str]:
            pids = []
            for line in _lines(ps_output):
                if command not in line: continue
                m = re.match(r"\s*[\d:]*\s+(\S+)\s+(\S+)\s+(.*)", line)
                if not m: continue
                pid, ppid, args = m.groups()
                # logg.info("  %s | %s | %s", pid, ppid, args)
                pids.append(pid)
            return pids
        ps1 = find_pids(top1, testsleep)
        ps2 = find_pids(top2, testsleep)
        logg.info("found PIDs %s and %s", ps1, ps2)
        self.assertTrue(len(ps1), 1)
        self.assertTrue(len(ps2), 1)
        self.assertNotEqual(ps1[0], ps2[0])
        #
        logg.info("== 'reload' will NOT restart a service that is-active")
        cmd = "{systemctl} reload zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top3 = top
        #
        logg.info("-- and we check that there is NO new PID for the service process")
        ps3 = find_pids(top3, testsleep)
        logg.info("found PIDs %s and %s", ps2, ps3)
        self.assertTrue(len(ps2), 1)
        self.assertTrue(len(ps3), 1)
        self.assertEqual(ps2[0], ps3[0])
        #
        logg.info("== 'reload-or-restart' will restart a service that is-active (if no ExecReload)")
        cmd = "{systemctl} reload-or-restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top4 = top
        #
        logg.info("-- and we check that there is a new PID for the service process (if no ExecReload)")
        ps4 = find_pids(top4, testsleep)
        logg.info("found PIDs %s and %s", ps3, ps4)
        self.assertTrue(len(ps3), 1)
        self.assertTrue(len(ps4), 1)
        self.assertNotEqual(ps3[0], ps4[0])
        #
        logg.info("== 'kill' will bring is-active non-active as well (when the PID is known)")
        cmd = "{systemctl} kill zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'stop' will turn 'failed' to 'inactive' (when the PID is known)")
        cmd = "{systemctl} stop zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'reload-or-try-restart' will not start a not-active service")
        cmd = "{systemctl} reload-or-try-restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'try-restart' will not start a not-active service")
        cmd = "{systemctl} try-restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'reload-or-restart' will start a not-active service")
        cmd = "{systemctl} reload-or-restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top5 = top
        #
        logg.info("== 'reload-or-try-restart' will restart an is-active service (with no ExecReload)")
        cmd = "{systemctl} try-restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top6 = top
        #
        logg.info("-- and we check that there is a new PID for the service process (if no ExecReload)")
        ps5 = find_pids(top5, testsleep)
        ps6 = find_pids(top6, testsleep)
        logg.info("found PIDs %s and %s", ps5, ps6)
        self.assertTrue(len(ps5), 1)
        self.assertTrue(len(ps6), 1)
        self.assertNotEqual(ps5[0], ps6[0])
        #
        logg.info("== 'try-restart' will restart an is-active service")
        cmd = "{systemctl} try-restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top7 = top
        #
        logg.info("-- and we check that there is a new PID for the service process")
        ps7 = find_pids(top7, testsleep)
        logg.info("found PIDs %s and %s", ps6, ps7)
        self.assertTrue(len(ps6), 1)
        self.assertTrue(len(ps7), 1)
        self.assertNotEqual(ps6[0], ps7[0])
        #
        logg.info("LOG\n%s", " "+reads(logfile).replace("\n", "\n "))
    def test_4036_notify_service_functions_with_reload(self) -> None:
        """ check that we manage notify services in a root env
            with basic run-service commands: start, stop, restart,
            reload, try-restart, reload-or-restart, kill and
            reload-or-try-restart. (with ExecReload)"""
        self.begin()
        socat = self.socat()
        if not os.path.exists(socat):
            self.skipTest("missing "+socat)
        testname = self.testname()
        testdir = self.testdir()
        self.notify_service_functions_with_reload("system", testname, testdir)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4037_notify_service_functions_with_reload_user(self) -> None:
        """ check that we manage notify services in a root env
            with basic run-service commands: start, stop, restart,
            reload, try-restart, reload-or-restart, kill and
            reload-or-try-restart. (with ExecReload)"""
        # test_4037 is triggering len(socketfile) > 100 | "new notify socketfile"
        self.begin()
        socat = self.socat()
        if not os.path.exists(socat):
            self.skipTest("missing "+socat)
        testname = self.testname()
        testdir = self.testdir()
        self.notify_service_functions_with_reload("user", testname, testdir)
        self.rm_testdir()
        self.coverage()
        self.end()
    def notify_service_functions_with_reload(self, system: str, testname: str, testdir: str) -> None:
        socat = self.socat()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        systemctl += " --{system}".format(**locals())
        testsleep = self.testname("sleep")
        logfile = os_path(root, "/var/log/"+testsleep+".log")
        bindir = os_path(root, "/usr/bin")
        os.makedirs(os_path(root, "/var/run"))
        text_file(logfile, "created\n")
        begin = "{"
        ends = "}"
        shell_file(os_path(testdir, "zzz.init"), """
            #! /bin/bash
            logfile={logfile}
            start() {begin}
                ls -l  $NOTIFY_SOCKET
                {bindir}/{testsleep} 111 0<&- &>/dev/null &
                echo "MAINPID=$!" | {socat} -v -d - UNIX-CLIENT:$NOTIFY_SOCKET
                echo "READY=1" | {socat} -v -d - UNIX-CLIENT:$NOTIFY_SOCKET
                wait %1
                # ps -o pid,ppid,args
            {ends}
            stop() {begin}
                killall {testsleep}
            {ends}
            case "$1" in start)
               date "+START.%T" >> $logfile
               start >> $logfile 2>&1
               date "+start.%T" >> $logfile
            ;; stop)
               date "+STOP.%T" >> $logfile
               stop >> $logfile 2>&1
               date "+stop.%T" >> $logfile
            ;; restart)
               date "+RESTART.%T" >> $logfile
               stop >> $logfile 2>&1
               start >> $logfile 2>&1
               date "+.%T" >> $logfile
            ;; reload)
               date "+RELOAD.%T" >> $logfile
               echo "...." >> $logfile 2>&1
               date "+reload.%T" >> $logfile
            ;; esac
            echo "done$1" >&2
            exit 0
            """.format(**locals()))
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            [Service]
            Type=notify
            # PIDFile={root}/var/run/zzz.init.pid
            ExecStart={root}/usr/bin/zzz.init start
            ExecReload={root}/usr/bin/zzz.init reload
            ExecStop={root}/usr/bin/zzz.init stop
            TimeoutRestartSec=4
            TimeoutReloadSec=4
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        zzz_service = "/etc/systemd/{system}/zzz.service".format(**locals())
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_tool(os_path(testdir, "zzz.init"), os_path(root, "/usr/bin/zzz.init"))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, zzz_service))
        #
        cmd = "{systemctl} enable zzz.service -vv"
        sh____(cmd.format(**locals()))
        #
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'start' shall start a service that is NOT is-active ")
        cmd = "{systemctl} start zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        #
        logg.info("== 'stop' shall stop a service that is-active")
        cmd = "{systemctl} stop zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'restart' shall start a service that NOT is-active")
        cmd = "{systemctl} restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top1= top
        #
        logg.info("== 'restart' shall restart a service that is-active")
        cmd = "{systemctl} restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top2 = top
        #
        logg.info("-- and we check that there is a new PID for the service process")
        def find_pids(ps_output: Union[str, List[str]], command: str) -> List[str]:
            pids = []
            for line in _lines(ps_output):
                if command not in line: continue
                m = re.match(r"\s*[\d:]*\s+(\S+)\s+(\S+)\s+(.*)", line)
                if not m: continue
                pid, ppid, args = m.groups()
                # logg.info("  %s | %s | %s", pid, ppid, args)
                pids.append(pid)
            return pids
        ps1 = find_pids(top1, testsleep)
        ps2 = find_pids(top2, testsleep)
        logg.info("found PIDs %s and %s", ps1, ps2)
        self.assertTrue(len(ps1), 1)
        self.assertTrue(len(ps2), 1)
        self.assertNotEqual(ps1[0], ps2[0])
        #
        logg.info("== 'reload' will NOT restart a service that is-active")
        cmd = "{systemctl} reload zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top3 = top
        #
        logg.info("-- and we check that there is NO new PID for the service process")
        ps3 = find_pids(top3, testsleep)
        logg.info("found PIDs %s and %s", ps2, ps3)
        self.assertTrue(len(ps2), 1)
        self.assertTrue(len(ps3), 1)
        self.assertEqual(ps2[0], ps3[0])
        #
        logg.info("== 'reload-or-restart' will restart a service that is-active (if no ExecReload)")
        cmd = "{systemctl} reload-or-restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top4 = top
        #
        logg.info("-- and we check that there is the same PID for the service process (if ExecReload)")
        ps4 = find_pids(top4, testsleep)
        logg.info("found PIDs %s and %s", ps3, ps4)
        self.assertTrue(len(ps3), 1)
        self.assertTrue(len(ps4), 1)
        self.assertEqual(ps3[0], ps4[0])
        #
        logg.info("== 'kill' will bring is-active non-active as well (when the PID is known)")
        cmd = "{systemctl} kill zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'stop' will turn 'failed' to 'inactive' (when the PID is known)")  # TODO#
        cmd = "{systemctl} stop zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'reload-or-try-restart' will not start a not-active service")
        cmd = "{systemctl} reload-or-try-restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'try-restart' will not start a not-active service")
        cmd = "{systemctl} try-restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'reload-or-restart' will start a not-active service")
        cmd = "{systemctl} reload-or-restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top5 = top
        #
        logg.info("== 'reload-or-try-restart' will restart an is-active service (with no ExecReload)")
        cmd = "{systemctl} try-restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top6 = top
        #
        logg.info("-- and we check that there is a new PID for the service process (if no ExecReload)")
        ps5 = find_pids(top5, testsleep)
        ps6 = find_pids(top6, testsleep)
        logg.info("found PIDs %s and %s", ps5, ps6)
        self.assertTrue(len(ps5), 1)
        self.assertTrue(len(ps6), 1)
        self.assertNotEqual(ps5[0], ps6[0])
        #
        logg.info("== 'try-restart' will restart an is-active service")
        cmd = "{systemctl} try-restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top7 = top
        #
        logg.info("-- and we check that there is a new PID for the service process")
        ps7 = find_pids(top7, testsleep)
        logg.info("found PIDs %s and %s", ps6, ps7)
        self.assertTrue(len(ps6), 1)
        self.assertTrue(len(ps7), 1)
        self.assertNotEqual(ps6[0], ps7[0])
        #
        logg.info("LOG\n%s", " "+reads(logfile).replace("\n", "\n "))
    def test_4038_notify_service_functions_with_failed(self) -> None:
        """ check that we manage notify services in a root env
            with basic run-service commands: start, stop, restart,
            reload, try-restart, reload-or-restart, kill and
            reload-or-try-restart. (with ExecReload)"""
        self.begin()
        socat = self.socat()
        if not os.path.exists(socat):
            self.skipTest("missing "+socat)
        testname = self.testname()
        testdir = self.testdir()
        self.notify_service_functions_with_failed("system", testname, testdir)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4039_notify_service_functions_with_failed(self) -> None:
        """ check that we manage notify services in a root env
            with basic run-service commands: start, stop, restart,
            reload, try-restart, reload-or-restart, kill and
            reload-or-try-restart. (with ExecReload)"""
        # test_4037 is triggering len(socketfile) > 100 | "new notify socketfile"
        self.begin()
        socat = self.socat()
        if not os.path.exists(socat):
            self.skipTest("missing "+socat)
        testname = self.testname()
        testdir = self.testdir()
        self.notify_service_functions_with_failed("user", testname, testdir)
        self.rm_testdir()
        self.coverage()
        self.end()
    def notify_service_functions_with_failed(self, system: str, testname: str, testdir: str) -> None:
        socat = self.socat()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        systemctl += " --{system}".format(**locals())
        testsleep = self.testname("sleep")
        logfile = os_path(root, "/var/log/"+testsleep+".log")
        bindir = os_path(root, "/usr/bin")
        os.makedirs(os_path(root, "/var/run"))
        text_file(logfile, "created\n")
        begin = "{"
        ends = "}"
        shell_file(os_path(testdir, "zzz.init"), """
            #! /bin/bash
            logfile={logfile}
            start() {begin}
                ls -l  $NOTIFY_SOCKET
                {bindir}/{testsleep} 4 0<&- &>/dev/null &
                echo "MAINPID=$!" | {socat} -v -d - UNIX-CLIENT:$NOTIFY_SOCKET
                echo "READY=1" | {socat} -v -d - UNIX-CLIENT:$NOTIFY_SOCKET
                wait %1
                # ps -o pid,ppid,args
            {ends}
            stop() {begin}
                killall {testsleep}
            {ends}
            case "$1" in start)
               date "+START.%T" >> $logfile
               start >> $logfile 2>&1
               date "+start.%T" >> $logfile
            ;; stop)
               date "+STOP.%T" >> $logfile
               stop >> $logfile 2>&1
               date "+stop.%T" >> $logfile
            ;; restart)
               date "+RESTART.%T" >> $logfile
               stop >> $logfile 2>&1
               start >> $logfile 2>&1
               date "+.%T" >> $logfile
            ;; reload)
               date "+RELOAD.%T" >> $logfile
               echo "...." >> $logfile 2>&1
               date "+reload.%T" >> $logfile
            ;; esac
            echo "done$1" >&2
            exit 0
            """.format(**locals()))
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            [Service]
            Type=notify
            # PIDFile={root}/var/run/zzz.init.pid
            ExecStart={root}/usr/bin/zzz.init start
            ExecReload={root}/usr/bin/zzz.init reload
            ExecStop={root}/usr/bin/zzz.init stop
            TimeoutRestartSec=4
            TimeoutReloadSec=4
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        zzz_service = "/etc/systemd/{system}/zzz.service".format(**locals())
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_tool(os_path(testdir, "zzz.init"), os_path(root, "/usr/bin/zzz.init"))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, zzz_service))
        #
        cmd = "{systemctl} enable zzz.service -vv"
        sh____(cmd.format(**locals()))
        #
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'start' shall start a service that is NOT is-active ")
        cmd = "{systemctl} start zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        #
        time.sleep(5) # -> "failed"
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "failed")
        #
        logg.info("== 'stop' shall stop a service that is-active")
        cmd = "{systemctl} stop zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("LOG\n%s", " "+reads(logfile).replace("\n", "\n "))
    def test_4040_oneshot_service_functions(self) -> None:
        """ check that we manage oneshot services in a root env
            with basic run-service commands: start, stop, restart,
            reload, try-restart, reload-or-restart, kill and
            reload-or-try-restart."""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        self.oneshot_service_functions("system", testname, testdir)
        self.rm_testdir()
        self.end()
    def test_4041_oneshot_service_functions_user(self) -> None:
        """ check that we manage oneshot services in a root env
            with basic run-service commands: start, stop, restart,
            reload, try-restart, reload-or-restart, kill and
            reload-or-try-restart."""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        self.oneshot_service_functions("user", testname, testdir)
        self.rm_testdir()
        self.end()
    def oneshot_service_functions(self, system: str, testname: str, testdir: str) -> None:
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        systemctl += " --{system}".format(**locals())
        testsleep = self.testname("sleep")
        logfile = os_path(root, "/var/log/"+testsleep+".log")
        bindir = os_path(root, "/usr/bin")
        os.makedirs(os_path(root, "/var/run"))
        text_file(logfile, "created\n")
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            [Service]
            Type=oneshot
            ExecStartPre={bindir}/backup {root}/var/tmp/test.1 {root}/var/tmp/test.2
            ExecStart=/usr/bin/touch {root}/var/tmp/test.1
            ExecStop=/bin/rm {root}/var/tmp/test.1
            ExecStopPost=/bin/rm -f {root}/var/tmp/test.2
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        shell_file(os_path(testdir, "backup"), """
           #! /bin/sh
           set -x
           test ! -f "$1" || mv -v "$1" "$2"
        """)
        zzz_service = "/etc/systemd/{system}/zzz.service".format(**locals())
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, zzz_service))
        copy_tool(os_path(testdir, "backup"), os_path(root, "/usr/bin/backup"))
        text_file(os_path(root, "/var/tmp/test.0"), """..""")
        #
        cmd = "{systemctl} enable zzz.service -vv"
        sh____(cmd.format(**locals()))
        #
        is_active = "{systemctl} is-active zzz.service -vv"
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "inactive")
        self.assertEqual(end, 3)
        #
        logg.info("== 'start' shall start a service that is NOT is-active ")
        cmd = "{systemctl} start zzz.service -vvvv"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "active")
        self.assertEqual(end, 0)
        self.assertTrue(os.path.exists(os_path(root, "/var/tmp/test.1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.2")))
        #
        logg.info("== 'stop' shall stop a service that is-active")
        cmd = "{systemctl} stop zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "inactive")
        self.assertEqual(end, 3)
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.2")))
        #
        logg.info("== 'restart' shall start a service that NOT is-active")
        cmd = "{systemctl} restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "active")
        self.assertEqual(end, 0)
        self.assertTrue(os.path.exists(os_path(root, "/var/tmp/test.1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.2")))
        #
        logg.info("== 'restart' shall restart a service that is-active")
        cmd = "{systemctl} restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "active")
        self.assertEqual(end, 0)
        self.assertTrue(os.path.exists(os_path(root, "/var/tmp/test.1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.2")))
        #
        logg.info("== 'reload' will NOT restart a service that is-active")
        cmd = "{systemctl} reload zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "active")
        self.assertEqual(end, 0)
        self.assertTrue(os.path.exists(os_path(root, "/var/tmp/test.1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.2")))
        #
        logg.info("== 'reload-or-restart' will restart a service that is-active")
        cmd = "{systemctl} reload-or-restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "active")
        self.assertEqual(end, 0)
        #
        logg.info("== 'stop' will brings it back to 'inactive'")
        cmd = "{systemctl} stop zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "inactive")
        self.assertEqual(end, 3)
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.2")))
        #
        logg.info("== 'reload-or-try-restart' will not start a not-active service")
        cmd = "{systemctl} reload-or-try-restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "inactive")
        self.assertEqual(end, 3)
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.2")))
        #
        logg.info("== 'try-restart' will not start a not-active service")
        cmd = "{systemctl} try-restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "inactive")
        self.assertEqual(end, 3)
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.2")))
        #
        logg.info("== 'reload-or-restart' will start a not-active service")
        cmd = "{systemctl} reload-or-restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "active")
        self.assertEqual(end, 0)
        self.assertTrue(os.path.exists(os_path(root, "/var/tmp/test.1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.2")))
        #
        logg.info("== 'reload-or-try-restart' will restart an is-active service")
        cmd = "{systemctl} reload-or-try-restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "active")
        self.assertEqual(end, 0)
        self.assertTrue(os.path.exists(os_path(root, "/var/tmp/test.1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.2")))
        #
        logg.info("== 'try-restart' will restart an is-active service")
        cmd = "{systemctl} try-restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "active")
        self.assertEqual(end, 0)
        self.assertTrue(os.path.exists(os_path(root, "/var/tmp/test.1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.2")))
        #
        logg.info("== 'stop' will brings it back to 'inactive'")
        cmd = "{systemctl} stop zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "inactive")
        self.assertEqual(end, 3)
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.2")))
        #
        logg.info("LOG\n%s", " "+reads(logfile).replace("\n", "\n "))
    def test_4042_oneshot_and_unknown_service_functions(self) -> None:
        """ check that we manage multiple services even when some
            services are not actually known. Along with oneshot serivce
            with basic run-service commands: start, stop, restart,
            reload, try-restart, reload-or-restart, kill and
            reload-or-try-restart / we have only different exit-code."""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        logfile = os_path(root, "/var/log/"+testsleep+".log")
        bindir = os_path(root, "/usr/bin")
        os.makedirs(os_path(root, "/var/run"))
        text_file(logfile, "created\n")
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            [Service]
            Type=oneshot
            ExecStartPre={bindir}/backup {root}/var/tmp/test.1 {root}/var/tmp/test.2
            ExecStart=/usr/bin/touch {root}/var/tmp/test.1
            ExecStop=/bin/rm {root}/var/tmp/test.1
            ExecStopPost=/bin/rm -f {root}/var/tmp/test.2
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        shell_file(os_path(testdir, "backup"), """
           #! /bin/sh
           set -x
           test ! -f "$1" || mv -v "$1" "$2"
        """)
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        copy_tool(os_path(testdir, "backup"), os_path(root, "/usr/bin/backup"))
        text_file(os_path(root, "/var/tmp/test.0"), """..""")
        #
        cmd = "{systemctl} enable zzz.service -vv"
        sh____(cmd.format(**locals()))
        is_active = "{systemctl} is-active zzz.service other.service -vv"
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "inactive\ninactive")
        self.assertEqual(end, 3)
        #
        logg.info("== 'start' shall start a service that is NOT is-active ")
        cmd = "{systemctl} start zzz.service other.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertNotEqual(end, 0)
        is_active = "{systemctl} is-active zzz.service other.service -vv"
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "active\ninactive")
        self.assertEqual(end, 3)
        self.assertTrue(os.path.exists(os_path(root, "/var/tmp/test.1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.2")))
        #
        logg.info("== 'stop' shall stop a service that is-active")
        cmd = "{systemctl} stop zzz.service other.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertNotEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "inactive\ninactive")
        self.assertEqual(end, 3)
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.2")))
        #
        logg.info("== 'restart' shall start a service that NOT is-active")
        cmd = "{systemctl} restart zzz.service other.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertNotEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "active\ninactive")
        self.assertEqual(end, 3)
        self.assertTrue(os.path.exists(os_path(root, "/var/tmp/test.1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.2")))
        #
        logg.info("== 'restart' shall restart a service that is-active")
        cmd = "{systemctl} restart zzz.service other.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertNotEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "active\ninactive")
        self.assertEqual(end, 3)
        self.assertTrue(os.path.exists(os_path(root, "/var/tmp/test.1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.2")))
        #
        logg.info("== 'reload' will NOT restart a service that is-active")
        cmd = "{systemctl} reload zzz.service other.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertNotEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "active\ninactive")
        self.assertEqual(end, 3)
        self.assertTrue(os.path.exists(os_path(root, "/var/tmp/test.1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.2")))
        #
        logg.info("== 'reload-or-restart' will restart a service that is-active")
        cmd = "{systemctl} reload-or-restart zzz.service other.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertNotEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "active\ninactive")
        self.assertEqual(end, 3)
        #
        logg.info("== 'stop' will brings it back to 'inactive'")
        cmd = "{systemctl} stop zzz.service other.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertNotEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "inactive\ninactive")
        self.assertEqual(end, 3)
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.2")))
        #
        logg.info("== 'reload-or-try-restart' will not start a not-active service")
        cmd = "{systemctl} reload-or-try-restart zzz.service other.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertNotEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "inactive\ninactive")
        self.assertEqual(end, 3)
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.2")))
        #
        logg.info("== 'try-restart' will not start a not-active service")
        cmd = "{systemctl} try-restart zzz.service other.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertNotEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "inactive\ninactive")
        self.assertEqual(end, 3)
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.2")))
        #
        logg.info("== 'reload-or-restart' will start a not-active service")
        cmd = "{systemctl} reload-or-restart zzz.service other.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertNotEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "active\ninactive")
        self.assertEqual(end, 3)
        self.assertTrue(os.path.exists(os_path(root, "/var/tmp/test.1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.2")))
        #
        logg.info("== 'reload-or-try-restart' will restart an is-active service")
        cmd = "{systemctl} reload-or-try-restart zzz.service other.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertNotEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "active\ninactive")
        self.assertEqual(end, 3)
        self.assertTrue(os.path.exists(os_path(root, "/var/tmp/test.1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.2")))
        #
        logg.info("== 'try-restart' will restart an is-active service")
        cmd = "{systemctl} try-restart zzz.service other.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertNotEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "active\ninactive")
        self.assertEqual(end, 3)
        self.assertTrue(os.path.exists(os_path(root, "/var/tmp/test.1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.2")))
        #
        logg.info("== 'stop' will brings it back to 'inactive'")
        cmd = "{systemctl} stop zzz.service other.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertNotEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "inactive\ninactive")
        self.assertEqual(end, 3)
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.2")))
        #
        logg.info("LOG\n%s", " "+reads(logfile).replace("\n", "\n "))
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4043_oneshot_template_service_functions(self) -> None:
        """ check that we manage oneshot template services in a root env
            with basic run-service commands: start, stop, restart,
            reload, try-restart, reload-or-restart, kill and
            reload-or-try-restart."""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        self.oneshot_template_service_functions("system", testname, testdir)
        self.rm_testdir()
        self.end()
    def test_4044_oneshot_template_service_functions_user(self) -> None:
        """ check that we manage oneshot template services in a root env
            with basic run-service commands: start, stop, restart,
            reload, try-restart, reload-or-restart, kill and
            reload-or-try-restart."""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        self.oneshot_template_service_functions("user", testname, testdir)
        self.rm_testdir()
        self.end()
    def oneshot_template_service_functions(self, system: str, testname: str, testdir: str) -> None:
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        systemctl += " --{system}".format(**locals())
        testsleep = self.testname("sleep")
        logfile = os_path(root, "/var/log/"+testsleep+".log")
        bindir = os_path(root, "/usr/bin")
        os.makedirs(os_path(root, "/var/run"))
        text_file(logfile, "created\n")
        text_file(os_path(testdir, "zzz@.service"), """
            [Unit]
            Description=Testing Z.%i
            [Service]
            Type=oneshot
            ExecStartPre={bindir}/backup {root}/var/tmp/test.%i.1 {root}/var/tmp/test.%i.2
            ExecStart=/usr/bin/touch {root}/var/tmp/test.%i.1
            ExecStop=/bin/rm {root}/var/tmp/test.%i.1
            ExecStopPost=/bin/rm -f {root}/var/tmp/test.%i.2
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        shell_file(os_path(testdir, "backup"), """
           #! /bin/sh
           set -x
           test ! -f "$1" || mv -v "$1" "$2"
        """)
        zzz_service = "/etc/systemd/{system}/zzz@.service".format(**locals())
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzz@.service"), os_path(root, zzz_service))
        copy_tool(os_path(testdir, "backup"), os_path(root, "/usr/bin/backup"))
        text_file(os_path(root, "/var/tmp/test.0"), """..""")
        #
        cmd = "{systemctl} enable zzz@rsa.service -vv"
        sh____(cmd.format(**locals()))
        #
        is_active = "{systemctl} is-active zzz@rsa.service -vv"
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "inactive")
        self.assertEqual(end, 3)
        #
        logg.info("== 'start' shall start a service that is NOT is-active ")
        cmd = "{systemctl} start zzz@rsa.service -vvvv"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "active")
        self.assertEqual(end, 0)
        self.assertTrue(os.path.exists(os_path(root, "/var/tmp/test.rsa.1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.rsa.2")))
        #
        logg.info("== 'stop' shall stop a service that is-active")
        cmd = "{systemctl} stop zzz@rsa.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "inactive")
        self.assertEqual(end, 3)
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.rsa.1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.rsa.2")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test..1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test..2")))
        #
        logg.info("== 'restart' shall start a service that NOT is-active")
        cmd = "{systemctl} restart zzz@rsa.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "active")
        self.assertEqual(end, 0)
        self.assertTrue(os.path.exists(os_path(root, "/var/tmp/test.rsa.1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.rsa.2")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test..1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test..2")))
        #
        logg.info("== 'restart' shall restart a service that is-active")
        cmd = "{systemctl} restart zzz@rsa.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "active")
        self.assertEqual(end, 0)
        self.assertTrue(os.path.exists(os_path(root, "/var/tmp/test.rsa.1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.rsa.2")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test..1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test..2")))
        #
        logg.info("== 'reload' will NOT restart a service that is-active")
        cmd = "{systemctl} reload zzz@rsa.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "active")
        self.assertEqual(end, 0)
        self.assertTrue(os.path.exists(os_path(root, "/var/tmp/test.rsa.1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.rsa.2")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test..1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test..2")))
        #
        logg.info("== 'reload-or-restart' will restart a service that is-active")
        cmd = "{systemctl} reload-or-restart zzz@rsa.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "active")
        self.assertEqual(end, 0)
        #
        logg.info("== 'stop' will brings it back to 'inactive'")
        cmd = "{systemctl} stop zzz@rsa.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "inactive")
        self.assertEqual(end, 3)
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.rsa.1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.rsa.2")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test..1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test..2")))
        #
        logg.info("== 'reload-or-try-restart' will not start a not-active service")
        cmd = "{systemctl} reload-or-try-restart zzz@rsa.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "inactive")
        self.assertEqual(end, 3)
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.rsa.1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.rsa.2")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test..1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test..2")))
        #
        logg.info("== 'try-restart' will not start a not-active service")
        cmd = "{systemctl} try-restart zzz@rsa.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "inactive")
        self.assertEqual(end, 3)
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.rsa.1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.rsa.2")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test..1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test..2")))
        #
        logg.info("== 'reload-or-restart' will start a not-active service")
        cmd = "{systemctl} reload-or-restart zzz@rsa.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "active")
        self.assertEqual(end, 0)
        self.assertTrue(os.path.exists(os_path(root, "/var/tmp/test.rsa.1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.rsa.2")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test..1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test..2")))
        #
        logg.info("== 'reload-or-try-restart' will restart an is-active service")
        cmd = "{systemctl} reload-or-try-restart zzz@rsa.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "active")
        self.assertEqual(end, 0)
        self.assertTrue(os.path.exists(os_path(root, "/var/tmp/test.rsa.1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.rsa.2")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test..1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test..2")))
        #
        logg.info("== 'try-restart' will restart an is-active service")
        cmd = "{systemctl} try-restart zzz@rsa.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "active")
        self.assertEqual(end, 0)
        self.assertTrue(os.path.exists(os_path(root, "/var/tmp/test.rsa.1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.rsa.2")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test..1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test..2")))
        #
        logg.info("== 'stop' will brings it back to 'inactive'")
        cmd = "{systemctl} stop zzz@rsa.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "inactive")
        self.assertEqual(end, 3)
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.rsa.1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.rsa.2")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test..1")))
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test..2")))
        #
        logg.info("LOG\n%s", " "+reads(logfile).replace("\n", "\n "))
    def test_4045_sysv_service_functions(self) -> None:
        """ check that we manage SysV services in a root env
            with basic run-service commands: start, stop, restart,
            reload, try-restart, reload-or-restart, kill and
            reload-or-try-restart."""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        logfile = os_path(root, "/var/log/"+testsleep+".log")
        bindir = os_path(root, "/usr/bin")
        os.makedirs(os_path(root, "/var/run"))
        text_file(logfile, "created\n")
        begin = "{"
        ends = "}"
        shell_file(os_path(testdir, "zzz.init"), """
            #! /bin/bash
            ### BEGIN INIT INFO
            # Required-Start: $local_fs $remote_fs $syslog $network
            # Required-Stop:  $local_fs $remote_fs $syslog $network
            # Default-Start:  3 5
            # Default-Stop:   0 1 2 6
            # Short-Description: Testing Z
            # Description:    Allows for SysV testing
            ### END INIT INFO
            logfile={logfile}
            sleeptime=111
            start() {begin}
               [ -d /var/run ] || mkdir -p /var/run
               ({bindir}/{testsleep} $sleeptime 0<&- &>/dev/null &
                echo $! > {root}/var/run/zzz.init.pid
               ) &
               wait %1
               # ps -o pid,ppid,args
               cat "RUNNING `cat {root}/var/run/zzz.init.pid`"
            {ends}
            stop() {begin}
               killall {testsleep}
            {ends}
            case "$1" in start)
               date "+START.%T" >> $logfile
               start >> $logfile 2>&1
               date "+start.%T" >> $logfile
            ;; stop)
               date "+STOP.%T" >> $logfile
               stop >> $logfile 2>&1
               date "+stop.%T" >> $logfile
            ;; restart)
               date "+RESTART.%T" >> $logfile
               stop >> $logfile 2>&1
               start >> $logfile 2>&1
               date "+.%T" >> $logfile
            ;; reload)
               date "+RELOAD.%T" >> $logfile
               echo "...." >> $logfile 2>&1
               date "+reload.%T" >> $logfile
            ;; esac
            echo "done$1" >&2
            exit 0
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_tool(os_path(testdir, "zzz.init"), os_path(root, "/etc/init.d/zzz"))
        #
        cmd = "{systemctl} enable zzz.service -vv"
        sh____(cmd.format(**locals()))
        #
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'start' shall start a service that is NOT is-active ")
        cmd = "{systemctl} start zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        #
        logg.info("== 'stop' shall stop a service that is-active")
        cmd = "{systemctl} stop zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'restart' shall start a service that NOT is-active")
        cmd = "{systemctl} restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top1= top
        #
        logg.info("== 'restart' shall restart a service that is-active")
        cmd = "{systemctl} restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top2 = top
        #
        logg.info("-- and we check that there is a new PID for the service process")
        def find_pids(ps_output: Union[str, List[str]], command: str) -> List[str]:
            pids = []
            for line in _lines(ps_output):
                if command not in line: continue
                m = re.match(r"\s*[\d:]*\s+(\S+)\s+(\S+)\s+(.*)", line)
                if not m: continue
                pid, ppid, args = m.groups()
                # logg.info("  %s | %s | %s", pid, ppid, args)
                pids.append(pid)
            return pids
        ps1 = find_pids(top1, testsleep)
        ps2 = find_pids(top2, testsleep)
        logg.info("found PIDs %s and %s", ps1, ps2)
        self.assertTrue(len(ps1), 1)
        self.assertTrue(len(ps2), 1)
        self.assertNotEqual(ps1[0], ps2[0])
        #
        logg.info("== 'reload' will NOT restart a service that is-active")
        cmd = "{systemctl} reload zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top3 = top
        #
        logg.info("-- and we check that there is NO new PID for the service process")
        ps3 = find_pids(top3, testsleep)
        logg.info("found PIDs %s and %s", ps2, ps3)
        self.assertTrue(len(ps2), 1)
        self.assertTrue(len(ps3), 1)
        self.assertEqual(ps2[0], ps3[0])
        #
        logg.info("== 'reload-or-restart' may restart a service that is-active")
        cmd = "{systemctl} reload-or-restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        #
        logg.info("== 'stop' will turn 'failed' to 'inactive' (when the PID is known)")
        cmd = "{systemctl} stop zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'reload-or-try-restart' will start a not-active service")
        cmd = "{systemctl} reload-or-try-restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        #
        cmd = "{systemctl} stop zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        #
        logg.info("== 'try-restart' will not start a not-active service")
        cmd = "{systemctl} try-restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'reload-or-restart' will start a not-active service")
        cmd = "{systemctl} reload-or-restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top5 = top
        #
        logg.info("== 'reload-or-try-restart' will restart an is-active service (with no ExecReload)")
        cmd = "{systemctl} reload-or-try-restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top6 = top
        #
        logg.info("== 'try-restart' will restart an is-active service")
        cmd = "{systemctl} try-restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top7 = top
        #
        logg.info("-- and we check that there is a new PID for the service process")
        ps6 = find_pids(top6, testsleep)
        ps7 = find_pids(top7, testsleep)
        logg.info("found PIDs %s and %s", ps6, ps7)
        self.assertTrue(len(ps6), 1)
        self.assertTrue(len(ps7), 1)
        self.assertNotEqual(ps6[0], ps7[0])
        #
        logg.info("LOG\n%s", " "+reads(logfile).replace("\n", "\n "))
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4046_sysv_service_extras(self) -> None:
        """ check that we manage SysV services in a root env"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        logfile = os_path(root, "/var/log/"+testsleep+".log")
        bindir = os_path(root, "/usr/bin")
        os.makedirs(os_path(root, "/var/run"))
        text_file(logfile, "created\n")
        begin = "{"
        ends = "}"
        shell_file(os_path(testdir, "zzz.init"), """
            #! /bin/bash
            ### BEGIN INIT INFO
            # Required-Start: $local_fs $remote_fs $syslog $network
            # Required-Stop:  $local_fs $remote_fs $syslog $network
            # Default-Start:  3 5
            # Default-Stop:   0 1 2 6
            # Short-Description: Testing Z
            # Description:    Allows for SysV testing
            ### END INIT INFO
            logfile={logfile}
            sleeptime=111
            start() {begin}
               [ -d /var/run ] || mkdir -p /var/run
               ({bindir}/{testsleep} $sleeptime 0<&- &>/dev/null &
                echo $! > {root}/var/run/zzz.init.pid
               ) &
               wait %1
               # ps -o pid,ppid,args
               cat "RUNNING `cat {root}/var/run/zzz.init.pid`"
            {ends}
            stop() {begin}
               killall {testsleep}
            {ends}
            case "$1" in start)
               date "+START.%T" >> $logfile
               start >> $logfile 2>&1
               date "+start.%T" >> $logfile
            ;; stop)
               date "+STOP.%T" >> $logfile
               stop >> $logfile 2>&1
               date "+stop.%T" >> $logfile
            ;; restart)
               date "+RESTART.%T" >> $logfile
               stop >> $logfile 2>&1
               start >> $logfile 2>&1
               date "+.%T" >> $logfile
            ;; reload)
               date "+RELOAD.%T" >> $logfile
               echo "...." >> $logfile 2>&1
               date "+reload.%T" >> $logfile
            ;; esac
            echo "done$1" >&2
            exit 0
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_tool(os_path(testdir, "zzz.init"), os_path(root, "/etc/init.d/zzz"))
        #
        cmd = "{systemctl} enable zzz.service -vv"
        sh____(cmd.format(**locals()))
        #
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        #
        logg.info("== 'reload' will not start a not-active service")
        cmd = "{systemctl} reload zzz.service -vv -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        #
        logg.info("== 'start' will not start a not-active service")
        cmd = "{systemctl} start zzz.service -vv -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        #
        logg.info("== 'reload' will not start a not-active service")
        cmd = "{systemctl} reload zzz.service -vv -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top5 = top
        #
        logg.info("LOG\n%s", " "+reads(logfile).replace("\n", "\n "))
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4047_sysv_service_extras(self) -> None:
        """ check that we manage SysV services in a root env"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        logfile = os_path(root, "/var/log/"+testsleep+".log")
        bindir = os_path(root, "/usr/bin")
        os.makedirs(os_path(root, "/var/run"))
        text_file(logfile, "created\n")
        begin = "{"
        ends = "}"
        shell_file(os_path(testdir, "zzz.init"), """
            #! /bin/bash
            ### BEGIN INIT INFO
            # Required-Start: $local_fs $remote_fs $syslog $network
            # Required-Stop:  $local_fs $remote_fs $syslog $network
            # Default-Start:  3 5
            # Default-Stop:   0 1 2 6
            # Short-Description: Testing Z
            # Description:    Allows for SysV testing
            ### END INIT INFO
            logfile={logfile}
            sleeptime=111
            start() {begin}
               [ -d /var/run ] || mkdir -p /var/run
               ({bindir}/{testsleep} $sleeptime 0<&- &>/dev/null &
                echo $! > {root}/var/run/zzz.init.pid
               ) &
               wait %1
               # ps -o pid,ppid,args
               cat "RUNNING `cat {root}/var/run/zzz.init.pid`"
            {ends}
            stop() {begin}
               killall {testsleep}
            {ends}
            case "$1" in start)
               date "+START.%T" >> $logfile
               start >> $logfile 2>&1
               date "+start.%T" >> $logfile
            ;; stop)
               date "+STOP.%T" >> $logfile
               stop >> $logfile 2>&1
               date "+stop.%T" >> $logfile
            ;; restart)
               date "+RESTART.%T" >> $logfile
               stop >> $logfile 2>&1
               start >> $logfile 2>&1
               date "+.%T" >> $logfile
            ;; reload)
               date "+RELOAD.%T" >> $logfile
               echo "...." >> $logfile 2>&1
               date "+reload.%T" >> $logfile
               exit 1
            ;; esac
            echo "done$1" >&2
            exit 0
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_tool(os_path(testdir, "zzz.init"), os_path(root, "/etc/init.d/zzz"))
        #
        cmd = "{systemctl} enable zzz.service -vv"
        sh____(cmd.format(**locals()))
        #
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        #
        logg.info("== 'reload' will not start a not-active service")
        cmd = "{systemctl} reload zzz.service -vv -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        #
        logg.info("== 'reload-or-restart' will not start a not-active service")
        cmd = "{systemctl} reload-or-restart zzz.service -vv -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        #
        logg.info("== 'reload' will not start a not-active service")
        cmd = "{systemctl} reload zzz.service -vv -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "failed")
        top5 = top
        #
        logg.info("LOG\n%s", " "+reads(logfile).replace("\n", "\n "))
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4050_notify_service_functions_with_long_servicename(self) -> None:
        """ check that we manage notify services in a root env
            with a very long servicename (limiting the socket name)"""
        self.begin()
        socat = self.socat()
        if not os.path.exists(socat):
            self.skipTest("missing "+socat)
        testname = self.testname()
        testdir = self.testdir()
        self.notify_service_functions_with_long_servicename("system", testname, testdir)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4051_notify_service_functions_with_long_servicename(self) -> None:
        """ check that we manage notify services in a root env
            with a very long servicename (limiting the socket name)"""
        # test_4037 is also triggering len(socketfile) > 100 | "new notify socketfile"
        self.begin()
        socat = self.socat()
        if not os.path.exists(socat):
            self.skipTest("missing "+socat)
        testname = self.testname()
        testdir = self.testdir()
        self.notify_service_functions_with_long_servicename("user", testname, testdir)
        self.rm_testdir()
        self.coverage()
        self.end()
    def notify_service_functions_with_long_servicename(self, system: str, testname: str, testdir: str) -> None:
        socat = self.socat()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        systemctl += " --{system}".format(**locals())
        testsleep = self.testname("sleep")
        logfile = os_path(root, "/var/log/"+testsleep+".log")
        bindir = os_path(root, "/usr/bin")
        os.makedirs(os_path(root, "/var/run"))
        text_file(logfile, "created\n")
        begin = "{"
        ends = "}"
        shell_file(os_path(testdir, "zzz.init"), """
            #! /bin/bash
            logfile={logfile}
            start() {begin}
                ls -l  $NOTIFY_SOCKET
                {bindir}/{testsleep} 4 0<&- &>/dev/null &
                echo "MAINPID=$!" | {socat} -v -d - UNIX-CLIENT:$NOTIFY_SOCKET
                echo "READY=1" | {socat} -v -d - UNIX-CLIENT:$NOTIFY_SOCKET
                wait %1
                # ps -o pid,ppid,args
            {ends}
            stop() {begin}
                killall {testsleep}
            {ends}
            case "$1" in start)
               date "+START.%T" >> $logfile
               start >> $logfile 2>&1
               date "+start.%T" >> $logfile
            ;; stop)
               date "+STOP.%T" >> $logfile
               stop >> $logfile 2>&1
               date "+stop.%T" >> $logfile
            ;; restart)
               date "+RESTART.%T" >> $logfile
               stop >> $logfile 2>&1
               start >> $logfile 2>&1
               date "+.%T" >> $logfile
            ;; reload)
               date "+RELOAD.%T" >> $logfile
               echo "...." >> $logfile 2>&1
               date "+reload.%T" >> $logfile
            ;; esac
            echo "done$1" >&2
            exit 0
            """.format(**locals()))
        zzz_service = "zzz-using-a-very-long-service-name-which-needs-to-be-truncated-for-the-notify-socket-file.service"
        text_file(os_path(testdir, zzz_service), """
            [Unit]
            Description=Testing Z
            [Service]
            Type=notify
            # PIDFile={root}/var/run/zzz.init.pid
            ExecStart={root}/usr/bin/zzz.init start
            ExecReload={root}/usr/bin/zzz.init reload
            ExecStop={root}/usr/bin/zzz.init stop
            TimeoutRestartSec=4
            TimeoutReloadSec=4
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        zzz_service_path = "/etc/systemd/{system}/{zzz_service}".format(**locals())
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_tool(os_path(testdir, "zzz.init"), os_path(root, "/usr/bin/zzz.init"))
        copy_file(os_path(testdir, zzz_service), os_path(root, zzz_service_path))
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG, system not in ["user"]))
        text_file(debug_log, "")
        logg.info("debug.log = %s", debug_log)
        #
        cmd = "{systemctl} enable {zzz_service} -vv"
        sh____(cmd.format(**locals()))
        #
        cmd = "{systemctl} is-active {zzz_service} -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'start' shall start a service that is NOT is-active ")
        cmd = "{systemctl} start {zzz_service} -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        log = reads(debug_log)
        logg.info("debug.log>>%s", i2(log))
        self.assertTrue(greps(log, "old notify socketfile [(]\\d\\d\\d[)]"))
        self.assertTrue(greps(log, "new notify socketfile [(]\\d\\d[)]"))
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = "{systemctl} is-active {zzz_service} -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        #
        time.sleep(5) # -> "failed"
        cmd = "{systemctl} is-active {zzz_service} -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "failed")
        #
        logg.info("== 'stop' shall stop a service that is-active")
        cmd = "{systemctl} stop {zzz_service} -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = "{systemctl} is-active {zzz_service} -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("LOG\n%s", " "+reads(logfile).replace("\n", "\n "))
    def test_4052_notify_service_functions_with_other_notify_dir(self) -> None:
        """ check that we manage notify services in a root env
            with a very long servicename (limiting the socket name)"""
        self.begin()
        socat = self.socat()
        if not os.path.exists(socat):
            self.skipTest("missing "+socat)
        testname = self.testname()
        testdir = self.testdir()
        self.notify_service_functions_with_other_notify_dir("system", testname, testdir)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4053_notify_service_functions_with_other_notify_dir(self) -> None:
        """ check that we manage notify services in a root env
            with a very long servicename (limiting the socket name)"""
        # test_4037 is also triggering len(socketfile) > 100 | "new notify socketfile"
        self.begin()
        socat = self.socat()
        if not os.path.exists(socat):
            self.skipTest("missing "+socat)
        testname = self.testname()
        testdir = self.testdir()
        self.notify_service_functions_with_other_notify_dir("user", testname, testdir)
        self.rm_testdir()
        self.coverage()
        self.end()
    def notify_service_functions_with_other_notify_dir(self, system: str, testname: str, testdir: str) -> None:
        socat = self.socat()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        systemctl += " --{system}".format(**locals())
        systemctl += " -c _notify_socket_folder=/var/run-using-notify-special-folder"
        testsleep = self.testname("sleep")
        logfile = os_path(root, "/var/log/"+testsleep+".log")
        bindir = os_path(root, "/usr/bin")
        os.makedirs(os_path(root, "/var/run"))
        text_file(logfile, "created\n")
        begin = "{"
        ends = "}"
        shell_file(os_path(testdir, "zzz.init"), """
            #! /bin/bash
            logfile={logfile}
            start() {begin}
                ls -l  $NOTIFY_SOCKET
                {bindir}/{testsleep} 4 0<&- &>/dev/null &
                echo "MAINPID=$!" | {socat} -v -d - UNIX-CLIENT:$NOTIFY_SOCKET
                echo "READY=1" | {socat} -v -d - UNIX-CLIENT:$NOTIFY_SOCKET
                wait %1
                # ps -o pid,ppid,args
            {ends}
            stop() {begin}
                killall {testsleep}
            {ends}
            case "$1" in start)
               date "+START.%T" >> $logfile
               start >> $logfile 2>&1
               date "+start.%T" >> $logfile
            ;; stop)
               date "+STOP.%T" >> $logfile
               stop >> $logfile 2>&1
               date "+stop.%T" >> $logfile
            ;; restart)
               date "+RESTART.%T" >> $logfile
               stop >> $logfile 2>&1
               start >> $logfile 2>&1
               date "+.%T" >> $logfile
            ;; reload)
               date "+RELOAD.%T" >> $logfile
               echo "...." >> $logfile 2>&1
               date "+reload.%T" >> $logfile
            ;; esac
            echo "done$1" >&2
            exit 0
            """.format(**locals()))
        zzz_service = "zzz-using-a-very-long-service-name-which-needs-to-be-truncated-for-the-notify-socket-file.service"
        text_file(os_path(testdir, zzz_service), """
            [Unit]
            Description=Testing Z
            [Service]
            Type=notify
            # PIDFile={root}/var/run/zzz.init.pid
            ExecStart={root}/usr/bin/zzz.init start
            ExecReload={root}/usr/bin/zzz.init reload
            ExecStop={root}/usr/bin/zzz.init stop
            TimeoutRestartSec=4
            TimeoutReloadSec=4
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        zzz_service_path = "/etc/systemd/{system}/{zzz_service}".format(**locals())
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_tool(os_path(testdir, "zzz.init"), os_path(root, "/usr/bin/zzz.init"))
        copy_file(os_path(testdir, zzz_service), os_path(root, zzz_service_path))
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG, system not in ["user"]))
        text_file(debug_log, "")
        logg.info("debug.log = %s", debug_log)
        #
        cmd = "{systemctl} enable {zzz_service} -vv"
        sh____(cmd.format(**locals()))
        #
        cmd = "{systemctl} is-active {zzz_service} -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'start' shall start a service that is NOT is-active ")
        cmd = "{systemctl} start {zzz_service} -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        log = reads(debug_log)
        logg.info("debug.log>>%s", i2(log))
        self.assertTrue(greps(log, "old notify socketfile [(]\\d\\d\\d[)]"))
        self.assertTrue(greps(log, "new notify socketfile [(]\\d\\d[)].*special-folder"))
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = "{systemctl} is-active {zzz_service} -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        #
        time.sleep(5) # -> "failed"
        cmd = "{systemctl} is-active {zzz_service} -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "failed")
        #
        logg.info("== 'stop' shall stop a service that is-active")
        cmd = "{systemctl} stop {zzz_service} -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = "{systemctl} is-active {zzz_service} -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("LOG\n%s", " "+reads(logfile).replace("\n", "\n "))

    def test_4060_forking_service_failed_functions(self) -> None:
        """ check that we manage forking services in a root env
            with basic run-service commands: start, stop, restart,
            checking the executions when some part fails."""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        quick = QUICK
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        logfile = os_path(root, "/var/log/"+testsleep+".log")
        bindir = os_path(root, "/usr/bin")
        fail = os_path(root, "/tmp/fail")
        os.makedirs(os_path(root, "/var/run"))
        text_file(logfile, "created\n")
        begin = "{"
        ends = "}"
        shell_file(os_path(testdir, "zzz.init"), """
            #! /bin/bash
            logfile={logfile}
            start() {begin}
               [ -d /var/run ] || mkdir -p /var/run
               ({bindir}/{testsleep} 111 0<&- &>/dev/null &
                echo $! > {root}/var/run/zzz.init.pid
               ) &
               wait %1
               # ps -o pid,ppid,args
            {ends}
            stop() {begin}
               killall {testsleep}
            {ends}
            echo "run-$1" >> $logfile
            if test -f {fail}$1; then
               echo "fail-$1" >> $logfile
               exit 1
            fi
            case "$1"
            in start)
               echo "START-IT" >> $logfile
               start >> $logfile 2>&1
               echo "started" >> $logfile
            ;; stop)
               echo "STOP-IT" >> $logfile
               stop >> $logfile 2>&1
               echo "stopped" >> $logfile
            ;; restart)
               echo "RESTART-IT" >> $logfile
               stop >> $logfile 2>&1
               start >> $logfile 2>&1
               echo "restarted" >> $logfile
            ;; reload)
               echo "RELOAD-IT" >> $logfile
               echo "...." >> $logfile 2>&1
               echo "reloaded" >> $logfile
            ;; start-pre)
               echo "START-PRE" >> $logfile
            ;; start-post)
               echo "START-POST" >> $logfile
            ;; stop-post)
               echo "STOP-POST" >> $logfile
            ;; esac
            echo "done$1" >&2
            if test -f {fail}after$1; then
               echo "fail-after-$1" >> $logfile
               exit 1
            fi
            exit 0
            """.format(**locals()))
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            [Service]
            Type=forking
            PIDFile={root}/var/run/zzz.init.pid
            ExecStartPre={root}/usr/bin/zzz.init start-pre
            ExecStart={root}/usr/bin/zzz.init start
            ExecStartPost={root}/usr/bin/zzz.init start-post
            ExecStop={root}/usr/bin/zzz.init stop
            ExecStopPost={root}/usr/bin/zzz.init stop-post
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_tool(os_path(testdir, "zzz.init"), os_path(root, "/usr/bin/zzz.init"))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        #
        cmd = "{systemctl} enable zzz.service -vv"
        sh____(cmd.format(**locals()))
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        log = lines(open(logfile))
        logg.info("LOG\n %s", "\n ".join(log))
        os.remove(logfile)
        self.assertEqual(log, ["created"])
        #
        logg.info("== 'start' shall start a service that is NOT is-active ")
        cmd = "{systemctl} start zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        #
        log = lines(open(logfile))
        logg.info("LOG\n %s", "\n ".join(log))
        os.remove(logfile)
        self.assertEqual(log, [
            "run-start-pre", "START-PRE",
            "run-start", "START-IT", "started",
            "run-start-post", "START-POST"])
        #
        logg.info("== 'stop' shall stop a service that is-active")
        cmd = "{systemctl} stop zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        log = lines(open(logfile))
        logg.info("LOG\n %s", "\n ".join(log))
        os.remove(logfile)
        self.assertEqual(log, [
            "run-stop", "STOP-IT", "stopped",
            "run-stop-post", "STOP-POST"])
        #
        text_file(fail+"start", "")
        #
        logg.info("== 'start' returns to stopped if the main call fails ")
        cmd = "{systemctl} start zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertNotEqual(end, 0)
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertNotEqual(end, 0)
        self.assertEqual(out.strip(), "inactive")
        #
        log = lines(open(logfile))
        logg.info("LOG\n %s", "\n ".join(log))
        os.remove(logfile)
        self.assertEqual(log, [
            "run-start-pre", "START-PRE",
            "run-start", "fail-start",
            "run-stop-post", "STOP-POST"])
        #
        logg.info("== 'stop' on stopped service does not do much ")
        cmd = "{systemctl} stop zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertNotEqual(end, 0)
        self.assertEqual(out.strip(), "inactive")
        #
        log = lines(open(logfile))
        logg.info("LOG\n %s", "\n ".join(log))
        os.remove(logfile)
        self.assertEqual(log[:2], [
            "run-stop", "STOP-IT"])
        self.assertEqual(log[-2:], [
            "run-stop-post", "STOP-POST"])
        #
        logg.info("== 'restart' on a stopped item remains stopped if the main call fails ")
        cmd = "{systemctl} restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertNotEqual(end, 0)
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertNotEqual(end, 0)
        self.assertEqual(out.strip(), "inactive")
        #
        log = lines(open(logfile))
        logg.info("LOG\n %s", "\n ".join(log))
        os.remove(logfile)
        self.assertEqual(log, [
            "run-start-pre", "START-PRE",
            "run-start", "fail-start",
            "run-stop-post", "STOP-POST"])
        #
        os.remove(fail+"start")
        text_file(fail+"stop", "")
        #
        logg.info("== 'start' that service ")
        cmd = "{systemctl} start zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        logg.info("== 'stop' may have a failed item ")
        cmd = "{systemctl} stop zzz.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertNotEqual(end, 0)
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        # 'active' because the PIDFile process was not killed
        #
        log = lines(open(logfile))
        logg.info("LOG\n %s", "\n ".join(log))
        os.remove(logfile)
        self.assertEqual(log, [
            "run-start-pre", "START-PRE",
            "run-start", "START-IT", "started",
            "run-start-post", "START-POST",
            "run-stop", "fail-stop"])
        #
        os.remove(fail+"stop")
        text_file(fail+"afterstop", "")
        #
        logg.info("== 'start' that service ")
        cmd = "{systemctl} start zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        logg.info("== 'stop' may have a failed item ")
        cmd = "{systemctl} stop zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertNotEqual(end, 0)
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertNotEqual(end, 0)
        self.assertEqual(out.strip(), "inactive")
        #
        log = lines(open(logfile))
        logg.info("LOG\n %s", "\n ".join(log))
        os.remove(logfile)
        self.assertEqual(log, [
            "run-start-pre", "START-PRE",
            "run-start", "START-IT", "started",
            "run-start-post", "START-POST",
            "run-stop", "STOP-IT", "stopped", "fail-after-stop",
            "run-stop-post", "STOP-POST"])
        #
        os.remove(fail+"afterstop")
        text_file(fail+"afterstart", "")
        #
        logg.info("== 'start' shall start a service that is NOT is-active ")
        cmd = "{systemctl} start zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        cmd = "{systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "failed")
        #
        log = lines(open(logfile))
        logg.info("LOG\n %s", "\n ".join(log))
        os.remove(logfile)
        self.assertEqual(log, [
            "run-start-pre", "START-PRE",
            "run-start", "START-IT", "started", "fail-after-start",
            "run-stop-post", "STOP-POST"])
        #
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4070_oneshot_truncate_old_status(self) -> None:
        """ check that we manage a service that has some old .status
            file being around. That is a reboot has occurred and the
            information is not relevant to the current system state."""
        self.begin()
        self.rm_testdir()
        vv = "-vv"
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        logfile = os_path(root, "/var/log/"+testsleep+".log")
        bindir = os_path(root, "/usr/bin")
        os.makedirs(os_path(root, "/var/run"))
        text_file(logfile, "created\n")
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            [Service]
            Type=oneshot
            ExecStart=/usr/bin/touch {root}/var/tmp/test.1
            ExecStopPost=/bin/rm {root}/var/tmp/test.1
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        text_file(os_path(root, "/var/tmp/test.0"), """..""")
        #
        getpid_boot_time = get_proc_started(os.getpid())
        system_boot_time = datetime.datetime.fromtimestamp(getpid_boot_time - 1)
        systemctl += " -c BOOT_PID_MIN=%s -c DEBUG_BOOTTIME" % (os.getpid())
        #
        cmd = "{systemctl} enable zzz.service -vv"
        sh____(cmd.format(**locals()))
        is_active = "{systemctl} is-active zzz.service other.service {vv}"
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "inactive\ninactive")
        self.assertEqual(end, 3)
        #
        logg.info("== 'start' shall start a service that is NOT is-active ")
        cmd = "{systemctl} start zzz.service other.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertNotEqual(end, 0)
        is_active = "{systemctl} is-active zzz.service other.service -vv"
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "active\ninactive")
        self.assertEqual(end, 3)
        self.assertTrue(os.path.exists(os_path(root, "/var/tmp/test.1")))
        #
        is_active = "{systemctl} is-active zzz.service other.service -vvvv"
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "active\ninactive")
        self.assertEqual(end, 3)
        #
        logg.info("== 'stop' shall stop a service that is-active")
        cmd = "{systemctl} stop zzz.service other.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertNotEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "inactive\ninactive")
        self.assertEqual(end, 3)
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.1")))
        #
        logg.info("== 'restart' shall start a service that NOT is-active\n")
        cmd = "{systemctl} restart zzz.service other.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertNotEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "active\ninactive")
        self.assertEqual(end, 3)
        self.assertTrue(os.path.exists(os_path(root, "/var/tmp/test.1")))
        #
        logg.info("== mark the status file as being too old")
        # status_file = os_path(root, "/run/zzz.service.status")
        cmd = "{systemctl} -p StatusFile show zzz.service"
        status_file = output(cmd.format(**locals())).split("=", 1)[1].strip()
        logg.info("status_file = %s", status_file)
        self.assertTrue(os.path.exists(status_file))
        sh____("LANG=C stat {status_file} | grep Modify:".format(**locals()))
        sh____("touch -d '{system_boot_time}' {status_file}".format(**locals()))
        sh____("LANG=C stat {status_file} | grep Modify:".format(**locals()))
        #
        logg.info("== the next is-active shall then truncate it")
        old_size = os.path.getsize(status_file)
        is_activeXX = "{systemctl} is-active zzz.service other.service {vv} {vv}"
        act, end = output2(is_activeXX.format(**locals()))
        self.assertEqual(act.strip(), "inactive\ninactive")
        self.assertEqual(end, 3)
        self.assertTrue(os.path.exists(os_path(root, "/var/tmp/test.1")))
        new_size = os.path.getsize(status_file)
        logg.info("status-file size: old %s new %s", old_size, new_size)
        self.assertGreater(old_size, 0)
        self.assertEqual(new_size, 0)
        #
        logg.info("== 'stop' shall cleanup a service that was not inactive")
        cmd = "{systemctl} stop zzz.service other.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertNotEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "inactive\ninactive")
        self.assertEqual(end, 3)
        self.assertFalse(os.path.exists(os_path(root, "/var/tmp/test.1")))
        # and the status_file is also cleaned away
        self.assertFalse(os.path.exists(status_file))
        #
        logg.info("LOG\n%s", " "+reads(logfile).replace("\n", "\n "))
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4075_simple_truncate_old_pid(self) -> None:
        """ check that we manage a service that has some old .pid
            file being around. That is a reboot has occurred and the
            information is not relevant to the current system state."""
        self.begin()
        vv = "-vv"
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        logfile = os_path(root, "/var/log/test.log")
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            After=foo.service
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleep} 99
            ExecStop=/usr/bin/killall {testsleep}
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        #
        getpid_boot_time = get_proc_started(os.getpid())
        system_boot_time = datetime.datetime.fromtimestamp(getpid_boot_time - 1)
        systemctl += " -c BOOT_PID_MIN=%s -c DEBUG_BOOTTIME" % (os.getpid())
        #
        cmd = "{systemctl} enable zzz.service -vv"
        sh____(cmd.format(**locals()))
        is_active = "{systemctl} is-active zzz.service other.service {vv}"
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "inactive\ninactive")
        self.assertEqual(end, 3)
        #
        logg.info("== 'start' shall start a service that is NOT is-active ")
        cmd = "{systemctl} start zzz.service other.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertNotEqual(end, 0)
        is_active = "{systemctl} is-active zzz.service other.service -vv"
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "active\ninactive")
        self.assertEqual(end, 3)
        #
        logg.info("== 'stop' shall stop a service that is-active")
        cmd = "{systemctl} stop zzz.service other.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertNotEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "inactive\ninactive")
        self.assertEqual(end, 3)
        #
        logg.info("== 'restart' shall start a service that NOT is-active\n")
        cmd = "{systemctl} restart zzz.service other.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertNotEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "active\ninactive")
        self.assertEqual(end, 3)
        #
        time.sleep(2)
        logg.info("== mark the status file as being too old")
        # status_file = os_path(root, "/var/run/zzz.service.status")
        cmd = "{systemctl} -p StatusFile show zzz.service"
        status_file = output(cmd.format(**locals())).split("=", 1)[1].strip()
        logg.info("status_file = %s", status_file)
        self.assertTrue(os.path.exists(status_file))
        sh____("LANG=C stat {status_file} | grep Modify:".format(**locals()))
        sh____("LANG=C stat /proc/1/status | grep Modify:".format(**locals()))
        sh____("touch -d '{system_boot_time}' {status_file}".format(**locals()))
        sh____("LANG=C stat {status_file} | grep Modify:".format(**locals()))
        #
        pid_file = os_path(root, "/var/run/zzz.service.pid")
        #+ self.assertTrue(os.path.exists(pid_file))
        #+ sh____("LANG=C stat {pid_file} | grep Modify:".format(**locals()))
        #+ sh____("LANG=C stat /proc/1/status | grep Modify:".format(**locals()))
        #+ sh____("touch -r /proc/1/status {pid_file}".format(**locals()))
        #+ sh____("LANG=C stat {pid_file} | grep Modify:".format(**locals()))
        #
        logg.info("== the next is-active shall then truncate it")
        old_status = os.path.getsize(status_file)
        # + old_pid = os.path.getsize(pid_file)
        is_activeXX = "{systemctl} is-active zzz.service other.service {vv} {vv}"
        act, end = output2(is_activeXX.format(**locals()))
        self.assertEqual(act.strip(), "inactive\ninactive")
        self.assertEqual(end, 3)
        new_status = os.path.getsize(status_file)
        # + new_pid = os.path.getsize(pid_file)
        logg.info("status-file size: old %s new %s", old_status, new_status)
        self.assertGreater(old_status, 0)
        self.assertEqual(new_status, 0)
        #+ logg.info("pid-file size: old %s new %s", old_pid, new_pid)
        #+ self.assertGreater(old_pid, 0)
        #+ self.assertEqual(new_pid, 0)
        #
        logg.info("== 'stop' shall cleanup a service that was not inactive")
        cmd = "{systemctl} stop zzz.service other.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertNotEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "inactive\ninactive")
        self.assertEqual(end, 3)
        logg.info("== and the status_file / pid_file is also cleaned away")
        self.assertFalse(os.path.exists(status_file))
        self.assertFalse(os.path.exists(pid_file))
        #
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4079_simple_truncate_oldest_pid(self) -> None:
        """ check that we manage a service that has some old .pid
            file being around. That is a reboot has occurred and the
            information is not relevant to the current system state."""
        self.begin()
        vv = "-vv"
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        logfile = os_path(root, "/var/log/test.log")
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            After=foo.service
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleep} 99
            ExecStop=/usr/bin/killall {testsleep}
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        #
        pid_max = reads("/proc/sys/kernel/pid_max").strip()
        systemctl += " -c BOOT_PID_MIN=%s -c DEBUG_BOOTTIME" % (pid_max)
        #
        cmd = "{systemctl} enable zzz.service -vv"
        sh____(cmd.format(**locals()))
        cmd = "{systemctl} start zzz.service -vv"
        sh____(cmd.format(**locals()))
        #
        cmd = "{systemctl} is-active zzz.service other.service -vvvv"
        act, err, end = output3(cmd.format(**locals()))
        self.assertEqual(act.strip(), "active\ninactive")
        self.assertEqual(end, 3)
        #
        cmd = "{systemctl} stop zzz.service -vv"
        sh____(cmd.format(**locals()))
        #
        logg.info("ERR => %s", err)
        self.assertTrue(greps(err, "boottime from the oldest entry in /proc"))
        #
        self.rm_testdir()
        self.coverage()
        self.end()
    def real_4090_simple_service_RemainAfterExit(self) -> None:
        self.test_4090_simple_service_RemainAfterExit(True)
    def test_4090_simple_service_RemainAfterExit(self, real: bool = False) -> None:
        """ check that we manage simple services in a root env
            with commands like start, restart, stop, etc where
            RemainAfterExit=yes says the service is okay even
            when ExecStart has finished."""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir, real)
        vv = "-vv"
        systemctl = cover() + _systemctl_py + " --root=" + root
        if real: vv, systemctl = "", "/usr/bin/systemctl"
        testsleep = self.testname("testsleep")
        testfail = self.testname("testfail.sh")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            [Service]
            Type=simple
            ExecStartPre=/bin/echo %n
            ExecStart={bindir}/{testsleep} 20
            ExecStartPost=/bin/echo started $MAINPID
            ExecStop=/bin/kill $MAINPID
            ExecStopPost=/bin/echo stopped $MAINPID
            ExecStopPost=/bin/sleep 2
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zze.service"), """
            [Unit]
            Description=Testing E
            [Service]
            Type=simple
            ExecStartPre=/bin/echo %n
            ExecStart={bindir}/{testsleep} 3
            ExecStartPost=/bin/echo started $MAINPID
            ExecStop=/bin/kill $MAINPID
            ExecStopPost=/bin/echo stopped $MAINPID
            ExecStopPost=/bin/sleep 2
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zzf.service"), """
            [Unit]
            Description=Testing F
            [Service]
            Type=simple
            ExecStartPre=/bin/echo %n
            ExecStart={bindir}/{testfail} 3
            ExecStartPost=/bin/echo started $MAINPID
            ExecStop=/bin/kill $MAINPID
            ExecStopPost=/bin/echo stopped $MAINPID
            ExecStopPost=/bin/sleep 2
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zzr.service"), """
            [Unit]
            Description=Testing R
            [Service]
            Type=simple
            RemainAfterExit=yes
            ExecStartPre=/bin/echo %n
            ExecStart={bindir}/{testsleep} 3
            ExecStartPost=/bin/echo started $MAINPID
            ExecStop=/bin/kill $MAINPID
            ExecStopPost=/bin/echo stopped $MAINPID
            ExecStopPost=/bin/sleep 2
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zzx.service"), """
            [Unit]
            Description=Testing X
            [Service]
            Type=simple
            RemainAfterExit=yes
            ExecStartPre=/bin/echo %n
            ExecStart={bindir}/{testfail} 3
            ExecStartPost=/bin/echo started $MAINPID
            ExecStop=/bin/kill $MAINPID
            ExecStopPost=/bin/echo stopped $MAINPID
            ExecStopPost=/bin/sleep 2
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "testfail.sh"), """
            #! /bin/sh
            {bindir}/{testsleep} $1
            exit 2
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_tool(os_path(testdir, "testfail.sh"), os_path(bindir, testfail))
        copy_file(os_path(testdir, "zzz.service"), os_path(root, "/etc/systemd/system/zzz.service"))
        copy_file(os_path(testdir, "zze.service"), os_path(root, "/etc/systemd/system/zze.service"))
        copy_file(os_path(testdir, "zzf.service"), os_path(root, "/etc/systemd/system/zzf.service"))
        copy_file(os_path(testdir, "zzr.service"), os_path(root, "/etc/systemd/system/zzr.service"))
        copy_file(os_path(testdir, "zzx.service"), os_path(root, "/etc/systemd/system/zzx.service"))
        sh____("{systemctl} daemon-reload".format(**locals()))
        #
        cmd = "{systemctl} is-active zzz.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        cmd = "{systemctl} enable zzz.service {vv}"
        sh____(cmd.format(**locals()))
        cmd = "{systemctl} is-active zzz.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'start' shall start a normal service ")
        cmd = "{systemctl} start zzz.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        time.sleep(4)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        #
        logg.info("== 'stop' shall stop a normal service")
        cmd = "{systemctl} stop zzz.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = "{systemctl} is-active zzz.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        cmd = "{systemctl} enable zze.service {vv}"
        sh____(cmd.format(**locals()))
        #
        logg.info("== 'start' will run a later exiting service ")
        cmd = "{systemctl} start zze.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        time.sleep(4)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = "{systemctl} is-active zze.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "failed")
        #
        logg.info("== 'stop' shall clean an already exited service")
        cmd = "{systemctl} stop zze.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        if TODO or real: self.assertEqual(end, 0)
        else: self.assertEqual(end, 1)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = "{systemctl} is-active zze.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        if TODO or real: self.assertEqual(out.strip(), "failed")
        else: self.assertEqual(out.strip(), "inactive")

        #
        cmd = "{systemctl} enable zzf.service {vv}"
        sh____(cmd.format(**locals()))
        #
        logg.info("== 'start' will run a later failing service ")
        cmd = "{systemctl} start zzf.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        time.sleep(4)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = "{systemctl} is-active zzf.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "failed")
        #
        logg.info("== 'reset-failed' shall clean an already failed service")
        cmd = "{systemctl} reset-failed zzf.service {vv} {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = "{systemctl} is-active zzf.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'stop' shall clean an already failed service")
        cmd = "{systemctl} stop zzf.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        if TODO or real: self.assertEqual(end, 0)
        else: self.assertEqual(end, 1)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = "{systemctl} is-active zzf.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        #
        cmd = "{systemctl} enable zzr.service {vv}"
        sh____(cmd.format(**locals()))
        #
        logg.info("== 'start' will have a later exiting service as remaining active")
        cmd = "{systemctl} start zzr.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        time.sleep(4)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = "{systemctl} is-active zzr.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active") # <<<<<<<<<<< here's the new functionality
        #
        logg.info("== 'stop' shall clean an exited but remaining service")
        cmd = "{systemctl} stop zzr.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        if TODO or real: self.assertEqual(end, 0)
        else: self.assertEqual(end, 1)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = "{systemctl} is-active zzr.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        if TODO or real: self.assertEqual(end, 0)
        else: self.assertEqual(end, 3)
        if TODO or real: self.assertEqual(out.strip(), "failed")
        else: self.assertEqual(out.strip(), "inactive")

        #
        cmd = "{systemctl} enable zzx.service {vv}"
        sh____(cmd.format(**locals()))
        #
        #
        logg.info("== 'start' will have a later failing service remaining but failed")
        cmd = "{systemctl} start zzx.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        time.sleep(4)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = "{systemctl} is-active zzx.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        #
        logg.info("== 'stop' shall clean an already failed remaining service")
        cmd = "{systemctl} stop zzx.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        if TODO or real: self.assertEqual(end, 0)
        else: self.assertEqual(end, 1)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep))
        cmd = "{systemctl} is-active zzx.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        if TODO or real: self.assertEqual(out.strip(), "failed")
        else: self.assertEqual(out.strip(), "inactive")
        #
        # cleanup
        kill_testsleep = "{systemctl} __killall {testsleep}"
        sx____(kill_testsleep.format(**locals()))
        self.rm_testdir()
        self.rm_zzfiles(root)
        self.coverage()
        self.end()
    def test_4101_systemctl_py_kill_basic_behaviour(self) -> None:
        """ check systemctl_py kill basic behaviour"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        testsleepB = testsleep+"B"
        testsleepC = testsleep+"C"
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepB} 99
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zzc.service"), """
            [Unit]
            Description=Testing C
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepC} 111
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleepB))
        copy_tool(_bin_sleep, os_path(bindir, testsleepC))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        copy_file(os_path(testdir, "zzc.service"), os_path(root, "/etc/systemd/system/zzc.service"))
        #
        cmd = "{systemctl} start zzb.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = "{systemctl} start zzc.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleepB))
        self.assertTrue(greps(top, testsleepC))
        #
        cmd = "{systemctl} stop zzb.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = "{systemctl} kill zzc.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        time.sleep(1) # kill is asynchronous
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleepB))
        self.assertFalse(greps(top, testsleepC))
        #
        cmd = "{systemctl} start zzb.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = "{systemctl} start zzc.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleepB))
        self.assertTrue(greps(top, testsleepC))
        #
        cmd = "killall {testsleepB}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = "killall {testsleepC}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} stop zzb.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0) # already down
        cmd = "{systemctl} kill zzc.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0) # nothing to kill
        #
        time.sleep(1)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleepB))
        self.assertFalse(greps(top, testsleepC))
        #
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4105_systemctl_py_kill_in_stop(self) -> None:
        """ check systemctl_py kill from ExecStop"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("sleep")
        testsleepB = testsleep+"B"
        testsleepC = testsleep+"C"
        begin = "{"
        ends = "}"
        bindir = os_path(root, "/usr/bin")
        rundir = os_path(root, "/var/run")
        text_file(os_path(testdir, "zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepB} 99
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zzc.service"), """
            [Unit]
            Description=Testing C
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepC} 111
            ExecStop=/bin/kill ${begin}MAINPID{ends}
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleepB))
        copy_tool(_bin_sleep, os_path(bindir, testsleepC))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        copy_file(os_path(testdir, "zzc.service"), os_path(root, "/etc/systemd/system/zzc.service"))
        os.makedirs(rundir)
        #
        cmd = "{systemctl} stop zzb.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = "{systemctl} stop zzc.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        # self.assertEqual(end, 0)
        #
        cmd = "{systemctl} start zzb.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = "{systemctl} start zzc.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleepB))
        self.assertTrue(greps(top, testsleepC))
        #
        cmd = "ls -l {rundir}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        if TODO: self.assertTrue(greps(out, "zzb.service.pid"))
        if TODO: self.assertTrue(greps(out, "zzc.service.pid"))
        #
        cmd = "{systemctl} stop zzb.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = "{systemctl} kill zzc.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        time.sleep(1) # kill is asynchronous
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleepB))
        self.assertFalse(greps(top, testsleepC))
        #
        cmd = "ls -l {rundir}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        if TODO: self.assertFalse(greps(out, "zzb.service.pid"))
        if TODO: self.assertTrue(greps(out, "zzc.service.pid"))
        #
        cmd = "{systemctl} start zzb.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = "{systemctl} start zzc.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleepB))
        self.assertTrue(greps(top, testsleepC))
        #
        cmd = "ls -l {rundir}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        if TODO: self.assertTrue(greps(out, "zzb.service.pid"))
        if TODO: self.assertTrue(greps(out, "zzc.service.pid"))
        #
        cmd = "killall {testsleepB}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = "killall {testsleepC}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} stop zzb.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0) # already down
        cmd = "{systemctl} kill zzc.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0) # nothing to kill
        #
        cmd = "ls -l {rundir}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        if TODO: self.assertFalse(greps(out, "zzb.service.pid")) # issue #13
        if TODO: self.assertTrue(greps(out, "zzc.service.pid")) # TODO ?
        #
        time.sleep(1)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleepB))
        self.assertFalse(greps(top, testsleepC))
        #
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4120_systemctl_kill_ignore_behaviour(self) -> None:
        """ systemctl kill ignore behaviour"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        quick = QUICK
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("testsleep")
        testsleepB = testsleep+"B"
        testsleepC = testsleep+"C"
        testscriptB = self.testname("testscriptB.sh")
        testscriptC = self.testname("testscriptC.sh")
        logfile = os_path(root, "/var/log/test.log")
        bindir = os_path(root, "/usr/bin")
        begin = "{"
        ends = "}"
        text_file(logfile, "")
        text_file(os_path(testdir, "zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStartPre=/bin/echo %n
            ExecStart={bindir}/{testscriptB} 111
            ExecStartPost=/bin/echo started $MAINPID
            ExecStop=/bin/kill -3 $MAINPID
            ExecStopPost=/bin/echo stopped $MAINPID
            ExecStopPost=/bin/sleep 2
            ExecReload=/bin/kill -10 $MAINPID
            # KillSignal=SIGQUIT
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        shell_file(os_path(bindir, testscriptB), """
            #! /bin/sh
            date +%T,enter > {logfile}
            stops () {begin}
              date +%T,stopping >> {logfile}
              killall {testsleep}
              date +%T,stopped >> {logfile}
            {ends}
            reload () {begin}
              date +%T,reloading >> {logfile}
              date +%T,reloaded >> {logfile}
            {ends}
            ignored () {begin}
              date +%T,ignored >> {logfile}
            {ends}
            sighup () {begin}
              date +%T,sighup >> {logfile}
            {ends}
            trap "stops" 3     # SIGQUIT
            trap "reload" 10   # SIGUSR1
            trap "ignored" 15  # SIGTERM
            trap "sighup" 1    # SIGHUP
            date +%T,starting >> {logfile}
            {bindir}/{testsleepB} $1 >> {logfile} 2>&1 &
            while kill -0 $!; do
               # use 'kill -0' to check the existance of the child
               date +%T,waiting >> {logfile}
               # use 'wait' for children AND external signals
               wait
            done
            date +%T,leaving >> {logfile}
            trap - 3 10 15 # SIGQUIT SIGUSR1 SIGTERM
            date +%T,leave >> {logfile}
        """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleepB))
        copy_tool(_bin_sleep, os_path(bindir, testsleepC))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        #
        cmd = "{systemctl} start zzb.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleepB))
        #
        cmd = "{systemctl} stop zzb.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testscriptB))
        self.assertTrue(greps(top, testsleepB))
        #
        cmd = "{systemctl} kill zzb.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        time.sleep(1) # kill is asynchronous
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testscriptB))
        self.assertFalse(greps(top, testsleepB)) # kills children as well
        #
        log = lines(reads(logfile))
        logg.info("LOG %s\n| %s", logfile, "\n| ".join(log))
        self.assertTrue(greps(log, "ignored"))
        self.assertFalse(greps(log, "sighup"))
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        cmd = "{systemctl} __killall {testsleepB}"
        sx____(cmd.format(**locals())) # cleanup before check
        self.assertFalse(greps(top, testsleepB))
        #
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4121_systemctl_kill_ignore_nokill_behaviour(self) -> None:
        """ systemctl kill ignore and nokill behaviour"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        quick = QUICK
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("testsleep")
        testsleepB = testsleep+"B"
        testsleepC = testsleep+"C"
        testscriptB = self.testname("testscriptB.sh")
        testscriptC = self.testname("testscriptC.sh")
        logfile = os_path(root, "/var/log/test.log")
        bindir = os_path(root, "/usr/bin")
        begin = "{"
        ends = "}"
        text_file(logfile, "")
        text_file(os_path(testdir, "zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStartPre=/bin/echo %n
            ExecStart={bindir}/{testscriptB} 111
            ExecStartPost=/bin/echo started $MAINPID
            ExecStop=/bin/kill -3 $MAINPID
            ExecStopPost=/bin/echo stopped $MAINPID
            ExecStopPost=/bin/sleep 2
            ExecReload=/bin/kill -10 $MAINPID
            # KillSignal=SIGQUIT
            SendSIGKILL=no
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        shell_file(os_path(bindir, testscriptB), """
            #! /bin/sh
            date +%T,enter > {logfile}
            stops () {begin}
              date +%T,stopping >> {logfile}
              killall {testsleep}
              date +%T,stopped >> {logfile}
            {ends}
            reload () {begin}
              date +%T,reloading >> {logfile}
              date +%T,reloaded >> {logfile}
            {ends}
            ignored () {begin}
              date +%T,ignored >> {logfile}
            {ends}
            sighup () {begin}
              date +%T,sighup >> {logfile}
            {ends}
            trap "stops" 3    # SIGQUIT
            trap "reload" 10  # SIGUSR1
            trap "ignored" 15 # SIGTERM
            trap "sighup" 1   # SIGHUP
            date +%T,starting >> {logfile}
            {bindir}/{testsleepB} $1 >> {logfile} 2>&1 &
            while kill -0 $!; do
               # use 'kill -0' to check the existance of the child
               date +%T,waiting >> {logfile}
               # use 'wait' for children AND external signals
               wait
            done
            date +%T,leaving >> {logfile}
            trap - 3 10 15 # SIGQUIT SIGUSR1 SIGTERM
            date +%T,leave >> {logfile}
        """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleepB))
        copy_tool(_bin_sleep, os_path(bindir, testsleepC))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        #
        cmd = "{systemctl} start zzb.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleepB))
        #
        cmd = "{systemctl} stop zzb.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testscriptB))
        self.assertTrue(greps(top, testsleepB))
        #
        cmd = "{systemctl} kill zzb.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0) # actually killed
        #
        time.sleep(1) # kill is asynchronous
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testscriptB))
        self.assertFalse(greps(top, testsleepB)) # and it kills children
        #
        log = lines(reads(logfile))
        logg.info("LOG %s\n| %s", logfile, "\n| ".join(log))
        self.assertTrue(greps(log, "ignored"))
        self.assertFalse(greps(log, "sighup"))
        #
        time.sleep(1) # kill is asynchronous
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        cmd = "{systemctl} __killall {testsleepB}"
        sx____(cmd.format(**locals())) # cleanup before check
        self.assertFalse(greps(top, testscriptB))
        self.assertFalse(greps(top, testsleepB))
        #
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4151_systemctl_kill_sendsighup(self) -> None:
        """ systemctl kill with sighup"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        quick = QUICK
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("testsleep")
        testsleepB = testsleep+"B"
        testsleepC = testsleep+"C"
        testscriptB = self.testname("testscriptB.sh")
        testscriptC = self.testname("testscriptC.sh")
        logfile = os_path(root, "/var/log/test.log")
        bindir = os_path(root, "/usr/bin")
        begin = "{"
        ends = "}"
        text_file(logfile, "")
        text_file(os_path(testdir, "zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStartPre=/bin/echo %n
            ExecStart={bindir}/{testscriptB} 111
            ExecStartPost=/bin/echo started $MAINPID
            ExecStop=/bin/kill -3 $MAINPID
            ExecStopPost=/bin/echo stopped $MAINPID
            ExecStopPost=/bin/sleep 2
            ExecReload=/bin/kill -10 $MAINPID
            # KillSignal=SIGQUIT
            SendSIGHUP=yes
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        shell_file(os_path(bindir, testscriptB), """
            #! /bin/sh
            date +%T,enter > {logfile}
            stops () {begin}
              date +%T,stopping >> {logfile}
              killall {testsleep}
              date +%T,stopped >> {logfile}
            {ends}
            reload () {begin}
              date +%T,reloading >> {logfile}
              date +%T,reloaded >> {logfile}
            {ends}
            ignored () {begin}
              date +%T,ignored >> {logfile}
            {ends}
            sighup () {begin}
              date +%T,sighup >> {logfile}
            {ends}
            trap "stops" 3      # SIGQUIT
            trap "reload" 10    # SIGUSR1
            trap "ignored" 15   # SIGTERM
            trap "sighup" 1     # SIGHUP
            date +%T,starting >> {logfile}
            {bindir}/{testsleepB} $1 >> {logfile} 2>&1 &
            while kill -0 $!; do
               # use 'kill -0' to check the existance of the child
               date +%T,waiting >> {logfile}
               # use 'wait' for children AND external signals
               wait
            done
            date +%T,leaving >> {logfile}
            trap - 3 10 15  # SIGQUIT SIGUSR1 SIGTERM
            date +%T,leave >> {logfile}
        """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleepB))
        copy_tool(_bin_sleep, os_path(bindir, testsleepC))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        #
        cmd = "{systemctl} start zzb.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleepB))
        #
        cmd = "{systemctl} stop zzb.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testscriptB))
        self.assertTrue(greps(top, testsleepB))
        #
        cmd = "{systemctl} kill zzb.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0) # actually killed
        #
        time.sleep(1) # kill is asynchronous
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testscriptB))
        self.assertFalse(greps(top, testsleepB)) # and it kills children
        #
        log = lines(reads(logfile))
        logg.info("LOG %s\n| %s", logfile, "\n| ".join(log))
        self.assertTrue(greps(log, "ignored"))
        self.assertTrue(greps(log, "sighup"))
        #
        time.sleep(1) # kill is asynchronous
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        cmd = "{systemctl} __killall {testsleepB}"
        sx____(cmd.format(**locals())) # cleanup before check
        self.assertFalse(greps(top, testscriptB))
        self.assertFalse(greps(top, testsleepB))
        #
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4160_systemctl_kill_process_hard(self) -> None:
        """ systemctl kill needs to be hard"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        quick = QUICK
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("testsleep")
        testsleepB = testsleep+"B"
        testsleepC = testsleep+"C"
        testscriptB = self.testname("testscriptB.sh")
        testscriptC = self.testname("testscriptC.sh")
        logfile = os_path(root, "/var/log/test.log")
        bindir = os_path(root, "/usr/bin")
        begin = "{"
        ends = "}"
        text_file(logfile, "")
        text_file(os_path(testdir, "zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStartPre=/bin/echo %n
            ExecStart={bindir}/{testscriptB} 111
            ExecStartPost=/bin/echo started $MAINPID
            ExecStop=/bin/kill -3 $MAINPID
            ExecStopPost=/bin/echo stopped $MAINPID
            ExecStopPost=/bin/sleep 2
            ExecReload=/bin/kill -10 $MAINPID
            KillMode=process
            KillSignal=SIGQUIT
            # SendSIGHUP=yes
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        shell_file(os_path(bindir, testscriptB), """
            #! /bin/sh
            date +%T,enter > {logfile}
            stops () {begin}
              date +%T,stopfails >> {logfile}
              # killall {testsleep} ############## kill ignored
            {ends}
            reload () {begin}
              date +%T,reloading >> {logfile}
              date +%T,reloaded >> {logfile}
            {ends}
            ignored () {begin}
              date +%T,ignored >> {logfile}
            {ends}
            sighup () {begin}
              date +%T,sighup >> {logfile}
            {ends}
            trap "stops" 3      # SIGQUIT
            trap "reload" 10    # SIGUSR1
            trap "ignored" 15   # SIGTERM
            trap "sighup" 1     # SIGHUP
            date +%T,starting >> {logfile}
            {bindir}/{testsleepB} $1 >> {logfile} 2>&1 &
            while kill -0 $!; do
               # use 'kill -0' to check the existance of the child
               date +%T,waiting >> {logfile}
               # use 'wait' for children AND external signals
               wait
            done
            date +%T,leaving >> {logfile}
            trap - 3 10 15  # SIGQUIT SIGUSR1 SIGTERM
            date +%T,leave >> {logfile}
        """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleepB))
        copy_tool(_bin_sleep, os_path(bindir, testsleepC))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        #
        cmd = "{systemctl} start zzb.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleepB))
        #
        cmd = "{systemctl} stop zzb.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testscriptB))
        self.assertTrue(greps(top, testsleepB))
        #
        cmd = "{systemctl} kill zzb.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0) # actually killed
        #
        time.sleep(1) # kill is asynchronous
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testscriptB))
        self.assertTrue(greps(top, testsleepB))
        #
        log = lines(reads(logfile))
        logg.info("LOG %s\n| %s", logfile, "\n| ".join(log))
        # self.assertTrue(greps(log, "ignored"))
        # self.assertTrue(greps(log, "sighup"))
        #
        time.sleep(1) # kill is asynchronous
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        cmd = "{systemctl} __killall {testsleepB}"
        sx____(cmd.format(**locals())) # cleanup before check
        self.assertFalse(greps(top, testscriptB))
        self.assertTrue(greps(top, testsleepB))  # TODO?##
        #
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4161_systemctl_kill_mixed_hard(self) -> None:
        """ systemctl kill needs to be hard"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        quick = QUICK
        systemctl = cover() + _systemctl_py + " --root=" + root
        testsleep = self.testname("testsleep")
        testsleepB = testsleep+"B"
        testsleepC = testsleep+"C"
        testscriptB = self.testname("testscriptB.sh")
        testscriptC = self.testname("testscriptC.sh")
        logfile = os_path(root, "/var/log/test.log")
        bindir = os_path(root, "/usr/bin")
        begin = "{"
        ends = "}"
        text_file(logfile, "")
        text_file(os_path(testdir, "zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStartPre=/bin/echo %n
            ExecStart={bindir}/{testscriptB} 111
            ExecStartPost=/bin/echo started $MAINPID
            ExecStop=/bin/kill -3 $MAINPID
            ExecStopPost=/bin/echo stopped $MAINPID
            ExecStopPost=/bin/sleep 2
            ExecReload=/bin/kill -10 $MAINPID
            KillMode=mixed
            KillSignal=SIGQUIT
            # SendSIGHUP=yes
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        shell_file(os_path(bindir, testscriptB), """
            #! /bin/sh
            date +%T,enter > {logfile}
            stops () {begin}
              date +%T,stopfails >> {logfile}
              # killall {testsleep} ############## kill ignored
            {ends}
            reload () {begin}
              date +%T,reloading >> {logfile}
              date +%T,reloaded >> {logfile}
            {ends}
            ignored () {begin}
              date +%T,ignored >> {logfile}
            {ends}
            sighup () {begin}
              date +%T,sighup >> {logfile}
            {ends}
            trap "stops" 3      # SIGQUIT
            trap "reload" 10    # SIGUSR1
            trap "ignored" 15   # SIGTERM
            trap "sighup" 1     # SIGHUP
            date +%T,starting >> {logfile}
            {bindir}/{testsleepB} $1 >> {logfile} 2>&1 &
            while kill -0 $!; do
               # use 'kill -0' to check the existance of the child
               date +%T,waiting >> {logfile}
               # use 'wait' for children AND external signals
               wait
            done
            date +%T,leaving >> {logfile}
            trap - 3 10 15  # SIGQUIT SIGUSR1 SIGTERM
            date +%T,leave >> {logfile}
        """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleepB))
        copy_tool(_bin_sleep, os_path(bindir, testsleepC))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        #
        cmd = "{systemctl} start zzb.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleepB))
        #
        cmd = "{systemctl} stop zzb.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testscriptB))
        self.assertTrue(greps(top, testsleepB))
        #
        cmd = "{systemctl} kill zzb.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0) # actually killed
        #
        time.sleep(1) # kill is asynchronous
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testscriptB))
        self.assertFalse(greps(top, testsleepB))  # TODO?##
        #
        log = lines(reads(logfile))
        logg.info("LOG %s\n| %s", logfile, "\n| ".join(log))
        # self.assertTrue(greps(log, "ignored"))
        # self.assertTrue(greps(log, "sighup"))
        #
        time.sleep(1) # kill is asynchronous
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        cmd = "{systemctl} __killall {testsleepB}"
        sx____(cmd.format(**locals())) # cleanup before check
        self.assertFalse(greps(top, testscriptB))
        self.assertFalse(greps(top, testsleepB))
        #
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4201_systemctl_py_dependencies_plain_start_order(self) -> None:
        """ check list-dependencies - standard order of starting
            units is simply the command line order"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStartPre={bindir}/logger 'start-A'
            ExecStart={bindir}/{testsleep} 30
            ExecStopPost={bindir}/logger 'stop-A'
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStartPre={bindir}/logger 'start-B'
            ExecStart={bindir}/{testsleep} 99
            ExecStopPost={bindir}/logger 'stop-B'
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zzc.service"), """
            [Unit]
            Description=Testing C
            [Service]
            Type=simple
            ExecStartPre={bindir}/logger 'start-C'
            ExecStart={bindir}/{testsleep} 111
            ExecStopPost={bindir}/logger 'stop-C'
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        shell_file(os_path(testdir, "logger"), """
            #! /bin/sh
            echo "$@" >> {logfile}
            cat {logfile} | sed -e "s|^| : |"
            true
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_tool(os_path(testdir, "logger"), os_path(bindir, "logger"))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        copy_file(os_path(testdir, "zzc.service"), os_path(root, "/etc/systemd/system/zzc.service"))
        os.makedirs(os_path(root, "/var/run"))
        os.makedirs(os_path(root, "/var/log"))
        #
        list_dependencies = "{systemctl} list-dependencies zza.service --now"
        deps = output(list_dependencies.format(**locals()))
        logg.info("deps \n%s", deps)
        #
        cmd = "{systemctl} start zza.service zzb.service zzc.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep+" 99"))
        #
        # inspect logfile
        log = lines(open(logfile))
        logg.info("logs \n| %s", "\n| ".join(log))
        self.assertEqual(log[0], "start-A")
        self.assertEqual(log[1], "start-B")
        self.assertEqual(log[2], "start-C")
        os.remove(logfile)
        #
        cmd = "{systemctl} stop zza.service zzb.service zzc.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep+" 99"))
        #
        # inspect logfile
        log = lines(open(logfile))
        logg.info("logs \n| %s", "\n| ".join(log))
        self.assertEqual(log[0], "stop-A")
        self.assertEqual(log[1], "stop-B")
        self.assertEqual(log[2], "stop-C")
        os.remove(logfile)
        #
        kill_testsleep = "{systemctl} __killall {testsleep}"
        sx____(kill_testsleep.format(**locals()))
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4211_systemctl_py_dependencies_basic_reorder(self) -> None:
        """ check list-dependencies - standard order of starting
            units is simply the command line order (After case)"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            After=zzb.service
            [Service]
            Type=simple
            ExecStartPre={bindir}/logger 'start-A'
            ExecStart={bindir}/{testsleep} 30
            ExecStopPost={bindir}/logger 'stop-A'
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStartPre={bindir}/logger 'start-B'
            ExecStart={bindir}/{testsleep} 99
            ExecStopPost={bindir}/logger 'stop-B'
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zzc.service"), """
            [Unit]
            Description=Testing C
            After=zza.service
            [Service]
            Type=simple
            ExecStartPre={bindir}/logger 'start-C'
            ExecStart={bindir}/{testsleep} 111
            ExecStopPost={bindir}/logger 'stop-C'
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        shell_file(os_path(testdir, "logger"), """
            #! /bin/sh
            echo "$@" >> {logfile}
            cat {logfile} | sed -e "s|^| : |"
            true
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_tool(os_path(testdir, "logger"), os_path(bindir, "logger"))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        copy_file(os_path(testdir, "zzc.service"), os_path(root, "/etc/systemd/system/zzc.service"))
        os.makedirs(os_path(root, "/var/run"))
        os.makedirs(os_path(root, "/var/log"))
        #
        list_dependencies = "{systemctl} list-dependencies zza.service --now"
        deps = output(list_dependencies.format(**locals()))
        logg.info("deps \n%s", deps)
        #
        cmd = "{systemctl} start zza.service zzb.service zzc.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep+" 99"))
        #
        # inspect logfile
        log = lines(open(logfile))
        logg.info("logs \n| %s", "\n| ".join(log))
        self.assertEqual(log[0], "start-B")
        self.assertEqual(log[1], "start-A")
        self.assertEqual(log[2], "start-C")
        os.remove(logfile)
        #
        cmd = "{systemctl} stop zza.service zzb.service zzc.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep+" 99"))
        #
        # inspect logfile
        log = lines(open(logfile))
        logg.info("logs \n| %s", "\n| ".join(log))
        self.assertEqual(log[0], "stop-C")
        self.assertEqual(log[1], "stop-A")
        self.assertEqual(log[2], "stop-B")
        os.remove(logfile)
        #
        kill_testsleep = "{systemctl} __killall {testsleep}"
        sx____(kill_testsleep.format(**locals()))
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4251_systemctl_py_dependencies_basic_reorder(self) -> None:
        """ check list-dependencies - standard order of starting
            units is simply the command line order (Before case)"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            Before=zzb.service
            [Service]
            Type=simple
            ExecStartPre={bindir}/logger 'start-A'
            ExecStart={bindir}/{testsleep} 30
            ExecStopPost={bindir}/logger 'stop-A'
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStartPre={bindir}/logger 'start-B'
            ExecStart={bindir}/{testsleep} 99
            ExecStopPost={bindir}/logger 'stop-B'
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zzc.service"), """
            [Unit]
            Description=Testing C
            Before=zza.service
            [Service]
            Type=simple
            ExecStartPre={bindir}/logger 'start-C'
            ExecStart={bindir}/{testsleep} 111
            ExecStopPost={bindir}/logger 'stop-C'
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        shell_file(os_path(testdir, "logger"), """
            #! /bin/sh
            echo "$@" >> {logfile}
            cat {logfile} | sed -e "s|^| : |"
            true
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_tool(os_path(testdir, "logger"), os_path(bindir, "logger"))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        copy_file(os_path(testdir, "zzc.service"), os_path(root, "/etc/systemd/system/zzc.service"))
        os.makedirs(os_path(root, "/var/run"))
        os.makedirs(os_path(root, "/var/log"))
        #
        list_dependencies = "{systemctl} list-dependencies zza.service --now"
        deps = output(list_dependencies.format(**locals()))
        logg.info("deps \n%s", deps)
        #
        cmd = "{systemctl} start zza.service zzb.service zzc.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, testsleep+" 99"))
        #
        # inspect logfile
        log = lines(open(logfile))
        logg.info("logs \n| %s", "\n| ".join(log))
        self.assertEqual(log[0], "start-C")
        self.assertEqual(log[1], "start-A")
        self.assertEqual(log[2], "start-B")
        os.remove(logfile)
        #
        cmd = "{systemctl} stop zza.service zzb.service zzc.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        time.sleep(1)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, testsleep+" 99"))
        #
        # inspect logfile
        log = lines(open(logfile))
        logg.info("logs \n| %s", "\n| ".join(log))
        self.assertEqual(log[0], "stop-B")
        self.assertEqual(log[1], "stop-A")
        self.assertEqual(log[2], "stop-C")
        os.remove(logfile)
        #
        kill_testsleep = "{systemctl} __killall {testsleep}"
        sx____(kill_testsleep.format(**locals()))
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4261_systemctl_py_list_dependencies_with_after(self) -> None:
        """ check list-dependencies - standard order of starting
            units is simply the command line order"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            After=zzb.service
            [Service]
            Type=simple
            ExecStartPre={bindir}/logger 'start-A'
            ExecStart={bindir}/{testsleep} 30
            ExecStopPost={bindir}/logger 'stop-A'
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStartPre={bindir}/logger 'start-B'
            ExecStart={bindir}/{testsleep} 99
            ExecStopPost={bindir}/logger 'stop-B'
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zzc.service"), """
            [Unit]
            Description=Testing C
            After=zza.service
            [Service]
            Type=simple
            ExecStartPre={bindir}/logger 'start-C'
            ExecStart={bindir}/{testsleep} 111
            ExecStopPost={bindir}/logger 'stop-C'
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        shell_file(os_path(testdir, "logger"), """
            #! /bin/sh
            echo "$@" >> {logfile}
            cat {logfile} | sed -e "s|^| : |"
            true
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_tool(os_path(testdir, "logger"), os_path(bindir, "logger"))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        copy_file(os_path(testdir, "zzc.service"), os_path(root, "/etc/systemd/system/zzc.service"))
        os.makedirs(os_path(root, "/var/run"))
        os.makedirs(os_path(root, "/var/log"))
        #
        list_dependencies = "{systemctl} list-start-dependencies zza.service"
        deps_text = output(list_dependencies.format(**locals()))
        # logg.info("deps \n%s", deps_text)
        #
        # inspect logfile
        deps = lines(deps_text)
        logg.info("deps \n| %s", "\n| ".join(deps))
        self.assertEqual(deps[0], "zza.service\t(Requested)")
        self.assertEqual(len(deps), 1)
        #
        kill_testsleep = "{systemctl} __killall {testsleep}"
        sx____(kill_testsleep.format(**locals()))
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4262_systemctl_py_list_dependencies_with_wants(self) -> None:
        """ check list-dependencies - standard order of starting
            units is simply the command line order"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            Wants=zzb.service
            [Service]
            Type=simple
            ExecStartPre={bindir}/logger 'start-A'
            ExecStart={bindir}/{testsleep} 30
            ExecStopPost={bindir}/logger 'stop-A'
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStartPre={bindir}/logger 'start-B'
            ExecStart={bindir}/{testsleep} 99
            ExecStopPost={bindir}/logger 'stop-B'
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zzc.service"), """
            [Unit]
            Description=Testing C
            Wants=zza.service
            [Service]
            Type=simple
            ExecStartPre={bindir}/logger 'start-C'
            ExecStart={bindir}/{testsleep} 111
            ExecStopPost={bindir}/logger 'stop-C'
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        shell_file(os_path(testdir, "logger"), """
            #! /bin/sh
            echo "$@" >> {logfile}
            cat {logfile} | sed -e "s|^| : |"
            true
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_tool(os_path(testdir, "logger"), os_path(bindir, "logger"))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        copy_file(os_path(testdir, "zzc.service"), os_path(root, "/etc/systemd/system/zzc.service"))
        os.makedirs(os_path(root, "/var/run"))
        os.makedirs(os_path(root, "/var/log"))
        #
        list_dependencies = "{systemctl} list-start-dependencies zza.service"
        deps_text = output(list_dependencies.format(**locals()))
        # logg.info("deps \n%s", deps_text)
        #
        # inspect logfile
        deps = lines(deps_text)
        logg.info("deps \n| %s", "\n| ".join(deps))
        self.assertEqual(deps[0], "zzb.service\t(Wants)")
        self.assertEqual(deps[1], "zza.service\t(Requested)")
        self.assertEqual(len(deps), 2)
        #
        list_dependencies = "{systemctl} list-start-dependencies zzb.service"
        deps_text = output(list_dependencies.format(**locals()))
        # logg.info("deps \n%s", deps_text)
        #
        # inspect logfile
        deps = lines(deps_text)
        logg.info("deps \n| %s", "\n| ".join(deps))
        self.assertEqual(deps[0], "zzb.service\t(Requested)")
        self.assertEqual(len(deps), 1)
        #
        #
        list_dependencies = "{systemctl} list-start-dependencies zzc.service"
        deps_text = output(list_dependencies.format(**locals()))
        # logg.info("deps \n%s", deps_text)
        #
        # inspect logfile
        deps = lines(deps_text)
        logg.info("deps \n| %s", "\n| ".join(deps))
        self.assertEqual(deps[0], "zza.service\t(Wants)")
        self.assertEqual(deps[1], "zzc.service\t(Requested)")
        self.assertEqual(len(deps), 2)
        #
        kill_testsleep = "{systemctl} __killall {testsleep}"
        sx____(kill_testsleep.format(**locals()))
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4263_systemctl_py_list_dependencies_with_requires(self) -> None:
        """ check list-dependencies - standard order of starting
            units is simply the command line order"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            Requires=zzb.service
            [Service]
            Type=simple
            ExecStartPre={bindir}/logger 'start-A'
            ExecStart={bindir}/{testsleep} 30
            ExecStopPost={bindir}/logger 'stop-A'
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStartPre={bindir}/logger 'start-B'
            ExecStart={bindir}/{testsleep} 99
            ExecStopPost={bindir}/logger 'stop-B'
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zzc.service"), """
            [Unit]
            Description=Testing C
            Requires=zza.service
            [Service]
            Type=simple
            ExecStartPre={bindir}/logger 'start-C'
            ExecStart={bindir}/{testsleep} 111
            ExecStopPost={bindir}/logger 'stop-C'
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        shell_file(os_path(testdir, "logger"), """
            #! /bin/sh
            echo "$@" >> {logfile}
            cat {logfile} | sed -e "s|^| : |"
            true
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_tool(os_path(testdir, "logger"), os_path(bindir, "logger"))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        copy_file(os_path(testdir, "zzc.service"), os_path(root, "/etc/systemd/system/zzc.service"))
        os.makedirs(os_path(root, "/var/run"))
        os.makedirs(os_path(root, "/var/log"))
        #
        list_dependencies = "{systemctl} list-start-dependencies zza.service"
        deps_text = output(list_dependencies.format(**locals()))
        # logg.info("deps \n%s", deps_text)
        #
        # inspect logfile
        deps = lines(deps_text)
        logg.info("deps \n| %s", "\n| ".join(deps))
        self.assertEqual(deps[0], "zzb.service\t(Requires)")
        self.assertEqual(deps[1], "zza.service\t(Requested)")
        self.assertEqual(len(deps), 2)
        #
        list_dependencies = "{systemctl} list-start-dependencies zzb.service"
        deps_text = output(list_dependencies.format(**locals()))
        # logg.info("deps \n%s", deps_text)
        #
        # inspect logfile
        deps = lines(deps_text)
        logg.info("deps \n| %s", "\n| ".join(deps))
        self.assertEqual(deps[0], "zzb.service\t(Requested)")
        self.assertEqual(len(deps), 1)
        #
        #
        list_dependencies = "{systemctl} list-start-dependencies zzc.service"
        deps_text = output(list_dependencies.format(**locals()))
        # logg.info("deps \n%s", deps_text)
        #
        # inspect logfile
        deps = lines(deps_text)
        logg.info("deps \n| %s", "\n| ".join(deps))
        self.assertEqual(deps[0], "zza.service\t(Requires)")
        self.assertEqual(deps[1], "zzc.service\t(Requested)")
        self.assertEqual(len(deps), 2)
        #
        kill_testsleep = "{systemctl} __killall {testsleep}"
        sx____(kill_testsleep.format(**locals()))
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4271_systemctl_py_list_dependencies_with_after(self) -> None:
        """ check list-dependencies - standard order of starting
            units is simply the command line order"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            After=zzb.service
            [Service]
            Type=simple
            ExecStartPre={bindir}/logger 'start-A'
            ExecStart={bindir}/{testsleep} 30
            ExecStopPost={bindir}/logger 'stop-A'
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStartPre={bindir}/logger 'start-B'
            ExecStart={bindir}/{testsleep} 99
            ExecStopPost={bindir}/logger 'stop-B'
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zzc.service"), """
            [Unit]
            Description=Testing C
            After=zza.service
            [Service]
            Type=simple
            ExecStartPre={bindir}/logger 'start-C'
            ExecStart={bindir}/{testsleep} 111
            ExecStopPost={bindir}/logger 'stop-C'
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        shell_file(os_path(testdir, "logger"), """
            #! /bin/sh
            echo "$@" >> {logfile}
            cat {logfile} | sed -e "s|^| : |"
            true
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_tool(os_path(testdir, "logger"), os_path(bindir, "logger"))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        copy_file(os_path(testdir, "zzc.service"), os_path(root, "/etc/systemd/system/zzc.service"))
        os.makedirs(os_path(root, "/var/run"))
        os.makedirs(os_path(root, "/var/log"))
        #
        list_dependencies = "{systemctl} list-dependencies zza.service"
        deps_text = output(list_dependencies.format(**locals()))
        # logg.info("deps \n%s", deps_text)
        #
        # inspect logfile
        deps = lines(deps_text)
        logg.info("deps \n| %s", "\n| ".join(deps))
        self.assertEqual(deps[0], "zza.service:")
        self.assertEqual(len(deps), 1)
        #
        kill_testsleep = "{systemctl} __killall {testsleep}"
        sx____(kill_testsleep.format(**locals()))
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4272_systemctl_py_list_dependencies_with_wants(self) -> None:
        """ check list-dependencies - standard order of starting
            units is simply the command line order"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            Wants=zzb.service
            [Service]
            Type=simple
            ExecStartPre={bindir}/logger 'start-A'
            ExecStart={bindir}/{testsleep} 30
            ExecStopPost={bindir}/logger 'stop-A'
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStartPre={bindir}/logger 'start-B'
            ExecStart={bindir}/{testsleep} 99
            ExecStopPost={bindir}/logger 'stop-B'
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zzc.service"), """
            [Unit]
            Description=Testing C
            Wants=zza.service
            [Service]
            Type=simple
            ExecStartPre={bindir}/logger 'start-C'
            ExecStart={bindir}/{testsleep} 111
            ExecStopPost={bindir}/logger 'stop-C'
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        shell_file(os_path(testdir, "logger"), """
            #! /bin/sh
            echo "$@" >> {logfile}
            cat {logfile} | sed -e "s|^| : |"
            true
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_tool(os_path(testdir, "logger"), os_path(bindir, "logger"))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        copy_file(os_path(testdir, "zzc.service"), os_path(root, "/etc/systemd/system/zzc.service"))
        os.makedirs(os_path(root, "/var/run"))
        os.makedirs(os_path(root, "/var/log"))
        #
        list_dependencies = "{systemctl} list-dependencies zza.service"
        deps_text = output(list_dependencies.format(**locals()))
        # logg.info("deps \n%s", deps_text)
        #
        # inspect logfile
        deps = lines(deps_text)
        logg.info("deps \n| %s", "\n| ".join(deps))
        self.assertEqual(deps[0], "zza.service:")
        self.assertEqual(deps[1], "| zzb.service: wanted to start")
        self.assertEqual(len(deps), 2)
        #
        list_dependencies = "{systemctl} list-dependencies zzb.service"
        deps_text = output(list_dependencies.format(**locals()))
        # logg.info("deps \n%s", deps_text)
        #
        # inspect logfile
        deps = lines(deps_text)
        logg.info("deps \n| %s", "\n| ".join(deps))
        self.assertEqual(deps[0], "zzb.service:")
        self.assertEqual(len(deps), 1)
        #
        #
        list_dependencies = "{systemctl} list-dependencies zzc.service"
        deps_text = output(list_dependencies.format(**locals()))
        # logg.info("deps \n%s", deps_text)
        #
        # inspect logfile
        deps = lines(deps_text)
        logg.info("deps \n| %s", "\n| ".join(deps))
        self.assertEqual(deps[0], "zzc.service:")
        self.assertEqual(deps[1], "| zza.service: wanted to start")
        self.assertEqual(deps[2], "| | zzb.service: wanted to start")
        self.assertEqual(len(deps), 3)
        #
        kill_testsleep = "{systemctl} __killall {testsleep}"
        sx____(kill_testsleep.format(**locals()))
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4273_systemctl_py_list_dependencies_with_requires(self) -> None:
        """ check list-dependencies - standard order of starting
            units is simply the command line order"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            Requires=zzb.service
            [Service]
            Type=simple
            ExecStartPre={bindir}/logger 'start-A'
            ExecStart={bindir}/{testsleep} 30
            ExecStopPost={bindir}/logger 'stop-A'
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStartPre={bindir}/logger 'start-B'
            ExecStart={bindir}/{testsleep} 99
            ExecStopPost={bindir}/logger 'stop-B'
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zzc.service"), """
            [Unit]
            Description=Testing C
            Requires=zza.service
            [Service]
            Type=simple
            ExecStartPre={bindir}/logger 'start-C'
            ExecStart={bindir}/{testsleep} 111
            ExecStopPost={bindir}/logger 'stop-C'
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        shell_file(os_path(testdir, "logger"), """
            #! /bin/sh
            echo "$@" >> {logfile}
            cat {logfile} | sed -e "s|^| : |"
            true
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_tool(os_path(testdir, "logger"), os_path(bindir, "logger"))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        copy_file(os_path(testdir, "zzc.service"), os_path(root, "/etc/systemd/system/zzc.service"))
        os.makedirs(os_path(root, "/var/run"))
        os.makedirs(os_path(root, "/var/log"))
        #
        list_dependencies = "{systemctl} list-dependencies zza.service"
        deps_text = output(list_dependencies.format(**locals()))
        # logg.info("deps \n%s", deps_text)
        #
        # inspect logfile
        deps = lines(deps_text)
        logg.info("deps \n| %s", "\n| ".join(deps))
        self.assertEqual(deps[0], "zza.service:")
        self.assertEqual(deps[1], "| zzb.service: required to start")
        self.assertEqual(len(deps), 2)
        #
        list_dependencies = "{systemctl} list-dependencies zzb.service"
        deps_text = output(list_dependencies.format(**locals()))
        # logg.info("deps \n%s", deps_text)
        #
        # inspect logfile
        deps = lines(deps_text)
        logg.info("deps \n| %s", "\n| ".join(deps))
        self.assertEqual(deps[0], "zzb.service:")
        self.assertEqual(len(deps), 1)
        #
        #
        list_dependencies = "{systemctl} list-dependencies zzc.service"
        deps_text = output(list_dependencies.format(**locals()))
        # logg.info("deps \n%s", deps_text)
        #
        # inspect logfile
        deps = lines(deps_text)
        logg.info("deps \n| %s", "\n| ".join(deps))
        self.assertEqual(deps[0], "zzc.service:")
        self.assertEqual(deps[1], "| zza.service: required to start")
        self.assertEqual(deps[2], "| | zzb.service: required to start")
        self.assertEqual(len(deps), 3)
        #
        kill_testsleep = "{systemctl} __killall {testsleep}"
        sx____(kill_testsleep.format(**locals()))
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4300_background_default_journal(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleepA = self.testname("sleepA")
        testsleepB = self.testname("sleepB")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepA} 4
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepB} 5
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleepA))
        copy_tool(_bin_sleep, os_path(bindir, testsleepB))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        cmd = "{systemctl} enable zza.service"
        sh____(cmd.format(**locals()))
        cmd = "{systemctl} enable zzb.service"
        sh____(cmd.format(**locals()))
        #
        InitLoopSleep = 1
        initsystemctl = systemctl
        initsystemctl += " -c InitLoopSleep={InitLoopSleep}".format(**locals())
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = "{initsystemctl} -1"
        init = background(cmd.format(**locals()))
        time.sleep(InitLoopSleep+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*InitLoopSleep"))
        #
        cmd = "{systemctl} show zza.service -p JournalFilePath"
        journal_a=output(cmd.format(**locals())).strip().split("=", 1)[1]
        cmd = "{systemctl} show zzb.service -p JournalFilePath"
        journal_b=output(cmd.format(**locals())).strip().split("=", 1)[1]
        logg.info("journal zza = %s", journal_a)
        logg.info("journal zzb = %s", journal_b)
        for attempt in xrange(5):
            time.sleep(1)
            if not os.path.exists(journal_a): continue
            if not os.path.exists(journal_b): continue
            break
        self.assertTrue(os.path.exists(journal_a))
        self.assertTrue(os.path.exists(journal_b))
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4301_background_default_journal_written(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleepA = self.testname("sleepA")
        testsleepB = self.testname("sleepB")
        bindir = os_path(root, "/usr/bin")
        shell_file(os_path(testdir, "testsleepA.bin"), """
            #! /bin/sh
            echo running testsleepA
            exec {bindir}/{testsleepA} "$@"
            """.format(**locals()))
        shell_file(os_path(testdir, "testsleepB.bin"), """
            #! /bin/sh
            echo running testsleepB
            exec {bindir}/{testsleepB} "$@"
            """.format(**locals()))
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepA}.bin 4
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepB}.bin 5
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleepA))
        copy_tool(_bin_sleep, os_path(bindir, testsleepB))
        copy_tool(os_path(testdir, "testsleepA.bin"), os_path(bindir, testsleepA + ".bin"))
        copy_tool(os_path(testdir, "testsleepB.bin"), os_path(bindir, testsleepB + ".bin"))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        cmd = "{systemctl} enable zza.service"
        sh____(cmd.format(**locals()))
        cmd = "{systemctl} enable zzb.service"
        sh____(cmd.format(**locals()))
        #
        InitLoopSleep = 1
        initsystemctl = systemctl
        initsystemctl += " -c InitLoopSleep={InitLoopSleep}".format(**locals())
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = "{initsystemctl} -1"
        init = background(cmd.format(**locals()))
        time.sleep(InitLoopSleep+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*InitLoopSleep"))
        #
        cmd = "{systemctl} show zza.service -p JournalFilePath"
        journal_a=output(cmd.format(**locals())).strip().split("=", 1)[1]
        cmd = "{systemctl} show zzb.service -p JournalFilePath"
        journal_b=output(cmd.format(**locals())).strip().split("=", 1)[1]
        logg.info("journal zza = %s", journal_a)
        logg.info("journal zzb = %s", journal_b)
        time.sleep(1)
        self.assertTrue(os.path.exists(journal_a))
        self.assertTrue(os.path.exists(journal_b))
        out_a = open(journal_a).read()
        out_b = open(journal_b).read()
        logg.info("out_a=%s", out_a.strip())
        logg.info("out_b=%s", out_b.strip())
        self.assertTrue(greps(out_a, "running testsleepA"))
        self.assertTrue(greps(out_b, "running testsleepB"))
        self.assertFalse(greps(out_a, "running testsleepB"))
        self.assertFalse(greps(out_b, "running testsleepA"))
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4302_background_default_journal_written_error(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleepA = self.testname("sleepA")
        testsleepB = self.testname("sleepB")
        bindir = os_path(root, "/usr/bin")
        shell_file(os_path(testdir, "testsleepA.bin"), """
            #! /bin/sh
            echo starts testsleepA >&2
            echo running testsleepA
            exec {bindir}/{testsleepA} "$@"
            """.format(**locals()))
        shell_file(os_path(testdir, "testsleepB.bin"), """
            #! /bin/sh
            echo starts testsleepB >&2
            echo running testsleepB
            exec {bindir}/{testsleepB} "$@"
            """.format(**locals()))
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepA}.bin 4
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepB}.bin 5
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleepA))
        copy_tool(_bin_sleep, os_path(bindir, testsleepB))
        copy_tool(os_path(testdir, "testsleepA.bin"), os_path(bindir, testsleepA + ".bin"))
        copy_tool(os_path(testdir, "testsleepB.bin"), os_path(bindir, testsleepB + ".bin"))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        cmd = "{systemctl} enable zza.service"
        sh____(cmd.format(**locals()))
        cmd = "{systemctl} enable zzb.service"
        sh____(cmd.format(**locals()))
        #
        InitLoopSleep = 1
        initsystemctl = systemctl
        initsystemctl += " -c InitLoopSleep={InitLoopSleep}".format(**locals())
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = "{initsystemctl} -1"
        init = background(cmd.format(**locals()))
        time.sleep(InitLoopSleep+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*InitLoopSleep"))
        #
        cmd = "{systemctl} show zza.service -p JournalFilePath"
        journal_a=output(cmd.format(**locals())).strip().split("=", 1)[1]
        cmd = "{systemctl} show zzb.service -p JournalFilePath"
        journal_b=output(cmd.format(**locals())).strip().split("=", 1)[1]
        logg.info("journal zza = %s", journal_a)
        logg.info("journal zzb = %s", journal_b)
        time.sleep(1)
        self.assertTrue(os.path.exists(journal_a))
        self.assertTrue(os.path.exists(journal_b))
        out_a = open(journal_a).read()
        out_b = open(journal_b).read()
        logg.info("out_a=%s", out_a.strip())
        logg.info("out_b=%s", out_b.strip())
        self.assertTrue(greps(out_a, "running testsleepA"))
        self.assertTrue(greps(out_b, "running testsleepB"))
        self.assertTrue(greps(out_a, "starts testsleepA"))
        self.assertTrue(greps(out_b, "starts testsleepB"))
        self.assertFalse(greps(out_a, "running testsleepB"))
        self.assertFalse(greps(out_b, "running testsleepA"))
        self.assertFalse(greps(out_a, "starts testsleepB"))
        self.assertFalse(greps(out_b, "starts testsleepA"))

        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4303_background_default_journal_null_stderr(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleepA = self.testname("sleepA")
        testsleepB = self.testname("sleepB")
        bindir = os_path(root, "/usr/bin")
        shell_file(os_path(testdir, "testsleepA.bin"), """
            #! /bin/sh
            echo starts testsleepA >&2
            echo running testsleepA
            exec {bindir}/{testsleepA} "$@"
            """.format(**locals()))
        shell_file(os_path(testdir, "testsleepB.bin"), """
            #! /bin/sh
            echo starts testsleepB >&2
            echo running testsleepB
            exec {bindir}/{testsleepB} "$@"
            """.format(**locals()))
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepA}.bin 4
            StandardError=null
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepB}.bin 5
            StandardError=null
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleepA))
        copy_tool(_bin_sleep, os_path(bindir, testsleepB))
        copy_tool(os_path(testdir, "testsleepA.bin"), os_path(bindir, testsleepA + ".bin"))
        copy_tool(os_path(testdir, "testsleepB.bin"), os_path(bindir, testsleepB + ".bin"))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        cmd = "{systemctl} enable zza.service"
        sh____(cmd.format(**locals()))
        cmd = "{systemctl} enable zzb.service"
        sh____(cmd.format(**locals()))
        #
        InitLoopSleep = 1
        initsystemctl = systemctl
        initsystemctl += " -c InitLoopSleep={InitLoopSleep}".format(**locals())
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = "{initsystemctl} -1"
        init = background(cmd.format(**locals()))
        time.sleep(InitLoopSleep+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*InitLoopSleep"))
        #
        cmd = "{systemctl} show zza.service -p JournalFilePath"
        journal_a=output(cmd.format(**locals())).strip().split("=", 1)[1]
        cmd = "{systemctl} show zzb.service -p JournalFilePath"
        journal_b=output(cmd.format(**locals())).strip().split("=", 1)[1]
        logg.info("journal zza = %s", journal_a)
        logg.info("journal zzb = %s", journal_b)
        time.sleep(1)
        self.assertTrue(os.path.exists(journal_a))
        self.assertTrue(os.path.exists(journal_b))
        out_a = open(journal_a).read()
        out_b = open(journal_b).read()
        logg.info("out_a=%s", out_a.strip())
        logg.info("out_b=%s", out_b.strip())
        self.assertTrue(greps(out_a, "running testsleepA"))
        self.assertTrue(greps(out_b, "running testsleepB"))
        self.assertFalse(greps(out_a, "starts testsleepA"))
        self.assertFalse(greps(out_b, "starts testsleepB"))
        self.assertFalse(greps(out_a, "running testsleepB"))
        self.assertFalse(greps(out_b, "running testsleepA"))
        self.assertFalse(greps(out_a, "starts testsleepB"))
        self.assertFalse(greps(out_b, "starts testsleepA"))
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4304_background_default_journal_null_stdout(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleepA = self.testname("sleepA")
        testsleepB = self.testname("sleepB")
        bindir = os_path(root, "/usr/bin")
        shell_file(os_path(testdir, "testsleepA.bin"), """
            #! /bin/sh
            echo starts testsleepA >&2
            echo running testsleepA
            exec {bindir}/{testsleepA} "$@"
            """.format(**locals()))
        shell_file(os_path(testdir, "testsleepB.bin"), """
            #! /bin/sh
            echo starts testsleepB >&2
            echo running testsleepB
            exec {bindir}/{testsleepB} "$@"
            """.format(**locals()))
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepA}.bin 4
            StandardOutput=null
            StandardError=journal
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepB}.bin 5
            StandardOutput=null
            StandardError=journal
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleepA))
        copy_tool(_bin_sleep, os_path(bindir, testsleepB))
        copy_tool(os_path(testdir, "testsleepA.bin"), os_path(bindir, testsleepA + ".bin"))
        copy_tool(os_path(testdir, "testsleepB.bin"), os_path(bindir, testsleepB + ".bin"))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        cmd = "{systemctl} enable zza.service"
        sh____(cmd.format(**locals()))
        cmd = "{systemctl} enable zzb.service"
        sh____(cmd.format(**locals()))
        #
        InitLoopSleep = 1
        initsystemctl = systemctl
        initsystemctl += " -c InitLoopSleep={InitLoopSleep}".format(**locals())
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = "{initsystemctl} -1"
        init = background(cmd.format(**locals()))
        time.sleep(InitLoopSleep+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*InitLoopSleep"))
        #
        cmd = "{systemctl} show zza.service -p JournalFilePath"
        journal_a=output(cmd.format(**locals())).strip().split("=", 1)[1]
        cmd = "{systemctl} show zzb.service -p JournalFilePath"
        journal_b=output(cmd.format(**locals())).strip().split("=", 1)[1]
        logg.info("journal zza = %s", journal_a)
        logg.info("journal zzb = %s", journal_b)
        time.sleep(1)
        self.assertTrue(os.path.exists(journal_a))
        self.assertTrue(os.path.exists(journal_b))
        out_a = open(journal_a).read()
        out_b = open(journal_b).read()
        logg.info("out_a=%s", out_a.strip())
        logg.info("out_b=%s", out_b.strip())
        self.assertFalse(greps(out_a, "running testsleepA"))
        self.assertFalse(greps(out_b, "running testsleepB"))
        self.assertTrue(greps(out_a, "starts testsleepA"))
        self.assertTrue(greps(out_b, "starts testsleepB"))
        self.assertFalse(greps(out_a, "running testsleepB"))
        self.assertFalse(greps(out_b, "running testsleepA"))
        self.assertFalse(greps(out_a, "starts testsleepB"))
        self.assertFalse(greps(out_b, "starts testsleepA"))
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4308_background_default_journal_null_stdout_stderr(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleepA = self.testname("sleepA")
        testsleepB = self.testname("sleepB")
        bindir = os_path(root, "/usr/bin")
        shell_file(os_path(testdir, "testsleepA.bin"), """
            #! /bin/sh
            echo starts testsleepA >&2
            echo running testsleepA
            exec {bindir}/{testsleepA} "$@"
            """.format(**locals()))
        shell_file(os_path(testdir, "testsleepB.bin"), """
            #! /bin/sh
            echo starts testsleepB >&2
            echo running testsleepB
            exec {bindir}/{testsleepB} "$@"
            """.format(**locals()))
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepA}.bin 4
            StandardOutput=null
            StandardError=null
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepB}.bin 5
            StandardOutput=null
            StandardError=null
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleepA))
        copy_tool(_bin_sleep, os_path(bindir, testsleepB))
        copy_tool(os_path(testdir, "testsleepA.bin"), os_path(bindir, testsleepA + ".bin"))
        copy_tool(os_path(testdir, "testsleepB.bin"), os_path(bindir, testsleepB + ".bin"))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        cmd = "{systemctl} enable zza.service"
        sh____(cmd.format(**locals()))
        cmd = "{systemctl} enable zzb.service"
        sh____(cmd.format(**locals()))
        #
        InitLoopSleep = 1
        initsystemctl = systemctl
        initsystemctl += " -c InitLoopSleep={InitLoopSleep}".format(**locals())
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = "{initsystemctl} -1"
        init = background(cmd.format(**locals()))
        time.sleep(InitLoopSleep+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*InitLoopSleep"))
        #
        cmd = "{systemctl} show zza.service -p JournalFilePath"
        journal_a=output(cmd.format(**locals())).strip().split("=", 1)[1]
        cmd = "{systemctl} show zzb.service -p JournalFilePath"
        journal_b=output(cmd.format(**locals())).strip().split("=", 1)[1]
        logg.info("journal zza = %s", journal_a)
        logg.info("journal zzb = %s", journal_b)
        time.sleep(1)
        self.assertFalse(os.path.exists(journal_a))
        self.assertFalse(os.path.exists(journal_b))
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4309_background_default_journal_null_stdout_inherit(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleepA = self.testname("sleepA")
        testsleepB = self.testname("sleepB")
        bindir = os_path(root, "/usr/bin")
        shell_file(os_path(testdir, "testsleepA.bin"), """
            #! /bin/sh
            echo starts testsleepA >&2
            echo running testsleepA
            exec {bindir}/{testsleepA} "$@"
            """.format(**locals()))
        shell_file(os_path(testdir, "testsleepB.bin"), """
            #! /bin/sh
            echo starts testsleepB >&2
            echo running testsleepB
            exec {bindir}/{testsleepB} "$@"
            """.format(**locals()))
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepA}.bin 4
            StandardOutput=null
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepB}.bin 5
            StandardOutput=null
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleepA))
        copy_tool(_bin_sleep, os_path(bindir, testsleepB))
        copy_tool(os_path(testdir, "testsleepA.bin"), os_path(bindir, testsleepA + ".bin"))
        copy_tool(os_path(testdir, "testsleepB.bin"), os_path(bindir, testsleepB + ".bin"))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        cmd = "{systemctl} enable zza.service"
        sh____(cmd.format(**locals()))
        cmd = "{systemctl} enable zzb.service"
        sh____(cmd.format(**locals()))
        #
        InitLoopSleep = 1
        initsystemctl = systemctl
        initsystemctl += " -c InitLoopSleep={InitLoopSleep}".format(**locals())
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = "{initsystemctl} -1"
        init = background(cmd.format(**locals()))
        time.sleep(InitLoopSleep+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*InitLoopSleep"))
        #
        cmd = "{systemctl} show zza.service -p JournalFilePath"
        journal_a=output(cmd.format(**locals())).strip().split("=", 1)[1]
        cmd = "{systemctl} show zzb.service -p JournalFilePath"
        journal_b=output(cmd.format(**locals())).strip().split("=", 1)[1]
        logg.info("journal zza = %s", journal_a)
        logg.info("journal zzb = %s", journal_b)
        time.sleep(1)
        self.assertFalse(os.path.exists(journal_a))
        self.assertFalse(os.path.exists(journal_b))
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4311_background_logfile_journal(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleepA = self.testname("sleepA")
        testsleepB = self.testname("sleepB")
        bindir = os_path(root, "/usr/bin")
        shell_file(os_path(testdir, "testsleepA.bin"), """
            #! /bin/sh
            echo starts testsleepA >&2
            echo running testsleepA
            exec {bindir}/{testsleepA} "$@"
            """.format(**locals()))
        shell_file(os_path(testdir, "testsleepB.bin"), """
            #! /bin/sh
            echo starts testsleepB >&2
            echo running testsleepB
            exec {bindir}/{testsleepB} "$@"
            """.format(**locals()))
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepA}.bin 4
            StandardOutput=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepB}.bin 5
            StandardOutput=file:{root}/var/log/zzb.log
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleepA))
        copy_tool(_bin_sleep, os_path(bindir, testsleepB))
        copy_tool(os_path(testdir, "testsleepA.bin"), os_path(bindir, testsleepA + ".bin"))
        copy_tool(os_path(testdir, "testsleepB.bin"), os_path(bindir, testsleepB + ".bin"))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        cmd = "{systemctl} enable zza.service"
        sh____(cmd.format(**locals()))
        cmd = "{systemctl} enable zzb.service"
        sh____(cmd.format(**locals()))
        #
        InitLoopSleep = 1
        initsystemctl = systemctl
        initsystemctl += " -c InitLoopSleep={InitLoopSleep}".format(**locals())
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = "{initsystemctl} -1"
        init = background(cmd.format(**locals()))
        time.sleep(InitLoopSleep+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*InitLoopSleep"))
        #
        cmd = "{systemctl} show zza.service -p JournalFilePath"
        journal_a=output(cmd.format(**locals())).strip().split("=", 1)[1]
        cmd = "{systemctl} show zzb.service -p JournalFilePath"
        journal_b=output(cmd.format(**locals())).strip().split("=", 1)[1]
        logg.info("journal zza = %s", journal_a)
        logg.info("journal zzb = %s", journal_b)
        time.sleep(1)
        self.assertFalse(os.path.exists(journal_a))
        self.assertFalse(os.path.exists(journal_b))
        log_a = root + "/var/log/zza.log"
        log_b = root + "/var/log/zzb.log"
        logg.info("log zza = %s", log_a)
        logg.info("log zzb = %s", log_b)
        self.assertTrue(os.path.exists(log_a))
        self.assertTrue(os.path.exists(log_b))
        out_a = open(log_a).read()
        out_b = open(log_b).read()
        logg.info("out_a=%s", out_a.strip())
        logg.info("out_b=%s", out_b.strip())
        self.assertTrue(greps(out_a, "running testsleepA"))
        self.assertTrue(greps(out_b, "running testsleepB"))
        self.assertFalse(greps(out_a, "running testsleepB"))
        self.assertFalse(greps(out_b, "running testsleepA"))
        self.assertTrue(greps(out_a, "starts testsleepA"))
        self.assertTrue(greps(out_b, "starts testsleepB"))
        self.assertFalse(greps(out_a, "starts testsleepB"))
        self.assertFalse(greps(out_b, "starts testsleepA"))
        #
        logg.info("kill daemon at %s", init.pid)
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4312_background_logfile_journal(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleepA = self.testname("sleepA")
        testsleepB = self.testname("sleepB")
        bindir = os_path(root, "/usr/bin")
        shell_file(os_path(testdir, "testsleepA.bin"), """
            #! /bin/sh
            echo starts testsleepA >&2
            echo running testsleepA
            exec {bindir}/{testsleepA} "$@"
            """.format(**locals()))
        shell_file(os_path(testdir, "testsleepB.bin"), """
            #! /bin/sh
            echo starts testsleepB >&2
            echo running testsleepB
            exec {bindir}/{testsleepB} "$@"
            """.format(**locals()))
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepA}.bin 4
            StandardError=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepB}.bin 5
            StandardError=file:{root}/var/log/zzb.log
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleepA))
        copy_tool(_bin_sleep, os_path(bindir, testsleepB))
        copy_tool(os_path(testdir, "testsleepA.bin"), os_path(bindir, testsleepA + ".bin"))
        copy_tool(os_path(testdir, "testsleepB.bin"), os_path(bindir, testsleepB + ".bin"))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        cmd = "{systemctl} enable zza.service"
        sh____(cmd.format(**locals()))
        cmd = "{systemctl} enable zzb.service"
        sh____(cmd.format(**locals()))
        #
        InitLoopSleep = 1
        initsystemctl = systemctl
        initsystemctl += " -c InitLoopSleep={InitLoopSleep}".format(**locals())
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = "{initsystemctl} -1"
        init = background(cmd.format(**locals()))
        time.sleep(InitLoopSleep+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*InitLoopSleep"))
        #
        cmd = "{systemctl} show zza.service -p JournalFilePath"
        journal_a=output(cmd.format(**locals())).strip().split("=", 1)[1]
        cmd = "{systemctl} show zzb.service -p JournalFilePath"
        journal_b=output(cmd.format(**locals())).strip().split("=", 1)[1]
        logg.info("journal zza = %s", journal_a)
        logg.info("journal zzb = %s", journal_b)
        time.sleep(1)
        self.assertTrue(os.path.exists(journal_a))
        self.assertTrue(os.path.exists(journal_b))
        out_a = open(journal_a).read()
        out_b = open(journal_b).read()
        self.assertTrue(greps(out_a, "running testsleepA"))
        self.assertTrue(greps(out_b, "running testsleepB"))
        self.assertFalse(greps(out_a, "running testsleepB"))
        self.assertFalse(greps(out_b, "running testsleepA"))
        log_a = root + "/var/log/zza.log"
        log_b = root + "/var/log/zzb.log"
        logg.info("log zza = %s", log_a)
        logg.info("log zzb = %s", log_b)
        self.assertTrue(os.path.exists(log_a))
        self.assertTrue(os.path.exists(log_b))
        out_a = open(log_a).read()
        out_b = open(log_b).read()
        logg.info("out_a=%s", out_a.strip())
        logg.info("out_b=%s", out_b.strip())
        self.assertTrue(greps(out_a, "starts testsleepA"))
        self.assertTrue(greps(out_b, "starts testsleepB"))
        self.assertFalse(greps(out_a, "starts testsleepB"))
        self.assertFalse(greps(out_b, "starts testsleepA"))
        #
        logg.info("kill daemon at %s", init.pid)
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4313_background_logfile_journal(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleepA = self.testname("sleepA")
        testsleepB = self.testname("sleepB")
        bindir = os_path(root, "/usr/bin")
        shell_file(os_path(testdir, "testsleepA.bin"), """
            #! /bin/sh
            echo starts testsleepA >&2
            echo running testsleepA
            exec {bindir}/{testsleepA} "$@"
            """.format(**locals()))
        shell_file(os_path(testdir, "testsleepB.bin"), """
            #! /bin/sh
            echo starts testsleepB >&2
            echo running testsleepB
            exec {bindir}/{testsleepB} "$@"
            """.format(**locals()))
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepA}.bin 4
            StandardOutput=file:{root}/var/log/zza.log
            StandardError=journal
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepB}.bin 5
            StandardOutput=file:{root}/var/log/zzb.log
            StandardError=journal
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleepA))
        copy_tool(_bin_sleep, os_path(bindir, testsleepB))
        copy_tool(os_path(testdir, "testsleepA.bin"), os_path(bindir, testsleepA + ".bin"))
        copy_tool(os_path(testdir, "testsleepB.bin"), os_path(bindir, testsleepB + ".bin"))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        cmd = "{systemctl} enable zza.service"
        sh____(cmd.format(**locals()))
        cmd = "{systemctl} enable zzb.service"
        sh____(cmd.format(**locals()))
        #
        InitLoopSleep = 1
        initsystemctl = systemctl
        initsystemctl += " -c InitLoopSleep={InitLoopSleep}".format(**locals())
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = "{initsystemctl} -1"
        init = background(cmd.format(**locals()))
        time.sleep(InitLoopSleep+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*InitLoopSleep"))
        #
        cmd = "{systemctl} show zza.service -p JournalFilePath"
        journal_a=output(cmd.format(**locals())).strip().split("=", 1)[1]
        cmd = "{systemctl} show zzb.service -p JournalFilePath"
        journal_b=output(cmd.format(**locals())).strip().split("=", 1)[1]
        logg.info("journal zza = %s", journal_a)
        logg.info("journal zzb = %s", journal_b)
        time.sleep(1)
        self.assertTrue(os.path.exists(journal_a))
        self.assertTrue(os.path.exists(journal_b))
        out_a = open(journal_a).read()
        out_b = open(journal_b).read()
        self.assertTrue(greps(out_a, "starts testsleepA"))
        self.assertTrue(greps(out_b, "starts testsleepB"))
        self.assertFalse(greps(out_a, "starts testsleepB"))
        self.assertFalse(greps(out_b, "starts testsleepA"))
        log_a = root + "/var/log/zza.log"
        log_b = root + "/var/log/zzb.log"
        logg.info("log zza = %s", log_a)
        logg.info("log zzb = %s", log_b)
        self.assertTrue(os.path.exists(log_a))
        self.assertTrue(os.path.exists(log_b))
        out_a = open(log_a).read()
        out_b = open(log_b).read()
        logg.info("out_a=%s", out_a.strip())
        logg.info("out_b=%s", out_b.strip())
        self.assertTrue(greps(out_a, "running testsleepA"))
        self.assertTrue(greps(out_b, "running testsleepB"))
        self.assertFalse(greps(out_a, "running testsleepB"))
        self.assertFalse(greps(out_b, "running testsleepA"))
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4321_background_logfile_journal(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleepA = self.testname("sleepA")
        testsleepB = self.testname("sleepB")
        bindir = os_path(root, "/usr/bin")
        shell_file(os_path(testdir, "testsleepA.bin"), """
            #! /bin/sh
            echo starts testsleepA >&2
            echo running testsleepA
            exec {bindir}/{testsleepA} "$@"
            """.format(**locals()))
        shell_file(os_path(testdir, "testsleepB.bin"), """
            #! /bin/sh
            echo starts testsleepB >&2
            echo running testsleepB
            exec {bindir}/{testsleepB} "$@"
            """.format(**locals()))
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepA}.bin 4
            StandardOutput=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepB}.bin 5
            StandardOutput=file:{root}/var/log/zzb.log
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "append.log"), "append")
        copy_tool(_bin_sleep, os_path(bindir, testsleepA))
        copy_tool(_bin_sleep, os_path(bindir, testsleepB))
        copy_tool(os_path(testdir, "testsleepA.bin"), os_path(bindir, testsleepA + ".bin"))
        copy_tool(os_path(testdir, "testsleepB.bin"), os_path(bindir, testsleepB + ".bin"))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        copy_file(os_path(testdir, "append.log"), os_path(root, "/var/log/zza.log"))
        copy_file(os_path(testdir, "append.log"), os_path(root, "/var/log/zzb.log"))
        cmd = "{systemctl} enable zza.service"
        sh____(cmd.format(**locals()))
        cmd = "{systemctl} enable zzb.service"
        sh____(cmd.format(**locals()))
        #
        InitLoopSleep = 1
        initsystemctl = systemctl
        initsystemctl += " -c InitLoopSleep={InitLoopSleep}".format(**locals())
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = "{initsystemctl} -1"
        init = background(cmd.format(**locals()))
        time.sleep(InitLoopSleep+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*InitLoopSleep"))
        #
        cmd = "{systemctl} show zza.service -p JournalFilePath"
        journal_a=output(cmd.format(**locals())).strip().split("=", 1)[1]
        cmd = "{systemctl} show zzb.service -p JournalFilePath"
        journal_b=output(cmd.format(**locals())).strip().split("=", 1)[1]
        logg.info("journal zza = %s", journal_a)
        logg.info("journal zzb = %s", journal_b)
        time.sleep(1)
        self.assertFalse(os.path.exists(journal_a))
        self.assertFalse(os.path.exists(journal_b))
        log_a = root + "/var/log/zza.log"
        log_b = root + "/var/log/zzb.log"
        logg.info("log zza = %s", log_a)
        logg.info("log zzb = %s", log_b)
        self.assertTrue(os.path.exists(log_a))
        self.assertTrue(os.path.exists(log_b))
        out_a = open(log_a).read()
        out_b = open(log_b).read()
        logg.info("out_a=%s", out_a.strip())
        logg.info("out_b=%s", out_b.strip())
        self.assertTrue(greps(out_a, "running testsleepA"))
        self.assertTrue(greps(out_b, "running testsleepB"))
        self.assertFalse(greps(out_a, "running testsleepB"))
        self.assertFalse(greps(out_b, "running testsleepA"))
        self.assertTrue(greps(out_a, "starts testsleepA"))
        self.assertTrue(greps(out_b, "starts testsleepB"))
        self.assertFalse(greps(out_a, "starts testsleepB"))
        self.assertFalse(greps(out_b, "starts testsleepA"))
        self.assertFalse(greps(out_a, "append"))
        self.assertFalse(greps(out_b, "append"))
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4322_background_logfile_journal(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleepA = self.testname("sleepA")
        testsleepB = self.testname("sleepB")
        bindir = os_path(root, "/usr/bin")
        shell_file(os_path(testdir, "testsleepA.bin"), """
            #! /bin/sh
            echo starts testsleepA >&2
            echo running testsleepA
            exec {bindir}/{testsleepA} "$@"
            """.format(**locals()))
        shell_file(os_path(testdir, "testsleepB.bin"), """
            #! /bin/sh
            echo starts testsleepB >&2
            echo running testsleepB
            exec {bindir}/{testsleepB} "$@"
            """.format(**locals()))
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepA}.bin 4
            StandardError=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepB}.bin 5
            StandardError=file:{root}/var/log/zzb.log
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "append.log"), "append")
        copy_tool(_bin_sleep, os_path(bindir, testsleepA))
        copy_tool(_bin_sleep, os_path(bindir, testsleepB))
        copy_tool(os_path(testdir, "testsleepA.bin"), os_path(bindir, testsleepA + ".bin"))
        copy_tool(os_path(testdir, "testsleepB.bin"), os_path(bindir, testsleepB + ".bin"))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        copy_file(os_path(testdir, "append.log"), os_path(root, "/var/log/zza.log"))
        copy_file(os_path(testdir, "append.log"), os_path(root, "/var/log/zzb.log"))
        cmd = "{systemctl} enable zza.service"
        sh____(cmd.format(**locals()))
        cmd = "{systemctl} enable zzb.service"
        sh____(cmd.format(**locals()))
        #
        InitLoopSleep = 1
        initsystemctl = systemctl
        initsystemctl += " -c InitLoopSleep={InitLoopSleep}".format(**locals())
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = "{initsystemctl} -1"
        init = background(cmd.format(**locals()))
        time.sleep(InitLoopSleep+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*InitLoopSleep"))
        #
        cmd = "{systemctl} show zza.service -p JournalFilePath"
        journal_a=output(cmd.format(**locals())).strip().split("=", 1)[1]
        cmd = "{systemctl} show zzb.service -p JournalFilePath"
        journal_b=output(cmd.format(**locals())).strip().split("=", 1)[1]
        logg.info("journal zza = %s", journal_a)
        logg.info("journal zzb = %s", journal_b)
        time.sleep(1)
        self.assertTrue(os.path.exists(journal_a))
        self.assertTrue(os.path.exists(journal_b))
        out_a = open(journal_a).read()
        out_b = open(journal_b).read()
        self.assertTrue(greps(out_a, "running testsleepA"))
        self.assertTrue(greps(out_b, "running testsleepB"))
        self.assertFalse(greps(out_a, "running testsleepB"))
        self.assertFalse(greps(out_b, "running testsleepA"))
        log_a = root + "/var/log/zza.log"
        log_b = root + "/var/log/zzb.log"
        logg.info("log zza = %s", log_a)
        logg.info("log zzb = %s", log_b)
        self.assertTrue(os.path.exists(log_a))
        self.assertTrue(os.path.exists(log_b))
        out_a = open(log_a).read()
        out_b = open(log_b).read()
        logg.info("out_a=%s", out_a.strip())
        logg.info("out_b=%s", out_b.strip())
        self.assertTrue(greps(out_a, "starts testsleepA"))
        self.assertTrue(greps(out_b, "starts testsleepB"))
        self.assertFalse(greps(out_a, "starts testsleepB"))
        self.assertFalse(greps(out_b, "starts testsleepA"))
        self.assertFalse(greps(out_a, "append"))
        self.assertFalse(greps(out_b, "append"))
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4323_background_logfile_journal(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleepA = self.testname("sleepA")
        testsleepB = self.testname("sleepB")
        bindir = os_path(root, "/usr/bin")
        shell_file(os_path(testdir, "testsleepA.bin"), """
            #! /bin/sh
            echo starts testsleepA >&2
            echo running testsleepA
            exec {bindir}/{testsleepA} "$@"
            """.format(**locals()))
        shell_file(os_path(testdir, "testsleepB.bin"), """
            #! /bin/sh
            echo starts testsleepB >&2
            echo running testsleepB
            exec {bindir}/{testsleepB} "$@"
            """.format(**locals()))
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepA}.bin 4
            StandardOutput=file:{root}/var/log/zza.log
            StandardError=journal
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepB}.bin 5
            StandardOutput=file:{root}/var/log/zzb.log
            StandardError=journal
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "append.log"), "append")
        copy_tool(_bin_sleep, os_path(bindir, testsleepA))
        copy_tool(_bin_sleep, os_path(bindir, testsleepB))
        copy_tool(os_path(testdir, "testsleepA.bin"), os_path(bindir, testsleepA + ".bin"))
        copy_tool(os_path(testdir, "testsleepB.bin"), os_path(bindir, testsleepB + ".bin"))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        copy_file(os_path(testdir, "append.log"), os_path(root, "/var/log/zza.log"))
        copy_file(os_path(testdir, "append.log"), os_path(root, "/var/log/zzb.log"))
        cmd = "{systemctl} enable zza.service"
        sh____(cmd.format(**locals()))
        cmd = "{systemctl} enable zzb.service"
        sh____(cmd.format(**locals()))
        #
        InitLoopSleep = 1
        initsystemctl = systemctl
        initsystemctl += " -c InitLoopSleep={InitLoopSleep}".format(**locals())
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = "{initsystemctl} -1"
        init = background(cmd.format(**locals()))
        time.sleep(InitLoopSleep+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*InitLoopSleep"))
        #
        cmd = "{systemctl} show zza.service -p JournalFilePath"
        journal_a=output(cmd.format(**locals())).strip().split("=", 1)[1]
        cmd = "{systemctl} show zzb.service -p JournalFilePath"
        journal_b=output(cmd.format(**locals())).strip().split("=", 1)[1]
        logg.info("journal zza = %s", journal_a)
        logg.info("journal zzb = %s", journal_b)
        time.sleep(1)
        self.assertTrue(os.path.exists(journal_a))
        self.assertTrue(os.path.exists(journal_b))
        out_a = open(journal_a).read()
        out_b = open(journal_b).read()
        self.assertTrue(greps(out_a, "starts testsleepA"))
        self.assertTrue(greps(out_b, "starts testsleepB"))
        self.assertFalse(greps(out_a, "starts testsleepB"))
        self.assertFalse(greps(out_b, "starts testsleepA"))
        log_a = root + "/var/log/zza.log"
        log_b = root + "/var/log/zzb.log"
        logg.info("log zza = %s", log_a)
        logg.info("log zzb = %s", log_b)
        self.assertTrue(os.path.exists(log_a))
        self.assertTrue(os.path.exists(log_b))
        out_a = open(log_a).read()
        out_b = open(log_b).read()
        logg.info("out_a=%s", out_a.strip())
        logg.info("out_b=%s", out_b.strip())
        self.assertTrue(greps(out_a, "running testsleepA"))
        self.assertTrue(greps(out_b, "running testsleepB"))
        self.assertFalse(greps(out_a, "running testsleepB"))
        self.assertFalse(greps(out_b, "running testsleepA"))
        self.assertFalse(greps(out_a, "append"))
        self.assertFalse(greps(out_b, "append"))
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4331_background_logfile_journal(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleepA = self.testname("sleepA")
        testsleepB = self.testname("sleepB")
        bindir = os_path(root, "/usr/bin")
        shell_file(os_path(testdir, "testsleepA.bin"), """
            #! /bin/sh
            echo starts testsleepA >&2
            echo running testsleepA
            exec {bindir}/{testsleepA} "$@"
            """.format(**locals()))
        shell_file(os_path(testdir, "testsleepB.bin"), """
            #! /bin/sh
            echo starts testsleepB >&2
            echo running testsleepB
            exec {bindir}/{testsleepB} "$@"
            """.format(**locals()))
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepA}.bin 4
            StandardOutput=append:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepB}.bin 5
            StandardOutput=append:{root}/var/log/zzb.log
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "append.log"), "append")
        copy_tool(_bin_sleep, os_path(bindir, testsleepA))
        copy_tool(_bin_sleep, os_path(bindir, testsleepB))
        copy_tool(os_path(testdir, "testsleepA.bin"), os_path(bindir, testsleepA + ".bin"))
        copy_tool(os_path(testdir, "testsleepB.bin"), os_path(bindir, testsleepB + ".bin"))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        copy_file(os_path(testdir, "append.log"), os_path(root, "/var/log/zza.log"))
        copy_file(os_path(testdir, "append.log"), os_path(root, "/var/log/zzb.log"))
        cmd = "{systemctl} enable zza.service"
        sh____(cmd.format(**locals()))
        cmd = "{systemctl} enable zzb.service"
        sh____(cmd.format(**locals()))
        #
        InitLoopSleep = 1
        initsystemctl = systemctl
        initsystemctl += " -c InitLoopSleep={InitLoopSleep}".format(**locals())
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = "{initsystemctl} -1"
        init = background(cmd.format(**locals()))
        time.sleep(InitLoopSleep+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*InitLoopSleep"))
        #
        cmd = "{systemctl} show zza.service -p JournalFilePath"
        journal_a=output(cmd.format(**locals())).strip().split("=", 1)[1]
        cmd = "{systemctl} show zzb.service -p JournalFilePath"
        journal_b=output(cmd.format(**locals())).strip().split("=", 1)[1]
        logg.info("journal zza = %s", journal_a)
        logg.info("journal zzb = %s", journal_b)
        time.sleep(1)
        self.assertFalse(os.path.exists(journal_a))
        self.assertFalse(os.path.exists(journal_b))
        log_a = root + "/var/log/zza.log"
        log_b = root + "/var/log/zzb.log"
        logg.info("log zza = %s", log_a)
        logg.info("log zzb = %s", log_b)
        self.assertTrue(os.path.exists(log_a))
        self.assertTrue(os.path.exists(log_b))
        out_a = open(log_a).read()
        out_b = open(log_b).read()
        logg.info("out_a=%s", out_a.strip())
        logg.info("out_b=%s", out_b.strip())
        self.assertTrue(greps(out_a, "running testsleepA"))
        self.assertTrue(greps(out_b, "running testsleepB"))
        self.assertFalse(greps(out_a, "running testsleepB"))
        self.assertFalse(greps(out_b, "running testsleepA"))
        self.assertTrue(greps(out_a, "starts testsleepA"))
        self.assertTrue(greps(out_b, "starts testsleepB"))
        self.assertFalse(greps(out_a, "starts testsleepB"))
        self.assertFalse(greps(out_b, "starts testsleepA"))
        self.assertTrue(greps(out_a, "append"))
        self.assertTrue(greps(out_b, "append"))
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4332_background_logfile_journal(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleepA = self.testname("sleepA")
        testsleepB = self.testname("sleepB")
        bindir = os_path(root, "/usr/bin")
        shell_file(os_path(testdir, "testsleepA.bin"), """
            #! /bin/sh
            echo starts testsleepA >&2
            echo running testsleepA
            exec {bindir}/{testsleepA} "$@"
            """.format(**locals()))
        shell_file(os_path(testdir, "testsleepB.bin"), """
            #! /bin/sh
            echo starts testsleepB >&2
            echo running testsleepB
            exec {bindir}/{testsleepB} "$@"
            """.format(**locals()))
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepA}.bin 4
            StandardError=append:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepB}.bin 5
            StandardError=append:{root}/var/log/zzb.log
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "append.log"), "append")
        copy_tool(_bin_sleep, os_path(bindir, testsleepA))
        copy_tool(_bin_sleep, os_path(bindir, testsleepB))
        copy_tool(os_path(testdir, "testsleepA.bin"), os_path(bindir, testsleepA + ".bin"))
        copy_tool(os_path(testdir, "testsleepB.bin"), os_path(bindir, testsleepB + ".bin"))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        copy_file(os_path(testdir, "append.log"), os_path(root, "/var/log/zza.log"))
        copy_file(os_path(testdir, "append.log"), os_path(root, "/var/log/zzb.log"))
        cmd = "{systemctl} enable zza.service"
        sh____(cmd.format(**locals()))
        cmd = "{systemctl} enable zzb.service"
        sh____(cmd.format(**locals()))
        #
        InitLoopSleep = 1
        initsystemctl = systemctl
        initsystemctl += " -c InitLoopSleep={InitLoopSleep}".format(**locals())
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = "{initsystemctl} -1"
        init = background(cmd.format(**locals()))
        time.sleep(InitLoopSleep+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*InitLoopSleep"))
        #
        cmd = "{systemctl} show zza.service -p JournalFilePath"
        journal_a=output(cmd.format(**locals())).strip().split("=", 1)[1]
        cmd = "{systemctl} show zzb.service -p JournalFilePath"
        journal_b=output(cmd.format(**locals())).strip().split("=", 1)[1]
        logg.info("journal zza = %s", journal_a)
        logg.info("journal zzb = %s", journal_b)
        time.sleep(1)
        self.assertTrue(os.path.exists(journal_a))
        self.assertTrue(os.path.exists(journal_b))
        out_a = open(journal_a).read()
        out_b = open(journal_b).read()
        self.assertTrue(greps(out_a, "running testsleepA"))
        self.assertTrue(greps(out_b, "running testsleepB"))
        self.assertFalse(greps(out_a, "running testsleepB"))
        self.assertFalse(greps(out_b, "running testsleepA"))
        log_a = root + "/var/log/zza.log"
        log_b = root + "/var/log/zzb.log"
        logg.info("log zza = %s", log_a)
        logg.info("log zzb = %s", log_b)
        self.assertTrue(os.path.exists(log_a))
        self.assertTrue(os.path.exists(log_b))
        out_a = open(log_a).read()
        out_b = open(log_b).read()
        logg.info("out_a=%s", out_a.strip())
        logg.info("out_b=%s", out_b.strip())
        self.assertTrue(greps(out_a, "starts testsleepA"))
        self.assertTrue(greps(out_b, "starts testsleepB"))
        self.assertFalse(greps(out_a, "starts testsleepB"))
        self.assertFalse(greps(out_b, "starts testsleepA"))
        self.assertTrue(greps(out_a, "append"))
        self.assertTrue(greps(out_b, "append"))
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4333_background_logfile_journal(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleepA = self.testname("sleepA")
        testsleepB = self.testname("sleepB")
        bindir = os_path(root, "/usr/bin")
        shell_file(os_path(testdir, "testsleepA.bin"), """
            #! /bin/sh
            echo starts testsleepA >&2
            echo running testsleepA
            exec {bindir}/{testsleepA} "$@"
            """.format(**locals()))
        shell_file(os_path(testdir, "testsleepB.bin"), """
            #! /bin/sh
            echo starts testsleepB >&2
            echo running testsleepB
            exec {bindir}/{testsleepB} "$@"
            """.format(**locals()))
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepA}.bin 4
            StandardOutput=append:{root}/var/log/zza.log
            StandardError=journal
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepB}.bin 5
            StandardOutput=append:{root}/var/log/zzb.log
            StandardError=journal
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "append.log"), "append")
        copy_tool(_bin_sleep, os_path(bindir, testsleepA))
        copy_tool(_bin_sleep, os_path(bindir, testsleepB))
        copy_tool(os_path(testdir, "testsleepA.bin"), os_path(bindir, testsleepA + ".bin"))
        copy_tool(os_path(testdir, "testsleepB.bin"), os_path(bindir, testsleepB + ".bin"))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        copy_file(os_path(testdir, "append.log"), os_path(root, "/var/log/zza.log"))
        copy_file(os_path(testdir, "append.log"), os_path(root, "/var/log/zzb.log"))
        cmd = "{systemctl} enable zza.service"
        sh____(cmd.format(**locals()))
        cmd = "{systemctl} enable zzb.service"
        sh____(cmd.format(**locals()))
        #
        InitLoopSleep = 1
        initsystemctl = systemctl
        initsystemctl += " -c InitLoopSleep={InitLoopSleep}".format(**locals())
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = "{initsystemctl} -1"
        init = background(cmd.format(**locals()))
        time.sleep(InitLoopSleep+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*InitLoopSleep"))
        #
        cmd = "{systemctl} show zza.service -p JournalFilePath"
        journal_a=output(cmd.format(**locals())).strip().split("=", 1)[1]
        cmd = "{systemctl} show zzb.service -p JournalFilePath"
        journal_b=output(cmd.format(**locals())).strip().split("=", 1)[1]
        logg.info("journal zza = %s", journal_a)
        logg.info("journal zzb = %s", journal_b)
        time.sleep(1)
        self.assertTrue(os.path.exists(journal_a))
        self.assertTrue(os.path.exists(journal_b))
        out_a = open(journal_a).read()
        out_b = open(journal_b).read()
        self.assertTrue(greps(out_a, "starts testsleepA"))
        self.assertTrue(greps(out_b, "starts testsleepB"))
        self.assertFalse(greps(out_a, "starts testsleepB"))
        self.assertFalse(greps(out_b, "starts testsleepA"))
        log_a = root + "/var/log/zza.log"
        log_b = root + "/var/log/zzb.log"
        logg.info("log zza = %s", log_a)
        logg.info("log zzb = %s", log_b)
        self.assertTrue(os.path.exists(log_a))
        self.assertTrue(os.path.exists(log_b))
        out_a = open(log_a).read()
        out_b = open(log_b).read()
        logg.info("out_a=%s", out_a.strip())
        logg.info("out_b=%s", out_b.strip())
        self.assertTrue(greps(out_a, "running testsleepA"))
        self.assertTrue(greps(out_b, "running testsleepB"))
        self.assertFalse(greps(out_a, "running testsleepB"))
        self.assertFalse(greps(out_b, "running testsleepA"))
        self.assertTrue(greps(out_a, "append"))
        self.assertTrue(greps(out_b, "append"))
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4351_background_logfile_journal(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleepA = self.testname("sleepA")
        testsleepB = self.testname("sleepB")
        bindir = os_path(root, "/usr/bin")
        shell_file(os_path(testdir, "testsleepA.bin"), """
            #! /bin/sh
            echo starts testsleepA >&2
            echo running testsleepA
            exec {bindir}/{testsleepA} "$@"
            """.format(**locals()))
        shell_file(os_path(testdir, "testsleepB.bin"), """
            #! /bin/sh
            echo starts testsleepB >&2
            echo running testsleepB
            exec {bindir}/{testsleepB} "$@"
            """.format(**locals()))
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepA}.bin 4
            StandardOutput=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepB}.bin 5
            StandardOutput=file:{root}/var/log/zzb.log
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleepA))
        copy_tool(_bin_sleep, os_path(bindir, testsleepB))
        copy_tool(os_path(testdir, "testsleepA.bin"), os_path(bindir, testsleepA + ".bin"))
        copy_tool(os_path(testdir, "testsleepB.bin"), os_path(bindir, testsleepB + ".bin"))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        os.makedirs(os_path(root, "/var/log/zza.log"))
        os.makedirs(os_path(root, "/var/log/zzb.log"))
        cmd = "{systemctl} enable zza.service"
        sh____(cmd.format(**locals()))
        cmd = "{systemctl} enable zzb.service"
        sh____(cmd.format(**locals()))
        #
        InitLoopSleep = 1
        initsystemctl = systemctl
        initsystemctl += " -c InitLoopSleep={InitLoopSleep}".format(**locals())
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = "{initsystemctl} -1"
        init = background(cmd.format(**locals()))
        time.sleep(InitLoopSleep+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*InitLoopSleep"))
        #
        cmd = "{systemctl} show zza.service -p JournalFilePath"
        journal_a=output(cmd.format(**locals())).strip().split("=", 1)[1]
        cmd = "{systemctl} show zzb.service -p JournalFilePath"
        journal_b=output(cmd.format(**locals())).strip().split("=", 1)[1]
        logg.info("journal zza = %s", journal_a)
        logg.info("journal zzb = %s", journal_b)
        time.sleep(1)
        self.assertTrue(os.path.exists(journal_a))
        self.assertTrue(os.path.exists(journal_b))
        log_a = root + "/var/log/zza.log"
        log_b = root + "/var/log/zzb.log"
        logg.info("log zza = %s", log_a)
        logg.info("log zzb = %s", log_b)
        # self.assertFalse(os.path.exists(log_a))
        # self.assertFalse(os.path.exists(log_b))
        #
        out_a = open(journal_a).read()
        out_b = open(journal_b).read()
        logg.info("out_a=%s", out_a.strip())
        logg.info("out_b=%s", out_b.strip())
        self.assertTrue(greps(out_a, "running testsleepA"))
        self.assertTrue(greps(out_b, "running testsleepB"))
        self.assertFalse(greps(out_a, "running testsleepB"))
        self.assertFalse(greps(out_b, "running testsleepA"))
        self.assertTrue(greps(out_a, "starts testsleepA"))
        self.assertTrue(greps(out_b, "starts testsleepB"))
        self.assertFalse(greps(out_a, "starts testsleepB"))
        self.assertFalse(greps(out_b, "starts testsleepA"))
        self.assertFalse(greps(out_a, "append"))
        self.assertFalse(greps(out_b, "append"))
        self.assertTrue(greps(out_a, "Is a directory"))
        self.assertTrue(greps(out_b, "Is a directory"))
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4352_background_logfile_journal(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleepA = self.testname("sleepA")
        testsleepB = self.testname("sleepB")
        bindir = os_path(root, "/usr/bin")
        shell_file(os_path(testdir, "testsleepA.bin"), """
            #! /bin/sh
            echo starts testsleepA >&2
            echo running testsleepA
            exec {bindir}/{testsleepA} "$@"
            """.format(**locals()))
        shell_file(os_path(testdir, "testsleepB.bin"), """
            #! /bin/sh
            echo starts testsleepB >&2
            echo running testsleepB
            exec {bindir}/{testsleepB} "$@"
            """.format(**locals()))
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepA}.bin 4
            StandardError=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepB}.bin 5
            StandardError=file:{root}/var/log/zzb.log
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleepA))
        copy_tool(_bin_sleep, os_path(bindir, testsleepB))
        copy_tool(os_path(testdir, "testsleepA.bin"), os_path(bindir, testsleepA + ".bin"))
        copy_tool(os_path(testdir, "testsleepB.bin"), os_path(bindir, testsleepB + ".bin"))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        os.makedirs(os_path(root, "/var/log/zza.log"))
        os.makedirs(os_path(root, "/var/log/zzb.log"))
        cmd = "{systemctl} enable zza.service"
        sh____(cmd.format(**locals()))
        cmd = "{systemctl} enable zzb.service"
        sh____(cmd.format(**locals()))
        #
        InitLoopSleep = 1
        initsystemctl = systemctl
        initsystemctl += " -c InitLoopSleep={InitLoopSleep}".format(**locals())
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = "{initsystemctl} -1"
        init = background(cmd.format(**locals()))
        time.sleep(InitLoopSleep+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*InitLoopSleep"))
        #
        cmd = "{systemctl} show zza.service -p JournalFilePath"
        journal_a=output(cmd.format(**locals())).strip().split("=", 1)[1]
        cmd = "{systemctl} show zzb.service -p JournalFilePath"
        journal_b=output(cmd.format(**locals())).strip().split("=", 1)[1]
        logg.info("journal zza = %s", journal_a)
        logg.info("journal zzb = %s", journal_b)
        time.sleep(1)
        self.assertTrue(os.path.exists(journal_a))
        self.assertTrue(os.path.exists(journal_b))
        out_a = open(journal_a).read()
        out_b = open(journal_b).read()
        self.assertTrue(greps(out_a, "running testsleepA"))
        self.assertTrue(greps(out_b, "running testsleepB"))
        self.assertFalse(greps(out_a, "running testsleepB"))
        self.assertFalse(greps(out_b, "running testsleepA"))
        log_a = root + "/var/log/zza.log"
        log_b = root + "/var/log/zzb.log"
        logg.info("log zza = %s", log_a)
        logg.info("log zzb = %s", log_b)
        self.assertTrue(os.path.exists(log_a))
        self.assertTrue(os.path.exists(log_b))
        #
        out_a = open(journal_a).read()
        out_b = open(journal_b).read()
        logg.info("out_a=%s", out_a.strip())
        logg.info("out_b=%s", out_b.strip())
        self.assertTrue(greps(out_a, "starts testsleepA"))
        self.assertTrue(greps(out_b, "starts testsleepB"))
        self.assertFalse(greps(out_a, "starts testsleepB"))
        self.assertFalse(greps(out_b, "starts testsleepA"))
        self.assertFalse(greps(out_a, "append"))
        self.assertFalse(greps(out_b, "append"))
        self.assertTrue(greps(out_a, "Is a directory"))
        self.assertTrue(greps(out_b, "Is a directory"))
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4353_background_logfile_journal(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleepA = self.testname("sleepA")
        testsleepB = self.testname("sleepB")
        bindir = os_path(root, "/usr/bin")
        shell_file(os_path(testdir, "testsleepA.bin"), """
            #! /bin/sh
            echo starts testsleepA >&2
            echo running testsleepA
            exec {bindir}/{testsleepA} "$@"
            """.format(**locals()))
        shell_file(os_path(testdir, "testsleepB.bin"), """
            #! /bin/sh
            echo starts testsleepB >&2
            echo running testsleepB
            exec {bindir}/{testsleepB} "$@"
            """.format(**locals()))
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepA}.bin 4
            StandardOutput=file:{root}/var/log/zza.log
            StandardError=journal
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepB}.bin 5
            StandardOutput=file:{root}/var/log/zzb.log
            StandardError=journal
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool(_bin_sleep, os_path(bindir, testsleepA))
        copy_tool(_bin_sleep, os_path(bindir, testsleepB))
        copy_tool(os_path(testdir, "testsleepA.bin"), os_path(bindir, testsleepA + ".bin"))
        copy_tool(os_path(testdir, "testsleepB.bin"), os_path(bindir, testsleepB + ".bin"))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        os.makedirs(os_path(root, "/var/log/zza.log"))
        os.makedirs(os_path(root, "/var/log/zzb.log"))
        cmd = "{systemctl} enable zza.service"
        sh____(cmd.format(**locals()))
        cmd = "{systemctl} enable zzb.service"
        sh____(cmd.format(**locals()))
        #
        InitLoopSleep = 1
        initsystemctl = systemctl
        initsystemctl += " -c InitLoopSleep={InitLoopSleep}".format(**locals())
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = "{initsystemctl} -1"
        init = background(cmd.format(**locals()))
        time.sleep(InitLoopSleep+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*InitLoopSleep"))
        #
        cmd = "{systemctl} show zza.service -p JournalFilePath"
        journal_a=output(cmd.format(**locals())).strip().split("=", 1)[1]
        cmd = "{systemctl} show zzb.service -p JournalFilePath"
        journal_b=output(cmd.format(**locals())).strip().split("=", 1)[1]
        logg.info("journal zza = %s", journal_a)
        logg.info("journal zzb = %s", journal_b)
        time.sleep(1)
        self.assertTrue(os.path.exists(journal_a))
        self.assertTrue(os.path.exists(journal_b))
        out_a = open(journal_a).read()
        out_b = open(journal_b).read()
        self.assertTrue(greps(out_a, "starts testsleepA"))
        self.assertTrue(greps(out_b, "starts testsleepB"))
        self.assertFalse(greps(out_a, "starts testsleepB"))
        self.assertFalse(greps(out_b, "starts testsleepA"))
        log_a = root + "/var/log/zza.log"
        log_b = root + "/var/log/zzb.log"
        logg.info("log zza = %s", log_a)
        logg.info("log zzb = %s", log_b)
        self.assertTrue(os.path.exists(log_a))
        self.assertTrue(os.path.exists(log_b))
        #
        out_a = open(journal_a).read()
        out_b = open(journal_b).read()
        logg.info("out_a=%s", out_a.strip())
        logg.info("out_b=%s", out_b.strip())
        self.assertTrue(greps(out_a, "running testsleepA"))
        self.assertTrue(greps(out_b, "running testsleepB"))
        self.assertFalse(greps(out_a, "running testsleepB"))
        self.assertFalse(greps(out_b, "running testsleepA"))
        self.assertFalse(greps(out_a, "append"))
        self.assertFalse(greps(out_b, "append"))
        self.assertTrue(greps(out_a, "Is a directory"))
        self.assertTrue(greps(out_b, "Is a directory"))
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4401_background_logfile_input(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        replyA = self.testname("replyA")
        replyB = self.testname("replyB")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} echo
            StandardOutput=file:{root}/var/log/zza.log
            StandardInput=file:{root}/var/log/zza.txt
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart={bindir}/{replyB} echo
            StandardOutput=file:{root}/var/log/zzb.log
            StandardInput=file:{root}/var/log/zzb.txt
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zza.txt"), """testing zzA""")
        text_file(os_path(testdir, "zzb.txt"), """testing zzB""")
        copy_tool("reply.py", os_path(bindir, replyA))
        copy_tool("reply.py", os_path(bindir, replyB))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        copy_file(os_path(testdir, "zza.txt"), os_path(root, "/var/log/zza.txt"))
        copy_file(os_path(testdir, "zzb.txt"), os_path(root, "/var/log/zzb.txt"))
        cmd = "{systemctl} enable zza.service"
        sh____(cmd.format(**locals()))
        cmd = "{systemctl} enable zzb.service"
        sh____(cmd.format(**locals()))
        #
        InitLoopSleep = 1
        initsystemctl = systemctl
        initsystemctl += " -c InitLoopSleep={InitLoopSleep}".format(**locals())
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = "{initsystemctl} -1"
        init = background(cmd.format(**locals()))
        time.sleep(InitLoopSleep+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*InitLoopSleep"))
        #
        cmd = "{systemctl} show zza.service -p JournalFilePath"
        journal_a=output(cmd.format(**locals())).strip().split("=", 1)[1]
        cmd = "{systemctl} show zzb.service -p JournalFilePath"
        journal_b=output(cmd.format(**locals())).strip().split("=", 1)[1]
        logg.info("journal zza = %s", journal_a)
        logg.info("journal zzb = %s", journal_b)
        time.sleep(2)
        self.assertFalse(os.path.exists(journal_a))
        self.assertFalse(os.path.exists(journal_b))
        log_a = root + "/var/log/zza.log"
        log_b = root + "/var/log/zzb.log"
        logg.info("log zza = %s", log_a)
        logg.info("log zzb = %s", log_b)
        #
        out_a = open(log_a).read()
        out_b = open(log_b).read()
        logg.info("out_a=%s", out_a.strip())
        logg.info("out_b=%s", out_b.strip())
        self.assertTrue(greps(out_a, "TESTING ZZA"))
        self.assertTrue(greps(out_b, "TESTING ZZB"))
        self.assertFalse(greps(out_a, "TESTING ZZB"))
        self.assertFalse(greps(out_b, "TESTING ZZA"))
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4408_background_logfile_input_noexistant(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        replyA = self.testname("replyA")
        replyB = self.testname("replyB")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} echo
            StandardOutput=file:{root}/var/log/zza.log
            StandardInput=file:{root}/var/log/zza-nothing.txt
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart={bindir}/{replyB} echo
            StandardOutput=file:{root}/var/log/zzb.log
            StandardInput=file:{root}/var/log/zzb.txt
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zza.txt"), """testing zzA""")
        text_file(os_path(testdir, "zzb.txt"), """testing zzB""")
        copy_tool("reply.py", os_path(bindir, replyA))
        copy_tool("reply.py", os_path(bindir, replyB))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        copy_file(os_path(testdir, "zza.txt"), os_path(root, "/var/log/zza.txt"))
        copy_file(os_path(testdir, "zzb.txt"), os_path(root, "/var/log/zzb.txt"))
        cmd = "{systemctl} enable zza.service"
        sh____(cmd.format(**locals()))
        cmd = "{systemctl} enable zzb.service"
        sh____(cmd.format(**locals()))
        #
        InitLoopSleep = 1
        initsystemctl = systemctl
        initsystemctl += " -c InitLoopSleep={InitLoopSleep}".format(**locals())
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = "{initsystemctl} -1"
        init = background(cmd.format(**locals()))
        time.sleep(InitLoopSleep+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*InitLoopSleep"))
        #
        cmd = "{systemctl} show zza.service -p JournalFilePath"
        journal_a=output(cmd.format(**locals())).strip().split("=", 1)[1]
        cmd = "{systemctl} show zzb.service -p JournalFilePath"
        journal_b=output(cmd.format(**locals())).strip().split("=", 1)[1]
        logg.info("journal zza = %s", journal_a)
        logg.info("journal zzb = %s", journal_b)
        time.sleep(2)
        self.assertFalse(os.path.exists(journal_a))
        self.assertFalse(os.path.exists(journal_b))
        log_a = root + "/var/log/zza.log"
        log_b = root + "/var/log/zzb.log"
        logg.info("log zza = %s", log_a)
        logg.info("log zzb = %s", log_b)
        #
        out_a = open(log_a).read()
        out_b = open(log_b).read()
        logg.info("out_a=%s", out_a.strip())
        logg.info("out_b=%s", out_b.strip())
        self.assertFalse(greps(out_a, "TESTING ZZA"))
        self.assertTrue(greps(out_b, "TESTING ZZB"))
        self.assertFalse(greps(out_a, "TESTING ZZB"))
        self.assertFalse(greps(out_b, "TESTING ZZA"))
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4409_background_logfile_input_noexistant(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        replyA = self.testname("replyA")
        replyB = self.testname("replyB")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} echo
            StandardOutput=file:{root}/var/log/zza.log
            StandardInput=syslog
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart={bindir}/{replyB} echo
            StandardOutput=file:{root}/var/log/zzb.log
            StandardInput=file:{root}/var/log/zzb.txt
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zza.txt"), """testing zzA""")
        text_file(os_path(testdir, "zzb.txt"), """testing zzB""")
        copy_tool("reply.py", os_path(bindir, replyA))
        copy_tool("reply.py", os_path(bindir, replyB))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        copy_file(os_path(testdir, "zza.txt"), os_path(root, "/var/log/zza.txt"))
        copy_file(os_path(testdir, "zzb.txt"), os_path(root, "/var/log/zzb.txt"))
        cmd = "{systemctl} enable zza.service"
        sh____(cmd.format(**locals()))
        cmd = "{systemctl} enable zzb.service"
        sh____(cmd.format(**locals()))
        #
        InitLoopSleep = 1
        initsystemctl = systemctl
        initsystemctl += " -c InitLoopSleep={InitLoopSleep}".format(**locals())
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = "{initsystemctl} -1"
        init = background(cmd.format(**locals()))
        time.sleep(InitLoopSleep+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*InitLoopSleep"))
        #
        cmd = "{systemctl} show zza.service -p JournalFilePath"
        journal_a=output(cmd.format(**locals())).strip().split("=", 1)[1]
        cmd = "{systemctl} show zzb.service -p JournalFilePath"
        journal_b=output(cmd.format(**locals())).strip().split("=", 1)[1]
        logg.info("journal zza = %s", journal_a)
        logg.info("journal zzb = %s", journal_b)
        time.sleep(2)
        self.assertFalse(os.path.exists(journal_a))
        self.assertFalse(os.path.exists(journal_b))
        log_a = root + "/var/log/zza.log"
        log_b = root + "/var/log/zzb.log"
        logg.info("log zza = %s", log_a)
        logg.info("log zzb = %s", log_b)
        #
        out_a = open(log_a).read()
        out_b = open(log_b).read()
        logg.info("out_a=%s", out_a.strip())
        logg.info("out_b=%s", out_b.strip())
        self.assertFalse(greps(out_a, "TESTING ZZA"))
        self.assertTrue(greps(out_b, "TESTING ZZB"))
        self.assertFalse(greps(out_a, "TESTING ZZB"))
        self.assertFalse(greps(out_b, "TESTING ZZA"))
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_testdir()
        self.rm_killall()
        self.coverage()
        self.end()
    def test_4411_socket_accept(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        replyB = self.testname("replyB")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} serverUNIX -f {sockfile}
            StandardOutput=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zza.socket"), """
            [Unit]
            Description=Testing B
            [Socket]
            Accept=yes
            ListenStream={sockfile}
            Service=zza.service
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool("reply.py", os_path(bindir, replyA))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        cmd = "{systemctl} enable zza.socket"
        sh____(cmd.format(**locals()))
        #
        InitLoopSleep = 1
        initsystemctl = systemctl
        initsystemctl += " -c InitLoopSleep={InitLoopSleep}".format(**locals())
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = "{initsystemctl} -1"
        init = background(cmd.format(**locals()))
        time.sleep(InitLoopSleep+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*InitLoopSleep"))
        #
        oo = reads(debug_log.format(**locals()))
        logg.info("debug.log>>\%s", oo)
        #
        cmd = "./reply.py sendUNIX -d foo -f {sockfile}"
        out, end = output2(cmd.format(**locals()))
        self.assertEqual(end, 0)
        logg.info("send.log>>\n%s", out)
        self.assertTrue(greps(out, "request: foo"))
        self.assertTrue(greps(out, "replied: FOO"))
        #
        log = "{root}/var/log/zza.log"
        out = reads(log.format(**locals()))
        logg.info("zza.log>>%s", out)
        self.assertTrue(greps(out, "received:.*foo"))
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4412_start_socket_accept(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        replyB = self.testname("replyB")
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} serverUNIX -f {sockfile}
            StandardOutput=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zza.socket"), """
            [Unit]
            Description=Testing B
            [Socket]
            Accept=yes
            ListenStream={sockfile}
            Service=zza.service
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zzc.service"), """
            [Unit]
            Description=Testing C
            [Service]
            Accept=yes
            ExecStart={root}/usr/bin/{testsleep} 5
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool("reply.py", os_path(bindir, replyA))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        copy_file(os_path(testdir, "zzc.service"), os_path(root, "/etc/systemd/system/zzc.service"))
        cmd = "{systemctl} enable zzc.service"
        sh____(cmd.format(**locals()))
        #
        InitLoopSleep = 1
        initsystemctl = systemctl
        initsystemctl += " -c InitLoopSleep={InitLoopSleep}".format(**locals())
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = "{initsystemctl} -1"
        init = background(cmd.format(**locals()))
        time.sleep(InitLoopSleep+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*InitLoopSleep"))
        #
        oo = reads(debug_log.format(**locals()))
        logg.info("debug.log>>\%s", oo)
        #
        cmd = "./reply.py sendUNIX -d foo -f {sockfile}"
        out, end = output2(cmd.format(**locals()))
        self.assertEqual(end, 0)
        logg.info("send.log>>\n%s", out)
        self.assertTrue(greps(out, "request: foo"))
        self.assertFalse(greps(out, "replied: FOO"))
        #
        cmd = "{systemctl} start zza.socket -vvvv"
        sh____(cmd.format(**locals()))
        #
        cmd = "./reply.py sendUNIX -d foo -f {sockfile}"
        out, end = output2(cmd.format(**locals()))
        self.assertEqual(end, 0)
        logg.info("send.log>>\n%s", out)
        self.assertTrue(greps(out, "request: foo"))
        self.assertTrue(greps(out, "replied: FOO"))
        #
        log = "{root}/var/log/zza.log"
        out = reads(log.format(**locals()))
        logg.info("zza.log>>%s", out)
        self.assertTrue(greps(out, "received:.*foo"))
        #
        cmd = "{systemctl} stop zza.socket -vvvv"
        sh____(cmd.format(**locals()))
        #
        cmd = "./reply.py sendUNIX -d foo -f {sockfile}"
        out, end = output2(cmd.format(**locals()))
        self.assertEqual(end, 0)
        logg.info("send.log>>\n%s", out)
        self.assertTrue(greps(out, "request: foo"))
        self.assertFalse(greps(out, "replied: FOO"))
        #
        ##################################################
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4413_start_pre_socket_accept(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        replyB = self.testname("replyB")
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(root, "/var/run/zz.txt"), "zz")
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} serverUNIX -f {sockfile}
            StandardOutput=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zza.socket"), """
            [Unit]
            Description=Testing B
            [Socket]
            Accept=yes
            ListenStream={sockfile}
            Service=zza.service
            ExecStartPre=/usr/bin/touch {root}/var/run/zza.socket.pre.txt
            ExecStartPost=/usr/bin/touch {root}/var/run/zza.socket.post.txt
            ExecStopPost=/usr/bin/touch {root}/var/run/zza.socket.end.txt
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zzc.service"), """
            [Unit]
            Description=Testing C
            [Service]
            Accept=yes
            ExecStart={root}/usr/bin/{testsleep} 5
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool("reply.py", os_path(bindir, replyA))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        copy_file(os_path(testdir, "zzc.service"), os_path(root, "/etc/systemd/system/zzc.service"))
        cmd = "{systemctl} enable zzc.service"
        sh____(cmd.format(**locals()))
        #
        InitLoopSleep = 1
        initsystemctl = systemctl
        initsystemctl += " -c InitLoopSleep={InitLoopSleep}".format(**locals())
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = "{initsystemctl} -1"
        init = background(cmd.format(**locals()))
        time.sleep(InitLoopSleep+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*InitLoopSleep"))
        #
        oo = reads(debug_log.format(**locals()))
        logg.info("debug.log>>\%s", oo)
        #
        cmd = "./reply.py sendUNIX -d foo -f {sockfile}"
        out, end = output2(cmd.format(**locals()))
        self.assertEqual(end, 0)
        logg.info("send.log>>\n%s", out)
        self.assertTrue(greps(out, "request: foo"))
        self.assertFalse(greps(out, "replied: FOO"))
        #
        zza_pre = os_path(root, "/var/run/zza.socket.pre.txt")
        zza_post = os_path(root, "/var/run/zza.socket.post.txt")
        zza_end = os_path(root, "/var/run/zza.socket.end.txt")
        self.assertFalse(os.path.exists(zza_pre))
        self.assertFalse(os.path.exists(zza_post))
        self.assertFalse(os.path.exists(zza_end))
        #
        cmd = "{systemctl} start zza.socket -vvvv"
        sh____(cmd.format(**locals()))
        self.assertTrue(os.path.exists(zza_pre))
        self.assertTrue(os.path.exists(zza_post))
        self.assertFalse(os.path.exists(zza_end))
        #
        cmd = "./reply.py sendUNIX -d foo -f {sockfile}"
        out, end = output2(cmd.format(**locals()))
        self.assertEqual(end, 0)
        logg.info("send.log>>\n%s", out)
        self.assertTrue(greps(out, "request: foo"))
        self.assertTrue(greps(out, "replied: FOO"))
        #
        log = "{root}/var/log/zza.log"
        out = reads(log.format(**locals()))
        logg.info("zza.log>>%s", out)
        self.assertTrue(greps(out, "received:.*foo"))
        #
        cmd = "{systemctl} stop zza.socket -vvvv"
        sh____(cmd.format(**locals()))
        self.assertTrue(os.path.exists(zza_pre))
        self.assertTrue(os.path.exists(zza_post))
        self.assertTrue(os.path.exists(zza_end))
        #
        cmd = "./reply.py sendUNIX -d foo -f {sockfile}"
        out, end = output2(cmd.format(**locals()))
        self.assertEqual(end, 0)
        logg.info("send.log>>\n%s", out)
        self.assertTrue(greps(out, "request: foo"))
        self.assertFalse(greps(out, "replied: FOO"))
        #
        ##################################################
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4414_start_pre_enabled_socket_accept(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        replyB = self.testname("replyB")
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(root, "/var/run/zz.txt"), "zz")
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} serverUNIX -f {sockfile}
            StandardOutput=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zza.socket"), """
            [Unit]
            Description=Testing B
            [Socket]
            Accept=yes
            ListenStream={sockfile}
            Service=zza.service
            ExecStartPre=/usr/bin/touch {root}/var/run/zza.socket.pre.txt
            ExecStartPost=/usr/bin/touch {root}/var/run/zza.socket.post.txt
            ExecStopPost=/usr/bin/touch {root}/var/run/zza.socket.end.txt
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zzc.service"), """
            [Unit]
            Description=Testing C
            [Service]
            Accept=yes
            ExecStart={root}/usr/bin/{testsleep} 5
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool("reply.py", os_path(bindir, replyA))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        copy_file(os_path(testdir, "zzc.service"), os_path(root, "/etc/systemd/system/zzc.service"))
        cmd = "{systemctl} enable zza.socket"
        sh____(cmd.format(**locals()))
        #
        InitLoopSleep = 1
        initsystemctl = systemctl
        initsystemctl += " -c InitLoopSleep={InitLoopSleep}".format(**locals())
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        sx____("ls -l {root}/var/run/zz*".format(**locals()))
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = "{initsystemctl} -1"
        init = background(cmd.format(**locals()))
        time.sleep(InitLoopSleep+1)
        #
        sx____("ls -l {root}/var/run/zz*".format(**locals()))
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*InitLoopSleep"))
        #
        oo = reads(debug_log.format(**locals()))
        logg.info("debug.log>>\%s", i2(oo))
        #
        sx____("ls -l {root}/var/run/zz*".format(**locals()))
        zza_pre = os_path(root, "/var/run/zza.socket.pre.txt")
        zza_post = os_path(root, "/var/run/zza.socket.post.txt")
        zza_end = os_path(root, "/var/run/zza.socket.end.txt")
        self.assertTrue(os.path.exists(zza_pre))
        self.assertTrue(os.path.exists(zza_post))
        self.assertFalse(os.path.exists(zza_end))
        #
        cmd = "./reply.py sendUNIX -d foo -f {sockfile}"
        out, end = output2(cmd.format(**locals()))
        self.assertEqual(end, 0)
        logg.info("send.log>>\n%s", out)
        self.assertTrue(greps(out, "request: foo"))
        self.assertTrue(greps(out, "replied: FOO"))
        #
        log = "{root}/var/log/zza.log"
        out = reads(log.format(**locals()))
        logg.info("zza.log>>%s", out)
        self.assertTrue(greps(out, "received:.*foo"))
        #
        cmd = "{systemctl} stop zza.socket -vvvv"
        sh____(cmd.format(**locals()))
        self.assertTrue(os.path.exists(zza_pre))
        self.assertTrue(os.path.exists(zza_post))
        self.assertTrue(os.path.exists(zza_end))
        #
        cmd = "./reply.py sendUNIX -d foo -f {sockfile}"
        out, end = output2(cmd.format(**locals()))
        self.assertEqual(end, 0)
        logg.info("send.log>>\n%s", out)
        self.assertTrue(greps(out, "request: foo"))
        self.assertFalse(greps(out, "replied: FOO"))
        #
        ##################################################
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4417_stop_post_socket_accept(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        replyB = self.testname("replyB")
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(root, "/var/run/zz.txt"), "zz")
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStartPre=/bin/false
            ExecStart={bindir}/{replyA} serverUNIX -f {sockfile}
            StandardOutput=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zza.socket"), """
            [Unit]
            Description=Testing B
            [Socket]
            Accept=yes
            ListenStream={sockfile}
            Service=zza.service
            ExecStartPre=/usr/bin/touch {root}/var/run/zza.socket.pre.txt
            ExecStartPost=/usr/bin/touch {root}/var/run/zza.socket.post.txt
            ExecStopPost=/usr/bin/touch {root}/var/run/zza.socket.end.txt
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zzc.service"), """
            [Unit]
            Description=Testing C
            [Service]
            Accept=yes
            ExecStart={root}/usr/bin/{testsleep} 5
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool("reply.py", os_path(bindir, replyA))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        copy_file(os_path(testdir, "zzc.service"), os_path(root, "/etc/systemd/system/zzc.service"))
        cmd = "{systemctl} enable zzc.service"
        sh____(cmd.format(**locals()))
        #
        InitLoopSleep = 1
        initsystemctl = systemctl
        initsystemctl += " -c InitLoopSleep={InitLoopSleep}".format(**locals())
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = "{initsystemctl} -1"
        init = background(cmd.format(**locals()))
        time.sleep(InitLoopSleep+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*InitLoopSleep"))
        #
        oo = reads(debug_log.format(**locals()))
        logg.info("debug.log>>\%s", oo)
        #
        cmd = "./reply.py sendUNIX -d foo -f {sockfile}"
        out, end = output2(cmd.format(**locals()))
        self.assertEqual(end, 0)
        logg.info("send.log>>\n%s", out)
        self.assertTrue(greps(out, "request: foo"))
        self.assertFalse(greps(out, "replied: FOO"))
        #
        zza_pre = os_path(root, "/var/run/zza.socket.pre.txt")
        zza_post = os_path(root, "/var/run/zza.socket.post.txt")
        zza_end = os_path(root, "/var/run/zza.socket.end.txt")
        self.assertFalse(os.path.exists(zza_pre))
        self.assertFalse(os.path.exists(zza_post))
        self.assertFalse(os.path.exists(zza_end))
        #
        cmd = "{systemctl} start zza.socket -vvvv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        self.assertTrue(os.path.exists(zza_pre))
        self.assertFalse(os.path.exists(zza_post))
        self.assertTrue(os.path.exists(zza_end))
        #
        cmd = "./reply.py sendUNIX -d foo -f {sockfile}"
        out, end = output2(cmd.format(**locals()))
        self.assertEqual(end, 0)
        logg.info("send.log>>\n%s", out)
        self.assertTrue(greps(out, "request: foo"))
        self.assertFalse(greps(out, "replied: FOO"))
        #
        cmd = "{systemctl} stop zza.socket -vvvv"
        sh____(cmd.format(**locals()))
        self.assertTrue(os.path.exists(zza_pre))
        self.assertFalse(os.path.exists(zza_post))
        self.assertTrue(os.path.exists(zza_end))
        #
        ##################################################
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4418_stop_post_enabled_socket_accept(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        replyB = self.testname("replyB")
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(root, "/var/run/zz.txt"), "zz")
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStartPre=/bin/false
            ExecStart={bindir}/{replyA} serverUNIX -f {sockfile}
            StandardOutput=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zza.socket"), """
            [Unit]
            Description=Testing B
            [Socket]
            Accept=yes
            ListenStream={sockfile}
            Service=zza.service
            ExecStartPre=/usr/bin/touch {root}/var/run/zza.socket.pre.txt
            ExecStartPost=/usr/bin/touch {root}/var/run/zza.socket.post.txt
            ExecStopPost=/usr/bin/touch {root}/var/run/zza.socket.end.txt
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zzc.service"), """
            [Unit]
            Description=Testing C
            [Service]
            Accept=yes
            ExecStart={root}/usr/bin/{testsleep} 5
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool("reply.py", os_path(bindir, replyA))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        copy_file(os_path(testdir, "zzc.service"), os_path(root, "/etc/systemd/system/zzc.service"))
        cmd = "{systemctl} enable zza.socket"
        sh____(cmd.format(**locals()))
        #
        InitLoopSleep = 1
        initsystemctl = systemctl
        initsystemctl += " -c InitLoopSleep={InitLoopSleep}".format(**locals())
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = "{initsystemctl} -1"
        init = background(cmd.format(**locals()))
        time.sleep(InitLoopSleep+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*InitLoopSleep"))
        #
        oo = reads(debug_log.format(**locals()))
        logg.info("debug.log>>\%s", oo)
        #
        zza_pre = os_path(root, "/var/run/zza.socket.pre.txt")
        zza_post = os_path(root, "/var/run/zza.socket.post.txt")
        zza_end = os_path(root, "/var/run/zza.socket.end.txt")
        self.assertTrue(os.path.exists(zza_pre))
        if not COVERAGE:
            self.assertFalse(os.path.exists(zza_post))
            self.assertTrue(os.path.exists(zza_end))
        #
        cmd = "./reply.py sendUNIX -d foo -f {sockfile}"
        out, end = output2(cmd.format(**locals()))
        self.assertEqual(end, 0)
        logg.info("send.log>>\n%s", out)
        self.assertTrue(greps(out, "request: foo"))
        if not COVERAGE:
            self.assertFalse(greps(out, "replied: FOO"))
        #
        cmd = "{systemctl} stop zza.socket -vvvv"
        sh____(cmd.format(**locals()))
        self.assertTrue(os.path.exists(zza_pre))
        if not COVERAGE:
            self.assertFalse(os.path.exists(zza_post))
            self.assertTrue(os.path.exists(zza_end))
        #
        ##################################################
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4421_chown_user_socket_accept(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        replyB = self.testname("replyB")
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        this_user=get_USER()
        this_group=get_GROUP()
        text_file(os_path(root, "/var/run/zz.txt"), "zz")
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} serverUNIX -f {sockfile}
            StandardOutput=file:{root}/var/log/zza.log
            # ExecStartPre=/usr/bin/touch {root}/var/run/zza.service.pre.txt
            # ExecStartPost=/usr/bin/touch {root}/var/run/zza.service.post.txt
            # ExecStopPost=/usr/bin/touch {root}/var/run/zza.service.end.txt
            # User={this_user}
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zza.socket"), """
            [Unit]
            Description=Testing B
            [Socket]
            Accept=yes
            ListenStream={sockfile}
            SocketUser={this_user}
            Service=zza.service
            ExecStartPre=/usr/bin/touch {root}/var/run/zza.socket.pre.txt
            ExecStartPost=/usr/bin/touch {root}/var/run/zza.socket.post.txt
            ExecStopPost=/usr/bin/touch {root}/var/run/zza.socket.end.txt
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zzc.service"), """
            [Unit]
            Description=Testing C
            [Service]
            Accept=yes
            ExecStart={root}/usr/bin/{testsleep} 5
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool("reply.py", os_path(bindir, replyA))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        copy_file(os_path(testdir, "zzc.service"), os_path(root, "/etc/systemd/system/zzc.service"))
        cmd = "{systemctl} enable zzc.service"
        sh____(cmd.format(**locals()))
        #
        InitLoopSleep = 1
        initsystemctl = systemctl
        initsystemctl += " -c InitLoopSleep={InitLoopSleep}".format(**locals())
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = "{initsystemctl} -1"
        init = background(cmd.format(**locals()))
        time.sleep(InitLoopSleep+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*InitLoopSleep"))
        #
        oo = reads(debug_log.format(**locals()))
        logg.info("debug.log>>\%s", oo)
        #
        cmd = "./reply.py sendUNIX -d foo -f {sockfile}"
        out, end = output2(cmd.format(**locals()))
        self.assertEqual(end, 0)
        logg.info("send.log>>\n%s", out)
        self.assertTrue(greps(out, "request: foo"))
        self.assertFalse(greps(out, "replied: FOO"))
        #
        zza_pre = os_path(root, "/var/run/zza.socket.pre.txt")
        zza_post = os_path(root, "/var/run/zza.socket.post.txt")
        zza_end = os_path(root, "/var/run/zza.socket.end.txt")
        self.assertFalse(os.path.exists(zza_pre))
        self.assertFalse(os.path.exists(zza_post))
        self.assertFalse(os.path.exists(zza_end))
        #
        cmd = "{systemctl} start zza.socket -vvvv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(os.path.exists(zza_pre))
        self.assertTrue(os.path.exists(zza_post))
        self.assertFalse(os.path.exists(zza_end))
        #
        cmd = "./reply.py sendUNIX -d foo -f {sockfile}"
        out, end = output2(cmd.format(**locals()))
        self.assertEqual(end, 0)
        logg.info("send.log>>\n%s", out)
        self.assertTrue(greps(out, "request: foo"))
        self.assertTrue(greps(out, "replied: FOO"))
        #
        cmd = "{systemctl} stop zza.socket -vvvv"
        sh____(cmd.format(**locals()))
        self.assertTrue(os.path.exists(zza_pre))
        self.assertTrue(os.path.exists(zza_post))
        self.assertTrue(os.path.exists(zza_end))
        #
        ##################################################
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4422_chown_user_group_socket_accept(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        replyB = self.testname("replyB")
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        this_user=get_USER()
        this_group=get_GROUP()
        text_file(os_path(root, "/var/run/zz.txt"), "zz")
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} serverUNIX -f {sockfile}
            StandardOutput=file:{root}/var/log/zza.log
            # ExecStartPre=/usr/bin/touch {root}/var/run/zza.service.pre.txt
            # ExecStartPost=/usr/bin/touch {root}/var/run/zza.service.post.txt
            # ExecStopPost=/usr/bin/touch {root}/var/run/zza.service.end.txt
            # User={this_user}
            # Group={this_group}
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zza.socket"), """
            [Unit]
            Description=Testing B
            [Socket]
            Accept=yes
            ListenStream={sockfile}
            SocketUser={this_user}
            SocketGroup={this_group}
            Service=zza.service
            ExecStartPre=/usr/bin/touch {root}/var/run/zza.socket.pre.txt
            ExecStartPost=/usr/bin/touch {root}/var/run/zza.socket.post.txt
            ExecStopPost=/usr/bin/touch {root}/var/run/zza.socket.end.txt
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zzc.service"), """
            [Unit]
            Description=Testing C
            [Service]
            Accept=yes
            ExecStart={root}/usr/bin/{testsleep} 5
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool("reply.py", os_path(bindir, replyA))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        copy_file(os_path(testdir, "zzc.service"), os_path(root, "/etc/systemd/system/zzc.service"))
        cmd = "{systemctl} enable zzc.service"
        sh____(cmd.format(**locals()))
        #
        InitLoopSleep = 1
        initsystemctl = systemctl
        initsystemctl += " -c InitLoopSleep={InitLoopSleep}".format(**locals())
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = "{initsystemctl} -1"
        init = background(cmd.format(**locals()))
        time.sleep(InitLoopSleep+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*InitLoopSleep"))
        #
        oo = reads(debug_log.format(**locals()))
        logg.info("debug.log>>\%s", oo)
        #
        cmd = "./reply.py sendUNIX -d foo -f {sockfile}"
        out, end = output2(cmd.format(**locals()))
        self.assertEqual(end, 0)
        logg.info("send.log>>\n%s", out)
        self.assertTrue(greps(out, "request: foo"))
        self.assertFalse(greps(out, "replied: FOO"))
        #
        zza_pre = os_path(root, "/var/run/zza.socket.pre.txt")
        zza_post = os_path(root, "/var/run/zza.socket.post.txt")
        zza_end = os_path(root, "/var/run/zza.socket.end.txt")
        self.assertFalse(os.path.exists(zza_pre))
        self.assertFalse(os.path.exists(zza_post))
        self.assertFalse(os.path.exists(zza_end))
        #
        cmd = "{systemctl} start zza.socket -vvvv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(os.path.exists(zza_pre))
        self.assertTrue(os.path.exists(zza_post))
        self.assertFalse(os.path.exists(zza_end))
        #
        cmd = "./reply.py sendUNIX -d foo -f {sockfile}"
        out, end = output2(cmd.format(**locals()))
        self.assertEqual(end, 0)
        logg.info("send.log>>\n%s", out)
        self.assertTrue(greps(out, "request: foo"))
        self.assertTrue(greps(out, "replied: FOO"))
        #
        cmd = "{systemctl} stop zza.socket -vvvv"
        sh____(cmd.format(**locals()))
        self.assertTrue(os.path.exists(zza_pre))
        self.assertTrue(os.path.exists(zza_post))
        self.assertTrue(os.path.exists(zza_end))
        #
        ##################################################
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4423_chown_group_socket_accept(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        replyB = self.testname("replyB")
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        this_user=get_USER()
        this_group=get_GROUP()
        text_file(os_path(root, "/var/run/zz.txt"), "zz")
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} serverUNIX -f {sockfile}
            StandardOutput=file:{root}/var/log/zza.log
            # ExecStartPre=/usr/bin/touch {root}/var/run/zza.service.pre.txt
            # ExecStartPost=/usr/bin/touch {root}/var/run/zza.service.post.txt
            # ExecStopPost=/usr/bin/touch {root}/var/run/zza.service.end.txt
            Group={this_group}
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zza.socket"), """
            [Unit]
            Description=Testing B
            [Socket]
            Accept=yes
            ListenStream={sockfile}
            SocketGroup={this_group}
            Service=zza.service
            ExecStartPre=/usr/bin/touch {root}/var/run/zza.socket.pre.txt
            ExecStartPost=/usr/bin/touch {root}/var/run/zza.socket.post.txt
            ExecStopPost=/usr/bin/touch {root}/var/run/zza.socket.end.txt
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zzc.service"), """
            [Unit]
            Description=Testing C
            [Service]
            Accept=yes
            ExecStart={root}/usr/bin/{testsleep} 5
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool("reply.py", os_path(bindir, replyA))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        copy_file(os_path(testdir, "zzc.service"), os_path(root, "/etc/systemd/system/zzc.service"))
        cmd = "{systemctl} enable zzc.service"
        sh____(cmd.format(**locals()))
        #
        InitLoopSleep = 1
        initsystemctl = systemctl
        initsystemctl += " -c InitLoopSleep={InitLoopSleep}".format(**locals())
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = "{initsystemctl} -1"
        init = background(cmd.format(**locals()))
        time.sleep(InitLoopSleep+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*InitLoopSleep"))
        #
        oo = reads(debug_log.format(**locals()))
        logg.info("debug.log>>\%s", oo)
        #
        cmd = "./reply.py sendUNIX -d foo -f {sockfile}"
        out, end = output2(cmd.format(**locals()))
        self.assertEqual(end, 0)
        logg.info("send.log>>\n%s", out)
        self.assertTrue(greps(out, "request: foo"))
        self.assertFalse(greps(out, "replied: FOO"))
        #
        zza_pre = os_path(root, "/var/run/zza.socket.pre.txt")
        zza_post = os_path(root, "/var/run/zza.socket.post.txt")
        zza_end = os_path(root, "/var/run/zza.socket.end.txt")
        self.assertFalse(os.path.exists(zza_pre))
        self.assertFalse(os.path.exists(zza_post))
        self.assertFalse(os.path.exists(zza_end))
        #
        cmd = "{systemctl} start zza.socket -vvvv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertTrue(os.path.exists(zza_pre))
        self.assertTrue(os.path.exists(zza_post))
        self.assertFalse(os.path.exists(zza_end))
        #
        cmd = "./reply.py sendUNIX -d foo -f {sockfile}"
        out, end = output2(cmd.format(**locals()))
        self.assertEqual(end, 0)
        logg.info("send.log>>\n%s", out)
        self.assertTrue(greps(out, "request: foo"))
        self.assertTrue(greps(out, "replied: FOO"))
        #
        cmd = "{systemctl} stop zza.socket -vvvv"
        sh____(cmd.format(**locals()))
        self.assertTrue(os.path.exists(zza_pre))
        self.assertTrue(os.path.exists(zza_post))
        self.assertTrue(os.path.exists(zza_end))
        #
        ##################################################
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4426_chown_user_enabled_socket_accept(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        replyB = self.testname("replyB")
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        this_user=get_USER()
        this_group=get_GROUP()
        text_file(os_path(root, "/var/run/zz.txt"), "zz")
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} serverUNIX -f {sockfile}
            StandardOutput=file:{root}/var/log/zza.log
            # ExecStartPre=/usr/bin/touch {root}/var/run/zza.service.pre.txt
            # ExecStartPost=/usr/bin/touch {root}/var/run/zza.service.post.txt
            # ExecStopPost=/usr/bin/touch {root}/var/run/zza.service.end.txt
            # User={this_user}
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zza.socket"), """
            [Unit]
            Description=Testing B
            [Socket]
            Accept=yes
            ListenStream={sockfile}
            SocketUser={this_user}
            Service=zza.service
            ExecStartPre=/usr/bin/touch {root}/var/run/zza.socket.pre.txt
            ExecStartPost=/usr/bin/touch {root}/var/run/zza.socket.post.txt
            ExecStopPost=/usr/bin/touch {root}/var/run/zza.socket.end.txt
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zzc.service"), """
            [Unit]
            Description=Testing C
            [Service]
            Accept=yes
            ExecStart={root}/usr/bin/{testsleep} 5
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool("reply.py", os_path(bindir, replyA))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        copy_file(os_path(testdir, "zzc.service"), os_path(root, "/etc/systemd/system/zzc.service"))
        cmd = "{systemctl} enable zza.socket"
        sh____(cmd.format(**locals()))
        #
        InitLoopSleep = 1
        initsystemctl = systemctl
        initsystemctl += " -c InitLoopSleep={InitLoopSleep}".format(**locals())
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = "{initsystemctl} -1"
        init = background(cmd.format(**locals()))
        time.sleep(InitLoopSleep+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*InitLoopSleep"))
        #
        oo = reads(debug_log.format(**locals()))
        logg.info("debug.log>>\%s", oo)
        #
        zza_pre = os_path(root, "/var/run/zza.socket.pre.txt")
        zza_post = os_path(root, "/var/run/zza.socket.post.txt")
        zza_end = os_path(root, "/var/run/zza.socket.end.txt")
        self.assertTrue(os.path.exists(zza_pre))
        self.assertTrue(os.path.exists(zza_post))
        self.assertFalse(os.path.exists(zza_end))
        #
        cmd = "./reply.py sendUNIX -d foo -f {sockfile}"
        out, end = output2(cmd.format(**locals()))
        self.assertEqual(end, 0)
        logg.info("send.log>>\n%s", out)
        self.assertTrue(greps(out, "request: foo"))
        self.assertTrue(greps(out, "replied: FOO"))
        #
        cmd = "{systemctl} stop zza.socket -vvvv"
        sh____(cmd.format(**locals()))
        self.assertTrue(os.path.exists(zza_pre))
        self.assertTrue(os.path.exists(zza_post))
        self.assertTrue(os.path.exists(zza_end))
        #
        ##################################################
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4427_chown_user_group_enabled_socket_accept(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        replyB = self.testname("replyB")
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        this_user=get_USER()
        this_group=get_GROUP()
        text_file(os_path(root, "/var/run/zz.txt"), "zz")
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} serverUNIX -f {sockfile}
            StandardOutput=file:{root}/var/log/zza.log
            # ExecStartPre=/usr/bin/touch {root}/var/run/zza.service.pre.txt
            # ExecStartPost=/usr/bin/touch {root}/var/run/zza.service.post.txt
            # ExecStopPost=/usr/bin/touch {root}/var/run/zza.service.end.txt
            # User={this_user}
            # Group={this_group}
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zza.socket"), """
            [Unit]
            Description=Testing B
            [Socket]
            Accept=yes
            ListenStream={sockfile}
            SocketUser={this_user}
            SocketGroup={this_group}
            Service=zza.service
            ExecStartPre=/usr/bin/touch {root}/var/run/zza.socket.pre.txt
            ExecStartPost=/usr/bin/touch {root}/var/run/zza.socket.post.txt
            ExecStopPost=/usr/bin/touch {root}/var/run/zza.socket.end.txt
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zzc.service"), """
            [Unit]
            Description=Testing C
            [Service]
            Accept=yes
            ExecStart={root}/usr/bin/{testsleep} 5
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool("reply.py", os_path(bindir, replyA))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        copy_file(os_path(testdir, "zzc.service"), os_path(root, "/etc/systemd/system/zzc.service"))
        cmd = "{systemctl} enable zza.socket"
        sh____(cmd.format(**locals()))
        #
        InitLoopSleep = 1
        initsystemctl = systemctl
        initsystemctl += " -c InitLoopSleep={InitLoopSleep}".format(**locals())
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = "{initsystemctl} -1"
        init = background(cmd.format(**locals()))
        time.sleep(InitLoopSleep+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*InitLoopSleep"))
        #
        oo = reads(debug_log.format(**locals()))
        logg.info("debug.log>>\%s", oo)
        #
        zza_pre = os_path(root, "/var/run/zza.socket.pre.txt")
        zza_post = os_path(root, "/var/run/zza.socket.post.txt")
        zza_end = os_path(root, "/var/run/zza.socket.end.txt")
        self.assertTrue(os.path.exists(zza_pre))
        self.assertTrue(os.path.exists(zza_post))
        self.assertFalse(os.path.exists(zza_end))
        #
        cmd = "./reply.py sendUNIX -d foo -f {sockfile}"
        out, end = output2(cmd.format(**locals()))
        self.assertEqual(end, 0)
        logg.info("send.log>>\n%s", out)
        self.assertTrue(greps(out, "request: foo"))
        self.assertTrue(greps(out, "replied: FOO"))
        #
        cmd = "{systemctl} stop zza.socket -vvvv"
        sh____(cmd.format(**locals()))
        self.assertTrue(os.path.exists(zza_pre))
        self.assertTrue(os.path.exists(zza_post))
        self.assertTrue(os.path.exists(zza_end))
        #
        ##################################################
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4428_chown_group_enabled_socket_accept(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        replyB = self.testname("replyB")
        testsleep = self.testname("sleep")
        bindir = os_path(root, "/usr/bin")
        this_user=get_USER()
        this_group=get_GROUP()
        text_file(os_path(root, "/var/run/zz.txt"), "zz")
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} serverUNIX -f {sockfile}
            StandardOutput=file:{root}/var/log/zza.log
            # ExecStartPre=/usr/bin/touch {root}/var/run/zza.service.pre.txt
            # ExecStartPost=/usr/bin/touch {root}/var/run/zza.service.post.txt
            # ExecStopPost=/usr/bin/touch {root}/var/run/zza.service.end.txt
            Group={this_group}
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zza.socket"), """
            [Unit]
            Description=Testing B
            [Socket]
            Accept=yes
            ListenStream={sockfile}
            SocketGroup={this_group}
            Service=zza.service
            ExecStartPre=/usr/bin/touch {root}/var/run/zza.socket.pre.txt
            ExecStartPost=/usr/bin/touch {root}/var/run/zza.socket.post.txt
            ExecStopPost=/usr/bin/touch {root}/var/run/zza.socket.end.txt
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zzc.service"), """
            [Unit]
            Description=Testing C
            [Service]
            Accept=yes
            ExecStart={root}/usr/bin/{testsleep} 5
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool("reply.py", os_path(bindir, replyA))
        copy_tool(_bin_sleep, os_path(bindir, testsleep))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        copy_file(os_path(testdir, "zzc.service"), os_path(root, "/etc/systemd/system/zzc.service"))
        cmd = "{systemctl} enable zza.socket"
        sh____(cmd.format(**locals()))
        #
        InitLoopSleep = 1
        initsystemctl = systemctl
        initsystemctl += " -c InitLoopSleep={InitLoopSleep}".format(**locals())
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = "{initsystemctl} -1"
        init = background(cmd.format(**locals()))
        time.sleep(InitLoopSleep+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*InitLoopSleep"))
        #
        oo = reads(debug_log.format(**locals()))
        logg.info("debug.log>>\%s", oo)
        #
        zza_pre = os_path(root, "/var/run/zza.socket.pre.txt")
        zza_post = os_path(root, "/var/run/zza.socket.post.txt")
        zza_end = os_path(root, "/var/run/zza.socket.end.txt")
        self.assertTrue(os.path.exists(zza_pre))
        self.assertTrue(os.path.exists(zza_post))
        self.assertFalse(os.path.exists(zza_end))
        #
        cmd = "./reply.py sendUNIX -d foo -f {sockfile}"
        out, end = output2(cmd.format(**locals()))
        self.assertEqual(end, 0)
        logg.info("send.log>>\n%s", out)
        self.assertTrue(greps(out, "request: foo"))
        self.assertTrue(greps(out, "replied: FOO"))
        #
        cmd = "{systemctl} stop zza.socket -vvvv"
        sh____(cmd.format(**locals()))
        self.assertTrue(os.path.exists(zza_pre))
        self.assertTrue(os.path.exists(zza_post))
        self.assertTrue(os.path.exists(zza_end))
        #
        ##################################################
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4511_unix_socket_accept(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        replyB = self.testname("replyB")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} serverUNIX -f {sockfile}
            StandardOutput=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zza.socket"), """
            [Unit]
            Description=Testing B
            [Socket]
            Accept=yes
            ListenStream={sockfile}
            Service=zza.service
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool("reply.py", os_path(bindir, replyA))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        cmd = "{systemctl} enable zza.socket"
        sh____(cmd.format(**locals()))
        #
        InitLoopSleep = 1
        initsystemctl = systemctl
        initsystemctl += " -c InitLoopSleep={InitLoopSleep}".format(**locals())
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = "{initsystemctl} listen zza.socket"
        init = background(cmd.format(**locals()))
        time.sleep(InitLoopSleep+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*listen"))
        #
        cmd = "./reply.py sendUNIX -d foo -f {sockfile}"
        out, end = output2(cmd.format(**locals()))
        self.assertEqual(end, 0)
        logg.info("send.log>>\n%s", out)
        self.assertTrue(greps(out, "request: foo"))
        self.assertTrue(greps(out, "replied: FOO"))
        log = "{root}/var/log/zza.log"
        out = reads(log.format(**locals()))
        logg.info("zza.log>>\n%s", out)
        self.assertTrue(greps(out, "received:.*foo"))
        #
        logg.info("kill daemon at %s", init.pid)
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4512_unix_socket_listen(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        replyB = self.testname("replyB")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} serverUNIX -f {sockfile}
            StandardOutput=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zza.socket"), """
            [Unit]
            Description=Testing B
            [Socket]
            ListenStream={sockfile}
            Service=zza.service
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool("reply.py", os_path(bindir, replyA))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        cmd = "{systemctl} enable zza.socket"
        sh____(cmd.format(**locals()))
        #
        InitLoopSleep = 1
        initsystemctl = systemctl
        initsystemctl += " -c InitLoopSleep={InitLoopSleep}".format(**locals())
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = "{initsystemctl} listen zza.socket -c TestListen -c TestAccept"
        init = background(cmd.format(**locals()))
        time.sleep(InitLoopSleep+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*listen"))
        #
        cmd = "./reply.py sendUNIX -d foo -f {sockfile}"
        out, end = output2(cmd.format(**locals()))
        # self.assertEqual(end, 0) # FIXME
        logg.info("send.log>>\n%s", out)
        self.assertTrue(greps(out, "request: foo"))
        # self.assertTrue(greps(out, "replied: FOO")) # FIXME
        self.assertTrue(greps(out, "replied: ERROR: FOO"))
        ### log = "{root}/var/log/zza.log"
        ### out = open(log.format(**locals())).read()
        ### logg.info("zza.log>>\n%s", out)
        # self.assertTrue(greps(out, "received:.*foo")) # FIXME
        #
        logg.info("kill daemon at %s", init.pid)
        if TestListen:
            self.assertTrue(self.kill(init.pid))
        elif not self.kill(init.pid):
            self.kill(init.pid, sig = signal.SIGKILL)
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4513_unix_socket_listen_user_group(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        this_user=get_USER()
        this_group=get_GROUP()
        logfile = os_path(root, "/var/log/"+testname+".log")
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        replyB = self.testname("replyB")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} serverUNIX -f {sockfile}
            StandardOutput=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zza.socket"), """
            [Unit]
            Description=Testing B
            [Socket]
            ListenStream={sockfile}
            SocketUser={this_user}
            SocketGroup={this_group}
            Service=zza.service
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool("reply.py", os_path(bindir, replyA))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        cmd = "{systemctl} enable zza.socket"
        sh____(cmd.format(**locals()))
        #
        InitLoopSleep = 1
        initsystemctl = systemctl
        initsystemctl += " -c InitLoopSleep={InitLoopSleep}".format(**locals())
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = "{initsystemctl} listen zza.socket -c TestListen -c TestAccept"
        init = background(cmd.format(**locals()))
        time.sleep(InitLoopSleep+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*listen"))
        #
        cmd = "./reply.py sendUNIX -d foo -f {sockfile}"
        out, end = output2(cmd.format(**locals()))
        # self.assertEqual(end, 0) # FIXME
        logg.info("send.log>>\n%s", out)
        self.assertTrue(greps(out, "request: foo"))
        # self.assertTrue(greps(out, "replied: FOO")) # FIXME
        self.assertTrue(greps(out, "replied: ERROR: FOO"))
        ### log = "{root}/var/log/zza.log"
        ### out = open(log.format(**locals())).read()
        ### logg.info("zza.log>>\n%s", out)
        # self.assertTrue(greps(out, "received:.*foo")) # FIXME
        #
        logg.info("kill daemon at %s", init.pid)
        if TestListen:
            self.assertTrue(self.kill(init.pid))
        elif not self.kill(init.pid):
            self.kill(init.pid, sig = signal.SIGKILL)

        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4514_unix_socket_listen_group(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        this_user=get_USER()
        this_group=get_GROUP()
        logfile = os_path(root, "/var/log/"+testname+".log")
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        replyB = self.testname("replyB")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} serverUNIX -f {sockfile}
            StandardOutput=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zza.socket"), """
            [Unit]
            Description=Testing B
            [Socket]
            ListenStream={sockfile}
            # SocketUser={this_user}
            SocketGroup={this_group}
            Service=zza.service
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool("reply.py", os_path(bindir, replyA))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        cmd = "{systemctl} enable zza.socket"
        sh____(cmd.format(**locals()))
        #
        InitLoopSleep = 1
        initsystemctl = systemctl
        initsystemctl += " -c InitLoopSleep={InitLoopSleep}".format(**locals())
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = "{initsystemctl} listen zza.socket -c TestListen -c TestAccept"
        init = background(cmd.format(**locals()))
        time.sleep(InitLoopSleep+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*listen"))
        #
        cmd = "./reply.py sendUNIX -d foo -f {sockfile}"
        out, end = output2(cmd.format(**locals()))
        # self.assertEqual(end, 0) # FIXME
        logg.info("send.log>>\n%s", out)
        self.assertTrue(greps(out, "request: foo"))
        # self.assertTrue(greps(out, "replied: FOO")) # FIXME
        self.assertTrue(greps(out, "replied: ERROR: FOO"))
        ### log = "{root}/var/log/zza.log"
        ### out = open(log.format(**locals())).read()
        ### logg.info("zza.log>>\n%s", out)
        # self.assertTrue(greps(out, "received:.*foo")) # FIXME
        #
        logg.info("kill daemon at %s", init.pid)
        if TestListen:
            self.assertTrue(self.kill(init.pid))
        elif not self.kill(init.pid):
            self.kill(init.pid, sig = signal.SIGKILL)

        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4515_unix_socket_listen_user(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        this_user=get_USER()
        this_group=get_GROUP()
        logfile = os_path(root, "/var/log/"+testname+".log")
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        replyB = self.testname("replyB")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} serverUNIX -f {sockfile}
            StandardOutput=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zza.socket"), """
            [Unit]
            Description=Testing B
            [Socket]
            ListenStream={sockfile}
            SocketUser={this_user}
            # SocketGroup={this_group}
            Service=zza.service
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool("reply.py", os_path(bindir, replyA))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        cmd = "{systemctl} enable zza.socket"
        sh____(cmd.format(**locals()))
        #
        InitLoopSleep = 1
        initsystemctl = systemctl
        initsystemctl += " -c InitLoopSleep={InitLoopSleep}".format(**locals())
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = "{initsystemctl} listen zza.socket -c TestListen -c TestAccept"
        init = background(cmd.format(**locals()))
        time.sleep(InitLoopSleep+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*listen"))
        #
        cmd = "./reply.py sendUNIX -d foo -f {sockfile}"
        out, end = output2(cmd.format(**locals()))
        # self.assertEqual(end, 0) # FIXME
        logg.info("send.log>>\n%s", out)
        self.assertTrue(greps(out, "request: foo"))
        # self.assertTrue(greps(out, "replied: FOO")) # FIXME
        self.assertTrue(greps(out, "replied: ERROR: FOO"))
        ### log = "{root}/var/log/zza.log"
        ### out = open(log.format(**locals())).read()
        ### logg.info("zza.log>>\n%s", out)
        # self.assertTrue(greps(out, "received:.*foo")) # FIXME
        #
        logg.info("kill daemon at %s", init.pid)
        if TestListen:
            self.assertTrue(self.kill(init.pid))
        elif not self.kill(init.pid):
            self.kill(init.pid, sig = signal.SIGKILL)

        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4516_unix_socket_listen_bad_pre(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        replyB = self.testname("replyB")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} serverUNIX -f {sockfile}
            StandardOutput=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zza.socket"), """
            [Unit]
            Description=Testing B
            [Socket]
            ExecStartPre=/bin/false
            ListenStream={sockfile}
            Service=zza.service
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool("reply.py", os_path(bindir, replyA))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        cmd = "{systemctl} enable zza.socket"
        sh____(cmd.format(**locals()))
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        text_file(debug_log, "")
        #
        InitLoopSleep = 1
        initsystemctl = systemctl
        initsystemctl += " -c InitLoopSleep={InitLoopSleep}".format(**locals())
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = "{initsystemctl} listen zza.socket -c TestListen -c TestAccept"
        init = background(cmd.format(**locals()))
        time.sleep(InitLoopSleep+1)
        #
        log = reads(debug_log)
        logg.info("systemctl.debug.log:\n%s", i2(log))
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, "systemctl.*listen"))
        #
        # no reply
        #
        logg.info("kill daemon at %s", init.pid)
        if TestListen:
            self.assertTrue(self.kill(init.pid))
        elif not self.kill(init.pid):
            self.kill(init.pid, sig = signal.SIGKILL)

        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4517_unix_socket_listen_bad_post(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        replyB = self.testname("replyB")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} serverUNIX -f {sockfile}
            StandardOutput=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zza.socket"), """
            [Unit]
            Description=Testing B
            [Socket]
            ExecStartPost=/bin/false
            ListenStream={sockfile}
            Service=zza.service
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool("reply.py", os_path(bindir, replyA))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        cmd = "{systemctl} enable zza.socket"
        sh____(cmd.format(**locals()))
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        text_file(debug_log, "")
        #
        InitLoopSleep = 1
        initsystemctl = systemctl
        initsystemctl += " -c InitLoopSleep={InitLoopSleep}".format(**locals())
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = "{initsystemctl} listen zza.socket -c TestListen -c TestAccept"
        init = background(cmd.format(**locals()))
        time.sleep(InitLoopSleep+1)
        #
        log = reads(debug_log)
        logg.info("systemctl.debug.log:\n%s", i2(log))
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*listen"))
        #
        cmd = "./reply.py sendUNIX -d foo -f {sockfile}"
        out, end = output2(cmd.format(**locals()))
        self.assertEqual(end, 0) # FIXME
        logg.info("send.log>>\n%s", out)
        self.assertTrue(greps(out, "request: foo"))
        self.assertTrue(greps(out, "replied: ERROR: FOO"))
        #
        logg.info("kill daemon at %s", init.pid)
        if TestListen:
            self.assertTrue(self.kill(init.pid))
        elif not self.kill(init.pid):
            self.kill(init.pid, sig = signal.SIGKILL)

        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4518_unix_socket_listen_bad_start(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        replyB = self.testname("replyB")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart=/bin/false
            StandardOutput=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zza.socket"), """
            [Unit]
            Description=Testing B
            [Socket]
            ExecStartPre=/bin/false
            ExecStopPost=/bin/true
            ListenStream={sockfile}
            Service=zza.service
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool("reply.py", os_path(bindir, replyA))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        cmd = "{systemctl} enable zza.socket"
        sh____(cmd.format(**locals()))
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        text_file(debug_log, "")
        #
        InitLoopSleep = 1
        initsystemctl = systemctl
        initsystemctl += " -c InitLoopSleep={InitLoopSleep}".format(**locals())
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = "{initsystemctl} listen zza.socket -c TestListen -c TestAccept"
        init = background(cmd.format(**locals()))
        time.sleep(InitLoopSleep+1)
        #
        log = reads(debug_log)
        logg.info("systemctl.debug.log:\n%s", i2(log))
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, "systemctl.*listen"))
        #
        # no reply
        #
        logg.info("kill daemon at %s", init.pid)
        if TestListen:
            self.assertTrue(self.kill(init.pid))
        elif not self.kill(init.pid):
            self.kill(init.pid, sig = signal.SIGKILL)

        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4519_unix_socket_listen_bad_start_bad_post(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        replyB = self.testname("replyB")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart=/bin/false
            StandardOutput=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zza.socket"), """
            [Unit]
            Description=Testing B
            [Socket]
            ExecStartPre=/bin/false
            ExecStopPost=/bin/false
            ListenStream={sockfile}
            Service=zza.service
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool("reply.py", os_path(bindir, replyA))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        cmd = "{systemctl} enable zza.socket"
        sh____(cmd.format(**locals()))
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        text_file(debug_log, "")
        #
        InitLoopSleep = 1
        initsystemctl = systemctl
        initsystemctl += " -c InitLoopSleep={InitLoopSleep}".format(**locals())
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = "{initsystemctl} listen zza.socket -c TestListen -c TestAccept"
        init = background(cmd.format(**locals()))
        time.sleep(InitLoopSleep+1)
        #
        log = reads(debug_log)
        logg.info("systemctl.debug.log:\n%s", i2(log))
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, "systemctl.*listen"))
        #
        # no reply
        #
        logg.info("kill daemon at %s", init.pid)
        if TestListen:
            self.assertTrue(self.kill(init.pid))
        elif not self.kill(init.pid):
            self.kill(init.pid, sig = signal.SIGKILL)

        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4520_udp_socket_accept(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        testport = self.testport()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        replyB = self.testname("replyB")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} serverUDP -p {testport}
            StandardOutput=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zza.socket"), """
            [Unit]
            Description=Testing B
            [Socket]
            Accept=yes
            ListenStream={testport}
            Service=zza.service
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool("reply.py", os_path(bindir, replyA))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        cmd = "{systemctl} enable zza.socket"
        sh____(cmd.format(**locals()))
        #
        InitLoopSleep = 1
        initsystemctl = systemctl
        initsystemctl += " -c InitLoopSleep={InitLoopSleep}".format(**locals())
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = "{initsystemctl} listen zza.socket"
        init = background(cmd.format(**locals()))
        time.sleep(InitLoopSleep+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*listen"))
        #
        cmd = "./reply.py sendUDP -d foo -p {testport}"
        out, end = output2(cmd.format(**locals()))
        self.assertEqual(end, 0)
        logg.info("send.log>>\n%s", out)
        self.assertTrue(greps(out, "request: foo"))
        self.assertTrue(greps(out, "replied: FOO"))
        log = "{root}/var/log/zza.log"
        out = open(log.format(**locals())).read()
        logg.info("zza.log>>\n%s", out)
        self.assertTrue(greps(out, "received:.*foo"))
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4521_tcp_socket_accept(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        testport = self.testport()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        replyB = self.testname("replyB")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} serverTCP -p {testport}
            StandardOutput=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zza.socket"), """
            [Unit]
            Description=Testing B
            [Socket]
            Accept=yes
            ListenStream={testport}
            Service=zza.service
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool("reply.py", os_path(bindir, replyA))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        cmd = "{systemctl} enable zza.socket"
        sh____(cmd.format(**locals()))
        #
        InitLoopSleep = 1
        initsystemctl = systemctl
        initsystemctl += " -c InitLoopSleep={InitLoopSleep}".format(**locals())
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = "{initsystemctl} listen zza.socket"
        init = background(cmd.format(**locals()))
        time.sleep(InitLoopSleep+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*listen"))
        #
        cmd = "./reply.py sendTCP -d foo -p {testport}"
        out, end = output2(cmd.format(**locals()))
        self.assertEqual(end, 0)
        logg.info("send.log>>\n%s", out)
        self.assertTrue(greps(out, "request: foo"))
        self.assertTrue(greps(out, "replied: FOO"))
        log = "{root}/var/log/zza.log"
        out = open(log.format(**locals())).read()
        logg.info("zza.log>>\n%s", out)
        self.assertTrue(greps(out, "received:.*foo"))
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4522_inet_socket_accept(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        testport = self.testport()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        replyB = self.testname("replyB")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} serverINET -p {testport}
            StandardOutput=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zza.socket"), """
            [Unit]
            Description=Testing B
            [Socket]
            Accept=yes
            ListenStream={testport}
            Service=zza.service
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool("reply.py", os_path(bindir, replyA))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        cmd = "{systemctl} enable zza.socket"
        sh____(cmd.format(**locals()))
        #
        InitLoopSleep = 1
        initsystemctl = systemctl
        initsystemctl += " -c InitLoopSleep={InitLoopSleep}".format(**locals())
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = "{initsystemctl} listen zza.socket"
        init = background(cmd.format(**locals()))
        time.sleep(InitLoopSleep+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*listen"))
        #
        cmd = "./reply.py sendTCP -d foo -p {testport}"
        out, end = output2(cmd.format(**locals()))
        self.assertEqual(end, 0)
        logg.info("send.log>>\n%s", out)
        self.assertTrue(greps(out, "request: foo"))
        self.assertTrue(greps(out, "replied: FOO"))
        log = "{root}/var/log/zza.log"
        out = open(log.format(**locals())).read()
        logg.info("zza.log>>\n%s", out)
        self.assertTrue(greps(out, "received:.*foo"))
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4530_udp_socket_listen(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        testport = self.testport()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        replyB = self.testname("replyB")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} serverUDP -p {testport}
            StandardOutput=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zza.socket"), """
            [Unit]
            Description=Testing B
            [Socket]
            ListenDatagram={testport}
            Service=zza.service
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool("reply.py", os_path(bindir, replyA))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        cmd = "{systemctl} enable zza.socket"
        sh____(cmd.format(**locals()))
        #
        InitLoopSleep = 1
        initsystemctl = systemctl
        initsystemctl += " -c InitLoopSleep={InitLoopSleep}".format(**locals())
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = "{initsystemctl} listen zza.socket -c TestListen -c TestAccept"
        init = background(cmd.format(**locals()))
        time.sleep(InitLoopSleep+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*listen"))
        #
        cmd = "./reply.py sendUDP -d foo -p {testport}"
        out, end = output2(cmd.format(**locals()))
        self.assertEqual(end, 0)
        logg.info("send.log>>\n%s", out)
        self.assertTrue(greps(out, "request: foo"))
        # self.assertTrue(greps(out, "replied: FOO"))
        self.assertTrue(greps(out, "replied: ERROR: FOO"))
        log = "{root}/var/log/zza.log"
        ### out = open(log.format(**locals())).read()
        ### logg.info("zza.log>>\n%s", out)
        ### self.assertTrue(greps(out, "received:.*foo"))
        #
        logg.info("kill daemon at %s", init.pid)
        if TestListen:
            self.assertTrue(self.kill(init.pid))
        elif not self.kill(init.pid):
            self.kill(init.pid, sig = signal.SIGKILL)

        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4531_tcp_socket_listen(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        testport = self.testport()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        replyB = self.testname("replyB")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} serverTCP -p {testport}
            StandardOutput=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zza.socket"), """
            [Unit]
            Description=Testing B
            [Socket]
            ListenStream={testport}
            Service=zza.service
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool("reply.py", os_path(bindir, replyA))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        cmd = "{systemctl} enable zza.socket"
        sh____(cmd.format(**locals()))
        #
        InitLoopSleep = 1
        initsystemctl = systemctl
        initsystemctl += " -c InitLoopSleep={InitLoopSleep}".format(**locals())
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = "{initsystemctl} listen zza.socket -c TestListen -c TestAccept"
        init = background(cmd.format(**locals()))
        time.sleep(InitLoopSleep+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*listen"))
        #
        cmd = "./reply.py sendTCP -d foo -p {testport}"
        out, end = output2(cmd.format(**locals()))
        self.assertEqual(end, 0)
        logg.info("send.log>>\n%s", out)
        self.assertTrue(greps(out, "request: foo"))
        # self.assertTrue(greps(out, "replied: FOO"))
        self.assertTrue(greps(out, "replied: ERROR: FOO"))
        log = "{root}/var/log/zza.log"
        ### out = open(log.format(**locals())).read()
        ### logg.info("zza.log>>\n%s", out)
        ### self.assertTrue(greps(out, "received:.*foo"))
        #
        logg.info("kill daemon at %s", init.pid)
        if TestListen:
            self.assertTrue(self.kill(init.pid))
        elif not self.kill(init.pid):
            self.kill(init.pid, sig = signal.SIGKILL)

        self.assertTrue(self.kill(init.pid))
        #
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4532_tcp4_socket_listen(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        testport = self.testport()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        replyB = self.testname("replyB")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} serverTCP -p {testport}
            StandardOutput=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zza.socket"), """
            [Unit]
            Description=Testing B
            [Socket]
            ListenStream=127.0.0.1:{testport}
            Service=zza.service
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool("reply.py", os_path(bindir, replyA))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        cmd = "{systemctl} enable zza.socket"
        sh____(cmd.format(**locals()))
        #
        InitLoopSleep = 1
        initsystemctl = systemctl
        initsystemctl += " -c InitLoopSleep={InitLoopSleep}".format(**locals())
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = "{initsystemctl} listen zza.socket -c TestListen -c TestAccept"
        init = background(cmd.format(**locals()))
        time.sleep(InitLoopSleep+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*listen"))
        #
        cmd = "./reply.py sendTCP -d foo -p {testport} -a 127.0.0.1"
        out, end = output2(cmd.format(**locals()))
        self.assertEqual(end, 0)
        logg.info("send.log>>\n%s", out)
        self.assertTrue(greps(out, "request: foo"))
        # self.assertTrue(greps(out, "replied: FOO"))
        self.assertTrue(greps(out, "replied: ERROR: FOO"))
        log = "{root}/var/log/zza.log"
        ### out = open(log.format(**locals())).read()
        ### logg.info("zza.log>>\n%s", out)
        ### self.assertTrue(greps(out, "received:.*foo"))
        #
        logg.info("kill daemon at %s", init.pid)
        if TestListen:
            self.assertTrue(self.kill(init.pid))
        elif not self.kill(init.pid):
            self.kill(init.pid, sig = signal.SIGKILL)

        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4534_inet4_socket_listen(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        testport = self.testport()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        replyB = self.testname("replyB")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} serverINET -p {testport}
            StandardOutput=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zza.socket"), """
            [Unit]
            Description=Testing B
            [Socket]
            ListenStream=127.0.0.1:{testport}
            Service=zza.service
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool("reply.py", os_path(bindir, replyA))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        cmd = "{systemctl} enable zza.socket"
        sh____(cmd.format(**locals()))
        #
        InitLoopSleep = 1
        initsystemctl = systemctl
        initsystemctl += " -c InitLoopSleep={InitLoopSleep}".format(**locals())
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = "{initsystemctl} listen zza.socket -c TestListen -c TestAccept"
        init = background(cmd.format(**locals()))
        time.sleep(InitLoopSleep+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*listen"))
        #
        cmd = "./reply.py sendTCP4 -d foo -p {testport} -a 127.0.0.1"
        out, end = output2(cmd.format(**locals()))
        self.assertEqual(end, 0)
        logg.info("send.log>>\n%s", out)
        self.assertTrue(greps(out, "request: foo"))
        # self.assertTrue(greps(out, "replied: FOO"))
        self.assertTrue(greps(out, "replied: ERROR: FOO"))
        log = "{root}/var/log/zza.log"
        ### out = open(log.format(**locals())).read()
        ### logg.info("zza.log>>\n%s", out)
        ### self.assertTrue(greps(out, "received:.*foo"))
        #
        logg.info("kill daemon at %s", init.pid)
        if TestListen:
            self.assertTrue(self.kill(init.pid))
        elif not self.kill(init.pid):
            self.kill(init.pid, sig = signal.SIGKILL)

        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4536_tcp6_socket_listen(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        testport = self.testport()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        replyB = self.testname("replyB")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} serverINET6 -p {testport}
            StandardOutput=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zza.socket"), """
            [Unit]
            Description=Testing B
            [Socket]
            ListenStream=[::1]:{testport}
            Service=zza.service
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool("reply.py", os_path(bindir, replyA))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        cmd = "{systemctl} enable zza.socket"
        sh____(cmd.format(**locals()))
        #
        InitLoopSleep = 1
        initsystemctl = systemctl
        initsystemctl += " -c InitLoopSleep={InitLoopSleep}".format(**locals())
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = "{initsystemctl} listen zza.socket -c TestListen -c TestAccept"
        init = background(cmd.format(**locals()))
        time.sleep(InitLoopSleep+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*listen"))
        #
        cmd = "./reply.py sendTCP6 -d foo -p {testport} -a '::1'"
        out, end = output2(cmd.format(**locals()))
        self.assertEqual(end, 0)
        logg.info("send.log>>\n%s", out)
        self.assertTrue(greps(out, "request: foo"))
        # self.assertTrue(greps(out, "replied: FOO"))
        self.assertTrue(greps(out, "replied: ERROR: FOO"))
        log = "{root}/var/log/zza.log"
        ### out = open(log.format(**locals())).read()
        ### logg.info("zza.log>>\n%s", out)
        ### self.assertTrue(greps(out, "received:.*foo"))
        #
        logg.info("kill daemon at %s", init.pid)
        if TestListen:
            self.assertTrue(self.kill(init.pid))
        elif not self.kill(init.pid):
            self.kill(init.pid, sig = signal.SIGKILL)

        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4540_udp_socket_server(self) -> None:
        self.skipTest("LISTEN_FDS not implemented yet")
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        testport = self.testport()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        replyB = self.testname("replyB")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} socketUDP -p {testport}
            StandardOutput=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zza.socket"), """
            [Unit]
            Description=Testing B
            [Socket]
            ListenDatagram={testport}
            Service=zza.service
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool("reply.py", os_path(bindir, replyA))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        cmd = "{systemctl} enable zza.socket"
        sh____(cmd.format(**locals()))
        #
        InitLoopSleep = 1
        initsystemctl = systemctl
        initsystemctl += " -c InitLoopSleep={InitLoopSleep}".format(**locals())
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = "{initsystemctl} listen zza.socket -c TestListen"
        init = background(cmd.format(**locals()))
        time.sleep(InitLoopSleep+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*listen"))
        #
        cmd = "./reply.py sendUDP -d foo -p {testport}"
        out, end = output2(cmd.format(**locals()))
        self.assertEqual(end, 0)
        logg.info("send.log>>\n%s", out)
        self.assertTrue(greps(out, "request: foo"))
        # self.assertTrue(greps(out, "replied: FOO"))
        self.assertTrue(greps(out, "replied: ERROR: FOO"))
        log = "{root}/var/log/zza.log"
        ### out = open(log.format(**locals())).read()
        ### logg.info("zza.log>>\n%s", out)
        ### self.assertTrue(greps(out, "received:.*foo"))
        #
        logg.info("kill daemon at %s", init.pid)
        if TestListen:
            self.assertTrue(self.kill(init.pid))
        elif not self.kill(init.pid):
            self.kill(init.pid, sig = signal.SIGKILL)

        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4542_tcp_socket_server(self) -> None:
        self.skipTest("LISTEN_FDS not implemented yet")
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        testport = self.testport()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        replyB = self.testname("replyB")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} socketTCP -p {testport}
            StandardOutput=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zza.socket"), """
            [Unit]
            Description=Testing B
            [Socket]
            ListenStream=127.0.0.1:{testport}
            Service=zza.service
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool("reply.py", os_path(bindir, replyA))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        cmd = "{systemctl} enable zza.socket"
        sh____(cmd.format(**locals()))
        #
        InitLoopSleep = 1
        initsystemctl = systemctl
        initsystemctl += " -c InitLoopSleep={InitLoopSleep}".format(**locals())
        if COVERAGE:
            initsystemctl += " -c EXEC_SPAWN=True"
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = "{initsystemctl} listen zza.socket -c TestListen"
        init = background(cmd.format(**locals()))
        time.sleep(InitLoopSleep+1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "systemctl.*listen"))
        #
        cmd = "./reply.py sendTCP -d foo -p {testport} -a 127.0.0.1"
        out, end = output2(cmd.format(**locals()))
        self.assertEqual(end, 0)
        logg.info("send.log>>\n%s", out)
        self.assertTrue(greps(out, "request: foo"))
        # self.assertTrue(greps(out, "replied: FOO"))
        self.assertTrue(greps(out, "replied: ERROR: FOO"))
        log = "{root}/var/log/zza.log"
        ### out = open(log.format(**locals())).read()
        ### logg.info("zza.log>>\n%s", out)
        ### self.assertTrue(greps(out, "received:.*foo"))
        #
        logg.info("kill daemon at %s", init.pid)
        if TestListen:
            self.assertTrue(self.kill(init.pid))
        elif not self.kill(init.pid):
            self.kill(init.pid, sig = signal.SIGKILL)

        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4551_ListenUSB_not_implemented(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        testport = self.testport()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        replyB = self.testname("replyB")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} socketTCP -p {testport}
            StandardOutput=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zza.socket"), """
            [Unit]
            Description=Testing B
            [Socket]
            ListenUSBFunction=foo
            Service=zza.service
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool("reply.py", os_path(bindir, replyA))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        #
        cmd = "{systemctl} start zza.socket -c TestListen -vvvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertTrue(greps(err, "ListenUSBFunction sockets are not implemented"))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4552_ListenSpecial_not_implemented(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        testport = self.testport()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        replyB = self.testname("replyB")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} socketTCP -p {testport}
            StandardOutput=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zza.socket"), """
            [Unit]
            Description=Testing B
            [Socket]
            ListenSpecial=foo
            Service=zza.service
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool("reply.py", os_path(bindir, replyA))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        #
        cmd = "{systemctl} start zza.socket -c TestListen -vvvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertTrue(greps(err, "ListenSpecial sockets are not implemented"))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4553_ListenFIFO_not_implemented(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        testport = self.testport()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        replyB = self.testname("replyB")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} socketTCP -p {testport}
            StandardOutput=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zza.socket"), """
            [Unit]
            Description=Testing B
            [Socket]
            ListenFIFO=foo
            Service=zza.service
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool("reply.py", os_path(bindir, replyA))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        #
        cmd = "{systemctl} start zza.socket -c TestListen -vvvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertTrue(greps(err, "ListenFIFO sockets are not implemented"))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4554_ListenSequentialPacket_not_implemented(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        testport = self.testport()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        replyB = self.testname("replyB")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} socketTCP -p {testport}
            StandardOutput=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zza.socket"), """
            [Unit]
            Description=Testing B
            [Socket]
            ListenSequentialPacket=foo
            Service=zza.service
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool("reply.py", os_path(bindir, replyA))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        #
        cmd = "{systemctl} start zza.socket -c TestListen -vvvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertTrue(greps(err, "ListenSequentialPacket sockets are not implemented"))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4555_ListenMessageQueue_not_implemented(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        testport = self.testport()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        replyB = self.testname("replyB")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} socketTCP -p {testport}
            StandardOutput=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zza.socket"), """
            [Unit]
            Description=Testing B
            [Socket]
            ListenMessageQueue=foo
            Service=zza.service
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool("reply.py", os_path(bindir, replyA))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        #
        cmd = "{systemctl} start zza.socket -c TestListen -vvvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertTrue(greps(err, "ListenMessageQueue sockets are not implemented"))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4561_vsock_not_implemented(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        testport = self.testport()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        replyB = self.testname("replyB")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} socketTCP -p {testport}
            StandardOutput=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zza.socket"), """
            [Unit]
            Description=Testing B
            [Socket]
            ListenStream=vsock:foo
            Service=zza.service
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool("reply.py", os_path(bindir, replyA))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        #
        cmd = "{systemctl} start zza.socket -c TestListen -vvvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertTrue(greps(err, "virtual machine socket not implemented"))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4562_abstract_not_implemented(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        testport = self.testport()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        replyB = self.testname("replyB")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} socketTCP -p {testport}
            StandardOutput=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zza.socket"), """
            [Unit]
            Description=Testing B
            [Socket]
            ListenStream=@/foo
            Service=zza.service
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool("reply.py", os_path(bindir, replyA))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        #
        cmd = "{systemctl} start zza.socket -c TestListen -vvvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertTrue(greps(err, "abstract namespace socket not implemented"))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4566_unknown_type_not_implemented(self) -> None:
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        testport = self.testport()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        sockfile = os_path(root, "/var/run/"+testname+".sock")
        replyA = self.testname("replyA")
        replyB = self.testname("replyB")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{replyA} socketTCP -p {testport}
            StandardOutput=file:{root}/var/log/zza.log
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zza.socket"), """
            [Unit]
            Description=Testing B
            [Socket]
            ListenStream=&append
            Service=zza.service
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool("reply.py", os_path(bindir, replyA))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zza.socket"), os_path(root, "/etc/systemd/system/zza.socket"))
        #
        cmd = "{systemctl} start zza.socket -c TestListen -vvvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s\n%s", cmd, end, out, err)
        self.assertTrue(greps(err, "unknown socket address type"))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4600_systemctl_py_start_target_units(self) -> None:
        """ check that we can enable template services in a target"""
        vv = self.begin()
        self.rm_testdir()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=oneshot
            ExecStart=/bin/touch {root}/tmp/zz.a.txt
            ExecStop=/bin/rm {root}/tmp/zz.a.txt
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=oneshot
            ExecStart=/bin/touch {root}/tmp/zz.b.txt
            ExecStop=/bin/rm {root}/tmp/zz.b.txt
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zz@.service"), """
            [Unit]
            Description=Testing Z.%i
            [Service]
            Type=oneshot
            ExecStart=/bin/touch {root}/tmp/zz.%i.txt
            ExecStop=/bin/rm {root}/tmp/zz.%i.txt
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zzxx.target"), """
            [Unit]
            Description=Testing D
            Requires= zza.service zz@rsa.service
            """.format(**locals()))
        #
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        copy_file(os_path(testdir, "zz@.service"), os_path(root, "/etc/systemd/system/zz@.service"))
        copy_file(os_path(testdir, "zzxx.target"), os_path(root, "/etc/systemd/system/zzxx.target"))
        text_file(os_path(root, "/tmp/zz.tmp"), "")
        cmd = "{systemctl} enable zza.service"
        sh____(cmd.format(**locals()))
        cmd = "{systemctl} enable zzb.service"
        sh____(cmd.format(**locals()))
        cmd = "{systemctl} default-services | sort"
        out = output(cmd.format(**locals()))
        logg.info("\n>\n%s", out)
        self.assertEqual(out.strip(), "zza.service\nzzb.service")
        cmd = "{systemctl} default-services zzxx.target | sort"
        out = output(cmd.format(**locals()))
        logg.info("\n>\n%s", out)
        self.assertEqual(out.strip(), "zza.service\nzz@rsa.service")
        #
        cmd = "{systemctl} is-active zzxx.target"
        out = output(cmd.format(**locals()))
        logg.info("\n>\n%s", out)
        self.assertEqual(out.strip(), "inactive")
        cmd = "{systemctl} is-active zza.service"
        out = output(cmd.format(**locals()))
        logg.info("\n>\n%s", out)
        self.assertEqual(out.strip(), "inactive")
        #
        cmd = "{systemctl} start zza.service {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} is-active zzxx.target"
        out = output(cmd.format(**locals()))
        logg.info("\n>\n%s", out)
        self.assertEqual(out.strip(), "inactive")
        cmd = "{systemctl} is-active zza.service"
        out = output(cmd.format(**locals()))
        logg.info("\n>\n%s", out)
        self.assertEqual(out.strip(), "active")
        #
        cmd = "{systemctl} start zzxx.target {vv}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        cmd = "{systemctl} is-active zzxx.target {vv}"
        out = output(cmd.format(**locals()))
        logg.info("\n>\n%s", out)
        self.assertEqual(out.strip(), "active")
        cmd = "{systemctl} is-active zza.service"
        out = output(cmd.format(**locals()))
        logg.info("\n>\n%s", out)
        self.assertEqual(out.strip(), "active")
        cmd = "{systemctl} is-active zz@rsa.service"
        out = output(cmd.format(**locals()))
        logg.info("\n>\n%s", out)
        self.assertEqual(out.strip(), "active")
        #
        self.rm_zzfiles(root)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4700_systemctl_py_restart_failed_units(self) -> None:
        """ check that we can enable services in a docker container to be run as default-services
            and failed units are going to be restarted"""
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleepA = self.testname("sleepA")
        testsleepB = self.testname("sleepB")
        testsleepC = self.testname("sleepC")
        testsleepD = self.testname("sleepD")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepA} 44
            Restart=on-failure
            RestartSec=4
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepB} 55
            Restart=on-failure
            RestartSec=5
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zzc.service"), """
            [Unit]
            Description=Testing C
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepC} 66
            Restart=on-failure
            RestartSec=6
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zzd.service"), """
            [Unit]
            Description=Testing D
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepD} 122
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        #
        copy_tool(_bin_sleep, os_path(bindir, testsleepA))
        copy_tool(_bin_sleep, os_path(bindir, testsleepB))
        copy_tool(_bin_sleep, os_path(bindir, testsleepC))
        copy_tool(_bin_sleep, os_path(bindir, testsleepD))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        copy_file(os_path(testdir, "zzc.service"), os_path(root, "/etc/systemd/system/zzc.service"))
        copy_file(os_path(testdir, "zzd.service"), os_path(root, "/etc/systemd/system/zzd.service"))
        cmd = "{systemctl} enable zza.service"
        sh____(cmd.format(**locals()))
        cmd = "{systemctl} enable zzb.service"
        sh____(cmd.format(**locals()))
        cmd = "{systemctl} enable zzc.service"
        sh____(cmd.format(**locals()))
        cmd = "{systemctl} enable zzd.service"
        sh____(cmd.format(**locals()))
        cmd = "{systemctl} default-services -v"
        sh____(cmd.format(**locals()))
        # sh____(cmd.format(**locals()))
        out2 = output(cmd.format(**locals()))
        logg.info("\n>\n%s", out2)
        #
        InitLoopSleep = 1
        initsystemctl = systemctl
        initsystemctl += " -c InitLoopSleep={InitLoopSleep}".format(**locals())
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = "{initsystemctl} -1"
        init = background(cmd.format(**locals()))
        time.sleep(InitLoopSleep+2)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "sleepA"))
        self.assertTrue(greps(top, "sleepB"))
        self.assertTrue(greps(top, "sleepC"))
        self.assertTrue(greps(top, "sleepD"))
        #
        check = "{systemctl} list-units --state=running --type=service"
        top = output(check.format(**locals()))
        logg.info("\n>>>\n%s", top)
        self.assertEqual(len(greps(top, "zz")), 4)
        #
        log = lines(open(debug_log))
        logg.info("systemctl.debug.log>\n\t%s", "\n\t".join(log))
        self.assertFalse(greps(log, "restart"))
        #
        cmd = "{systemctl} __killall {testsleepD}" # <<<
        sh____(cmd.format(**locals()))
        #
        time.sleep(InitLoopSleep+1)
        log = lines(open(debug_log))
        # logg.info("systemctl.debug.log>\n\t%s", "\n\t".join(log))
        self.assertFalse(greps(log, "restart"))
        #
        check = "{systemctl} list-units --state=running --type=service"
        top = output(check.format(**locals()))
        logg.info("\n>>>\n%s", top)
        self.assertEqual(len(greps(top, "zz")), 3)
        #
        cmd = "{systemctl} __killall {testsleepC}" # <<<
        sh____(cmd.format(**locals()))
        #
        check = "{systemctl} list-units --state=running --type=service"
        top = output(check.format(**locals()))
        logg.info("\n>>>\n%s", top)
        self.assertEqual(len(greps(top, "zz")), 2)
        #
        time.sleep(InitLoopSleep+1) # RestartSec=6
        #
        check = "{systemctl} list-units --state=running --type=service"
        top = output(check.format(**locals()))
        logg.info("\n>>>\n%s", top)
        self.assertEqual(len(greps(top, "zz")), 2)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        logg.info("============== wait for a Restart")
        time.sleep(6) # to have RestartSec=6
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        logg.info("==============>>")
        #
        log = lines(open(debug_log))
        logg.info("systemctl.debug.log>\n\t%s", "\n\t".join(log[-20:]))
        #
        check = "{systemctl} list-units --state=running --type=service"
        top = output(check.format(**locals()))
        logg.info("\n>>>\n%s", top)
        self.assertEqual(len(greps(top, "zz")), 3)
        #
        time.sleep(InitLoopSleep+1)
        log = lines(open(debug_log))
        logg.info("systemctl.debug.log>\n\t%s", "\n\t".join(log))
        self.assertTrue(greps(log, "restart"))
        #
        self.assertTrue(greps(log, ".zzc.service. --- restarting failed unit"))
        self.assertTrue(greps(log, ".zzd.service. Current NoCheck .Restart=no."))
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid, 20))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4710_systemctl_py_restart_failed_units_rate_limit(self) -> None:
        """ check that we can enable services in a docker container to be run as default-services
            and failed units are going to be restarted"""
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleepA = self.testname("sleepA")
        testsleepB = self.testname("sleepB")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepA} 2
            Restart=on-failure
            RestartSec=1
            StartLimitBurst=3
            StartLimitIntervalSec=12
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepB} 6
            Restart=on-failure
            RestartSec=3
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        #
        copy_tool(_bin_sleep, os_path(bindir, testsleepA))
        copy_tool(_bin_sleep, os_path(bindir, testsleepB))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        cmd = "{systemctl} enable zza.service"
        sh____(cmd.format(**locals()))
        cmd = "{systemctl} enable zzb.service"
        sh____(cmd.format(**locals()))
        cmd = "{systemctl} default-services -v"
        sh____(cmd.format(**locals()))
        # sh____(cmd.format(**locals()))
        out2 = output(cmd.format(**locals()))
        logg.info("\n>\n%s", out2)
        #
        InitLoopSleep = 1
        systemctl += " -c InitLoopSleep={InitLoopSleep}".format(**locals())
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = "{systemctl} -1"
        init = background(cmd.format(**locals()))
        time.sleep(1)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "sleepA"))
        self.assertTrue(greps(top, "sleepB"))
        #
        logg.info("===============SLEEP")
        time.sleep(22)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        logg.info("==============>>")
        #
        log = lines(open(debug_log))
        logg.info("systemctl.debug.log>\n\t%s", "\n\t".join(log[-20:]))
        #
        check = "{systemctl} list-units --state=running --type=service"
        top = output(check.format(**locals()))
        logg.info("\n>>>\n%s", top)
        # self.assertEqual(len(greps(top, "zz")), 3)
        #
        time.sleep(InitLoopSleep+1)
        log = lines(open(debug_log))
        logg.info("systemctl.debug.log>\n\t%s", "\n\t".join(log))
        self.assertTrue(greps(log, "restart"))
        self.assertTrue(greps(log, "zza.service.*Blocking Restart"))
        self.assertTrue(greps(log, "zza.service.*Status: error"))
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4760_systemctl_py_restart_sec_shortens_interval(self) -> None:
        """ check that we can enable services in a docker container to be run as default-services
            and RestartSec shortes the InitLoop interval"""
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleepA = self.testname("sleepA")
        testsleepB = self.testname("sleepB")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepA} 2
            Restart=on-failure
            RestartSec=200ms
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepB} 6
            Restart=on-failure
            RestartSec=2
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        #
        copy_tool(_bin_sleep, os_path(bindir, testsleepA))
        copy_tool(_bin_sleep, os_path(bindir, testsleepB))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        cmd = "{systemctl} enable zza.service"
        sh____(cmd.format(**locals()))
        cmd = "{systemctl} enable zzb.service"
        sh____(cmd.format(**locals()))
        cmd = "{systemctl} default-services -v"
        sh____(cmd.format(**locals()))
        # sh____(cmd.format(**locals()))
        out2 = output(cmd.format(**locals()))
        logg.info("\n>\n%s", out2)
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = "{systemctl} -1"
        init = background(cmd.format(**locals()))
        time.sleep(2)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "sleepA"))
        self.assertTrue(greps(top, "sleepB"))
        #
        logg.info("===============SLEEP")
        time.sleep(6)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        logg.info("==============>>")
        #
        log = lines(open(debug_log))
        logg.info("systemctl.debug.log>\n\t%s", "\n\t".join(log[-20:]))
        #
        self.assertTrue(greps(log, ".zzb.service. set InitLoopSleep from 5s to 2 .caused by RestartSec=2.000s"))
        self.assertFalse(greps(log, "zza.service.*set InitLoopSleep"))
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4770_systemctl_py_restart_sec_shortens_interval(self) -> None:
        """ check that we can enable services in a docker container to be run as default-services
            and RestartSec shortes the InitLoop interval"""
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleepA = self.testname("sleepA")
        testsleepB = self.testname("sleepB")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepA} 2
            Restart=on-failure
            RestartSec=2
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepB} 6
            Restart=on-failure
            RestartSec=0
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        #
        copy_tool(_bin_sleep, os_path(bindir, testsleepA))
        copy_tool(_bin_sleep, os_path(bindir, testsleepB))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        cmd = "{systemctl} enable zza.service"
        sh____(cmd.format(**locals()))
        cmd = "{systemctl} enable zzb.service"
        sh____(cmd.format(**locals()))
        cmd = "{systemctl} default-services -v"
        sh____(cmd.format(**locals()))
        # sh____(cmd.format(**locals()))
        out2 = output(cmd.format(**locals()))
        logg.info("\n>\n%s", out2)
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = "{systemctl} -1"
        init = background(cmd.format(**locals()))
        time.sleep(2)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "sleepA"))
        self.assertTrue(greps(top, "sleepB"))
        #
        logg.info("===============SLEEP")
        time.sleep(6)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        logg.info("==============>>")
        #
        log = lines(open(debug_log))
        logg.info("systemctl.debug.log>\n\t%s", "\n\t".join(log[-20:]))
        #
        self.assertTrue(greps(log, ".zza.service. set InitLoopSleep from 5s to 2"))
        self.assertTrue(greps(log, ".zzb.service. set InitLoopSleep from 2s to 1 .caused by RestartSec=0!"))
        #
        logg.info("kill daemon at %s", init.pid)
        self.assertTrue(self.kill(init.pid))
        #
        self.rm_killall()
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4800_is_system_running_features(self) -> None:
        """ check that we can enable services in a docker container
            and the is-system-running will not report true unless
            they are up and running"""
        self.begin()
        self.rm_testdir()
        self.rm_killall()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        systemctl += " -c InitLoopSleep=2"
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleepA = self.testname("sleepA")
        testsleepB = self.testname("sleepB")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStartPre={bindir}/{testsleepA} 4
            ExecStart={bindir}/{testsleepA} 5
            Restart=no
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(testdir, "zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepB} 16
            Restart=on-failure
            RestartSec=0
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        #
        copy_tool(_bin_sleep, os_path(bindir, testsleepA))
        copy_tool(_bin_sleep, os_path(bindir, testsleepB))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        copy_file(os_path(testdir, "zzb.service"), os_path(root, "/etc/systemd/system/zzb.service"))
        cmd = "{systemctl} enable zza.service"
        sh____(cmd.format(**locals()))
        cmd = "{systemctl} enable zzb.service"
        sh____(cmd.format(**locals()))
        cmd = "{systemctl} default-services -v"
        sh____(cmd.format(**locals()))
        # sh____(cmd.format(**locals()))
        out2 = output(cmd.format(**locals()))
        logg.info("\n>\n%s", out2)
        #
        debug_log = os_path(root, expand_path(SYSTEMCTL_DEBUG_LOG))
        os_remove(debug_log)
        text_file(debug_log, "")
        cmd = "{systemctl} -1" # init
        init = background(cmd.format(**locals()))
        #
        time.sleep(1)
        cmd = "{systemctl} is-system-running"
        out, err, rc = output3(cmd.format(**locals()))
        logg.info("\n>>>(%s)\n%s\n%s", rc, i2(err), out)
        # self.assertEqual(out, "starting\n")
        # self.assertEqual(rc, 1)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "sleepA 4"))
        self.assertFalse(greps(top, "sleepB")) # we do not start in parallel
        #
        cmd = "{systemctl} is-system-running --quiet"
        out, err, rc = output3(cmd.format(**locals()))
        logg.info("\n>>>(%s)\n%s\n%s", rc, i2(err), out)
        self.assertEqual(out, "")
        self.assertEqual(rc, 1)
        #
        time.sleep(4)
        cmd = "{systemctl} is-system-running"
        out, err, rc = output3(cmd.format(**locals()))
        logg.info("\n>>>(%s)\n%s\n%s", rc, i2(err), out)
        self.assertEqual(out, "running\n")
        self.assertEqual(rc, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "sleepA 5"))
        self.assertTrue(greps(top, "sleepB"))
        #
        # time.sleep(3) # InitLoopInterval+1
        # self.assertFalse(greps(top, "sleepA")) # failed state
        ## self.assertTrue(greps(top, "sleepB"))
        #
        logg.info("trying to send a 'halt'")
        logg.info("kill daemon at %s", init.pid)
        result = self.kill(init.pid)
        logg.info("kill daemon %s", result)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        #
        log = reads(debug_log)
        logg.info("systemctl.debug.log>\n\t%s", oi22(log))
        self.assertTrue(greps(log, "interrupted - exit init-loop"))
        #
        cmd = "{systemctl} is-system-running"
        out, err, rc = output3(cmd.format(**locals()))
        logg.info("\n>>>(%s)\n%s\n%s", rc, i2(err), out)
        self.assertEqual(out, "stopping\n")
        self.assertEqual(rc, 1)
        #
        for attempt in xrange(10):
            top = _recent(output(_top_list))
            logg.info("\n>>>\n%s", top)
            if greps(top, "sleepA") or greps(top, "sleepB"):
                time.sleep(1)
                continue
            break
        # atleast 1sec per ExecStop upon Halt # TODO?
        logg.info("===================== time to stop the subprocesses: %ss", attempt)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, "sleepA"))
        self.assertFalse(greps(top, "sleepB"))
        #
        self.rm_killall()
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        #
        log = reads(debug_log)
        logg.info("systemctl.debug.log>\n\t%s", oi22(log))
        #
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4881_set_user_to_same(self) -> None:
        """ check that we can run a service with User= settings (for coverage) """
        self.begin()
        self.rm_testdir()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        systemctl += " -c InitLoopSleep=2 -c EXEC_SPAWN=True"
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleepA = self.testname("sleepA")
        bindir = os_path(root, "/usr/bin")
        this_user=get_USER()
        this_group=get_GROUP()
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepA} 1
            User={this_user}
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        #
        copy_tool(_bin_sleep, os_path(bindir, testsleepA))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        kill_testsleep = "{systemctl} __killall {testsleepA} -vvvv"
        sx____(kill_testsleep.format(**locals()))
        #
        cmd = "{systemctl} start zza.service -vvvv"
        out, err, rc = output3(cmd.format(**locals()))
        logg.info("\n>>>(%s)\n%s\n%s", rc, i2(err), out)
        self.assertEqual(rc, 0)
        #
        kill_testsleep = "{systemctl} __killall {testsleepA}"
        sx____(kill_testsleep.format(**locals()))
        #
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4882_set_user_and_group_to_same(self) -> None:
        """ check that we can run a service with User= Group= settings (for coverage) """
        self.begin()
        self.rm_testdir()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        systemctl += " -c InitLoopSleep=2 -c EXEC_SPAWN=True"
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleepA = self.testname("sleepA")
        bindir = os_path(root, "/usr/bin")
        this_user=get_USER()
        this_group=get_GROUP()
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepA} 1
            User={this_user}
            Group={this_group}
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        #
        copy_tool(_bin_sleep, os_path(bindir, testsleepA))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        kill_testsleep = "{systemctl} __killall {testsleepA} -vvvv"
        sx____(kill_testsleep.format(**locals()))
        #
        cmd = "{systemctl} start zza.service -vvvv"
        out, err, rc = output3(cmd.format(**locals()))
        logg.info("\n>>>(%s)\n%s\n%s", rc, i2(err), out)
        self.assertEqual(rc, 0)
        #
        kill_testsleep = "{systemctl} __killall {testsleepA}"
        sx____(kill_testsleep.format(**locals()))
        #
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4883_set_group_to_same(self) -> None:
        """ check that we can run a service with Group= settings (for coverage) """
        self.begin()
        self.rm_testdir()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        systemctl += " -c InitLoopSleep=2 -c EXEC_SPAWN=True"
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleepA = self.testname("sleepA")
        bindir = os_path(root, "/usr/bin")
        this_user=get_USER()
        this_group=get_GROUP()
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepA} 1
            Group={this_group}
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        #
        copy_tool(_bin_sleep, os_path(bindir, testsleepA))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        kill_testsleep = "{systemctl} __killall {testsleepA} -vvvv"
        sx____(kill_testsleep.format(**locals()))
        #
        cmd = "{systemctl} start zza.service -vvvv"
        out, err, rc = output3(cmd.format(**locals()))
        logg.info("\n>>>(%s)\n%s\n%s", rc, i2(err), out)
        self.assertEqual(rc, 0)
        #
        kill_testsleep = "{systemctl} __killall {testsleepA}"
        sx____(kill_testsleep.format(**locals()))
        #
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4884_set_user_and_supp_group_to_same(self) -> None:
        """ check that we can run a service with User= Group= SupplementaryGroups= settings (for coverage) """
        self.begin()
        self.rm_testdir()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        systemctl += " -c InitLoopSleep=2 -c EXEC_SPAWN=True"
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleepA = self.testname("sleepA")
        bindir = os_path(root, "/usr/bin")
        this_user=get_USER()
        this_group=get_GROUP()
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepA} 1
            User={this_user}
            Group={this_group}
            SupplementaryGroups={this_group}
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        #
        copy_tool(_bin_sleep, os_path(bindir, testsleepA))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        kill_testsleep = "{systemctl} __killall {testsleepA} -vvvv"
        sx____(kill_testsleep.format(**locals()))
        #
        cmd = "{systemctl} start zza.service -vvvv"
        out, err, rc = output3(cmd.format(**locals()))
        logg.info("\n>>>(%s)\n%s\n%s", rc, i2(err), out)
        self.assertEqual(rc, 0)
        #
        kill_testsleep = "{systemctl} __killall {testsleepA}"
        sx____(kill_testsleep.format(**locals()))
        #
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4885_set_user_and_supp_group_to_same(self) -> None:
        """ check that we can run a service with User= SupplementaryGroups= extra (for coverage) """
        self.begin()
        self.rm_testdir()
        testname = self.testname()
        testdir = self.testdir()
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        systemctl += " -c InitLoopSleep=2 -c EXEC_SPAWN=True"
        logfile = os_path(root, "/var/log/"+testname+".log")
        testsleepA = self.testname("sleepA")
        bindir = os_path(root, "/usr/bin")
        this_user=get_USER()
        this_group=get_GROUP()
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepA} 1
            User={this_user}
            SupplementaryGroups={this_group}
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        #
        copy_tool(_bin_sleep, os_path(bindir, testsleepA))
        copy_file(os_path(testdir, "zza.service"), os_path(root, "/etc/systemd/system/zza.service"))
        kill_testsleep = "{systemctl} __killall {testsleepA} -vvvv"
        sx____(kill_testsleep.format(**locals()))
        #
        cmd = "{systemctl} start zza.service -vvvv"
        out, err, rc = output3(cmd.format(**locals()))
        logg.info("\n>>>(%s)\n%s\n%s", rc, i2(err), out)
        self.assertEqual(rc, 0)
        #
        kill_testsleep = "{systemctl} __killall {testsleepA}"
        sx____(kill_testsleep.format(**locals()))
        #
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4900_unreadable_files_can_be_handled(self) -> None:
        """ a file may exist but it is unreadable"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        testsleep = self.testname("sleep")
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            Requires=zzb.service
            [Service]
            Type=simple
            ExecStart={root}/bin/{testsleep} 10
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        text_file(os_path(root, "/etc/systemd/system-preset/our.preset"), """
            enable zza.service
            disable zzb.service""")
        os.makedirs(os_path(root, "/var/run"))
        os.makedirs(os_path(root, "/var/log"))
        copy_tool(_bin_sleep, "{root}/bin/{testsleep}".format(**locals()))
        #
        os.chmod(os_path(root, "/etc/systemd/system/zza.service"), 0o222)
        #
        cmd = "{systemctl} start zza"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = "{systemctl} start zza.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertNotEqual(end, 0)
        cmd = "{systemctl} stop zza.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertNotEqual(end, 0)
        cmd = "{systemctl} reload zza.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertNotEqual(end, 0)
        cmd = "{systemctl} restart zza.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertNotEqual(end, 0)
        cmd = "{systemctl} try-restart zza.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertNotEqual(end, 0)
        cmd = "{systemctl} reload-or-restart zza.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertNotEqual(end, 0)
        cmd = "{systemctl} reload-or-try-restart zza.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertNotEqual(end, 0)
        cmd = "{systemctl} kill zza.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertNotEqual(end, 0)
        #
        cmd = "{systemctl} is-active zza.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertNotEqual(end, 0)
        self.assertTrue(greps(out, "unknown"))
        cmd = "{systemctl} is-failed zza.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(out, "unknown"))
        #
        cmd = "{systemctl} status zza.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertNotEqual(end, 0)
        self.assertTrue(greps(out, "zza.service - NOT-FOUND"))
        #
        cmd = "{systemctl} show zza.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0) # shows not-found state ok
        self.assertTrue(greps(out, "LoadState=not-found"))
        #
        cmd = "{systemctl} cat zza.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertNotEqual(end, 0)
        self.assertTrue(greps(out, "Unit zza.service is not-loaded"))
        #
        cmd = "{systemctl} list-dependencies zza.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0) # always succeeds
        #
        cmd = "{systemctl} enable zza.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertNotEqual(end, 0)
        cmd = "{systemctl} disable zza.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertNotEqual(end, 0)
        cmd = "{systemctl} is-enabled zza.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 1)
        #
        cmd = "{systemctl} preset zza.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertNotEqual(end, 0)
        cmd = "{systemctl} preset-all"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertNotEqual(end, 0)
        #
        cmd = "{systemctl} daemon-reload"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0) # always succeeds
        #
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_4901_unsupported_run_type_for_service(self) -> None:
        """ a service file may exist but the run type is not supported"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        testsleep = self.testname("sleep")
        user = self.user()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        logfile = os_path(root, "/var/log/"+testname+".log")
        text_file(os_path(root, "/etc/systemd/system/zza.service"), """
            [Unit]
            Description=Testing A
            Requires=zzb.service
            [Service]
            Type=foo
            ExecStart={root}/bin/{testsleep} 10
            ExecStop=/bin/kill $MAINPID
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        copy_tool(_bin_sleep, "{root}/bin/{testsleep}".format(**locals()))
        #
        cmd = "{systemctl} start zza"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertNotEqual(end, 0)
        cmd = "{systemctl} start zza.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertNotEqual(end, 0)
        cmd = "{systemctl} stop zza.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertNotEqual(end, 0)
        cmd = "{systemctl} reload zza.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertNotEqual(end, 0)
        cmd = "{systemctl} restart zza.service"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertNotEqual(end, 0)
        self.rm_testdir()
        self.coverage()
        self.end()
    #
    #
    ###########################################################################
    #
    #                           INSIDE A CONTAINER
    #
    ###########################################################################
    #
    #
    def prep_coverage(self, image: Optional[str], testname: str, cov_option: Optional[str] = None) -> None:
        """ install a shell-wrapper /usr/bin/systemctl (testdir/systemctl.sh)
            which calls the develop systemctl.py prefixed by our coverage tool.
            .
            The weird name for systemctl_py_run is special for save_coverage().
            We take the realpath of our develop systemctl.py on purpose here.
        """
        docker = _docker
        testdir = self.testdir(testname, keep = True)
        cov_run = cover(image, append = "--parallel-mode")
        cov_option = cov_option or ""
        systemctl_py = realpath(_systemctl_py)
        systemctl_sh = os_path(testdir, "systemctl.sh")
        systemctl_py_run = systemctl_py.replace("/", "_")[1:]
        shell_file(systemctl_sh, """
            #! /bin/sh
            cd /tmp
            exec {cov_run} /{systemctl_py_run} "$@" -vv {cov_option}
            """.format(**locals()))
        cmd = "{docker} cp {systemctl_py} {testname}:/{systemctl_py_run}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {systemctl_sh} {testname}:/usr/bin/systemctl"
        sh____(cmd.format(**locals()))
    def save_coverage(self, *testnames: str) -> None:
        """ Copying the image's /tmp/.coverage to our local ./.coverage.image file.
            Since the path of systemctl.py inside the container is different
            than our develop systemctl.py we have to patch the .coverage file.
            .
            Some older coverage2 did use a binary format, so we had ensured
            the path of systemctl.py inside the container has the exact same
            length as the realpath of our develop systemctl.py outside the
            container. That way 'coverage combine' maps the results correctly."""
        if not COVERAGE:
            return
        docker = _docker
        sed = _sed
        systemctl_py = realpath(_systemctl_py)
        systemctl_py_run = systemctl_py.replace("/", "_")[1:]
        for testname in testnames:
            cmd = "{docker} export {testname} | tar tf - | grep tmp/.coverage"
            files = output(cmd.format(**locals()))
            for tmp_coverage in lines(files):
                suffix = tmp_coverage.replace("tmp/.coverage", "")
                cmd = "{docker} cp {testname}:/{tmp_coverage} .coverage.{testname}{suffix}"
                sh____(cmd.format(**locals()))
                cmd = "{sed} -i -e 's:/{systemctl_py_run}:{systemctl_py}:' .coverage.{testname}{suffix}"
                sh____(cmd.format(**locals()))

    #
    def test_5000_systemctl_py_inside_container(self) -> None:
        """ check that we can run systemctl.py inside a docker container """
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        images = IMAGES
        image = self.local_image(IMAGE or CENTOS)
        if _python.endswith("python3") and "centos:7" in image:
            if SKIP: self.skipTest("no python3 on centos:7")
        testname = self.testname()
        testdir = self.testdir()
        docker = _docker
        package = package_tool(image)
        refresh = refresh_tool(image)
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        python_coverage = coverage_package(image)
        systemctl_py = _systemctl_py
        sometime = SOMETIME or 188
        #
        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} cp {systemctl_py} {testname}:/usr/bin/systemctl"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl --version"
        sh____(cmd.format(**locals()))
        out = output(cmd.format(**locals()))
        logg.info("\n>\n%s", out)
        #
        self.rm_docker(testname)
        self.rm_testdir()
        #
        self.assertTrue(greps(out, "systemctl.py"))
    def test_5001_coverage_systemctl_py_inside_container(self) -> None:
        """ check that we can run systemctl.py with coverage inside a docker container """
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        images = IMAGES
        image = self.local_image(COVERAGE or IMAGE or CENTOS) # <<<< need to use COVERAGE image here
        if _python.endswith("python3") and "centos:7" in image:
            if SKIP: self.skipTest("no python3 on centos:7")
        docker = _docker
        testname = self.testname()
        testdir = self.testdir()
        package = package_tool(image)
        refresh = refresh_tool(image)
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        python_coverage = coverage_package(image) # <<<< and install the tool for the COVERAGE image
        systemctl_py = _systemctl_py
        sometime = SOMETIME or 188
        #
        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sx____(cmd.format(**locals()))
        if COVERAGE:
            cmd = "{docker} exec {testname} {package} install -y {python_coverage}" # <<<< like here
            sx____(cmd.format(**locals()))
        self.prep_coverage(image, testname)  # setup a shell-wrapper /usr/bin/systemctl calling systemctl.py
        cmd = "{docker} exec {testname} systemctl --version"
        sh____(cmd.format(**locals()))
        out = output(cmd.format(**locals()))
        logg.info("\n>\n%s", out)
        #
        self.save_coverage(testname)  # fetch {image}:.coverage and set path to develop systemctl.py
        #
        self.rm_docker(testname)
        self.rm_testdir()
        #
        self.assertTrue(greps(out, "systemctl.py"))
    def test_5002_systemctl_py_enable_in_container(self) -> None:
        """ check that we can enable services in a docker container """
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        images = IMAGES
        image = self.local_image(COVERAGE or IMAGE or CENTOS)
        if _python.endswith("python3") and "centos:7" in image:
            if SKIP: self.skipTest("no python3 on centos:7")
        docker = _docker
        testname = self.testname()
        testdir = self.testdir()
        package = package_tool(image)
        refresh = refresh_tool(image)
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        python_coverage = coverage_package(image)
        systemctl_py = _systemctl_py
        sometime = SOMETIME or 188
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A""")
        text_file(os_path(testdir, "zzb.service"), """
            [Unit]
            Description=Testing B
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(testdir, "zzc.service"), """
            [Unit]
            Description=Testing C
            [Install]
            WantedBy=multi-user.target""")
        #
        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sx____(cmd.format(**locals()))
        if COVERAGE:
            cmd = "{docker} exec {testname} {package} install -y {python_coverage}"
            sx____(cmd.format(**locals()))
        self.prep_coverage(image, testname)
        cmd = "{docker} exec {testname} mkdir -p /etc/systemd/system"
        sx____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zza.service {testname}:/etc/systemd/system/zza.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zzb.service {testname}:/etc/systemd/system/zzb.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zzc.service {testname}:/etc/systemd/system/zzc.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl enable zzc.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl --version"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl list-unit-files"
        # sh____(cmd.format(**locals()))
        out = output(cmd.format(**locals()))
        logg.info("\n>\n%s", out)
        #
        self.save_coverage(testname)
        #
        self.rm_docker(testname)
        self.rm_testdir()
        #
        self.assertTrue(greps(out, "zza.service.*static"))
        self.assertTrue(greps(out, "zzb.service.*disabled"))
        self.assertTrue(greps(out, "zzc.service.*enabled"))
    def test_5003_systemctl_py_default_services_in_container(self) -> None:
        """ check that we can enable services in a docker container to have default-services"""
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        images = IMAGES
        image = self.local_image(COVERAGE or IMAGE or CENTOS)
        if _python.endswith("python3") and "centos:7" in image:
            if SKIP: self.skipTest("no python3 on centos:7")
        testname = self.testname()
        testdir = self.testdir()
        docker = _docker
        package = package_tool(image)
        refresh = refresh_tool(image)
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        python_coverage = coverage_package(image)
        systemctl_py = _systemctl_py
        sometime = SOMETIME or 188
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A""")
        text_file(os_path(testdir, "zzb.service"), """
            [Unit]
            Description=Testing B
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(testdir, "zzc.service"), """
            [Unit]
            Description=Testing C
            [Install]
            WantedBy=multi-user.target""")
        #
        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sx____(cmd.format(**locals()))
        if COVERAGE:
            cmd = "{docker} exec {testname} {package} install -y {python_coverage}"
            sx____(cmd.format(**locals()))
        self.prep_coverage(image, testname)
        cmd = "{docker} exec {testname} mkdir -p /etc/systemd/system"
        sx____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zza.service {testname}:/etc/systemd/system/zza.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zzb.service {testname}:/etc/systemd/system/zzb.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zzc.service {testname}:/etc/systemd/system/zzc.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl enable zzb.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl enable zzc.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl --version"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl default-services -vv"
        out2 = output(cmd.format(**locals()))
        logg.info("\n>\n%s", out2)
        cmd = "{docker} exec {testname} systemctl --all default-services -vv"
        out3 = output(cmd.format(**locals()))
        logg.info("\ndefault-service>\n%s", out3)
        #
        self.save_coverage(testname)
        #
        self.rm_docker(testname)
        self.rm_testdir()
        #
        self.assertTrue(greps(out2, "zzb.service"))
        self.assertTrue(greps(out2, "zzc.service"))
        self.assertEqual(len(lines(out2)), 2)
        self.assertTrue(greps(out3, "zzb.service"))
        self.assertTrue(greps(out3, "zzc.service"))
        # self.assertGreater(len(lines(out2)), 2)
    #
    #
    #  compare the following with the test_4030 series
    #
    #
    def test_5030_simple_service_functions_system(self) -> None:
        """ check that we manage simple services in a root env
            with commands like start, restart, stop, etc"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        self.runuser_simple_service_functions("system", testname, testdir)
        self.rm_testdir()
        self.end(122)
    def test_5031_runuser_simple_service_functions_user(self) -> None:
        """ check that we manage simple services in a root env
            with commands like start, restart, stop, etc"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        self.runuser_simple_service_functions("user", testname, testdir)
        self.rm_testdir()
        self.end(122)
    def runuser_simple_service_functions(self, system: str, testname: str, testdir: str) -> None:
        """ check that we manage simple services in a root env
            with commands like start, restart, stop, etc"""
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        images = IMAGES
        image = self.local_image(COVERAGE or IMAGE or CENTOS)
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        python_coverage = coverage_package(image)
        if _python.endswith("python3") and "centos:7" in image:
            if SKIP: self.skipTest("no python3 on centos:7")
        docker = _docker
        package = package_tool(image)
        refresh = refresh_tool(image)
        sometime = SOMETIME or 188
        quick = QUICK
        #
        user = self.user()
        root = ""
        systemctl_py = realpath(_systemctl_py)
        systemctl = "/usr/bin/systemctl"
        systemctl += " --{system}".format(**locals())
        testsleep = testname+"_testsleep"
        testscript = testname+"_testscript.sh"
        logfile = os_path(root, "/var/log/test.log")
        bindir = os_path(root, "/usr/bin")
        begin = "{"
        ends = "}"
        shell_file(os_path(testdir, "binkillall"), """
            #! /bin/sh
            ps -eo pid,comm,args | { while read pid comm args; do
               case "$args" in *"/bin/$1 "*)
                  echo kill $pid
                  kill $pid
               ;; esac
               if [ "$comm" = "$1" ]; then
                  echo kill $pid
                  kill $pid
               fi done } """)
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            [Service]
            User=somebody
            Type=simple
            ExecStartPre=/bin/echo %n
            ExecStart={bindir}/{testscript} 111
            ExecStartPost=/bin/echo started $MAINPID
            ExecStop=/bin/kill -3 $MAINPID
            ExecStopPost=/bin/echo stopped $MAINPID
            ExecStopPost=/bin/sleep 2
            ExecReload=/bin/kill -10 $MAINPID
            KillSignal=SIGQUIT
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        shell_file(os_path(testdir, testscript), """
            #! /bin/sh
            date +%T,enter >> {logfile}
            stops () {begin}
              date +%T,stopping >> {logfile}
              binkillall {testsleep} >> {logfile} 2>&1
              date +%T,stopped >> {logfile}
            {ends}
            reload () {begin}
              date +%T,reloading >> {logfile}
              date +%T,reloaded >> {logfile}
            {ends}
            trap "stops" 3   # SIGQUIT
            trap "reload" 10 # SIGUSR1
            date +%T,starting >> {logfile}
            {bindir}/{testsleep} $1 >> {logfile} 2>&1 &
            pid="$!"
            while kill -0 $pid; do
               # use 'kill -0' to check the existance of the child
               date +%T,waiting >> {logfile}
               # use 'wait' for children AND external signals
               wait
            done
            date +%T,leaving >> {logfile}
            trap - 3 10 # SIGQUIT SIGUSR1
            date +%T,leave >> {logfile}
        """.format(**locals()))

        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/ps || {package} install -y procps'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sx____(cmd.format(**locals()))
        if COVERAGE:
            cmd = "{docker} exec {testname} {package} install -y {python_coverage}"
            sx____(cmd.format(**locals()))
        self.prep_coverage(image, testname)
        cmd = "{docker} cp {testdir}/binkillall {testname}:/usr/bin/binkillall"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} cp /bin/sleep {bindir}/{testsleep}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/{testscript} {testname}:{bindir}/{testscript}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} mkdir -p /etc/systemd/system /etc/systemd/user"
        sx____(cmd.format(**locals()))
        zzz_service = "/etc/systemd/{system}/zzz.service".format(**locals())
        cmd = "{docker} cp {testdir}/zzz.service {testname}:{zzz_service}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} touch {logfile}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} chmod 666 {logfile}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'grep nobody /etc/group || groupadd -g 65533 nobody'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} useradd -u 1001 somebody -g nobody -m"
        sh____(cmd.format(**locals()))
        #
        cmd = "{docker} exec {testname} {systemctl} enable zzz.service -vv"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'start' shall start a service that is NOT is-active ")
        cmd = "{docker} exec {testname} {systemctl} start zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        #
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(running(greps(top, testsleep)))
        self.assertEqual(end, 0)

        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        #
        logg.info("== 'stop' shall stop a service that is-active")
        cmd = "{docker} exec {testname} {systemctl} stop zzz.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        time.sleep(1) # kill is async
        cmd = "{docker} exec {testname} cat {logfile}"
        sh____(cmd.format(**locals()))
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        # inspect the service's log
        log = lines(output("{docker} exec {testname} cat {logfile}".format(**locals())))
        logg.info("LOG\n %s", "\n ".join(log))
        self.assertTrue(greps(log, "enter"))
        self.assertTrue(greps(log, "leave"))
        self.assertTrue(greps(log, "starting"))
        self.assertTrue(greps(log, "stopped"))
        self.assertFalse(greps(log, "reload"))
        sh____("{docker} exec {testname} truncate -s0 {logfile}".format(**locals()))
        #
        logg.info("== 'restart' shall start a service that NOT is-active")
        cmd = "{docker} exec {testname} {systemctl} restart zzz.service -vvvv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top1= top
        #
        # inspect the service's log
        log = lines(output("{docker} exec {testname} cat {logfile}".format(**locals())))
        logg.info("LOG\n %s", "\n ".join(log))
        self.assertTrue(greps(log, "enter"))
        self.assertFalse(greps(log, "leave"))
        self.assertTrue(greps(log, "starting"))
        self.assertFalse(greps(log, "stopped"))
        self.assertFalse(greps(log, "reload"))
        sh____("{docker} exec {testname} truncate -s0 {logfile}".format(**locals()))
        #
        logg.info("== 'restart' shall restart a service that is-active")
        cmd = "{docker} exec {testname} {systemctl} restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top2 = top
        #
        logg.info("-- and we check that there is a new PID for the service process")
        def find_pids(ps_output: Union[str, List[str]], command: str) -> List[str]:
            pids = []
            for line in _lines(ps_output):
                if command not in line: continue
                m = re.match(r"\s*[\d:]*\s+(\S+)\s+(\S+)\s+(.*)", line)
                if not m: continue
                pid, ppid, args = m.groups()
                # logg.info("  %s | %s | %s", pid, ppid, args)
                pids.append(pid)
            return pids
        ps1 = find_pids(top1, testsleep)
        ps2 = find_pids(top2, testsleep)
        logg.info("found PIDs %s and %s", ps1, ps2)
        self.assertTrue(len(ps1), 1)
        self.assertTrue(len(ps2), 1)
        self.assertNotEqual(ps1[0], ps2[0])
        #
        # inspect the service's log
        log = lines(output("{docker} exec {testname} cat {logfile}".format(**locals())))
        logg.info("LOG\n %s", "\n ".join(log))
        self.assertTrue(greps(log, "enter"))
        self.assertTrue(greps(log, "starting"))
        self.assertFalse(greps(log, "reload"))
        sh____("{docker} exec {testname} truncate -s0 {logfile}".format(**locals()))
        #
        #
        logg.info("== 'reload' will NOT restart a service that is-active")
        cmd = "{docker} exec {testname} {systemctl} reload zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top3 = top
        #
        logg.info("-- and we check that there is NO new PID for the service process")
        ps3 = find_pids(top3, testsleep)
        logg.info("found PIDs %s and %s", ps2, ps3)
        self.assertTrue(len(ps2), 1)
        self.assertTrue(len(ps3), 1)
        self.assertEqual(ps2[0], ps3[0])
        #
        # inspect the service's log
        log = lines(output("{docker} exec {testname} cat {logfile}".format(**locals())))
        logg.info("LOG\n %s", "\n ".join(log))
        self.assertFalse(greps(log, "enter"))
        self.assertFalse(greps(log, "leave"))
        self.assertFalse(greps(log, "starting"))
        self.assertFalse(greps(log, "stopped"))
        self.assertTrue(greps(log, "reload"))
        sh____("{docker} exec {testname} truncate -s0 {logfile}".format(**locals()))
        #
        logg.info("== 'reload-or-restart' will restart a service that is-active (if ExecReload)")
        cmd = "{docker} exec {testname} {systemctl} reload-or-restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top4 = top
        #
        logg.info("-- and we check that there is NO new PID for the service process (if ExecReload)")
        ps4 = find_pids(top4, testsleep)
        logg.info("found PIDs %s and %s", ps3, ps4)
        self.assertTrue(len(ps3), 1)
        self.assertTrue(len(ps4), 1)
        self.assertEqual(ps3[0], ps4[0])
        #
        logg.info("== 'kill' will bring is-active non-active as well (when the PID is known)")
        cmd = "{docker} exec {testname} {systemctl} kill zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'stop' will turn 'failed' to 'inactive' (when the PID is known)")
        cmd = "{docker} exec {testname} {systemctl} stop zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertNotEqual(end, 0) # no PID known so 'kill $MAINPID' fails
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'reload-or-try-restart' will not start a not-active service")
        cmd = "{docker} exec {testname} {systemctl} reload-or-try-restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'try-restart' will not start a not-active service")
        cmd = "{docker} exec {testname} {systemctl} try-restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'reload-or-restart' will start a not-active service")
        cmd = "{docker} exec {testname} {systemctl} reload-or-restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top5 = top
        #
        logg.info("== 'reload-or-try-restart' will NOT restart an is-active service (with ExecReload)")
        cmd = "{docker} exec {testname} {systemctl} reload-or-try-restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top6 = top
        #
        logg.info("-- and we check that there is NO new PID for the service process (if ExecReload)")
        ps5 = find_pids(top5, testsleep)
        ps6 = find_pids(top6, testsleep)
        logg.info("found PIDs %s and %s", ps5, ps6)
        self.assertTrue(len(ps5), 1)
        self.assertTrue(len(ps6), 1)
        self.assertEqual(ps5[0], ps6[0])
        #
        logg.info("== 'try-restart' will restart an is-active service")
        cmd = "{docker} exec {testname} {systemctl} try-restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top7 = top
        #
        logg.info("-- and we check that there is a new PID for the service process")
        ps7 = find_pids(top7, testsleep)
        logg.info("found PIDs %s and %s", ps6, ps7)
        self.assertTrue(len(ps6), 1)
        self.assertTrue(len(ps7), 1)
        self.assertNotEqual(ps6[0], ps7[0])
        #
        kill_testsleep = "{docker} exec {testname} binkillall {testsleep}"
        sx____(kill_testsleep.format(**locals()))
        #
        self.save_coverage(testname)
        #
        self.rm_docker(testname)
    def test_5032_runuser_forking_service_functions_system(self) -> None:
        """ check that we manage forking services in a root env
            with basic run-service commands: start, stop, restart,
            reload, try-restart, reload-or-restart, kill and
            reload-or-try-restart."""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        self.runuser_forking_service_functions("system", testname, testdir)
        self.rm_testdir()
        self.end()
    def test_5033_runuser_forking_service_functions_user(self) -> None:
        """ check that we manage forking services in a root env
            with basic run-service commands: start, stop, restart,
            reload, try-restart, reload-or-restart, kill and
            reload-or-try-restart."""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        self.runuser_forking_service_functions("user", testname, testdir)
        self.rm_testdir()
        self.end()
    def runuser_forking_service_functions(self, system: str, testname: str, testdir: str) -> None:
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        images = IMAGES
        image = self.local_image(COVERAGE or IMAGE or CENTOS)
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        python_coverage = coverage_package(image)
        if _python.endswith("python3") and "centos:7" in image:
            if SKIP: self.skipTest("no python3 on centos:7")
        docker = _docker
        package = package_tool(image)
        refresh = refresh_tool(image)
        sometime = SOMETIME or 188
        quick = QUICK
        #
        user = self.user()
        root = ""
        systemctl_py = realpath(_systemctl_py)
        systemctl = "/usr/bin/systemctl" # path in container
        systemctl += " --{system}".format(**locals())
        testsleep = testname+"_sleep"
        logfile = os_path(root, "/var/log/"+testsleep+".log")
        bindir = os_path(root, "/usr/bin")
        begin = "{"
        ends = "}"
        shell_file(os_path(testdir, "zzz.init"), """
            #! /bin/bash
            logfile={logfile}
            start() {begin}
               [ -d /var/run ] || mkdir -p /var/run
               ({bindir}/{testsleep} 111 0<&- &>/dev/null &
                echo $! > /tmp/zzz.init.pid
               ) &
               wait %1
               # ps -o pid,ppid,user,args
            {ends}
            stop() {begin}
               killall {testsleep}
            {ends}
            case "$1" in start)
               date "+START.%T" >> $logfile
               start >> $logfile 2>&1
               date "+start.%T" >> $logfile
            ;; stop)
               date "+STOP.%T" >> $logfile
               stop >> $logfile 2>&1
               date "+stop.%T" >> $logfile
            ;; restart)
               date "+RESTART.%T" >> $logfile
               stop >> $logfile 2>&1
               start >> $logfile 2>&1
               date "+.%T" >> $logfile
            ;; reload)
               date "+RELOAD.%T" >> $logfile
               echo "...." >> $logfile 2>&1
               date "+reload.%T" >> $logfile
            ;; esac
            echo "done$1" >&2
            exit 0
            """.format(**locals()))
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            [Service]
            User=somebody
            Type=forking
            PIDFile=/tmp/zzz.init.pid
            ExecStart=/usr/bin/zzz.init start
            ExecStop=/usr/bin/zzz.init stop
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))

        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/ps || {package} install -y procps'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/killall || {package} install -y psmisc'"
        sx____(cmd.format(**locals()))
        if COVERAGE:
            cmd = "{docker} exec {testname} {package} install -y {python_coverage}"
            sx____(cmd.format(**locals()))
        self.prep_coverage(image, testname)
        cmd = "{docker} exec {testname} mkdir -p /etc/systemd/system /etc/systemd/user"
        sx____(cmd.format(**locals()))
        zzz_service = "/etc/systemd/{system}/zzz.service".format(**locals())
        cmd = "{docker} exec {testname} cp /bin/sleep {bindir}/{testsleep}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zzz.init {testname}:/usr/bin/zzz.init"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zzz.service {testname}:{zzz_service}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} touch {logfile}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} chmod 666 {logfile}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'grep nobody /etc/group || groupadd -g 65533 nobody'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} useradd -u 1001 somebody -g nobody -m"
        sh____(cmd.format(**locals()))
        #
        cmd = "{docker} exec {testname} {systemctl} enable zzz.service -vv"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'start' shall start a service that is NOT is-active ")
        cmd = "{docker} exec {testname} {systemctl} start zzz.service -vvvv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        #
        logg.info("== 'stop' shall stop a service that is-active")
        cmd = "{docker} exec {testname} {systemctl} stop zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'restart' shall start a service that NOT is-active")
        cmd = "{docker} exec {testname} {systemctl} restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top1= top
        #
        logg.info("== 'restart' shall restart a service that is-active")
        cmd = "{docker} exec {testname} {systemctl} restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top2 = top
        #
        logg.info("-- and we check that there is a new PID for the service process")
        def find_pids(ps_output: Union[str, List[str]], command: str) -> List[str]:
            pids = []
            for line in _lines(ps_output):
                if command not in line: continue
                m = re.match(r"\s*[\d:]*\s+(\S+)\s+(\S+)\s+(.*)", line)
                if not m: continue
                pid, ppid, args = m.groups()
                # logg.info("  %s | %s | %s", pid, ppid, args)
                pids.append(pid)
            return pids
        ps1 = find_pids(running(top1), testsleep)
        ps2 = find_pids(running(top2), testsleep)
        logg.info("found PIDs %s and %s", ps1, ps2)
        self.assertTrue(len(ps1), 1)
        self.assertTrue(len(ps2), 1)
        self.assertNotEqual(ps1[0], ps2[0])
        #
        logg.info("== 'reload' will NOT restart a service that is-active")
        cmd = "{docker} exec {testname} {systemctl} reload zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top3 = top
        #
        logg.info("-- and we check that there is NO new PID for the service process")
        ps3 = find_pids(running(top3), testsleep)
        logg.info("found PIDs %s and %s", ps2, ps3)
        self.assertTrue(len(ps2), 1)
        self.assertTrue(len(ps3), 1)
        self.assertEqual(ps2[0], ps3[0])
        #
        logg.info("== 'reload-or-restart' will restart a service that is-active (if no ExecReload)")
        cmd = "{docker} exec {testname} {systemctl} reload-or-restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top4 = top
        #
        logg.info("-- and we check that there is a new PID for the service process (if no ExecReload)")
        ps4 = find_pids(running(top4), testsleep)
        logg.info("found PIDs %s and %s", ps3, ps4)
        self.assertTrue(len(ps3), 1)
        self.assertTrue(len(ps4), 1)
        self.assertNotEqual(ps3[0], ps4[0])
        #
        logg.info("== 'kill' will bring is-active non-active as well (when the PID is known)")
        cmd = "{docker} exec {testname} {systemctl} kill zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "failed")
        #
        logg.info("== 'stop' will turn 'failed' to 'inactive' (when the PID is known)")
        cmd = "{docker} exec {testname} {systemctl} stop zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'reload-or-try-restart' will not start a not-active service")
        cmd = "{docker} exec {testname} {systemctl} reload-or-try-restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'try-restart' will not start a not-active service")
        cmd = "{docker} exec {testname} {systemctl} try-restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'reload-or-restart' will start a not-active service")
        cmd = "{docker} exec {testname} {systemctl} reload-or-restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top5 = top
        #
        logg.info("== 'reload-or-try-restart' will restart an is-active service (with no ExecReload)")
        cmd = "{docker} exec {testname} {systemctl} try-restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top6 = top
        #
        logg.info("-- and we check that there is a new PID for the service process (if no ExecReload)")
        ps5 = find_pids(running(top5), testsleep)
        ps6 = find_pids(running(top6), testsleep)
        logg.info("found PIDs %s and %s", ps5, ps6)
        self.assertTrue(len(ps5), 1)
        self.assertTrue(len(ps6), 1)
        self.assertNotEqual(ps5[0], ps6[0])
        #
        logg.info("== 'try-restart' will restart an is-active service")
        cmd = "{docker} exec {testname} {systemctl} try-restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top7 = top
        #
        logg.info("-- and we check that there is a new PID for the service process")
        ps7 = find_pids(running(top7), testsleep)
        logg.info("found PIDs %s and %s", ps6, ps7)
        self.assertTrue(len(ps6), 1)
        self.assertTrue(len(ps7), 1)
        self.assertNotEqual(ps6[0], ps7[0])
        #
        logg.info("LOG\n%s", " "+output("{docker} exec {testname} cat {logfile}".format(**locals())).replace("\n", "\n "))
        self.save_coverage(testname)
        #
        self.rm_docker(testname)
    def test_5034_runuser_notify_service_functions_system(self) -> None:
        """ check that we manage notify services in a root env
            with basic run-service commands: start, stop, restart,
            reload, try-restart, reload-or-restart, kill and
            reload-or-try-restart."""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        self.runuser_notify_service_functions("system", testname, testdir)
        self.rm_testdir()
        self.end(188)
    def test_5035_runuser_notify_service_functions_user(self) -> None:
        """ check that we manage notify services in a root env
            with basic run-service commands: start, stop, restart,
            reload, try-restart, reload-or-restart, kill and
            reload-or-try-restart."""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        self.runuser_notify_service_functions("user", testname, testdir)
        self.rm_testdir()
        self.end(266)  # TODO# too long?
    def runuser_notify_service_functions(self, system: str, testname: str, testdir: str) -> None:
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        images = IMAGES
        image = self.local_image(COVERAGE or IMAGE or CENTOS)
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        python_coverage = coverage_package(image)
        if _python.endswith("python3") and "centos:7" in image:
            if SKIP: self.skipTest("no python3 on centos:7")
        docker = _docker
        package = package_tool(image)
        refresh = refresh_tool(image)
        sometime = SOMETIME or 288
        quick = QUICK
        #
        user = self.user()
        root = ""
        systemctl_py = realpath(_systemctl_py)
        systemctl = "/usr/bin/systemctl" # path in container
        systemctl += " --{system}".format(**locals())
        testsleep = testname+"_sleep"
        logfile = os_path(root, "/var/log/"+testsleep+".log")
        bindir = os_path(root, "/usr/bin")
        begin = "{"
        ends = "}"
        shell_file(os_path(testdir, "zzz.init"), """
            #! /bin/bash
            logfile={logfile}
            start() {begin}
                ls -l  $NOTIFY_SOCKET
                {bindir}/{testsleep} 111 0<&- &>/dev/null &
                echo "MAINPID=$!" | socat -v -d - UNIX-CLIENT:$NOTIFY_SOCKET
                echo "READY=1" | socat -v -d - UNIX-CLIENT:$NOTIFY_SOCKET
                wait %1
                # ps -o pid,ppid,user,args
            {ends}
            stop() {begin}
                killall {testsleep}
            {ends}
            case "$1" in start)
               date "+START.%T" >> $logfile
               start >> $logfile 2>&1
               date "+start.%T" >> $logfile
            ;; stop)
               date "+STOP.%T" >> $logfile
               stop >> $logfile 2>&1
               date "+stop.%T" >> $logfile
            ;; restart)
               date "+RESTART.%T" >> $logfile
               stop >> $logfile 2>&1
               start >> $logfile 2>&1
               date "+.%T" >> $logfile
            ;; reload)
               date "+RELOAD.%T" >> $logfile
               echo "...." >> $logfile 2>&1
               date "+reload.%T" >> $logfile
            ;; esac
            echo "done$1" >&2
            exit 0
            """.format(**locals()))
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            [Service]
            User=somebody
            Type=notify
            # PIDFile={root}/var/run/zzz.init.pid
            ExecStart={root}/usr/bin/zzz.init start
            ExecStop={root}/usr/bin/zzz.init stop
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))

        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/ps || {package} install -y procps'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/killall || {package} install -y psmisc'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/socat || {package} install -y socat'"
        if sx____(cmd.format(**locals())): self.skipTest("unable to install socat in a container from "+image)
        if COVERAGE:
            cmd = "{docker} exec {testname} {package} install -y {python_coverage}"
            sx____(cmd.format(**locals()))
        self.prep_coverage(image, testname)
        cmd = "{docker} exec {testname} mkdir -p /etc/systemd/system /etc/systemd/user"
        sx____(cmd.format(**locals()))
        zzz_service = "/etc/systemd/{system}/zzz.service".format(**locals())
        cmd = "{docker} exec {testname} cp /bin/sleep {bindir}/{testsleep}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zzz.init {testname}:/usr/bin/zzz.init"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zzz.service {testname}:{zzz_service}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} touch {logfile}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} chmod 666 {logfile}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'grep nobody /etc/group || groupadd -g 65533 nobody'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} useradd -u 1001 somebody -g nobody -m"
        sh____(cmd.format(**locals()))
        #
        cmd = "{docker} exec {testname} {systemctl} enable zzz.service -vv"
        sh____(cmd.format(**locals()))
        #
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'start' shall start a service that is NOT is-active ")
        sh____("{docker} exec {testname} ls -l /var/run".format(**locals()))
        cmd = "{docker} exec {testname} {systemctl} start zzz.service -vv -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        #
        logg.info("== 'stop' shall stop a service that is-active")
        cmd = "{docker} exec {testname} {systemctl} stop zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'restart' shall start a service that NOT is-active")
        cmd = "{docker} exec {testname} {systemctl} restart zzz.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = "{docker} exec {testname} cat {logfile}"
        sh____(cmd.format(**locals()))
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(running(greps(top, testsleep)))
        self.assertEqual(end, 0)
        #
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top1= top
        #
        logg.info("== 'restart' shall restart a service that is-active")
        cmd = "{docker} exec {testname} {systemctl} restart zzz.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = "{docker} exec {testname} cat {logfile}"
        sh____(cmd.format(**locals()))
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(running(greps(top, testsleep)))
        self.assertEqual(end, 0)
        #
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top2 = top
        #
        logg.info("-- and we check that there is a new PID for the service process")
        def find_pids(ps_output: Union[str, List[str]], command: str) -> List[str]:
            pids = []
            for line in _lines(ps_output):
                if command not in line: continue
                m = re.match(r"\s*[\d:]*\s+(\S+)\s+(\S+)\s+(.*)", line)
                if not m: continue
                pid, ppid, args = m.groups()
                # logg.info("  %s | %s | %s", pid, ppid, args)
                pids.append(pid)
            return pids
        ps1 = find_pids(running(top1), testsleep)
        ps2 = find_pids(running(top2), testsleep)
        logg.info("found PIDs %s and %s", ps1, ps2)
        self.assertTrue(len(ps1), 1)
        self.assertTrue(len(ps2), 1)
        self.assertNotEqual(ps1[0], ps2[0])
        #
        logg.info("== 'reload' will NOT restart a service that is-active")
        cmd = "{docker} exec {testname} {systemctl} reload zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top3 = top
        #
        logg.info("-- and we check that there is NO new PID for the service process")
        ps3 = find_pids(running(top3), testsleep)
        logg.info("found PIDs %s and %s", ps2, ps3)
        self.assertTrue(len(ps2), 1)
        self.assertTrue(len(ps3), 1)
        self.assertEqual(ps2[0], ps3[0])
        #
        logg.info("== 'reload-or-restart' will restart a service that is-active (if no ExecReload)")
        cmd = "{docker} exec {testname} {systemctl} reload-or-restart zzz.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top4 = top
        #
        logg.info("-- and we check that there is a new PID for the service process (if no ExecReload)")
        ps4 = find_pids(running(top4), testsleep)
        logg.info("found PIDs %s and %s", ps3, ps4)
        self.assertTrue(len(ps3), 1)
        self.assertTrue(len(ps4), 1)
        self.assertNotEqual(ps3[0], ps4[0])
        #
        logg.info("== 'kill' will bring is-active non-active as well (when the PID is known)")
        cmd = "{docker} exec {testname} {systemctl} kill zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'stop' will turn 'failed' to 'inactive' (when the PID is known)")
        cmd = "{docker} exec {testname} {systemctl} stop zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'reload-or-try-restart' will not start a not-active service")
        cmd = "{docker} exec {testname} {systemctl} reload-or-try-restart zzz.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'try-restart' will not start a not-active service")
        cmd = "{docker} exec {testname} {systemctl} try-restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'reload-or-restart' will start a not-active service")
        cmd = "{docker} exec {testname} {systemctl} reload-or-restart zzz.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top5 = top
        #
        logg.info("== 'reload-or-try-restart' will restart an is-active service (with no ExecReload)")
        cmd = "{docker} exec {testname} {systemctl} try-restart zzz.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top6 = top
        #
        logg.info("-- and we check that there is a new PID for the service process (if no ExecReload)")
        ps5 = find_pids(running(top5), testsleep)
        ps6 = find_pids(running(top6), testsleep)
        logg.info("found PIDs %s and %s", ps5, ps6)
        self.assertTrue(len(ps5), 1)
        self.assertTrue(len(ps6), 1)
        self.assertNotEqual(ps5[0], ps6[0])
        #
        logg.info("== 'try-restart' will restart an is-active service")
        cmd = "{docker} exec {testname} {systemctl} try-restart zzz.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top7 = top
        #
        logg.info("-- and we check that there is a new PID for the service process")
        ps7 = find_pids(running(top7), testsleep)
        logg.info("found PIDs %s and %s", ps6, ps7)
        self.assertTrue(len(ps6), 1)
        self.assertTrue(len(ps7), 1)
        self.assertNotEqual(ps6[0], ps7[0])
        #
        logg.info("LOG\n%s", " "+output("{docker} exec {testname} cat {logfile}".format(**locals())).replace("\n", "\n "))
        #
        self.save_coverage(testname)
        #
        self.rm_docker(testname)
    def test_5036_runuser_notify_service_functions_with_reload(self) -> None:
        """ check that we manage notify services in a root env
            with basic run-service commands: start, stop, restart,
            reload, try-restart, reload-or-restart, kill and
            reload-or-try-restart. (with ExecReload)"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        self.runuser_notify_service_functions_with_reload("system", testname, testdir)
        self.rm_testdir()
        logg.error("too long")  # TODO
        self.end(200)
    def test_5037_runuser_notify_service_functions_with_reload_user(self) -> None:
        """ check that we manage notify services in a root env
            with basic run-service commands: start, stop, restart,
            reload, try-restart, reload-or-restart, kill and
            reload-or-try-restart. (with ExecReload)"""
        # test_5037 is triggering len(socketfile) > 100 | "new notify socketfile"
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        self.runuser_notify_service_functions_with_reload("user", testname, testdir)
        self.rm_testdir()
        self.end(266)  # TODO# too long?
    def runuser_notify_service_functions_with_reload(self, system: str, testname: str, testdir: str) -> None:
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        images = IMAGES
        image = self.local_image(COVERAGE or IMAGE or CENTOS)
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        python_coverage = coverage_package(image)
        if _python.endswith("python3") and "centos:7" in image:
            if SKIP: self.skipTest("no python3 on centos:7")
        docker = _docker
        package = package_tool(image)
        refresh = refresh_tool(image)
        sometime = SOMETIME or 288
        quick = QUICK
        #
        user = self.user()
        root = ""
        systemctl_py = realpath(_systemctl_py)
        systemctl = "/usr/bin/systemctl" # path in container
        systemctl += " --{system}".format(**locals())
        testsleep = self.testname("sleep")
        logfile = os_path(root, "/var/log/"+testsleep+".log")
        bindir = os_path(root, "/usr/bin")
        begin = "{"
        ends = "}"
        shell_file(os_path(testdir, "zzz.init"), """
            #! /bin/bash
            logfile={logfile}
            start() {begin}
                ls -l  $NOTIFY_SOCKET
                {bindir}/{testsleep} 111 0<&- &>/dev/null &
                echo "MAINPID=$!" | socat -v -d - UNIX-CLIENT:$NOTIFY_SOCKET
                echo "READY=1" | socat -v -d - UNIX-CLIENT:$NOTIFY_SOCKET
                wait %1
                # ps -o pid,ppid,user,args
            {ends}
            stop() {begin}
                killall {testsleep}
            {ends}
            case "$1" in start)
               date "+START.%T" >> $logfile
               start >> $logfile 2>&1
               date "+start.%T" >> $logfile
            ;; stop)
               date "+STOP.%T" >> $logfile
               stop >> $logfile 2>&1
               date "+stop.%T" >> $logfile
            ;; restart)
               date "+RESTART.%T" >> $logfile
               stop >> $logfile 2>&1
               start >> $logfile 2>&1
               date "+.%T" >> $logfile
            ;; reload)
               date "+RELOAD.%T" >> $logfile
               echo "...." >> $logfile 2>&1
               date "+reload.%T" >> $logfile
            ;; esac
            echo "done$1" >&2
            exit 0
            """.format(**locals()))
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            [Service]
            User=somebody
            Type=notify
            # PIDFile={root}/var/run/zzz.init.pid
            ExecStart={root}/usr/bin/zzz.init start
            ExecReload={root}/usr/bin/zzz.init reload
            ExecStop={root}/usr/bin/zzz.init stop
            TimeoutRestartSec=4
            TimeoutReloadSec=4
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))

        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/ps || {package} install -y procps'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/killall || {package} install -y psmisc'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/socat || {package} install -y socat'"
        if sx____(cmd.format(**locals())): self.skipTest("unable to install socat in a container from "+image)
        if COVERAGE:
            cmd = "{docker} exec {testname} {package} install -y {python_coverage}"
            sx____(cmd.format(**locals()))
        self.prep_coverage(image, testname)
        cmd = "{docker} exec {testname} mkdir -p /etc/systemd/system /etc/systemd/user"
        sx____(cmd.format(**locals()))
        zzz_service = "/etc/systemd/{system}/zzz.service".format(**locals())
        cmd = "{docker} exec {testname} cp /bin/sleep {bindir}/{testsleep}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zzz.init {testname}:/usr/bin/zzz.init"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zzz.service {testname}:{zzz_service}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} touch {logfile}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} chmod 666 {logfile}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'grep nobody /etc/group || groupadd -g 65533 nobody'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} useradd -u 1001 somebody -g nobody -m"
        sh____(cmd.format(**locals()))
        #
        cmd = "{docker} exec {testname} {systemctl} enable zzz.service -vv"
        sh____(cmd.format(**locals()))
        #
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'start' shall start a service that is NOT is-active ")
        cmd = "{docker} exec {testname} {systemctl} start zzz.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        #
        logg.info("== 'stop' shall stop a service that is-active")
        cmd = "{docker} exec {testname} {systemctl} stop zzz.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'restart' shall start a service that NOT is-active")
        cmd = "{docker} exec {testname} {systemctl} restart zzz.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top1= top
        #
        logg.info("== 'restart' shall restart a service that is-active")
        cmd = "{docker} exec {testname} {systemctl} restart zzz.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top2 = top
        #
        logg.info("-- and we check that there is a new PID for the service process")
        def find_pids(ps_output: Union[str, List[str]], command: str) -> List[str]:
            pids = []
            for line in _lines(ps_output):
                if command not in line: continue
                m = re.match(r"\s*[\d:]*\s+(\S+)\s+(\S+)\s+(.*)", line)
                if not m: continue
                pid, ppid, args = m.groups()
                # logg.info("  %s | %s | %s", pid, ppid, args)
                pids.append(pid)
            return pids
        ps1 = find_pids(running(top1), testsleep)
        ps2 = find_pids(running(top2), testsleep)
        logg.info("found PIDs %s and %s", ps1, ps2)
        self.assertTrue(len(ps1), 1)
        self.assertTrue(len(ps2), 1)
        self.assertNotEqual(ps1[0], ps2[0])
        #
        logg.info("== 'reload' will NOT restart a service that is-active")
        cmd = "{docker} exec {testname} {systemctl} reload zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top3 = top
        #
        logg.info("-- and we check that there is NO new PID for the service process")
        ps3 = find_pids(running(top3), testsleep)
        logg.info("found PIDs %s and %s", ps2, ps3)
        self.assertTrue(len(ps2), 1)
        self.assertTrue(len(ps3), 1)
        self.assertEqual(ps2[0], ps3[0])
        #
        logg.info("== 'reload-or-restart' will restart a service that is-active (if no ExecReload)")
        cmd = "{docker} exec {testname} {systemctl} reload-or-restart zzz.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top4 = top
        #
        logg.info("-- and we check that there is the same PID for the service process (if ExecReload)")
        ps4 = find_pids(running(top4), testsleep)
        logg.info("found PIDs %s and %s", ps3, ps4)
        self.assertTrue(len(ps3), 1)
        self.assertTrue(len(ps4), 1)
        self.assertEqual(ps3[0], ps4[0])
        #
        logg.info("== 'kill' will bring is-active non-active as well (when the PID is known)")
        cmd = "{docker} exec {testname} {systemctl} kill zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'stop' will turn 'failed' to 'inactive' (when the PID is known)")  # TODO#
        cmd = "{docker} exec {testname} {systemctl} stop zzz.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'reload-or-try-restart' will not start a not-active service")
        cmd = "{docker} exec {testname} {systemctl} reload-or-try-restart zzz.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'try-restart' will not start a not-active service")
        cmd = "{docker} exec {testname} {systemctl} try-restart zzz.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'reload-or-restart' will start a not-active service")
        cmd = "{docker} exec {testname} {systemctl} reload-or-restart zzz.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top5 = top
        #
        logg.info("== 'reload-or-try-restart' will restart an is-active service (with no ExecReload)")
        cmd = "{docker} exec {testname} {systemctl} try-restart zzz.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top6 = top
        #
        logg.info("-- and we check that there is a new PID for the service process (if no ExecReload)")
        ps5 = find_pids(running(top5), testsleep)
        ps6 = find_pids(running(top6), testsleep)
        logg.info("found PIDs %s and %s", ps5, ps6)
        self.assertTrue(len(ps5), 1)
        self.assertTrue(len(ps6), 1)
        self.assertNotEqual(ps5[0], ps6[0])
        #
        logg.info("== 'try-restart' will restart an is-active service")
        cmd = "{docker} exec {testname} {systemctl} try-restart zzz.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top7 = top
        #
        logg.info("-- and we check that there is a new PID for the service process")
        ps7 = find_pids(running(top7), testsleep)
        logg.info("found PIDs %s and %s", ps6, ps7)
        self.assertTrue(len(ps6), 1)
        self.assertTrue(len(ps7), 1)
        self.assertNotEqual(ps6[0], ps7[0])
        #
        logg.info("LOG\n%s", " "+output("{docker} exec {testname} cat {logfile}".format(**locals())).replace("\n", "\n "))
        #
        self.save_coverage(testname)
        #
        self.rm_docker(testname)
    def test_5040_runuser_oneshot_service_functions(self) -> None:
        """ check that we manage oneshot services in a root env
            with basic run-service commands: start, stop, restart,
            reload, try-restart, reload-or-restart, kill and
            reload-or-try-restart."""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        self.runuser_oneshot_service_functions("system", testname, testdir)
        self.rm_testdir()
        self.end()
    def test_5041_runuser_oneshot_service_functions_user(self) -> None:
        """ check that we manage oneshot services in a root env
            with basic run-service commands: start, stop, restart,
            reload, try-restart, reload-or-restart, kill and
            reload-or-try-restart."""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        self.runuser_oneshot_service_functions("user", testname, testdir)
        self.rm_testdir()
        self.end()
    def runuser_oneshot_service_functions(self, system: str, testname: str, testdir: str) -> None:
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        images = IMAGES
        image = self.local_image(COVERAGE or IMAGE or CENTOS)
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        python_coverage = coverage_package(image)
        if _python.endswith("python3") and "centos:7" in image:
            if SKIP: self.skipTest("no python3 on centos:7")
        docker = _docker
        package = package_tool(image)
        refresh = refresh_tool(image)
        sometime = SOMETIME or 188
        quick = QUICK
        #
        user = self.user()
        root = ""
        systemctl_py = realpath(_systemctl_py)
        systemctl = "/usr/bin/systemctl" # path in container
        systemctl += " --{system}".format(**locals())
        testsleep = self.testname("sleep")
        logfile = os_path(root, "/var/log/"+testsleep+".log")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            [Service]
            User=somebody
            Type=oneshot
            ExecStartPre={bindir}/backup {root}/var/tmp/test.1 {root}/var/tmp/test.2
            ExecStart=/usr/bin/touch {root}/var/tmp/test.1
            ExecStop=/bin/rm {root}/var/tmp/test.1
            ExecStopPost=/bin/rm -f {root}/var/tmp/test.2
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        shell_file(os_path(testdir, "backup"), """
           #! /bin/sh
           set -x
           test ! -f "$1" || mv -v "$1" "$2"
        """)

        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/ps || {package} install -y procps'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/killall || {package} install -y psmisc'"
        sx____(cmd.format(**locals()))
        if COVERAGE:
            cmd = "{docker} exec {testname} {package} install -y {python_coverage}"
            sx____(cmd.format(**locals()))
        self.prep_coverage(image, testname)
        cmd = "{docker} exec {testname} mkdir -p /etc/systemd/system /etc/systemd/user"
        sx____(cmd.format(**locals()))
        zzz_service = "/etc/systemd/{system}/zzz.service".format(**locals())
        cmd = "{docker} exec {testname} cp /bin/sleep {bindir}/{testsleep}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zzz.service {testname}:{zzz_service}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} touch {logfile}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} chmod 666 {logfile}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'grep nobody /etc/group || groupadd -g 65533 nobody'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} useradd -u 1001 somebody -g nobody -m"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/backup {testname}:/usr/bin/backup"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} touch /var/tmp/test.0"
        sh____(cmd.format(**locals()))
        testfiles = output("{docker} exec {testname} find /var/tmp -name test.*".format(**locals()))
        logg.info("found testfiles:\n%s", testfiles)
        self.assertFalse(greps(testfiles, "/var/tmp/test.1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test.2"))
        #
        cmd = "{docker} exec {testname} {systemctl} enable zzz.service -vv"
        sh____(cmd.format(**locals()))
        #
        is_active = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "inactive")
        self.assertEqual(end, 3)
        #
        logg.info("== 'start' shall start a service that is NOT is-active ")
        cmd = "{docker} exec {testname} {systemctl} start zzz.service -vvvv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "active")
        self.assertEqual(end, 0)
        testfiles = output("{docker} exec {testname} find /var/tmp -name test.*".format(**locals()))
        logg.info("found testfiles:\n%s", testfiles)
        self.assertTrue(greps(testfiles, "/var/tmp/test.1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test.2"))
        #
        logg.info("== 'stop' shall stop a service that is-active")
        cmd = "{docker} exec {testname} {systemctl} stop zzz.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "inactive")
        self.assertEqual(end, 3)
        testfiles = output("{docker} exec {testname} find /var/tmp -name test.*".format(**locals()))
        logg.info("found testfiles:\n%s", testfiles)
        self.assertFalse(greps(testfiles, "/var/tmp/test.1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test.2"))
        #
        logg.info("== 'restart' shall start a service that NOT is-active")
        cmd = "{docker} exec {testname} {systemctl} restart zzz.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "active")
        self.assertEqual(end, 0)
        testfiles = output("{docker} exec {testname} find /var/tmp -name test.*".format(**locals()))
        logg.info("found testfiles:\n%s", testfiles)
        self.assertTrue(greps(testfiles, "/var/tmp/test.1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test.2"))
        #
        logg.info("== 'restart' shall restart a service that is-active")
        cmd = "{docker} exec {testname} {systemctl} restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "active")
        self.assertEqual(end, 0)
        testfiles = output("{docker} exec {testname} find /var/tmp -name test.*".format(**locals()))
        logg.info("found testfiles:\n%s", testfiles)
        self.assertTrue(greps(testfiles, "/var/tmp/test.1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test.2"))
        #
        logg.info("== 'reload' will NOT restart a service that is-active")
        cmd = "{docker} exec {testname} {systemctl} reload zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "active")
        self.assertEqual(end, 0)
        testfiles = output("{docker} exec {testname} find /var/tmp -name test.*".format(**locals()))
        logg.info("found testfiles:\n%s", testfiles)
        self.assertTrue(greps(testfiles, "/var/tmp/test.1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test.2"))
        #
        logg.info("== 'reload-or-restart' will restart a service that is-active")
        cmd = "{docker} exec {testname} {systemctl} reload-or-restart zzz.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "active")
        self.assertEqual(end, 0)
        #
        logg.info("== 'stop' will brings it back to 'inactive'")
        cmd = "{docker} exec {testname} {systemctl} stop zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "inactive")
        self.assertEqual(end, 3)
        testfiles = output("{docker} exec {testname} find /var/tmp -name test.*".format(**locals()))
        logg.info("found testfiles:\n%s", testfiles)
        self.assertFalse(greps(testfiles, "/var/tmp/test.1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test.2"))
        #
        logg.info("== 'reload-or-try-restart' will not start a not-active service")
        cmd = "{docker} exec {testname} {systemctl} reload-or-try-restart zzz.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "inactive")
        self.assertEqual(end, 3)
        testfiles = output("{docker} exec {testname} find /var/tmp -name test.*".format(**locals()))
        logg.info("found testfiles:\n%s", testfiles)
        self.assertFalse(greps(testfiles, "/var/tmp/test.1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test.2"))
        #
        logg.info("== 'try-restart' will not start a not-active service")
        cmd = "{docker} exec {testname} {systemctl} try-restart zzz.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "inactive")
        self.assertEqual(end, 3)
        testfiles = output("{docker} exec {testname} find /var/tmp -name test.*".format(**locals()))
        logg.info("found testfiles:\n%s", testfiles)
        self.assertFalse(greps(testfiles, "/var/tmp/test.1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test.2"))
        #
        logg.info("== 'reload-or-restart' will start a not-active service")
        cmd = "{docker} exec {testname} {systemctl} reload-or-restart zzz.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "active")
        self.assertEqual(end, 0)
        testfiles = output("{docker} exec {testname} find /var/tmp -name test.*".format(**locals()))
        logg.info("found testfiles:\n%s", testfiles)
        self.assertTrue(greps(testfiles, "/var/tmp/test.1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test.2"))
        #
        logg.info("== 'reload-or-try-restart' will restart an is-active service")
        cmd = "{docker} exec {testname} {systemctl} reload-or-try-restart zzz.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "active")
        self.assertEqual(end, 0)
        testfiles = output("{docker} exec {testname} find /var/tmp -name test.*".format(**locals()))
        logg.info("found testfiles:\n%s", testfiles)
        self.assertTrue(greps(testfiles, "/var/tmp/test.1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test.2"))
        #
        logg.info("== 'try-restart' will restart an is-active service")
        cmd = "{docker} exec {testname} {systemctl} try-restart zzz.service -vv -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "active")
        self.assertEqual(end, 0)
        testfiles = output("{docker} exec {testname} find /var/tmp -name test.*".format(**locals()))
        logg.info("found testfiles:\n%s", testfiles)
        self.assertTrue(greps(testfiles, "/var/tmp/test.1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test.2"))
        #
        logg.info("== 'stop' will brings it back to 'inactive'")
        cmd = "{docker} exec {testname} {systemctl} stop zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "inactive")
        self.assertEqual(end, 3)
        testfiles = output("{docker} exec {testname} find /var/tmp -name test.*".format(**locals()))
        logg.info("found testfiles:\n%s", testfiles)
        self.assertFalse(greps(testfiles, "/var/tmp/test.1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test.2"))
        #
        logg.info("LOG\n%s", " "+output("{docker} exec {testname} cat {logfile}".format(**locals())).replace("\n", "\n "))
        #
        self.save_coverage(testname)
        #
        self.rm_docker(testname)
    def test_5042_runuser_oneshot_and_unknown_service_functions(self) -> None:
        """ check that we manage multiple services even when some
            services are not actually known. Along with oneshot serivce
            with basic run-service commands: start, stop, restart,
            reload, try-restart, reload-or-restart, kill and
            reload-or-try-restart / we have only different exit-code."""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        images = IMAGES
        image = self.local_image(COVERAGE or IMAGE or CENTOS)
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        python_coverage = coverage_package(image)
        if _python.endswith("python3") and "centos:7" in image:
            if SKIP: self.skipTest("no python3 on centos:7")
        docker = _docker
        package = package_tool(image)
        refresh = refresh_tool(image)
        sometime = SOMETIME or 188
        quick = QUICK
        #
        user = self.user()
        root = ""
        systemctl_py = realpath(_systemctl_py)
        systemctl = "/usr/bin/systemctl" # path in container
        testsleep = self.testname("sleep")
        logfile = os_path(root, "/var/log/"+testsleep+".log")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            [Service]
            User=somebody
            Type=oneshot
            ExecStartPre={bindir}/backup {root}/var/tmp/test.1 {root}/var/tmp/test.2
            ExecStart=/usr/bin/touch {root}/var/tmp/test.1
            ExecStop=/bin/rm {root}/var/tmp/test.1
            ExecStopPost=/bin/rm -f {root}/var/tmp/test.2
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        shell_file(os_path(testdir, "backup"), """
           #! /bin/sh
           set -x
           test ! -f "$1" || mv -v "$1" "$2"
        """)

        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/ps || {package} install -y procps'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/killall || {package} install -y psmisc'"
        sx____(cmd.format(**locals()))
        if COVERAGE:
            cmd = "{docker} exec {testname} {package} install -y {python_coverage}"
            sx____(cmd.format(**locals()))
        self.prep_coverage(image, testname)
        cmd = "{docker} exec {testname} mkdir -p /etc/systemd/system /etc/systemd/user"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} cp /bin/sleep {bindir}/{testsleep}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zzz.service {testname}:/etc/systemd/system/zzz.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/backup {testname}:/usr/bin/backup"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} touch /var/tmp/test.0"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} touch {logfile}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} chmod 666 {logfile}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'grep nobody /etc/group || groupadd -g 65533 nobody'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} useradd -u 1001 somebody -g nobody -m"
        sh____(cmd.format(**locals()))
        testfiles = output("{docker} exec {testname} find /var/tmp -name test.*".format(**locals()))
        logg.info("found testfiles:\n%s", testfiles)
        self.assertFalse(greps(testfiles, "/var/tmp/test.1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test.2"))
        #
        cmd = "{docker} exec {testname} {systemctl} enable zzz.service -vv"
        sh____(cmd.format(**locals()))
        is_active = "{docker} exec {testname} {systemctl} is-active zzz.service other.service -vv"
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "inactive\ninactive")
        self.assertEqual(end, 3)
        #
        logg.info("== 'start' shall start a service that is NOT is-active ")
        cmd = "{docker} exec {testname} {systemctl} start zzz.service other.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertNotEqual(end, 0)
        is_active = "{docker} exec {testname} {systemctl} is-active zzz.service other.service -vv"
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "active\ninactive")
        self.assertEqual(end, 3)
        testfiles = output("{docker} exec {testname} find /var/tmp -name test.*".format(**locals()))
        logg.info("found testfiles:\n%s", testfiles)
        self.assertTrue(greps(testfiles, "/var/tmp/test.1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test.2"))
        #
        logg.info("== 'stop' shall stop a service that is-active")
        cmd = "{docker} exec {testname} {systemctl} stop zzz.service other.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertNotEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "inactive\ninactive")
        self.assertEqual(end, 3)
        testfiles = output("{docker} exec {testname} find /var/tmp -name test.*".format(**locals()))
        logg.info("found testfiles:\n%s", testfiles)
        self.assertFalse(greps(testfiles, "/var/tmp/test.1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test.2"))
        #
        logg.info("== 'restart' shall start a service that NOT is-active")
        cmd = "{docker} exec {testname} {systemctl} restart zzz.service other.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertNotEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "active\ninactive")
        self.assertEqual(end, 3)
        testfiles = output("{docker} exec {testname} find /var/tmp -name test.*".format(**locals()))
        logg.info("found testfiles:\n%s", testfiles)
        self.assertTrue(greps(testfiles, "/var/tmp/test.1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test.2"))
        #
        logg.info("== 'restart' shall restart a service that is-active")
        cmd = "{docker} exec {testname} {systemctl} restart zzz.service other.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertNotEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "active\ninactive")
        self.assertEqual(end, 3)
        testfiles = output("{docker} exec {testname} find /var/tmp -name test.*".format(**locals()))
        logg.info("found testfiles:\n%s", testfiles)
        self.assertTrue(greps(testfiles, "/var/tmp/test.1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test.2"))
        #
        logg.info("== 'reload' will NOT restart a service that is-active")
        cmd = "{docker} exec {testname} {systemctl} reload zzz.service other.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertNotEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "active\ninactive")
        self.assertEqual(end, 3)
        testfiles = output("{docker} exec {testname} find /var/tmp -name test.*".format(**locals()))
        logg.info("found testfiles:\n%s", testfiles)
        self.assertTrue(greps(testfiles, "/var/tmp/test.1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test.2"))
        #
        logg.info("== 'reload-or-restart' will restart a service that is-active")
        cmd = "{docker} exec {testname} {systemctl} reload-or-restart zzz.service other.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertNotEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "active\ninactive")
        self.assertEqual(end, 3)
        #
        logg.info("== 'stop' will brings it back to 'inactive'")
        cmd = "{docker} exec {testname} {systemctl} stop zzz.service other.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertNotEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "inactive\ninactive")
        self.assertEqual(end, 3)
        testfiles = output("{docker} exec {testname} find /var/tmp -name test.*".format(**locals()))
        logg.info("found testfiles:\n%s", testfiles)
        self.assertFalse(greps(testfiles, "/var/tmp/test.1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test.2"))
        #
        logg.info("== 'reload-or-try-restart' will not start a not-active service")
        cmd = "{docker} exec {testname} {systemctl} reload-or-try-restart zzz.service other.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertNotEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "inactive\ninactive")
        self.assertEqual(end, 3)
        testfiles = output("{docker} exec {testname} find /var/tmp -name test.*".format(**locals()))
        logg.info("found testfiles:\n%s", testfiles)
        self.assertFalse(greps(testfiles, "/var/tmp/test.1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test.2"))
        #
        logg.info("== 'try-restart' will not start a not-active service")
        cmd = "{docker} exec {testname} {systemctl} try-restart zzz.service other.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertNotEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "inactive\ninactive")
        self.assertEqual(end, 3)
        testfiles = output("{docker} exec {testname} find /var/tmp -name test.*".format(**locals()))
        logg.info("found testfiles:\n%s", testfiles)
        self.assertFalse(greps(testfiles, "/var/tmp/test.1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test.2"))
        #
        logg.info("== 'reload-or-restart' will start a not-active service")
        cmd = "{docker} exec {testname} {systemctl} reload-or-restart zzz.service other.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertNotEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "active\ninactive")
        self.assertEqual(end, 3)
        testfiles = output("{docker} exec {testname} find /var/tmp -name test.*".format(**locals()))
        logg.info("found testfiles:\n%s", testfiles)
        self.assertTrue(greps(testfiles, "/var/tmp/test.1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test.2"))
        #
        logg.info("== 'reload-or-try-restart' will restart an is-active service")
        cmd = "{docker} exec {testname} {systemctl} reload-or-try-restart zzz.service other.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertNotEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "active\ninactive")
        self.assertEqual(end, 3)
        testfiles = output("{docker} exec {testname} find /var/tmp -name test.*".format(**locals()))
        logg.info("found testfiles:\n%s", testfiles)
        self.assertTrue(greps(testfiles, "/var/tmp/test.1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test.2"))
        #
        logg.info("== 'try-restart' will restart an is-active service")
        cmd = "{docker} exec {testname} {systemctl} try-restart zzz.service other.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertNotEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "active\ninactive")
        self.assertEqual(end, 3)
        testfiles = output("{docker} exec {testname} find /var/tmp -name test.*".format(**locals()))
        logg.info("found testfiles:\n%s", testfiles)
        self.assertTrue(greps(testfiles, "/var/tmp/test.1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test.2"))
        #
        logg.info("== 'stop' will brings it back to 'inactive'")
        cmd = "{docker} exec {testname} {systemctl} stop zzz.service other.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertNotEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "inactive\ninactive")
        self.assertEqual(end, 3)
        testfiles = output("{docker} exec {testname} find /var/tmp -name test.*".format(**locals()))
        logg.info("found testfiles:\n%s", testfiles)
        self.assertFalse(greps(testfiles, "/var/tmp/test.1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test.2"))
        #
        logg.info("LOG\n%s", " "+output("{docker} exec {testname} cat {logfile}".format(**locals())).replace("\n", "\n "))
        #
        self.save_coverage(testname)
        #
        self.rm_docker(testname)
        self.rm_testdir()
        self.end()
    def test_5043_runuser_oneshot_template_service_functions(self) -> None:
        """ check that we manage oneshot template services in a root env
            with basic run-service commands: start, stop, restart,
            reload, try-restart, reload-or-restart, kill and
            reload-or-try-restart."""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        self.runuser_oneshot_template_service_functions("system", testname, testdir)
        self.rm_testdir()
        self.end()
    def test_5044_runuser_oneshot_template_service_functions_user(self) -> None:
        """ check that we manage oneshot template services in a root env
            with basic run-service commands: start, stop, restart,
            reload, try-restart, reload-or-restart, kill and
            reload-or-try-restart."""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        self.runuser_oneshot_template_service_functions("user", testname, testdir)
        self.rm_testdir()
        self.end()
    def runuser_oneshot_template_service_functions(self, system: str, testname: str, testdir: str) -> None:
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        images = IMAGES
        image = self.local_image(COVERAGE or IMAGE or CENTOS)
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        python_coverage = coverage_package(image)
        if _python.endswith("python3") and "centos:7" in image:
            if SKIP: self.skipTest("no python3 on centos:7")
        docker = _docker
        package = package_tool(image)
        refresh = refresh_tool(image)
        sometime = SOMETIME or 188
        quick = QUICK
        #
        user = self.user()
        root = ""
        systemctl_py = realpath(_systemctl_py)
        systemctl = "/usr/bin/systemctl" # path in container
        systemctl += " --{system}".format(**locals())
        testsleep = self.testname("sleep")
        logfile = os_path(root, "/var/log/"+testsleep+".log")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zzz@.service"), """
            [Unit]
            Description=Testing Z.%i
            [Service]
            User=somebody
            Type=oneshot
            ExecStartPre={bindir}/backup {root}/var/tmp/test.%i.1 {root}/var/tmp/test.%i.2
            ExecStart=/usr/bin/touch {root}/var/tmp/test.%i.1
            ExecStop=/bin/rm {root}/var/tmp/test.%i.1
            ExecStopPost=/bin/rm -f {root}/var/tmp/test.%i.2
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        shell_file(os_path(testdir, "backup"), """
           #! /bin/sh
           set -x
           test ! -f "$1" || mv -v "$1" "$2"
        """)

        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/ps || {package} install -y procps'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/killall || {package} install -y psmisc'"
        sx____(cmd.format(**locals()))
        if COVERAGE:
            cmd = "{docker} exec {testname} {package} install -y {python_coverage}"
            sx____(cmd.format(**locals()))
        self.prep_coverage(image, testname)
        cmd = "{docker} exec {testname} mkdir -p /etc/systemd/system /etc/systemd/user"
        sx____(cmd.format(**locals()))
        zzz_service = "/etc/systemd/{system}/zzz@.service".format(**locals())
        cmd = "{docker} exec {testname} cp /bin/sleep {bindir}/{testsleep}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zzz@.service {testname}:{zzz_service}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} touch {logfile}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} chmod 666 {logfile}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'grep nobody /etc/group || groupadd -g 65533 nobody'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} useradd -u 1001 somebody -g nobody -m"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/backup {testname}:/usr/bin/backup"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} touch /var/tmp/test.0"
        sh____(cmd.format(**locals()))
        testfiles = output("{docker} exec {testname} find /var/tmp -name test.*".format(**locals()))
        logg.info("found testfiles:\n%s", testfiles)
        self.assertFalse(greps(testfiles, "/var/tmp/test.rsa.1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test.rsa.2"))
        self.assertFalse(greps(testfiles, "/var/tmp/test..1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test..2"))
        #
        cmd = "{docker} exec {testname} {systemctl} enable zzz@rsa.service -vv"
        sh____(cmd.format(**locals()))
        #
        is_active = "{docker} exec {testname} {systemctl} is-active zzz@rsa.service -vv"
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "inactive")
        self.assertEqual(end, 3)
        #
        logg.info("== 'start' shall start a service that is NOT is-active ")
        cmd = "{docker} exec {testname} {systemctl} start zzz@rsa.service -vvvv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "active")
        self.assertEqual(end, 0)
        testfiles = output("{docker} exec {testname} find /var/tmp -name test.*".format(**locals()))
        logg.info("found testfiles:\n%s", testfiles)
        self.assertTrue(greps(testfiles, "/var/tmp/test.rsa.1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test.rsa.2"))
        self.assertFalse(greps(testfiles, "/var/tmp/test..1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test..2"))
        #
        logg.info("== 'stop' shall stop a service that is-active")
        cmd = "{docker} exec {testname} {systemctl} stop zzz@rsa.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "inactive")
        self.assertEqual(end, 3)
        testfiles = output("{docker} exec {testname} find /var/tmp -name test.*".format(**locals()))
        logg.info("found testfiles:\n%s", testfiles)
        self.assertFalse(greps(testfiles, "/var/tmp/test.rsa.1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test.rsa.2"))
        self.assertFalse(greps(testfiles, "/var/tmp/test..1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test..2"))
        #
        logg.info("== 'restart' shall start a service that NOT is-active")
        cmd = "{docker} exec {testname} {systemctl} restart zzz@rsa.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "active")
        self.assertEqual(end, 0)
        testfiles = output("{docker} exec {testname} find /var/tmp -name test.*".format(**locals()))
        logg.info("found testfiles:\n%s", testfiles)
        self.assertTrue(greps(testfiles, "/var/tmp/test.rsa.1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test.rsa.2"))
        self.assertFalse(greps(testfiles, "/var/tmp/test..1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test..2"))
        #
        logg.info("== 'restart' shall restart a service that is-active")
        cmd = "{docker} exec {testname} {systemctl} restart zzz@rsa.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "active")
        self.assertEqual(end, 0)
        testfiles = output("{docker} exec {testname} find /var/tmp -name test.*".format(**locals()))
        logg.info("found testfiles:\n%s", testfiles)
        self.assertTrue(greps(testfiles, "/var/tmp/test.rsa.1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test.rsa.2"))
        self.assertFalse(greps(testfiles, "/var/tmp/test..1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test..2"))
        #
        logg.info("== 'reload' will NOT restart a service that is-active")
        cmd = "{docker} exec {testname} {systemctl} reload zzz@rsa.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "active")
        self.assertEqual(end, 0)
        testfiles = output("{docker} exec {testname} find /var/tmp -name test.*".format(**locals()))
        logg.info("found testfiles:\n%s", testfiles)
        self.assertTrue(greps(testfiles, "/var/tmp/test.rsa.1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test.rsa.2"))
        self.assertFalse(greps(testfiles, "/var/tmp/test..1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test..2"))
        #
        logg.info("== 'reload-or-restart' will restart a service that is-active")
        cmd = "{docker} exec {testname} {systemctl} reload-or-restart zzz@rsa.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "active")
        self.assertEqual(end, 0)
        #
        logg.info("== 'stop' will brings it back to 'inactive'")
        cmd = "{docker} exec {testname} {systemctl} stop zzz@rsa.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "inactive")
        self.assertEqual(end, 3)
        testfiles = output("{docker} exec {testname} find /var/tmp -name test.*".format(**locals()))
        logg.info("found testfiles:\n%s", testfiles)
        self.assertFalse(greps(testfiles, "/var/tmp/test.rsa.1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test.rsa.2"))
        self.assertFalse(greps(testfiles, "/var/tmp/test..1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test..2"))
        #
        logg.info("== 'reload-or-try-restart' will not start a not-active service")
        cmd = "{docker} exec {testname} {systemctl} reload-or-try-restart zzz@rsa.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "inactive")
        self.assertEqual(end, 3)
        testfiles = output("{docker} exec {testname} find /var/tmp -name test.*".format(**locals()))
        logg.info("found testfiles:\n%s", testfiles)
        self.assertFalse(greps(testfiles, "/var/tmp/test.rsa.1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test.rsa.2"))
        self.assertFalse(greps(testfiles, "/var/tmp/test..1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test..2"))
        #
        logg.info("== 'try-restart' will not start a not-active service")
        cmd = "{docker} exec {testname} {systemctl} try-restart zzz@rsa.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "inactive")
        self.assertEqual(end, 3)
        testfiles = output("{docker} exec {testname} find /var/tmp -name test.*".format(**locals()))
        logg.info("found testfiles:\n%s", testfiles)
        self.assertFalse(greps(testfiles, "/var/tmp/test.rsa.1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test.rsa.2"))
        self.assertFalse(greps(testfiles, "/var/tmp/test..1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test..2"))
        #
        logg.info("== 'reload-or-restart' will start a not-active service")
        cmd = "{docker} exec {testname} {systemctl} reload-or-restart zzz@rsa.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "active")
        self.assertEqual(end, 0)
        testfiles = output("{docker} exec {testname} find /var/tmp -name test.*".format(**locals()))
        logg.info("found testfiles:\n%s", testfiles)
        self.assertTrue(greps(testfiles, "/var/tmp/test.rsa.1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test.rsa.2"))
        self.assertFalse(greps(testfiles, "/var/tmp/test..1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test..2"))
        #
        logg.info("== 'reload-or-try-restart' will restart an is-active service")
        cmd = "{docker} exec {testname} {systemctl} reload-or-try-restart zzz@rsa.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "active")
        self.assertEqual(end, 0)
        testfiles = output("{docker} exec {testname} find /var/tmp -name test.*".format(**locals()))
        logg.info("found testfiles:\n%s", testfiles)
        self.assertTrue(greps(testfiles, "/var/tmp/test.rsa.1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test.rsa.2"))
        self.assertFalse(greps(testfiles, "/var/tmp/test..1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test..2"))
        #
        logg.info("== 'try-restart' will restart an is-active service")
        cmd = "{docker} exec {testname} {systemctl} try-restart zzz@rsa.service -vv -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "active")
        self.assertEqual(end, 0)
        testfiles = output("{docker} exec {testname} find /var/tmp -name test.*".format(**locals()))
        logg.info("found testfiles:\n%s", testfiles)
        self.assertTrue(greps(testfiles, "/var/tmp/test.rsa.1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test.rsa.2"))
        self.assertFalse(greps(testfiles, "/var/tmp/test..1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test..2"))
        #
        logg.info("== 'stop' will brings it back to 'inactive'")
        cmd = "{docker} exec {testname} {systemctl} stop zzz@rsa.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "inactive")
        self.assertEqual(end, 3)
        testfiles = output("{docker} exec {testname} find /var/tmp -name test.*".format(**locals()))
        logg.info("found testfiles:\n%s", testfiles)
        self.assertFalse(greps(testfiles, "/var/tmp/test.rsa.1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test.rsa.2"))
        self.assertFalse(greps(testfiles, "/var/tmp/test..1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test..2"))
        #
        logg.info("LOG\n%s", " "+output("{docker} exec {testname} cat {logfile}".format(**locals())).replace("\n", "\n "))
        #
        self.save_coverage(testname)
        #
        self.rm_docker(testname)
    def test_5045_runuser_sysv_service_functions(self) -> None:
        """ check that we manage SysV services in a root env
            with basic run-service commands: start, stop, restart,
            reload, try-restart, reload-or-restart, kill and
            reload-or-try-restart."""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        images = IMAGES
        image = self.local_image(COVERAGE or IMAGE or CENTOS)
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        python_coverage = coverage_package(image)
        if _python.endswith("python3") and "centos:7" in image:
            if SKIP: self.skipTest("no python3 on centos:7")
        docker = _docker
        package = package_tool(image)
        refresh = refresh_tool(image)
        sometime = SOMETIME or 188
        quick = QUICK
        #
        user = self.user()
        root = ""
        systemctl_py = realpath(_systemctl_py)
        systemctl = "/usr/bin/systemctl" # path in container
        testsleep = self.testname("sleep")
        logfile = os_path(root, "/var/log/"+testsleep+".log")
        bindir = os_path(root, "/usr/bin")
        begin = "{"
        ends = "}"
        shell_file(os_path(testdir, "zzz.init"), """
            #! /bin/bash
            ### BEGIN INIT INFO
            # Required-Start: $local_fs $remote_fs $syslog $network
            # Required-Stop:  $local_fs $remote_fs $syslog $network
            # Default-Start:  3 5
            # Default-Stop:   0 1 2 6
            # Short-Description: Testing Z
            # Description:    Allows for SysV testing
            ### END INIT INFO
            logfile={logfile}
            sleeptime=111
            start() {begin}
               [ -d /var/run ] || mkdir -p /var/run
               (runuser -u somebody {bindir}/{testsleep} $sleeptime 0<&- &>/dev/null &
                echo $! > {root}/var/run/zzz.init.pid
               ) &
               wait %1
               # ps -o pid,ppid,user,args
               cat "RUNNING `cat {root}/var/run/zzz.init.pid`"
            {ends}
            stop() {begin}
               kill `cat {root}/var/run/zzz.init.pid` >>$logfile 2>&1
               killall {testsleep} >> $logfile 2>&1
            {ends}
            case "$1" in start)
               date "+START.%T" >> $logfile
               start >> $logfile 2>&1
               date "+start.%T" >> $logfile
            ;; stop)
               date "+STOP.%T" >> $logfile
               stop >> $logfile 2>&1
               date "+stop.%T" >> $logfile
            ;; restart)
               date "+RESTART.%T" >> $logfile
               stop >> $logfile 2>&1
               start >> $logfile 2>&1
               date "+.%T" >> $logfile
            ;; reload)
               date "+RELOAD.%T" >> $logfile
               echo "...." >> $logfile 2>&1
               date "+reload.%T" >> $logfile
            ;; esac
            echo "done$1" >&2
            exit 0
            """.format(**locals()))

        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/ps || {package} install -y procps'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/killall || {package} install -y psmisc'"
        sx____(cmd.format(**locals()))
        if COVERAGE:
            cmd = "{docker} exec {testname} {package} install -y {python_coverage}"
            sx____(cmd.format(**locals()))
        self.prep_coverage(image, testname)
        cmd = "{docker} exec {testname} cp /bin/sleep {bindir}/{testsleep}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'test -d /etc/init.d || mkdir -v /etc/init.d'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zzz.init {testname}:/etc/init.d/zzz"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} touch {logfile}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} chmod 666 {logfile}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'grep nobody /etc/group || groupadd -g 65533 nobody'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} useradd -u 1001 somebody -g nobody -m"
        sh____(cmd.format(**locals()))
        #
        cmd = "{docker} exec {testname} {systemctl} enable zzz.service -vv"
        sh____(cmd.format(**locals()))
        #
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'start' shall start a service that is NOT is-active ")
        cmd = "{docker} exec {testname} {systemctl} start zzz.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        #
        logg.info("== 'stop' shall stop a service that is-active")
        cmd = "{docker} exec {testname} {systemctl} stop zzz.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        time.sleep(1) # killall is async
        sx____("{docker} exec {testname} bash -c 'sed s/^/.../ {logfile} | tail'".format(**locals()))
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'restart' shall start a service that NOT is-active")
        cmd = "{docker} exec {testname} {systemctl} restart zzz.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top1= top
        #
        logg.info("== 'restart' shall restart a service that is-active")
        cmd = "{docker} exec {testname} {systemctl} restart zzz.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top2 = top
        #
        logg.info("-- and we check that there is a new PID for the service process")
        def find_pids(ps_output: Union[str, List[str]], command: str) -> List[str]:
            pids = []
            for line in _lines(ps_output):
                if command not in line: continue
                m = re.match(r"\s*[\d:]*\s+(\S+)\s+(\S+)\s+(.*)", line)
                if not m: continue
                pid, ppid, args = m.groups()
                # logg.info("  %s | %s | %s", pid, ppid, args)
                pids.append(pid)
            return pids
        ps1 = find_pids(running(top1), testsleep)
        ps2 = find_pids(running(top2), testsleep)
        logg.info("found PIDs %s and %s", ps1, ps2)
        self.assertTrue(len(ps1), 1)
        self.assertTrue(len(ps2), 1)
        self.assertNotEqual(ps1[0], ps2[0])
        #
        logg.info("== 'reload' will NOT restart a service that is-active")
        cmd = "{docker} exec {testname} {systemctl} reload zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top3 = top
        #
        logg.info("-- and we check that there is NO new PID for the service process")
        ps3 = find_pids(running(top3), testsleep)
        logg.info("found PIDs %s and %s", ps2, ps3)
        self.assertTrue(len(ps2), 1)
        self.assertTrue(len(ps3), 1)
        self.assertEqual(ps2[0], ps3[0])
        #
        logg.info("== 'reload-or-restart' may restart a service that is-active")
        cmd = "{docker} exec {testname} {systemctl} reload-or-restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        #
        logg.info("== 'stop' will turn 'failed' to 'inactive' (when the PID is known)")
        cmd = "{docker} exec {testname} {systemctl} stop zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'reload-or-try-restart' will not start a not-active service")
        cmd = "{docker} exec {testname} {systemctl} reload-or-try-restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        #
        cmd = "{docker} exec {testname} {systemctl} stop zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        #
        logg.info("== 'try-restart' will not start a not-active service")
        cmd = "{docker} exec {testname} {systemctl} try-restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'reload-or-restart' will start a not-active service")
        cmd = "{docker} exec {testname} {systemctl} reload-or-restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top5 = top
        #
        logg.info("== 'reload-or-try-restart' will restart an is-active service (with no ExecReload)")
        cmd = "{docker} exec {testname} {systemctl} reload-or-try-restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top6 = top
        #
        logg.info("== 'try-restart' will restart an is-active service")
        cmd = "{docker} exec {testname} {systemctl} try-restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top7 = top
        #
        logg.info("-- and we check that there is a new PID for the service process")
        ps6 = find_pids(running(top6), testsleep)
        ps7 = find_pids(running(top7), testsleep)
        logg.info("found PIDs %s and %s", ps6, ps7)
        self.assertTrue(len(ps6), 1)
        self.assertTrue(len(ps7), 1)
        self.assertNotEqual(ps6[0], ps7[0])
        #
        logg.info("LOG\n%s", " "+output("{docker} exec {testname} cat {logfile}".format(**locals())).replace("\n", "\n "))
        #
        self.save_coverage(testname)
        #
        self.rm_docker(testname)
        self.rm_testdir()
        self.end(188)
    #
    #
    #  compare the following with the test_5030 series
    #  as they are doing the same with usermode-only containers
    #
    #
    def test_5100_usermode_keeps_running(self) -> None:
        """ check that we manage simple services in a root env
            with commands like start, restart, stop, etc"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        self.usermode_keeps_running("system", testname, testdir)
        self.rm_testdir()
        self.end()
    def test_5101_usermode_keeps_running_user(self) -> None:
        """ check that we manage simple services in a root env
            with commands like start, restart, stop, etc"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        self.usermode_keeps_running("user", testname, testdir)
        self.rm_testdir()
        self.end()
    def usermode_keeps_running(self, system: str, testname: str, testdir: str) -> None:
        """ check that we manage simple services in a root env
            where the usermode container keeps running on PID 1 """
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        images = IMAGES
        image = self.local_image(COVERAGE or IMAGE or CENTOS)
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        python_coverage = coverage_package(image)
        if _python.endswith("python3") and "centos:7" in image:
            if SKIP: self.skipTest("no python3 on centos:7")
        docker = _docker
        package = package_tool(image)
        refresh = refresh_tool(image)
        sometime = SOMETIME or 288
        quick = QUICK
        #
        user = self.user()
        root = ""
        systemctl_py = realpath(_systemctl_py)
        systemctl = "/usr/bin/systemctl" # path in container
        systemctl += " --user"
        # systemctl += " --{system}".format(**locals())
        testsleep = testname+"_testsleep"
        logfile = os_path(root, "/var/log/test.log")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            [Service]
            User=somebody
            Type=simple
            ExecStartPre=/bin/echo %n
            ExecStart=/usr/bin/{testsleep} 8
            ExecStartPost=/bin/echo started $MAINPID
            # ExecStop=/bin/kill $MAINPID
            ExecStopPost=/bin/echo stopped $MAINPID
            ExecStopPost=/bin/sleep 2
            ExecReload=/bin/kill -10 $MAINPID
            KillSignal=SIGQUIT
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))

        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} rmi {images}:{testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/ps || {package} install -y procps'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/killall || {package} install -y psmisc'"
        sx____(cmd.format(**locals()))
        if COVERAGE:
            cmd = "{docker} exec {testname} {package} install -y {python_coverage}"
            sx____(cmd.format(**locals()))
        self.prep_coverage(image, testname)
        cmd = "{docker} exec {testname} mkdir -p /etc/systemd/system /etc/systemd/user"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} cp /bin/sleep {bindir}/{testsleep}"
        sh____(cmd.format(**locals()))
        zzz_service = "/etc/systemd/{system}/zzz.service".format(**locals())
        cmd = "{docker} cp {testdir}/zzz.service {testname}:{zzz_service}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} touch {logfile}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} chmod 666 {logfile}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'grep nobody /etc/group || groupadd -g 65533 nobody'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} useradd -u 1001 somebody -g nobody -m"
        sh____(cmd.format(**locals()))
        #
        cmd = "{docker} exec {testname} touch /var/log/systemctl.debug.log"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} chmod 666 /var/log/systemctl.debug.log"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} mkdir -p touch /tmp/run-somebody/log"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} touch /tmp/run-somebody/log/systemctl.debug.log"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} chown somebody -R /tmp/run-somebody"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl --version"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} chown somebody /tmp/.coverage"
        sx____(cmd.format(**locals()))
        #
        cmd = "{docker} commit -c 'CMD [\"/usr/bin/systemctl\"]' -c 'USER somebody' {testname} {images}:{testname}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} rm -f {testname}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} run -d --name {testname} {images}:{testname}"
        sh____(cmd.format(**locals()))
        #
        cmd = "{docker} exec {testname} {systemctl} enable zzz.service -vv"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {systemctl} is-system-running -vv"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'start' shall start a service that is NOT is-active ")
        cmd = "{docker} exec {testname} {systemctl} start zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(running(greps(top, testsleep)))
        self.assertEqual(end, 0)
        #
        for attempt in xrange(4): # 4*3 = 12s
            time.sleep(3)
            logg.info("=====================================================================")
            top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
            logg.info("\n>>>\n%s", top)
            cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
            out, err, end = output3(cmd.format(**locals()))
            logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
            cmd = "{docker} cp {testname}:/var/log/systemctl.debug.log {testdir}/gobal.systemctl.debug.log"
            sx____(cmd.format(**locals()))
            cmd = "tail {testdir}/gobal.systemctl.debug.log | sed -e s/^/GLOBAL:.../"
            sx____(cmd.format(**locals()))
            cmd = "{docker} cp {testname}:/tmp/run-somebody/log/systemctl.debug.log {testdir}/somebody.systemctl.debug.log"
            sx____(cmd.format(**locals()))
            cmd = "tail {testdir}/somebody.systemctl.debug.log | sed -e s/^/USER:.../"
            sx____(cmd.format(**locals()))
            #
            # out, end = output2(cmd.format(**locals()))
            if greps(err, "Error response from daemon"):
                break
        #
        kill_testsleep = "killall {testsleep}"
        sx____(kill_testsleep.format(**locals()))
        #
        self.save_coverage(testname)
        #
        cmd = "{docker} rmi {images}:{testname}"
        sx____(cmd.format(**locals()))
        self.rm_docker(testname)
        if True:
            cmd = "cat {testdir}/gobal.systemctl.debug.log | sed -e s/^/GLOBAL:.../"
            sx____(cmd.format(**locals()))
            cmd = "cat {testdir}/somebody.systemctl.debug.log | sed -e s/^/USER:.../"
            sx____(cmd.format(**locals()))
        #
        self.assertFalse(greps(err, "Error response from daemon"))
        self.assertEqual(out.strip(), "failed") # sleep did exit but not 'stop' requested
    def test_5130_usermode_simple_service_functions_system(self) -> None:
        """ check that we manage simple services in a root env
            with commands like start, restart, stop, etc"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        self.usermode_simple_service_functions("system", testname, testdir)
        self.rm_testdir()
        self.end(122)
    def test_5131_simple_service_functions_user(self) -> None:
        """ check that we manage simple services in a root env
            with commands like start, restart, stop, etc"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        self.usermode_simple_service_functions("user", testname, testdir)
        self.rm_testdir()
        self.end(122)
    def usermode_simple_service_functions(self, system: str, testname: str, testdir: str) -> None:
        """ check that we manage simple services in a root env
            with commands like start, restart, stop, etc"""
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        images = IMAGES
        image = self.local_image(COVERAGE or IMAGE or CENTOS)
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        python_coverage = coverage_package(image)
        if _python.endswith("python3") and "centos:7" in image:
            if SKIP: self.skipTest("no python3 on centos:7")
        docker = _docker
        package = package_tool(image)
        refresh = refresh_tool(image)
        sometime = SOMETIME or 288
        quick = QUICK
        #
        user = self.user()
        root = ""
        systemctl_py = realpath(_systemctl_py)
        systemctl = "/usr/bin/systemctl" # path in container
        systemctl += " --user"
        # systemctl += " --{system}".format(**locals())
        testsleep = testname+"_testsleep"
        testscript = testname+"_testscript.sh"
        logfile = os_path(root, "/var/log/test.log")
        bindir = os_path(root, "/usr/bin")
        begin = "{"
        ends = "}"
        shell_file(os_path(testdir, "binkillall"), """
            #! /bin/sh
            ps -eo pid,comm,args | { while read pid comm args; do
               case "$args" in *"/bin/$1 "*)
                  echo kill $pid
                  kill $pid
               ;; esac
               if [ "$comm" = "$1" ]; then
                  echo kill $pid
                  kill $pid
               fi done } """)
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            [Service]
            User=somebody
            Type=simple
            ExecStartPre=/bin/echo %n
            ExecStart={bindir}/{testscript} 111
            ExecStartPost=/bin/echo started $MAINPID
            ExecStop=/bin/kill -3 $MAINPID
            ExecStopPost=/bin/echo stopped $MAINPID
            ExecStopPost=/bin/sleep 2
            ExecReload=/bin/kill -10 $MAINPID
            KillSignal=SIGQUIT
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        shell_file(os_path(testdir, testscript), """
            #! /bin/sh
            date +%T,enter >> {logfile}
            stops () {begin}
              date +%T,stopping >> {logfile}
              binkillall {testsleep} >> {logfile} 2>&1
              date +%T,stopped >> {logfile}
            {ends}
            reload () {begin}
              date +%T,reloading >> {logfile}
              date +%T,reloaded >> {logfile}
            {ends}
            trap "stops" 3   # SIGQUIT
            trap "reload" 10 # SIGUSR1
            date +%T,starting >> {logfile}
            {bindir}/{testsleep} $1 >> {logfile} 2>&1 &
            pid="$!"
            while kill -0 $pid; do
               # use 'kill -0' to check the existance of the child
               date +%T,waiting >> {logfile}
               # use 'wait' for children AND external signals
               wait
            done
            date +%T,leaving >> {logfile}
            trap - 3 10 # SIGQUIT SIGUSR1
            date +%T,leave >> {logfile}
        """.format(**locals()))

        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} rmi {images}:{testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/ps || {package} install -y procps'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sx____(cmd.format(**locals()))
        if COVERAGE:
            cmd = "{docker} exec {testname} {package} install -y {python_coverage}"
            sx____(cmd.format(**locals()))
        self.prep_coverage(image, testname)
        cmd = "{docker} cp {testdir}/binkillall {testname}:/usr/bin/binkillall"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} cp /bin/sleep {bindir}/{testsleep}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/{testscript} {testname}:{bindir}/{testscript}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} mkdir -p /etc/systemd/system /etc/systemd/user"
        sx____(cmd.format(**locals()))
        zzz_service = "/etc/systemd/{system}/zzz.service".format(**locals())
        cmd = "{docker} cp {testdir}/zzz.service {testname}:{zzz_service}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} touch {logfile}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} chmod 666 {logfile}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'grep nobody /etc/group || groupadd -g 65533 nobody'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} useradd -u 1001 somebody -g nobody -m"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl --version"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} chown somebody /tmp/.coverage"
        sx____(cmd.format(**locals()))
        #
        cmd = "{docker} commit -c 'CMD [\"/usr/bin/systemctl\"]' -c 'USER somebody' {testname} {images}:{testname}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} rm -f {testname}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} run -d --name {testname} {images}:{testname}"
        sh____(cmd.format(**locals()))
        #
        cmd = "{docker} exec {testname} {systemctl} enable zzz.service -vv"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'start' shall start a service that is NOT is-active ")
        cmd = "{docker} exec {testname} {systemctl} start zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output(_top_list))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(running(greps(top, testsleep)))
        self.assertEqual(end, 0)
        #
        time.sleep(3)
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        #
        logg.info("== 'stop' shall stop a service that is-active")
        cmd = "{docker} exec {testname} {systemctl} stop zzz.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        time.sleep(1) # kill is async
        cmd = "{docker} exec {testname} cat {logfile}"
        sh____(cmd.format(**locals()))
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        # inspect the service's log
        log = lines(output("{docker} exec {testname} cat {logfile}".format(**locals())))
        logg.info("LOG\n %s", "\n ".join(log))
        self.assertTrue(greps(log, "enter"))
        self.assertTrue(greps(log, "leave"))
        self.assertTrue(greps(log, "starting"))
        self.assertTrue(greps(log, "stopped"))
        self.assertFalse(greps(log, "reload"))
        sh____("{docker} exec {testname} truncate -s0 {logfile}".format(**locals()))
        #
        logg.info("== 'restart' shall start a service that NOT is-active")
        cmd = "{docker} exec {testname} {systemctl} restart zzz.service -vvvv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top1= top
        #
        # inspect the service's log
        log = lines(output("{docker} exec {testname} cat {logfile}".format(**locals())))
        logg.info("LOG\n %s", "\n ".join(log))
        self.assertTrue(greps(log, "enter"))
        self.assertFalse(greps(log, "leave"))
        self.assertTrue(greps(log, "starting"))
        self.assertFalse(greps(log, "stopped"))
        self.assertFalse(greps(log, "reload"))
        sh____("{docker} exec {testname} truncate -s0 {logfile}".format(**locals()))
        #
        logg.info("== 'restart' shall restart a service that is-active")
        cmd = "{docker} exec {testname} {systemctl} restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top2 = top
        #
        logg.info("-- and we check that there is a new PID for the service process")
        def find_pids(ps_output: Union[str, List[str]], command: str) -> List[str]:
            pids = []
            for line in _lines(ps_output):
                if command not in line: continue
                m = re.match(r"\s*[\d:]*\s+(\S+)\s+(\S+)\s+(.*)", line)
                if not m: continue
                pid, ppid, args = m.groups()
                # logg.info("  %s | %s | %s", pid, ppid, args)
                pids.append(pid)
            return pids
        ps1 = find_pids(top1, testsleep)
        ps2 = find_pids(top2, testsleep)
        logg.info("found PIDs %s and %s", ps1, ps2)
        self.assertTrue(len(ps1), 1)
        self.assertTrue(len(ps2), 1)
        self.assertNotEqual(ps1[0], ps2[0])
        #
        # inspect the service's log
        log = lines(output("{docker} exec {testname} cat {logfile}".format(**locals())))
        logg.info("LOG\n %s", "\n ".join(log))
        self.assertTrue(greps(log, "enter"))
        self.assertTrue(greps(log, "starting"))
        self.assertFalse(greps(log, "reload"))
        sh____("{docker} exec {testname} truncate -s0 {logfile}".format(**locals()))
        #
        #
        logg.info("== 'reload' will NOT restart a service that is-active")
        cmd = "{docker} exec {testname} {systemctl} reload zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top3 = top
        #
        logg.info("-- and we check that there is NO new PID for the service process")
        ps3 = find_pids(top3, testsleep)
        logg.info("found PIDs %s and %s", ps2, ps3)
        self.assertTrue(len(ps2), 1)
        self.assertTrue(len(ps3), 1)
        self.assertEqual(ps2[0], ps3[0])
        #
        # inspect the service's log
        log = lines(output("{docker} exec {testname} cat {logfile}".format(**locals())))
        logg.info("LOG\n %s", "\n ".join(log))
        self.assertFalse(greps(log, "enter"))
        self.assertFalse(greps(log, "leave"))
        self.assertFalse(greps(log, "starting"))
        self.assertFalse(greps(log, "stopped"))
        self.assertTrue(greps(log, "reload"))
        sh____("{docker} exec {testname} truncate -s0 {logfile}".format(**locals()))
        #
        logg.info("== 'reload-or-restart' will restart a service that is-active (if ExecReload)")
        cmd = "{docker} exec {testname} {systemctl} reload-or-restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top4 = top
        #
        logg.info("-- and we check that there is NO new PID for the service process (if ExecReload)")
        ps4 = find_pids(top4, testsleep)
        logg.info("found PIDs %s and %s", ps3, ps4)
        self.assertTrue(len(ps3), 1)
        self.assertTrue(len(ps4), 1)
        self.assertEqual(ps3[0], ps4[0])
        #
        logg.info("== 'kill' will bring is-active non-active as well (when the PID is known)")
        cmd = "{docker} exec {testname} {systemctl} kill zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'stop' will turn 'failed' to 'inactive' (when the PID is known)")
        cmd = "{docker} exec {testname} {systemctl} stop zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertNotEqual(end, 0) # no PID known so 'kill $MAINPID' fails
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'reload-or-try-restart' will not start a not-active service")
        cmd = "{docker} exec {testname} {systemctl} reload-or-try-restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'try-restart' will not start a not-active service")
        cmd = "{docker} exec {testname} {systemctl} try-restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'reload-or-restart' will start a not-active service")
        cmd = "{docker} exec {testname} {systemctl} reload-or-restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top5 = top
        #
        logg.info("== 'reload-or-try-restart' will NOT restart an is-active service (with ExecReload)")
        cmd = "{docker} exec {testname} {systemctl} reload-or-try-restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top6 = top
        #
        logg.info("-- and we check that there is NO new PID for the service process (if ExecReload)")
        ps5 = find_pids(top5, testsleep)
        ps6 = find_pids(top6, testsleep)
        logg.info("found PIDs %s and %s", ps5, ps6)
        self.assertTrue(len(ps5), 1)
        self.assertTrue(len(ps6), 1)
        self.assertEqual(ps5[0], ps6[0])
        #
        logg.info("== 'try-restart' will restart an is-active service")
        cmd = "{docker} exec {testname} {systemctl} try-restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top7 = top
        #
        logg.info("-- and we check that there is a new PID for the service process")
        ps7 = find_pids(top7, testsleep)
        logg.info("found PIDs %s and %s", ps6, ps7)
        self.assertTrue(len(ps6), 1)
        self.assertTrue(len(ps7), 1)
        self.assertNotEqual(ps6[0], ps7[0])
        #
        kill_testsleep = "{docker} exec {testname} binkillall {testsleep}"
        sx____(kill_testsleep.format(**locals()))
        #
        self.save_coverage(testname)
        #
        cmd = "{docker} rmi {images}:{testname}"
        sx____(cmd.format(**locals()))
        self.rm_docker(testname)
    def test_5132_usermode_forking_service_functions_system(self) -> None:
        """ check that we manage forking services in a root env
            with basic run-service commands: start, stop, restart,
            reload, try-restart, reload-or-restart, kill and
            reload-or-try-restart."""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        self.usermode_forking_service_functions("system", testname, testdir)
        self.rm_testdir()
        self.end()
    def test_5133_usermode_forking_service_functions_user(self) -> None:
        """ check that we manage forking services in a root env
            with basic run-service commands: start, stop, restart,
            reload, try-restart, reload-or-restart, kill and
            reload-or-try-restart."""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        self.usermode_forking_service_functions("user", testname, testdir)
        self.rm_testdir()
        self.end()
    def usermode_forking_service_functions(self, system: str, testname: str, testdir: str) -> None:
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        images = IMAGES
        image = self.local_image(COVERAGE or IMAGE or CENTOS)
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        python_coverage = coverage_package(image)
        if _python.endswith("python3") and "centos:7" in image:
            if SKIP: self.skipTest("no python3 on centos:7")
        docker = _docker
        package = package_tool(image)
        refresh = refresh_tool(image)
        sometime = SOMETIME or 188
        quick = QUICK
        #
        user = self.user()
        root = ""
        systemctl_py = realpath(_systemctl_py)
        systemctl = "/usr/bin/systemctl" # path in container
        systemctl += " --user"
        # systemctl += " --{system}".format(**locals())
        testsleep = testname+"_sleep"
        logfile = os_path(root, "/var/log/"+testsleep+".log")
        bindir = os_path(root, "/usr/bin")
        begin = "{"
        ends = "}"
        shell_file(os_path(testdir, "zzz.init"), """
            #! /bin/bash
            logfile={logfile}
            start() {begin}
               [ -d /var/run ] || mkdir -p /var/run
               ({bindir}/{testsleep} 111 0<&- &>/dev/null &
                echo $! > /tmp/zzz.init.pid
               ) &
               wait %1
               # ps -o pid,ppid,user,args
            {ends}
            stop() {begin}
               killall {testsleep}
            {ends}
            case "$1" in start)
               date "+START.%T" >> $logfile
               start >> $logfile 2>&1
               date "+start.%T" >> $logfile
            ;; stop)
               date "+STOP.%T" >> $logfile
               stop >> $logfile 2>&1
               date "+stop.%T" >> $logfile
            ;; restart)
               date "+RESTART.%T" >> $logfile
               stop >> $logfile 2>&1
               start >> $logfile 2>&1
               date "+.%T" >> $logfile
            ;; reload)
               date "+RELOAD.%T" >> $logfile
               echo "...." >> $logfile 2>&1
               date "+reload.%T" >> $logfile
            ;; esac
            echo "done$1" >&2
            exit 0
            """.format(**locals()))
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            [Service]
            User=somebody
            Type=forking
            PIDFile=/tmp/zzz.init.pid
            ExecStart=/usr/bin/zzz.init start
            ExecStop=/usr/bin/zzz.init stop
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))

        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} rmi {images}:{testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/ps || {package} install -y procps'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/killall || {package} install -y psmisc'"
        sx____(cmd.format(**locals()))
        if COVERAGE:
            cmd = "{docker} exec {testname} {package} install -y {python_coverage}"
            sx____(cmd.format(**locals()))
        self.prep_coverage(image, testname)
        cmd = "{docker} exec {testname} mkdir -p /etc/systemd/system /etc/systemd/user"
        sx____(cmd.format(**locals()))
        zzz_service = "/etc/systemd/{system}/zzz.service".format(**locals())
        cmd = "{docker} exec {testname} cp /bin/sleep {bindir}/{testsleep}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zzz.init {testname}:/usr/bin/zzz.init"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zzz.service {testname}:{zzz_service}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} touch {logfile}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} chmod 666 {logfile}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'grep nobody /etc/group || groupadd -g 65533 nobody'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} useradd -u 1001 somebody -g nobody -m"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl --version"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} chown somebody /tmp/.coverage"
        sx____(cmd.format(**locals()))
        #
        cmd = "{docker} commit -c 'CMD [\"/usr/bin/systemctl\"]' -c 'USER somebody' {testname} {images}:{testname}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} rm -f {testname}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} run -d --name {testname} {images}:{testname}"
        sh____(cmd.format(**locals()))
        #
        cmd = "{docker} exec {testname} {systemctl} enable zzz.service -vv"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'start' shall start a service that is NOT is-active ")
        cmd = "{docker} exec {testname} {systemctl} start zzz.service -vvvv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        #
        logg.info("== 'stop' shall stop a service that is-active")
        cmd = "{docker} exec {testname} {systemctl} stop zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'restart' shall start a service that NOT is-active")
        cmd = "{docker} exec {testname} {systemctl} restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top1= top
        #
        logg.info("== 'restart' shall restart a service that is-active")
        cmd = "{docker} exec {testname} {systemctl} restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top2 = top
        #
        logg.info("-- and we check that there is a new PID for the service process")
        def find_pids(ps_output: Union[str, List[str]], command: str) -> List[str]:
            pids = []
            for line in _lines(ps_output):
                if command not in line: continue
                m = re.match(r"\s*[\d:]*\s+(\S+)\s+(\S+)\s+(.*)", line)
                if not m: continue
                pid, ppid, args = m.groups()
                # logg.info("  %s | %s | %s", pid, ppid, args)
                pids.append(pid)
            return pids
        ps1 = find_pids(running(top1), testsleep)
        ps2 = find_pids(running(top2), testsleep)
        logg.info("found PIDs %s and %s", ps1, ps2)
        self.assertTrue(len(ps1), 1)
        self.assertTrue(len(ps2), 1)
        self.assertNotEqual(ps1[0], ps2[0])
        #
        logg.info("== 'reload' will NOT restart a service that is-active")
        cmd = "{docker} exec {testname} {systemctl} reload zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top3 = top
        #
        logg.info("-- and we check that there is NO new PID for the service process")
        ps3 = find_pids(running(top3), testsleep)
        logg.info("found PIDs %s and %s", ps2, ps3)
        self.assertTrue(len(ps2), 1)
        self.assertTrue(len(ps3), 1)
        self.assertEqual(ps2[0], ps3[0])
        #
        logg.info("== 'reload-or-restart' will restart a service that is-active (if no ExecReload)")
        cmd = "{docker} exec {testname} {systemctl} reload-or-restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top4 = top
        #
        logg.info("-- and we check that there is a new PID for the service process (if no ExecReload)")
        ps4 = find_pids(running(top4), testsleep)
        logg.info("found PIDs %s and %s", ps3, ps4)
        self.assertTrue(len(ps3), 1)
        self.assertTrue(len(ps4), 1)
        self.assertNotEqual(ps3[0], ps4[0])
        #
        logg.info("== 'kill' will bring is-active non-active as well (when the PID is known)")
        cmd = "{docker} exec {testname} {systemctl} kill zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "failed")
        #
        logg.info("== 'stop' will turn 'failed' to 'inactive' (when the PID is known)")
        cmd = "{docker} exec {testname} {systemctl} stop zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'reload-or-try-restart' will not start a not-active service")
        cmd = "{docker} exec {testname} {systemctl} reload-or-try-restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'try-restart' will not start a not-active service")
        cmd = "{docker} exec {testname} {systemctl} try-restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'reload-or-restart' will start a not-active service")
        cmd = "{docker} exec {testname} {systemctl} reload-or-restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top5 = top
        #
        logg.info("== 'reload-or-try-restart' will restart an is-active service (with no ExecReload)")
        cmd = "{docker} exec {testname} {systemctl} try-restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top6 = top
        #
        logg.info("-- and we check that there is a new PID for the service process (if no ExecReload)")
        ps5 = find_pids(running(top5), testsleep)
        ps6 = find_pids(running(top6), testsleep)
        logg.info("found PIDs %s and %s", ps5, ps6)
        self.assertTrue(len(ps5), 1)
        self.assertTrue(len(ps6), 1)
        self.assertNotEqual(ps5[0], ps6[0])
        #
        logg.info("== 'try-restart' will restart an is-active service")
        cmd = "{docker} exec {testname} {systemctl} try-restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top7 = top
        #
        logg.info("-- and we check that there is a new PID for the service process")
        ps7 = find_pids(running(top7), testsleep)
        logg.info("found PIDs %s and %s", ps6, ps7)
        self.assertTrue(len(ps6), 1)
        self.assertTrue(len(ps7), 1)
        self.assertNotEqual(ps6[0], ps7[0])
        #
        logg.info("LOG\n%s", " "+output("{docker} exec {testname} cat {logfile}".format(**locals())).replace("\n", "\n "))
        self.save_coverage(testname)
        #
        cmd = "{docker} rmi {images}:{testname}"
        sx____(cmd.format(**locals()))
        self.rm_docker(testname)
    def test_5134_usermode_notify_service_functions_system(self) -> None:
        """ check that we manage notify services in a root env
            with basic run-service commands: start, stop, restart,
            reload, try-restart, reload-or-restart, kill and
            reload-or-try-restart."""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        self.usermode_notify_service_functions("system", testname, testdir)
        self.rm_testdir()
        self.coverage()
        self.end(122)
    def test_5135_usermode_notify_service_functions_user(self) -> None:
        """ check that we manage notify services in a root env
            with basic run-service commands: start, stop, restart,
            reload, try-restart, reload-or-restart, kill and
            reload-or-try-restart."""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        self.usermode_notify_service_functions("user", testname, testdir)
        self.rm_testdir()
        self.end(122)
    def usermode_notify_service_functions(self, system: str, testname: str, testdir: str) -> None:
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        images = IMAGES
        image = self.local_image(COVERAGE or IMAGE or CENTOS)
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        python_coverage = coverage_package(image)
        if _python.endswith("python3") and "centos:7" in image:
            if SKIP: self.skipTest("no python3 on centos:7")
        docker = _docker
        package = package_tool(image)
        refresh = refresh_tool(image)
        sometime = SOMETIME or 288
        quick = QUICK
        #
        user = self.user()
        root = ""
        systemctl_py = realpath(_systemctl_py)
        systemctl = "/usr/bin/systemctl" # path in container
        systemctl += " --user"
        # systemctl += " --{system}".format(**locals())
        testsleep = testname+"_sleep"
        logfile = os_path(root, "/var/log/"+testsleep+".log")
        bindir = os_path(root, "/usr/bin")
        begin = "{"
        ends = "}"
        shell_file(os_path(testdir, "zzz.init"), """
            #! /bin/bash
            logfile={logfile}
            start() {begin}
                ls -l  $NOTIFY_SOCKET
                {bindir}/{testsleep} 111 0<&- &>/dev/null &
                echo "MAINPID=$!" | socat -v -d - UNIX-CLIENT:$NOTIFY_SOCKET
                echo "READY=1" | socat -v -d - UNIX-CLIENT:$NOTIFY_SOCKET
                wait %1
                # ps -o pid,ppid,user,args
            {ends}
            stop() {begin}
                killall {testsleep}
            {ends}
            case "$1" in start)
               date "+START.%T" >> $logfile
               start >> $logfile 2>&1
               date "+start.%T" >> $logfile
            ;; stop)
               date "+STOP.%T" >> $logfile
               stop >> $logfile 2>&1
               date "+stop.%T" >> $logfile
            ;; restart)
               date "+RESTART.%T" >> $logfile
               stop >> $logfile 2>&1
               start >> $logfile 2>&1
               date "+.%T" >> $logfile
            ;; reload)
               date "+RELOAD.%T" >> $logfile
               echo "...." >> $logfile 2>&1
               date "+reload.%T" >> $logfile
            ;; esac
            echo "done$1" >&2
            exit 0
            """.format(**locals()))
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            [Service]
            User=somebody
            Type=notify
            # PIDFile={root}/var/run/zzz.init.pid
            ExecStart={root}/usr/bin/zzz.init start
            ExecStop={root}/usr/bin/zzz.init stop
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))

        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} rmi {images}:{testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/ps || {package} install -y procps'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/killall || {package} install -y psmisc'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/socat || {package} install -y socat'"
        if sx____(cmd.format(**locals())): self.skipTest("unable to install socat in a container from "+image)
        if COVERAGE:
            cmd = "{docker} exec {testname} {package} install -y {python_coverage}"
            sx____(cmd.format(**locals()))
        self.prep_coverage(image, testname)
        cmd = "{docker} exec {testname} mkdir -p /etc/systemd/system /etc/systemd/user"
        sx____(cmd.format(**locals()))
        zzz_service = "/etc/systemd/{system}/zzz.service".format(**locals())
        cmd = "{docker} exec {testname} cp /bin/sleep {bindir}/{testsleep}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zzz.init {testname}:/usr/bin/zzz.init"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zzz.service {testname}:{zzz_service}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} touch {logfile}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} chmod 666 {logfile}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'grep nobody /etc/group || groupadd -g 65533 nobody'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} useradd -u 1001 somebody -g nobody -m"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl --version"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} chown somebody /tmp/.coverage"
        sx____(cmd.format(**locals()))
        #
        cmd = "{docker} commit -c 'CMD [\"/usr/bin/systemctl\"]' -c 'USER somebody' {testname} {images}:{testname}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} rm -f {testname}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} run -d --name {testname} {images}:{testname}"
        sh____(cmd.format(**locals()))
        #
        cmd = "{docker} exec {testname} {systemctl} enable zzz.service -vv"
        sh____(cmd.format(**locals()))
        #
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'start' shall start a service that is NOT is-active ")
        sh____("{docker} exec {testname} ls -l /var/run".format(**locals()))
        cmd = "{docker} exec {testname} {systemctl} start zzz.service -vv -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        #
        logg.info("== 'stop' shall stop a service that is-active")
        cmd = "{docker} exec {testname} {systemctl} stop zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'restart' shall start a service that NOT is-active")
        cmd = "{docker} exec {testname} {systemctl} restart zzz.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = "{docker} exec {testname} cat {logfile}"
        sh____(cmd.format(**locals()))
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(running(greps(top, testsleep)))
        self.assertEqual(end, 0)
        #
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top1= top
        #
        logg.info("== 'restart' shall restart a service that is-active")
        cmd = "{docker} exec {testname} {systemctl} restart zzz.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = "{docker} exec {testname} cat {logfile}"
        sh____(cmd.format(**locals()))
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(running(greps(top, testsleep)))
        self.assertEqual(end, 0)
        #
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top2 = top
        #
        logg.info("-- and we check that there is a new PID for the service process")
        def find_pids(ps_output: Union[str, List[str]], command: str) -> List[str]:
            pids = []
            for line in _lines(ps_output):
                if command not in line: continue
                m = re.match(r"\s*[\d:]*\s+(\S+)\s+(\S+)\s+(.*)", line)
                if not m: continue
                pid, ppid, args = m.groups()
                # logg.info("  %s | %s | %s", pid, ppid, args)
                pids.append(pid)
            return pids
        ps1 = find_pids(running(top1), testsleep)
        ps2 = find_pids(running(top2), testsleep)
        logg.info("found PIDs %s and %s", ps1, ps2)
        self.assertTrue(len(ps1), 1)
        self.assertTrue(len(ps2), 1)
        self.assertNotEqual(ps1[0], ps2[0])
        #
        logg.info("== 'reload' will NOT restart a service that is-active")
        cmd = "{docker} exec {testname} {systemctl} reload zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top3 = top
        #
        logg.info("-- and we check that there is NO new PID for the service process")
        ps3 = find_pids(running(top3), testsleep)
        logg.info("found PIDs %s and %s", ps2, ps3)
        self.assertTrue(len(ps2), 1)
        self.assertTrue(len(ps3), 1)
        self.assertEqual(ps2[0], ps3[0])
        #
        logg.info("== 'reload-or-restart' will restart a service that is-active (if no ExecReload)")
        cmd = "{docker} exec {testname} {systemctl} reload-or-restart zzz.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top4 = top
        #
        logg.info("-- and we check that there is a new PID for the service process (if no ExecReload)")
        ps4 = find_pids(running(top4), testsleep)
        logg.info("found PIDs %s and %s", ps3, ps4)
        self.assertTrue(len(ps3), 1)
        self.assertTrue(len(ps4), 1)
        self.assertNotEqual(ps3[0], ps4[0])
        #
        logg.info("== 'kill' will bring is-active non-active as well (when the PID is known)")
        cmd = "{docker} exec {testname} {systemctl} kill zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'stop' will turn 'failed' to 'inactive' (when the PID is known)")
        cmd = "{docker} exec {testname} {systemctl} stop zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'reload-or-try-restart' will not start a not-active service")
        cmd = "{docker} exec {testname} {systemctl} reload-or-try-restart zzz.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'try-restart' will not start a not-active service")
        cmd = "{docker} exec {testname} {systemctl} try-restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'reload-or-restart' will start a not-active service")
        cmd = "{docker} exec {testname} {systemctl} reload-or-restart zzz.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top5 = top
        #
        logg.info("== 'reload-or-try-restart' will restart an is-active service (with no ExecReload)")
        cmd = "{docker} exec {testname} {systemctl} try-restart zzz.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top6 = top
        #
        logg.info("-- and we check that there is a new PID for the service process (if no ExecReload)")
        ps5 = find_pids(running(top5), testsleep)
        ps6 = find_pids(running(top6), testsleep)
        logg.info("found PIDs %s and %s", ps5, ps6)
        self.assertTrue(len(ps5), 1)
        self.assertTrue(len(ps6), 1)
        self.assertNotEqual(ps5[0], ps6[0])
        #
        logg.info("== 'try-restart' will restart an is-active service")
        cmd = "{docker} exec {testname} {systemctl} try-restart zzz.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top7 = top
        #
        logg.info("-- and we check that there is a new PID for the service process")
        ps7 = find_pids(running(top7), testsleep)
        logg.info("found PIDs %s and %s", ps6, ps7)
        self.assertTrue(len(ps6), 1)
        self.assertTrue(len(ps7), 1)
        self.assertNotEqual(ps6[0], ps7[0])
        #
        logg.info("LOG\n%s", " "+output("{docker} exec {testname} cat {logfile}".format(**locals())).replace("\n", "\n "))
        #
        self.save_coverage(testname)
        #
        cmd = "{docker} rmi {images}:{testname}"
        sx____(cmd.format(**locals()))
        self.rm_docker(testname)
    def test_5136_usermode_notify_service_functions_with_reload(self) -> None:
        """ check that we manage notify services in a root env
            with basic run-service commands: start, stop, restart,
            reload, try-restart, reload-or-restart, kill and
            reload-or-try-restart. (with ExecReload)"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        self.usermode_notify_service_functions_with_reload("system", testname, testdir)
        self.rm_testdir()
        self.coverage()
        logg.error("too long")  # TODO
        self.end(200)
    def test_5137_usermode_notify_service_functions_with_reload_user(self) -> None:
        """ check that we manage notify services in a root env
            with basic run-service commands: start, stop, restart,
            reload, try-restart, reload-or-restart, kill and
            reload-or-try-restart. (with ExecReload)"""
        # test_5037 is triggering len(socketfile) > 100 | "new notify socketfile"
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        self.usermode_notify_service_functions_with_reload("user", testname, testdir)
        self.rm_testdir()
        self.coverage()
        logg.error("too long")  # TODO
        self.end(266)
    def usermode_notify_service_functions_with_reload(self, system: str, testname: str, testdir: str) -> None:
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        images = IMAGES
        image = self.local_image(COVERAGE or IMAGE or CENTOS)
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        python_coverage = coverage_package(image)
        if _python.endswith("python3") and "centos:7" in image:
            if SKIP: self.skipTest("no python3 on centos:7")
        docker = _docker
        package = package_tool(image)
        refresh = refresh_tool(image)
        sometime = SOMETIME or 288
        quick = QUICK
        #
        user = self.user()
        root = ""
        systemctl_py = realpath(_systemctl_py)
        systemctl = "/usr/bin/systemctl" # path in container
        systemctl += " --user"
        # systemctl += " --{system}".format(**locals())
        testsleep = self.testname("sleep")
        logfile = os_path(root, "/var/log/"+testsleep+".log")
        bindir = os_path(root, "/usr/bin")
        begin = "{"
        ends = "}"
        shell_file(os_path(testdir, "zzz.init"), """
            #! /bin/bash
            logfile={logfile}
            start() {begin}
                ls -l  $NOTIFY_SOCKET
                {bindir}/{testsleep} 111 0<&- &>/dev/null &
                echo "MAINPID=$!" | socat -v -d - UNIX-CLIENT:$NOTIFY_SOCKET
                echo "READY=1" | socat -v -d - UNIX-CLIENT:$NOTIFY_SOCKET
                wait %1
                # ps -o pid,ppid,user,args
            {ends}
            stop() {begin}
                killall {testsleep}
            {ends}
            case "$1" in start)
               date "+START.%T" >> $logfile
               start >> $logfile 2>&1
               date "+start.%T" >> $logfile
            ;; stop)
               date "+STOP.%T" >> $logfile
               stop >> $logfile 2>&1
               date "+stop.%T" >> $logfile
            ;; restart)
               date "+RESTART.%T" >> $logfile
               stop >> $logfile 2>&1
               start >> $logfile 2>&1
               date "+.%T" >> $logfile
            ;; reload)
               date "+RELOAD.%T" >> $logfile
               echo "...." >> $logfile 2>&1
               date "+reload.%T" >> $logfile
            ;; esac
            echo "done$1" >&2
            exit 0
            """.format(**locals()))
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            [Service]
            User=somebody
            Type=notify
            # PIDFile={root}/var/run/zzz.init.pid
            ExecStart={root}/usr/bin/zzz.init start
            ExecReload={root}/usr/bin/zzz.init reload
            ExecStop={root}/usr/bin/zzz.init stop
            TimeoutRestartSec=4
            TimeoutReloadSec=4
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))

        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} rmi {images}:{testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/ps || {package} install -y procps'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/killall || {package} install -y psmisc'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/socat || {package} install -y socat'"
        if sx____(cmd.format(**locals())): self.skipTest("unable to install socat in a container from "+image)
        if COVERAGE:
            cmd = "{docker} exec {testname} {package} install -y {python_coverage}"
            sx____(cmd.format(**locals()))
        self.prep_coverage(image, testname)
        cmd = "{docker} exec {testname} mkdir -p /etc/systemd/system /etc/systemd/user"
        sx____(cmd.format(**locals()))
        zzz_service = "/etc/systemd/{system}/zzz.service".format(**locals())
        cmd = "{docker} exec {testname} cp /bin/sleep {bindir}/{testsleep}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zzz.init {testname}:/usr/bin/zzz.init"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zzz.service {testname}:{zzz_service}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} touch {logfile}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} chmod 666 {logfile}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'grep nobody /etc/group || groupadd -g 65533 nobody'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} useradd -u 1001 somebody -g nobody -m"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl --version"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} chown somebody /tmp/.coverage"
        sx____(cmd.format(**locals()))
        #
        cmd = "{docker} commit -c 'CMD [\"/usr/bin/systemctl\"]' -c 'USER somebody' {testname} {images}:{testname}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} rm -f {testname}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} run -d --name {testname} {images}:{testname}"
        sh____(cmd.format(**locals()))
        #
        cmd = "{docker} exec {testname} {systemctl} enable zzz.service -vv"
        sh____(cmd.format(**locals()))
        #
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'start' shall start a service that is NOT is-active ")
        cmd = "{docker} exec {testname} {systemctl} start zzz.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        #
        logg.info("== 'stop' shall stop a service that is-active")
        cmd = "{docker} exec {testname} {systemctl} stop zzz.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'restart' shall start a service that NOT is-active")
        cmd = "{docker} exec {testname} {systemctl} restart zzz.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top1= top
        #
        logg.info("== 'restart' shall restart a service that is-active")
        cmd = "{docker} exec {testname} {systemctl} restart zzz.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top2 = top
        #
        logg.info("-- and we check that there is a new PID for the service process")
        def find_pids(ps_output: Union[str, List[str]], command: str) -> List[str]:
            pids = []
            for line in _lines(ps_output):
                if command not in line: continue
                m = re.match(r"\s*[\d:]*\s+(\S+)\s+(\S+)\s+(.*)", line)
                if not m: continue
                pid, ppid, args = m.groups()
                # logg.info("  %s | %s | %s", pid, ppid, args)
                pids.append(pid)
            return pids
        ps1 = find_pids(running(top1), testsleep)
        ps2 = find_pids(running(top2), testsleep)
        logg.info("found PIDs %s and %s", ps1, ps2)
        self.assertTrue(len(ps1), 1)
        self.assertTrue(len(ps2), 1)
        self.assertNotEqual(ps1[0], ps2[0])
        #
        logg.info("== 'reload' will NOT restart a service that is-active")
        cmd = "{docker} exec {testname} {systemctl} reload zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top3 = top
        #
        logg.info("-- and we check that there is NO new PID for the service process")
        ps3 = find_pids(running(top3), testsleep)
        logg.info("found PIDs %s and %s", ps2, ps3)
        self.assertTrue(len(ps2), 1)
        self.assertTrue(len(ps3), 1)
        self.assertEqual(ps2[0], ps3[0])
        #
        logg.info("== 'reload-or-restart' will restart a service that is-active (if no ExecReload)")
        cmd = "{docker} exec {testname} {systemctl} reload-or-restart zzz.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top4 = top
        #
        logg.info("-- and we check that there is the same PID for the service process (if ExecReload)")
        ps4 = find_pids(running(top4), testsleep)
        logg.info("found PIDs %s and %s", ps3, ps4)
        self.assertTrue(len(ps3), 1)
        self.assertTrue(len(ps4), 1)
        self.assertEqual(ps3[0], ps4[0])
        #
        logg.info("== 'kill' will bring is-active non-active as well (when the PID is known)")
        cmd = "{docker} exec {testname} {systemctl} kill zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'stop' will turn 'failed' to 'inactive' (when the PID is known)")  # TODO#
        cmd = "{docker} exec {testname} {systemctl} stop zzz.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'reload-or-try-restart' will not start a not-active service")
        cmd = "{docker} exec {testname} {systemctl} reload-or-try-restart zzz.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'try-restart' will not start a not-active service")
        cmd = "{docker} exec {testname} {systemctl} try-restart zzz.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'reload-or-restart' will start a not-active service")
        cmd = "{docker} exec {testname} {systemctl} reload-or-restart zzz.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top5 = top
        #
        logg.info("== 'reload-or-try-restart' will restart an is-active service (with no ExecReload)")
        cmd = "{docker} exec {testname} {systemctl} try-restart zzz.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top6 = top
        #
        logg.info("-- and we check that there is a new PID for the service process (if no ExecReload)")
        ps5 = find_pids(running(top5), testsleep)
        ps6 = find_pids(running(top6), testsleep)
        logg.info("found PIDs %s and %s", ps5, ps6)
        self.assertTrue(len(ps5), 1)
        self.assertTrue(len(ps6), 1)
        self.assertNotEqual(ps5[0], ps6[0])
        #
        logg.info("== 'try-restart' will restart an is-active service")
        cmd = "{docker} exec {testname} {systemctl} try-restart zzz.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0)
        top = _recent(output("{docker} exec {testname} ps -eo etime,pid,ppid,user,args".format(**locals())))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(running(greps(top, testsleep)))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 0)
        self.assertEqual(out.strip(), "active")
        top7 = top
        #
        logg.info("-- and we check that there is a new PID for the service process")
        ps7 = find_pids(running(top7), testsleep)
        logg.info("found PIDs %s and %s", ps6, ps7)
        self.assertTrue(len(ps6), 1)
        self.assertTrue(len(ps7), 1)
        self.assertNotEqual(ps6[0], ps7[0])
        #
        logg.info("LOG\n%s", " "+output("{docker} exec {testname} cat {logfile}".format(**locals())).replace("\n", "\n "))
        #
        self.save_coverage(testname)
        #
        cmd = "{docker} rmi {images}:{testname}"
        sx____(cmd.format(**locals()))
        self.rm_docker(testname)
    def test_5140_usermode_oneshot_service_functions(self) -> None:
        """ check that we manage oneshot services in a root env
            with basic run-service commands: start, stop, restart,
            reload, try-restart, reload-or-restart, kill and
            reload-or-try-restart."""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        self.usermode_oneshot_service_functions("system", testname, testdir)
        self.rm_testdir()
        self.end()
    def test_5141_usermode_oneshot_service_functions_user(self) -> None:
        """ check that we manage oneshot services in a root env
            with basic run-service commands: start, stop, restart,
            reload, try-restart, reload-or-restart, kill and
            reload-or-try-restart."""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        self.usermode_oneshot_service_functions("user", testname, testdir)
        self.rm_testdir()
        self.end()
    def usermode_oneshot_service_functions(self, system: str, testname: str, testdir: str) -> None:
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        images = IMAGES
        image = self.local_image(COVERAGE or IMAGE or CENTOS)
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        python_coverage = coverage_package(image)
        if _python.endswith("python3") and "centos:7" in image:
            if SKIP: self.skipTest("no python3 on centos:7")
        docker = _docker
        package = package_tool(image)
        refresh = refresh_tool(image)
        sometime = SOMETIME or 188
        quick = QUICK
        #
        user = self.user()
        root = ""
        systemctl_py = realpath(_systemctl_py)
        systemctl = "/usr/bin/systemctl" # path in container
        systemctl += " --user"
        # systemctl += " --{system}".format(**locals())
        testsleep = self.testname("sleep")
        logfile = os_path(root, "/var/log/"+testsleep+".log")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            [Service]
            User=somebody
            Type=oneshot
            ExecStartPre={bindir}/backup {root}/var/tmp/test.1 {root}/var/tmp/test.2
            ExecStart=/usr/bin/touch {root}/var/tmp/test.1
            ExecStop=/bin/rm {root}/var/tmp/test.1
            ExecStopPost=/bin/rm -f {root}/var/tmp/test.2
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        shell_file(os_path(testdir, "backup"), """
           #! /bin/sh
           set -x
           test ! -f "$1" || mv -v "$1" "$2"
        """)

        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} rmi {images}:{testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/ps || {package} install -y procps'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/killall || {package} install -y psmisc'"
        sx____(cmd.format(**locals()))
        if COVERAGE:
            cmd = "{docker} exec {testname} {package} install -y {python_coverage}"
            sx____(cmd.format(**locals()))
        self.prep_coverage(image, testname)
        cmd = "{docker} exec {testname} mkdir -p /etc/systemd/system /etc/systemd/user"
        sx____(cmd.format(**locals()))
        zzz_service = "/etc/systemd/{system}/zzz.service".format(**locals())
        cmd = "{docker} exec {testname} cp /bin/sleep {bindir}/{testsleep}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zzz.service {testname}:{zzz_service}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} touch {logfile}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} chmod 666 {logfile}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'grep nobody /etc/group || groupadd -g 65533 nobody'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} useradd -u 1001 somebody -g nobody -m"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/backup {testname}:/usr/bin/backup"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} touch /var/tmp/test.0"
        sh____(cmd.format(**locals()))
        testfiles = output("{docker} exec {testname} find /var/tmp -name test.*".format(**locals()))
        logg.info("found testfiles:\n%s", testfiles)
        self.assertFalse(greps(testfiles, "/var/tmp/test.1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test.2"))
        #
        cmd = "{docker} exec {testname} systemctl --version"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} chown somebody /tmp/.coverage"
        sx____(cmd.format(**locals()))
        #
        cmd = "{docker} commit -c 'CMD [\"/usr/bin/systemctl\"]' -c 'USER somebody' {testname} {images}:{testname}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} rm -f {testname}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} run -d --name {testname} {images}:{testname}"
        sh____(cmd.format(**locals()))
        #
        cmd = "{docker} exec {testname} {systemctl} enable zzz.service -vv"
        sh____(cmd.format(**locals()))
        #
        is_active = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "inactive")
        self.assertEqual(end, 3)
        #
        logg.info("== 'start' shall start a service that is NOT is-active ")
        cmd = "{docker} exec {testname} {systemctl} start zzz.service -vvvv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "active")
        self.assertEqual(end, 0)
        testfiles = output("{docker} exec {testname} find /var/tmp -name test.*".format(**locals()))
        logg.info("found testfiles:\n%s", testfiles)
        self.assertTrue(greps(testfiles, "/var/tmp/test.1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test.2"))
        #
        logg.info("== 'stop' shall stop a service that is-active")
        cmd = "{docker} exec {testname} {systemctl} stop zzz.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "inactive")
        self.assertEqual(end, 3)
        testfiles = output("{docker} exec {testname} find /var/tmp -name test.*".format(**locals()))
        logg.info("found testfiles:\n%s", testfiles)
        self.assertFalse(greps(testfiles, "/var/tmp/test.1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test.2"))
        #
        logg.info("== 'restart' shall start a service that NOT is-active")
        cmd = "{docker} exec {testname} {systemctl} restart zzz.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "active")
        self.assertEqual(end, 0)
        testfiles = output("{docker} exec {testname} find /var/tmp -name test.*".format(**locals()))
        logg.info("found testfiles:\n%s", testfiles)
        self.assertTrue(greps(testfiles, "/var/tmp/test.1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test.2"))
        #
        logg.info("== 'restart' shall restart a service that is-active")
        cmd = "{docker} exec {testname} {systemctl} restart zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "active")
        self.assertEqual(end, 0)
        testfiles = output("{docker} exec {testname} find /var/tmp -name test.*".format(**locals()))
        logg.info("found testfiles:\n%s", testfiles)
        self.assertTrue(greps(testfiles, "/var/tmp/test.1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test.2"))
        #
        logg.info("== 'reload' will NOT restart a service that is-active")
        cmd = "{docker} exec {testname} {systemctl} reload zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "active")
        self.assertEqual(end, 0)
        testfiles = output("{docker} exec {testname} find /var/tmp -name test.*".format(**locals()))
        logg.info("found testfiles:\n%s", testfiles)
        self.assertTrue(greps(testfiles, "/var/tmp/test.1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test.2"))
        #
        logg.info("== 'reload-or-restart' will restart a service that is-active")
        cmd = "{docker} exec {testname} {systemctl} reload-or-restart zzz.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "active")
        self.assertEqual(end, 0)
        #
        logg.info("== 'stop' will brings it back to 'inactive'")
        cmd = "{docker} exec {testname} {systemctl} stop zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "inactive")
        self.assertEqual(end, 3)
        testfiles = output("{docker} exec {testname} find /var/tmp -name test.*".format(**locals()))
        logg.info("found testfiles:\n%s", testfiles)
        self.assertFalse(greps(testfiles, "/var/tmp/test.1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test.2"))
        #
        logg.info("== 'reload-or-try-restart' will not start a not-active service")
        cmd = "{docker} exec {testname} {systemctl} reload-or-try-restart zzz.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "inactive")
        self.assertEqual(end, 3)
        testfiles = output("{docker} exec {testname} find /var/tmp -name test.*".format(**locals()))
        logg.info("found testfiles:\n%s", testfiles)
        self.assertFalse(greps(testfiles, "/var/tmp/test.1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test.2"))
        #
        logg.info("== 'try-restart' will not start a not-active service")
        cmd = "{docker} exec {testname} {systemctl} try-restart zzz.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "inactive")
        self.assertEqual(end, 3)
        testfiles = output("{docker} exec {testname} find /var/tmp -name test.*".format(**locals()))
        logg.info("found testfiles:\n%s", testfiles)
        self.assertFalse(greps(testfiles, "/var/tmp/test.1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test.2"))
        #
        logg.info("== 'reload-or-restart' will start a not-active service")
        cmd = "{docker} exec {testname} {systemctl} reload-or-restart zzz.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "active")
        self.assertEqual(end, 0)
        testfiles = output("{docker} exec {testname} find /var/tmp -name test.*".format(**locals()))
        logg.info("found testfiles:\n%s", testfiles)
        self.assertTrue(greps(testfiles, "/var/tmp/test.1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test.2"))
        #
        logg.info("== 'reload-or-try-restart' will restart an is-active service")
        cmd = "{docker} exec {testname} {systemctl} reload-or-try-restart zzz.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "active")
        self.assertEqual(end, 0)
        testfiles = output("{docker} exec {testname} find /var/tmp -name test.*".format(**locals()))
        logg.info("found testfiles:\n%s", testfiles)
        self.assertTrue(greps(testfiles, "/var/tmp/test.1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test.2"))
        #
        logg.info("== 'try-restart' will restart an is-active service")
        cmd = "{docker} exec {testname} {systemctl} try-restart zzz.service -vv -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "active")
        self.assertEqual(end, 0)
        testfiles = output("{docker} exec {testname} find /var/tmp -name test.*".format(**locals()))
        logg.info("found testfiles:\n%s", testfiles)
        self.assertTrue(greps(testfiles, "/var/tmp/test.1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test.2"))
        #
        logg.info("== 'stop' will brings it back to 'inactive'")
        cmd = "{docker} exec {testname} {systemctl} stop zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "inactive")
        self.assertEqual(end, 3)
        testfiles = output("{docker} exec {testname} find /var/tmp -name test.*".format(**locals()))
        logg.info("found testfiles:\n%s", testfiles)
        self.assertFalse(greps(testfiles, "/var/tmp/test.1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test.2"))
        #
        logg.info("LOG\n%s", " "+output("{docker} exec {testname} cat {logfile}".format(**locals())).replace("\n", "\n "))
        #
        self.save_coverage(testname)
        #
        cmd = "{docker} rmi {images}:{testname}"
        sx____(cmd.format(**locals()))
        self.rm_docker(testname)
    def test_5142_usermode_oneshot_and_unknown_service_functions(self) -> None:
        """ check that we manage multiple services even when some
            services are not actually known. Along with oneshot serivce
            with basic run-service commands: start, stop, restart,
            reload, try-restart, reload-or-restart, kill and
            reload-or-try-restart / we have only different exit-code."""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        images = IMAGES
        image = self.local_image(COVERAGE or IMAGE or CENTOS)
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        python_coverage = coverage_package(image)
        if _python.endswith("python3") and "centos:7" in image:
            if SKIP: self.skipTest("no python3 on centos:7")
        docker = _docker
        package = package_tool(image)
        refresh = refresh_tool(image)
        sometime = SOMETIME or 188
        quick = QUICK
        #
        user = self.user()
        root = ""
        systemctl_py = realpath(_systemctl_py)
        systemctl = "/usr/bin/systemctl" # path in container
        systemctl += " --user"
        testsleep = self.testname("sleep")
        logfile = os_path(root, "/var/log/"+testsleep+".log")
        bindir = os_path(root, "/usr/bin")
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            [Service]
            User=somebody
            Type=oneshot
            ExecStartPre={bindir}/backup {root}/var/tmp/test.1 {root}/var/tmp/test.2
            ExecStart=/usr/bin/touch {root}/var/tmp/test.1
            ExecStop=/bin/rm {root}/var/tmp/test.1
            ExecStopPost=/bin/rm -f {root}/var/tmp/test.2
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        shell_file(os_path(testdir, "backup"), """
           #! /bin/sh
           set -x
           test ! -f "$1" || mv -v "$1" "$2"
        """)

        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} rmi {images}:{testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/ps || {package} install -y procps'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/killall || {package} install -y psmisc'"
        sx____(cmd.format(**locals()))
        if COVERAGE:
            cmd = "{docker} exec {testname} {package} install -y {python_coverage}"
            sx____(cmd.format(**locals()))
        self.prep_coverage(image, testname)
        cmd = "{docker} exec {testname} mkdir -p /etc/systemd/system /etc/systemd/user"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} cp /bin/sleep {bindir}/{testsleep}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zzz.service {testname}:/etc/systemd/system/zzz.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/backup {testname}:/usr/bin/backup"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} touch /var/tmp/test.0"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} touch {logfile}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} chmod 666 {logfile}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'grep nobody /etc/group || groupadd -g 65533 nobody'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} useradd -u 1001 somebody -g nobody -m"
        sh____(cmd.format(**locals()))
        testfiles = output("{docker} exec {testname} find /var/tmp -name test.*".format(**locals()))
        logg.info("found testfiles:\n%s", testfiles)
        self.assertFalse(greps(testfiles, "/var/tmp/test.1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test.2"))
        #
        cmd = "{docker} exec {testname} systemctl --version"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} chown somebody /tmp/.coverage"
        sx____(cmd.format(**locals()))
        #
        cmd = "{docker} commit -c 'CMD [\"/usr/bin/systemctl\"]' -c 'USER somebody' {testname} {images}:{testname}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} rm -f {testname}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} run -d --name {testname} {images}:{testname}"
        sh____(cmd.format(**locals()))
        #
        cmd = "{docker} exec {testname} {systemctl} enable zzz.service -vv"
        sh____(cmd.format(**locals()))
        is_active = "{docker} exec {testname} {systemctl} is-active zzz.service other.service -vv"
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "inactive\ninactive")
        self.assertEqual(end, 3)
        #
        logg.info("== 'start' shall start a service that is NOT is-active ")
        cmd = "{docker} exec {testname} {systemctl} start zzz.service other.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertNotEqual(end, 0)
        is_active = "{docker} exec {testname} {systemctl} is-active zzz.service other.service -vv"
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "active\ninactive")
        self.assertEqual(end, 3)
        testfiles = output("{docker} exec {testname} find /var/tmp -name test.*".format(**locals()))
        logg.info("found testfiles:\n%s", testfiles)
        self.assertTrue(greps(testfiles, "/var/tmp/test.1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test.2"))
        #
        logg.info("== 'stop' shall stop a service that is-active")
        cmd = "{docker} exec {testname} {systemctl} stop zzz.service other.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertNotEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "inactive\ninactive")
        self.assertEqual(end, 3)
        testfiles = output("{docker} exec {testname} find /var/tmp -name test.*".format(**locals()))
        logg.info("found testfiles:\n%s", testfiles)
        self.assertFalse(greps(testfiles, "/var/tmp/test.1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test.2"))
        #
        logg.info("== 'restart' shall start a service that NOT is-active")
        cmd = "{docker} exec {testname} {systemctl} restart zzz.service other.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertNotEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "active\ninactive")
        self.assertEqual(end, 3)
        testfiles = output("{docker} exec {testname} find /var/tmp -name test.*".format(**locals()))
        logg.info("found testfiles:\n%s", testfiles)
        self.assertTrue(greps(testfiles, "/var/tmp/test.1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test.2"))
        #
        logg.info("== 'restart' shall restart a service that is-active")
        cmd = "{docker} exec {testname} {systemctl} restart zzz.service other.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertNotEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "active\ninactive")
        self.assertEqual(end, 3)
        testfiles = output("{docker} exec {testname} find /var/tmp -name test.*".format(**locals()))
        logg.info("found testfiles:\n%s", testfiles)
        self.assertTrue(greps(testfiles, "/var/tmp/test.1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test.2"))
        #
        logg.info("== 'reload' will NOT restart a service that is-active")
        cmd = "{docker} exec {testname} {systemctl} reload zzz.service other.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertNotEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "active\ninactive")
        self.assertEqual(end, 3)
        testfiles = output("{docker} exec {testname} find /var/tmp -name test.*".format(**locals()))
        logg.info("found testfiles:\n%s", testfiles)
        self.assertTrue(greps(testfiles, "/var/tmp/test.1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test.2"))
        #
        logg.info("== 'reload-or-restart' will restart a service that is-active")
        cmd = "{docker} exec {testname} {systemctl} reload-or-restart zzz.service other.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertNotEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "active\ninactive")
        self.assertEqual(end, 3)
        #
        logg.info("== 'stop' will brings it back to 'inactive'")
        cmd = "{docker} exec {testname} {systemctl} stop zzz.service other.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertNotEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "inactive\ninactive")
        self.assertEqual(end, 3)
        testfiles = output("{docker} exec {testname} find /var/tmp -name test.*".format(**locals()))
        logg.info("found testfiles:\n%s", testfiles)
        self.assertFalse(greps(testfiles, "/var/tmp/test.1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test.2"))
        #
        logg.info("== 'reload-or-try-restart' will not start a not-active service")
        cmd = "{docker} exec {testname} {systemctl} reload-or-try-restart zzz.service other.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertNotEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "inactive\ninactive")
        self.assertEqual(end, 3)
        testfiles = output("{docker} exec {testname} find /var/tmp -name test.*".format(**locals()))
        logg.info("found testfiles:\n%s", testfiles)
        self.assertFalse(greps(testfiles, "/var/tmp/test.1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test.2"))
        #
        logg.info("== 'try-restart' will not start a not-active service")
        cmd = "{docker} exec {testname} {systemctl} try-restart zzz.service other.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertNotEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "inactive\ninactive")
        self.assertEqual(end, 3)
        testfiles = output("{docker} exec {testname} find /var/tmp -name test.*".format(**locals()))
        logg.info("found testfiles:\n%s", testfiles)
        self.assertFalse(greps(testfiles, "/var/tmp/test.1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test.2"))
        #
        logg.info("== 'reload-or-restart' will start a not-active service")
        cmd = "{docker} exec {testname} {systemctl} reload-or-restart zzz.service other.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertNotEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "active\ninactive")
        self.assertEqual(end, 3)
        testfiles = output("{docker} exec {testname} find /var/tmp -name test.*".format(**locals()))
        logg.info("found testfiles:\n%s", testfiles)
        self.assertTrue(greps(testfiles, "/var/tmp/test.1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test.2"))
        #
        logg.info("== 'reload-or-try-restart' will restart an is-active service")
        cmd = "{docker} exec {testname} {systemctl} reload-or-try-restart zzz.service other.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertNotEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "active\ninactive")
        self.assertEqual(end, 3)
        testfiles = output("{docker} exec {testname} find /var/tmp -name test.*".format(**locals()))
        logg.info("found testfiles:\n%s", testfiles)
        self.assertTrue(greps(testfiles, "/var/tmp/test.1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test.2"))
        #
        logg.info("== 'try-restart' will restart an is-active service")
        cmd = "{docker} exec {testname} {systemctl} try-restart zzz.service other.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertNotEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "active\ninactive")
        self.assertEqual(end, 3)
        testfiles = output("{docker} exec {testname} find /var/tmp -name test.*".format(**locals()))
        logg.info("found testfiles:\n%s", testfiles)
        self.assertTrue(greps(testfiles, "/var/tmp/test.1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test.2"))
        #
        logg.info("== 'stop' will brings it back to 'inactive'")
        cmd = "{docker} exec {testname} {systemctl} stop zzz.service other.service -vv {quick}"
        out, end = output2(cmd.format(**locals()))
        logg.info("%s =>\n%s", cmd, out)
        self.assertNotEqual(end, 0)
        act, end = output2(is_active.format(**locals()))
        self.assertEqual(act.strip(), "inactive\ninactive")
        self.assertEqual(end, 3)
        testfiles = output("{docker} exec {testname} find /var/tmp -name test.*".format(**locals()))
        logg.info("found testfiles:\n%s", testfiles)
        self.assertFalse(greps(testfiles, "/var/tmp/test.1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test.2"))
        #
        logg.info("LOG\n%s", " "+output("{docker} exec {testname} cat {logfile}".format(**locals())).replace("\n", "\n "))
        #
        self.save_coverage(testname)
        #
        cmd = "{docker} rmi {images}:{testname}"
        sx____(cmd.format(**locals()))
        self.rm_docker(testname)
        self.rm_testdir()
        self.end()
    def test_5144_usermode_sysv_service_functions(self) -> None:
        """ check that we are disallowed to manage SysV services in a root env
            with basic run-service commands: start, stop, restart,
            reload, try-restart, reload-or-restart, kill and
            reload-or-try-restart."""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        images = IMAGES
        image = self.local_image(COVERAGE or IMAGE or CENTOS)
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        python_coverage = coverage_package(image)
        if _python.endswith("python3") and "centos:7" in image:
            if SKIP: self.skipTest("no python3 on centos:7")
        docker = _docker
        package = package_tool(image)
        refresh = refresh_tool(image)
        sometime = SOMETIME or 188
        quick = QUICK
        #
        user = self.user()
        root = ""
        systemctl_py = realpath(_systemctl_py)
        systemctl = "/usr/bin/systemctl" # path in container
        systemctl += " --user"
        testsleep = self.testname("sleep")
        logfile = os_path(root, "/var/log/"+testsleep+".log")
        bindir = os_path(root, "/usr/bin")
        begin = "{"
        ends = "}"
        shell_file(os_path(testdir, "zzz.init"), """
            #! /bin/bash
            ### BEGIN INIT INFO
            # Required-Start: $local_fs $remote_fs $syslog $network
            # Required-Stop:  $local_fs $remote_fs $syslog $network
            # Default-Start:  3 5
            # Default-Stop:   0 1 2 6
            # Short-Description: Testing Z
            # Description:    Allows for SysV testing
            ### END INIT INFO
            logfile={logfile}
            sleeptime=111
            start() {begin}
               [ -d /var/run ] || mkdir -p /var/run
               (runuser -u somebody {bindir}/{testsleep} $sleeptime 0<&- &>/dev/null &
                echo $! > {root}/var/run/zzz.init.pid
               ) &
               wait %1
               # ps -o pid,ppid,user,args
               cat "RUNNING `cat {root}/var/run/zzz.init.pid`"
            {ends}
            stop() {begin}
               kill `cat {root}/var/run/zzz.init.pid` >>$logfile 2>&1
               killall {testsleep} >>$logfile 2>&1
            {ends}
            case "$1" in start)
               date "+START.%T" >> $logfile
               start >> $logfile 2>&1
               date "+start.%T" >> $logfile
            ;; stop)
               date "+STOP.%T" >> $logfile
               stop >> $logfile 2>&1
               date "+stop.%T" >> $logfile
            ;; restart)
               date "+RESTART.%T" >> $logfile
               stop >> $logfile 2>&1
               start >> $logfile 2>&1
               date "+.%T" >> $logfile
            ;; reload)
               date "+RELOAD.%T" >> $logfile
               echo "...." >> $logfile 2>&1
               date "+reload.%T" >> $logfile
            ;; esac
            echo "done$1" >&2
            exit 0
            """.format(**locals()))

        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} rmi {images}:{testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/ps || {package} install -y procps'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/killall || {package} install -y psmisc'"
        sx____(cmd.format(**locals()))
        if COVERAGE:
            cmd = "{docker} exec {testname} {package} install -y {python_coverage}"
            sx____(cmd.format(**locals()))
        self.prep_coverage(image, testname)
        cmd = "{docker} exec {testname} cp /bin/sleep {bindir}/{testsleep}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'test -d /etc/init.d || mkdir -v /etc/init.d'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zzz.init {testname}:/etc/init.d/zzz"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} touch {logfile}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} chmod 666 {logfile}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'grep nobody /etc/group || groupadd -g 65533 nobody'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} useradd -u 1001 somebody -g nobody -m"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl --version"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} chown somebody /tmp/.coverage"
        sx____(cmd.format(**locals()))
        #
        cmd = "{docker} commit -c 'CMD [\"/usr/bin/systemctl\"]' -c 'USER somebody' {testname} {images}:{testname}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} rm -f {testname}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} run -d --name {testname} {images}:{testname}"
        sh____(cmd.format(**locals()))
        #
        cmd = "{docker} exec {testname} {systemctl} enable zzz.service -vv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Initscript zzz.service not for --user mode"))
        #
        # .................... deleted stuff start/stop/etc
        #
        self.save_coverage(testname)
        #
        cmd = "{docker} rmi {images}:{testname}"
        sx____(cmd.format(**locals()))
        self.rm_docker(testname)
        self.rm_testdir()
        self.end()
    #
    #
    def test_5230_bad_usermode_simple_service_functions_system(self) -> None:
        """ check that we are disallowed to manage simple services in a root env
            with commands like start, restart, stop, etc"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        self.bad_usermode_simple_service_functions("", testname, testdir)
        self.rm_testdir()
        self.end()
    def test_5231_bad_simple_service_functions_user(self) -> None:
        """ check that we are disallowed to manage simple services in a root env
            with commands like start, restart, stop, etc"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        self.bad_usermode_simple_service_functions("User=foo", testname, testdir)
        self.rm_testdir()
        self.end()
    def bad_usermode_simple_service_functions(self, extra: str, testname: str, testdir: str) -> None:
        """ check that we are disallowed to manage simple services in a root env
            with commands like start, restart, stop, etc"""
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        images = IMAGES
        image = self.local_image(COVERAGE or IMAGE or CENTOS)
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        python_coverage = coverage_package(image)
        if _python.endswith("python3") and "centos:7" in image:
            if SKIP: self.skipTest("no python3 on centos:7")
        docker = _docker
        package = package_tool(image)
        refresh = refresh_tool(image)
        sometime = SOMETIME or 288
        quick = QUICK
        #
        user = self.user()
        root = ""
        systemctl_py = realpath(_systemctl_py)
        systemctl = "/usr/bin/systemctl" # path in container
        systemctl += " --user"
        testsleep = testname+"_testsleep"
        testscript = testname+"_testscript.sh"
        logfile = os_path(root, "/var/log/test.log")
        bindir = os_path(root, "/usr/bin")
        begin = "{"
        ends = "}"
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            [Service]
            {extra}
            Type=simple
            ExecStartPre=/bin/echo %n
            ExecStart={bindir}/{testscript} 111
            ExecStartPost=/bin/echo started $MAINPID
            ExecStop=/bin/kill -3 $MAINPID
            ExecStopPost=/bin/echo stopped $MAINPID
            ExecStopPost=/bin/sleep 2
            ExecReload=/bin/kill -10 $MAINPID
            KillSignal=SIGQUIT
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        shell_file(os_path(testdir, testscript), """
            #! /bin/sh
            date +%T,enter >> {logfile}
            stops () {begin}
              date +%T,stopping >> {logfile}
              killall {testsleep} >> {logfile} 2>&1
              date +%T,stopped >> {logfile}
            {ends}
            reload () {begin}
              date +%T,reloading >> {logfile}
              date +%T,reloaded >> {logfile}
            {ends}
            trap "stops" 3   # SIGQUIT
            trap "reload" 10 # SIGUSR1
            date +%T,starting >> {logfile}
            {bindir}/{testsleep} $1 >> {logfile} 2>&1 &
            pid="$!"
            while kill -0 $pid; do
               # use 'kill -0' to check the existance of the child
               date +%T,waiting >> {logfile}
               # use 'wait' for children AND external signals
               wait
            done
            date +%T,leaving >> {logfile}
            trap - 3 10 # SIGQUIT SIGUSR1
            date +%T,leave >> {logfile}
        """.format(**locals()))

        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} rmi {images}:{testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/ps || {package} install -y procps'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/killall || {package} install -y psmisc'"
        sx____(cmd.format(**locals()))
        if COVERAGE:
            cmd = "{docker} exec {testname} {package} install -y {python_coverage}"
            sx____(cmd.format(**locals()))
        self.prep_coverage(image, testname)
        cmd = "{docker} exec {testname} cp /bin/sleep {bindir}/{testsleep}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/{testscript} {testname}:{bindir}/{testscript}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} mkdir -p /etc/systemd/system /etc/systemd/user"
        sx____(cmd.format(**locals()))
        zzz_service = "/etc/systemd/system/zzz.service".format(**locals())
        cmd = "{docker} cp {testdir}/zzz.service {testname}:{zzz_service}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} touch {logfile}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} chmod 666 {logfile}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'grep nobody /etc/group || groupadd -g 65533 nobody'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} useradd -u 1001 somebody -g nobody -m"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl --version"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} chown somebody /tmp/.coverage"
        sx____(cmd.format(**locals()))
        #
        cmd = "{docker} commit -c 'CMD [\"/usr/bin/systemctl\"]' -c 'USER somebody' {testname} {images}:{testname}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} rm -f {testname}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} run -d --name {testname} {images}:{testname}"
        sh____(cmd.format(**locals()))
        #
        cmd = "{docker} exec {testname} {systemctl} enable zzz.service -vv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zzz.service not for --user mode"))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s", cmd, end, out)
        self.assertEqual(end, 3)
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'start' shall start a service that is NOT is-active ")
        cmd = "{docker} exec {testname} {systemctl} start zzz.service -vv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zzz.service not for --user mode"))
        #
        logg.info("== 'stop' shall stop a service that is-active")
        cmd = "{docker} exec {testname} {systemctl} stop zzz.service -vv {quick}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)  # TODO?
        # TODO?# self.assertTrue(greps(err, "Unit zzz.service not for --user mode"))
        #
        logg.info("== 'restart' shall start a service that NOT is-active")
        cmd = "{docker} exec {testname} {systemctl} restart zzz.service -vvvv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zzz.service not for --user mode"))
        #
        logg.info("== 'reload' will NOT restart a service that is-active")
        cmd = "{docker} exec {testname} {systemctl} reload zzz.service -vv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zzz.service not for --user mode"))
        #
        logg.info("== 'reload-or-restart' will restart a service that is-active (if ExecReload)")
        cmd = "{docker} exec {testname} {systemctl} reload-or-restart zzz.service -vv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zzz.service not for --user mode"))
        #
        logg.info("== 'kill' will bring is-active non-active as well (when the PID is known)")
        cmd = "{docker} exec {testname} {systemctl} kill zzz.service -vv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zzz.service not for --user mode"))
        #
        logg.info("== 'reload-or-try-restart' will not start a not-active service")
        cmd = "{docker} exec {testname} {systemctl} reload-or-try-restart zzz.service -vv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zzz.service not for --user mode"))
        #
        logg.info("== 'try-restart' will not start a not-active service")
        cmd = "{docker} exec {testname} {systemctl} try-restart zzz.service -vv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zzz.service not for --user mode"))
        #
        self.save_coverage(testname)
        #
        cmd = "{docker} rmi {images}:{testname}"
        sx____(cmd.format(**locals()))
        self.rm_docker(testname)
    def test_5232_bad_usermode_forking_service_functions_system(self) -> None:
        """ check that we are disallowed to manage forking services in a root env
            with basic run-service commands: start, stop, restart,
            reload, try-restart, reload-or-restart, kill and
            reload-or-try-restart."""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        self.bad_usermode_forking_service_functions("", testname, testdir)
        self.rm_testdir()
        self.end()
    def test_5233_bad_usermode_forking_service_functions_user(self) -> None:
        """ check that we are disallowed to manage forking services in a root env
            with basic run-service commands: start, stop, restart,
            reload, try-restart, reload-or-restart, kill and
            reload-or-try-restart."""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        self.bad_usermode_forking_service_functions("User=foo", testname, testdir)
        self.rm_testdir()
        self.end()
    def bad_usermode_forking_service_functions(self, extra: str, testname: str, testdir: str) -> None:
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        images = IMAGES
        image = self.local_image(COVERAGE or IMAGE or CENTOS)
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        python_coverage = coverage_package(image)
        if _python.endswith("python3") and "centos:7" in image:
            if SKIP: self.skipTest("no python3 on centos:7")
        docker = _docker
        package = package_tool(image)
        refresh = refresh_tool(image)
        sometime = SOMETIME or 188
        quick = QUICK
        #
        user = self.user()
        root = ""
        systemctl_py = realpath(_systemctl_py)
        systemctl = "/usr/bin/systemctl" # path in container
        systemctl += " --user"
        # systemctl += " --{system}".format(**locals())
        testsleep = testname+"_sleep"
        logfile = os_path(root, "/var/log/"+testsleep+".log")
        bindir = os_path(root, "/usr/bin")
        begin = "{"
        ends = "}"
        shell_file(os_path(testdir, "zzz.init"), """
            #! /bin/bash
            logfile={logfile}
            start() {begin}
               [ -d /var/run ] || mkdir -p /var/run
               ({bindir}/{testsleep} 111 0<&- &>/dev/null &
                echo $! > /tmp/zzz.init.pid
               ) &
               wait %1
               # ps -o pid,ppid,user,args
            {ends}
            stop() {begin}
               killall {testsleep}
            {ends}
            case "$1" in start)
               date "+START.%T" >> $logfile
               start >> $logfile 2>&1
               date "+start.%T" >> $logfile
            ;; stop)
               date "+STOP.%T" >> $logfile
               stop >> $logfile 2>&1
               date "+stop.%T" >> $logfile
            ;; restart)
               date "+RESTART.%T" >> $logfile
               stop >> $logfile 2>&1
               start >> $logfile 2>&1
               date "+.%T" >> $logfile
            ;; reload)
               date "+RELOAD.%T" >> $logfile
               echo "...." >> $logfile 2>&1
               date "+reload.%T" >> $logfile
            ;; esac
            echo "done$1" >&2
            exit 0
            """.format(**locals()))
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            [Service]
            {extra}
            Type=forking
            PIDFile=/tmp/zzz.init.pid
            ExecStart=/usr/bin/zzz.init start
            ExecStop=/usr/bin/zzz.init stop
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))

        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} rmi {images}:{testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/ps || {package} install -y procps'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/killall || {package} install -y psmisc'"
        sx____(cmd.format(**locals()))
        if COVERAGE:
            cmd = "{docker} exec {testname} {package} install -y {python_coverage}"
            sx____(cmd.format(**locals()))
        self.prep_coverage(image, testname)
        cmd = "{docker} exec {testname} mkdir -p /etc/systemd/system /etc/systemd/user"
        sx____(cmd.format(**locals()))
        zzz_service = "/etc/systemd/system/zzz.service".format(**locals())
        cmd = "{docker} exec {testname} cp /bin/sleep {bindir}/{testsleep}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zzz.init {testname}:/usr/bin/zzz.init"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zzz.service {testname}:{zzz_service}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} touch {logfile}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} chmod 666 {logfile}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'grep nobody /etc/group || groupadd -g 65533 nobody'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} useradd -u 1001 somebody -g nobody -m"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl --version"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} chown somebody /tmp/.coverage"
        sx____(cmd.format(**locals()))
        #
        cmd = "{docker} commit -c 'CMD [\"/usr/bin/systemctl\"]' -c 'USER somebody' {testname} {images}:{testname}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} rm -f {testname}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} run -d --name {testname} {images}:{testname}"
        sh____(cmd.format(**locals()))
        #
        cmd = "{docker} exec {testname} {systemctl} enable zzz.service -vv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zzz.service not for --user mode"))
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 3)
        # TODO?# self.assertTrue(greps(err, "Unit zzz.service not for --user mode"))
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'start' shall start a service that is NOT is-active ")
        cmd = "{docker} exec {testname} {systemctl} start zzz.service -vvvv {quick}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zzz.service not for --user mode"))
        #
        logg.info("== 'stop' shall stop a service that is-active")
        cmd = "{docker} exec {testname} {systemctl} stop zzz.service -vv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zzz.service not for --user mode"))
        #
        logg.info("== 'restart' shall start a service that NOT is-active")
        cmd = "{docker} exec {testname} {systemctl} restart zzz.service -vv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zzz.service not for --user mode"))
        #
        logg.info("== 'reload' will NOT restart a service that is-active")
        cmd = "{docker} exec {testname} {systemctl} reload zzz.service -vv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zzz.service not for --user mode"))
        #
        logg.info("== 'reload-or-restart' will restart a service that is-active (if no ExecReload)")
        cmd = "{docker} exec {testname} {systemctl} reload-or-restart zzz.service -vv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zzz.service not for --user mode"))
        #
        logg.info("== 'kill' will bring is-active non-active as well (when the PID is known)")
        cmd = "{docker} exec {testname} {systemctl} kill zzz.service -vv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zzz.service not for --user mode"))
        #
        logg.info("== 'reload-or-try-restart' will not start a not-active service")
        cmd = "{docker} exec {testname} {systemctl} reload-or-try-restart zzz.service -vv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zzz.service not for --user mode"))
        #
        logg.info("== 'try-restart' will not start a not-active service")
        cmd = "{docker} exec {testname} {systemctl} try-restart zzz.service -vv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zzz.service not for --user mode"))
        #
        logg.info("== 'reload-or-restart' will start a not-active service")
        cmd = "{docker} exec {testname} {systemctl} reload-or-restart zzz.service -vv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zzz.service not for --user mode"))
        #
        #
        self.save_coverage(testname)
        #
        self.rm_docker(testname)
    def test_5234_bad_usermode_notify_service_functions_system(self) -> None:
        """ check that we are disallowed to manage notify services in a root env
            with basic run-service commands: start, stop, restart,
            reload, try-restart, reload-or-restart, kill and
            reload-or-try-restart."""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        self.bad_usermode_notify_service_functions("", testname, testdir)
        self.rm_testdir()
        self.coverage()
        self.end()
    def test_5235_bad_usermode_notify_service_functions_user(self) -> None:
        """ check that we are disallowed to manage notify services in a root env
            with basic run-service commands: start, stop, restart,
            reload, try-restart, reload-or-restart, kill and
            reload-or-try-restart."""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        self.bad_usermode_notify_service_functions("User=foo", testname, testdir)
        self.rm_testdir()
        self.end(266)  # TODO# too long?
    def bad_usermode_notify_service_functions(self, extra: str, testname: str, testdir: str) -> None:
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        images = IMAGES
        image = self.local_image(COVERAGE or IMAGE or CENTOS)
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        python_coverage = coverage_package(image)
        if _python.endswith("python3") and "centos:7" in image:
            if SKIP: self.skipTest("no python3 on centos:7")
        docker = _docker
        package = package_tool(image)
        refresh = refresh_tool(image)
        sometime = SOMETIME or 288
        quick = QUICK
        #
        user = self.user()
        root = ""
        systemctl_py = realpath(_systemctl_py)
        systemctl = "/usr/bin/systemctl" # path in container
        systemctl += " --user"
        # systemctl += " --{system}".format(**locals())
        testsleep = testname+"_sleep"
        logfile = os_path(root, "/var/log/"+testsleep+".log")
        bindir = os_path(root, "/usr/bin")
        begin = "{"
        ends = "}"
        shell_file(os_path(testdir, "zzz.init"), """
            #! /bin/bash
            logfile={logfile}
            start() {begin}
                ls -l  $NOTIFY_SOCKET
                {bindir}/{testsleep} 111 0<&- &>/dev/null &
                echo "MAINPID=$!" | socat -v -d - UNIX-CLIENT:$NOTIFY_SOCKET
                echo "READY=1" | socat -v -d - UNIX-CLIENT:$NOTIFY_SOCKET
                wait %1
                # ps -o pid,ppid,user,args
            {ends}
            stop() {begin}
                killall {testsleep}
            {ends}
            case "$1" in start)
               date "+START.%T" >> $logfile
               start >> $logfile 2>&1
               date "+start.%T" >> $logfile
            ;; stop)
               date "+STOP.%T" >> $logfile
               stop >> $logfile 2>&1
               date "+stop.%T" >> $logfile
            ;; restart)
               date "+RESTART.%T" >> $logfile
               stop >> $logfile 2>&1
               start >> $logfile 2>&1
               date "+.%T" >> $logfile
            ;; reload)
               date "+RELOAD.%T" >> $logfile
               echo "...." >> $logfile 2>&1
               date "+reload.%T" >> $logfile
            ;; esac
            echo "done$1" >&2
            exit 0
            """.format(**locals()))
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            [Service]
            {extra}
            Type=notify
            # PIDFile={root}/var/run/zzz.init.pid
            ExecStart={root}/usr/bin/zzz.init start
            ExecStop={root}/usr/bin/zzz.init stop
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))

        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} rmi {images}:{testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/ps || {package} install -y procps'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/killall || {package} install -y psmisc'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/socat || {package} install -y socat'"
        if sx____(cmd.format(**locals())): self.skipTest("unable to install socat in a container from "+image)
        if COVERAGE:
            cmd = "{docker} exec {testname} {package} install -y {python_coverage}"
            sx____(cmd.format(**locals()))
        self.prep_coverage(image, testname)
        cmd = "{docker} exec {testname} mkdir -p /etc/systemd/system /etc/systemd/user"
        sx____(cmd.format(**locals()))
        zzz_service = "/etc/systemd/system/zzz.service".format(**locals())
        cmd = "{docker} exec {testname} cp /bin/sleep {bindir}/{testsleep}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zzz.init {testname}:/usr/bin/zzz.init"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zzz.service {testname}:{zzz_service}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} touch {logfile}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} chmod 666 {logfile}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'grep nobody /etc/group || groupadd -g 65533 nobody'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} useradd -u 1001 somebody -g nobody -m"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl --version"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} chown somebody /tmp/.coverage"
        sx____(cmd.format(**locals()))
        #
        cmd = "{docker} commit -c 'CMD [\"/usr/bin/systemctl\"]' -c 'USER somebody' {testname} {images}:{testname}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} rm -f {testname}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} run -d --name {testname} {images}:{testname}"
        sh____(cmd.format(**locals()))
        #
        cmd = "{docker} exec {testname} {systemctl} enable zzz.service -vv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zzz.service not for --user mode"))
        #
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 3)
        # TODO?# self.assertTrue(greps(err, "Unit zzz.service not for --user mode"))
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'start' shall start a service that is NOT is-active ")
        cmd = "{docker} exec {testname} {systemctl} start zzz.service -vv -vv {quick}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zzz.service not for --user mode"))
        #
        logg.info("== 'stop' shall stop a service that is-active")
        cmd = "{docker} exec {testname} {systemctl} stop zzz.service -vv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zzz.service not for --user mode"))
        #
        logg.info("== 'restart' shall start a service that NOT is-active")
        cmd = "{docker} exec {testname} {systemctl} restart zzz.service -vv {quick}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zzz.service not for --user mode"))
        #
        logg.info("== 'reload' will NOT restart a service that is-active")
        cmd = "{docker} exec {testname} {systemctl} reload zzz.service -vv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zzz.service not for --user mode"))
        #
        logg.info("== 'reload-or-restart' will restart a service that is-active (if no ExecReload)")
        cmd = "{docker} exec {testname} {systemctl} reload-or-restart zzz.service -vv {quick}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zzz.service not for --user mode"))
        #
        logg.info("== 'kill' will bring is-active non-active as well (when the PID is known)")
        cmd = "{docker} exec {testname} {systemctl} kill zzz.service -vv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zzz.service not for --user mode"))
        #
        logg.info("== 'reload-or-try-restart' will not start a not-active service")
        cmd = "{docker} exec {testname} {systemctl} reload-or-try-restart zzz.service -vv {quick}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zzz.service not for --user mode"))
        #
        logg.info("== 'try-restart' will not start a not-active service")
        cmd = "{docker} exec {testname} {systemctl} try-restart zzz.service -vv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zzz.service not for --user mode"))
        #
        logg.info("== 'reload-or-restart' will start a not-active service")
        cmd = "{docker} exec {testname} {systemctl} reload-or-restart zzz.service -vv {quick}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zzz.service not for --user mode"))
        #
        self.save_coverage(testname)
        #
        cmd = "{docker} rmi {images}:{testname}"
        sx____(cmd.format(**locals()))
        self.rm_docker(testname)
    def test_5236_bad_usermode_notify_service_functions_with_reload(self) -> None:
        """ check that we manage notify services in a root env
            with basic run-service commands: start, stop, restart,
            reload, try-restart, reload-or-restart, kill and
            reload-or-try-restart. (with ExecReload)"""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        self.bad_usermode_notify_service_functions_with_reload("", testname, testdir)
        self.rm_testdir()
        self.coverage()
        logg.error("too long")  # TODO
        self.end(200)
    def test_5237_bad_usermode_notify_service_functions_with_reload_user(self) -> None:
        """ check that we are disallowed to manage notify services in a root env
            with basic run-service commands: start, stop, restart,
            reload, try-restart, reload-or-restart, kill and
            reload-or-try-restart. (with ExecReload)"""
        # test_5037 is triggering len(socketfile) > 100 | "new notify socketfile"
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        self.bad_usermode_notify_service_functions_with_reload("User=foo", testname, testdir)
        self.rm_testdir()
        self.coverage()
        logg.error("too long")  # TODO
        self.end(266)
    def bad_usermode_notify_service_functions_with_reload(self, extra: str, testname: str, testdir: str) -> None:
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        images = IMAGES
        image = self.local_image(COVERAGE or IMAGE or CENTOS)
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        python_coverage = coverage_package(image)
        if _python.endswith("python3") and "centos:7" in image:
            if SKIP: self.skipTest("no python3 on centos:7")
        docker = _docker
        package = package_tool(image)
        refresh = refresh_tool(image)
        sometime = SOMETIME or 288
        quick = QUICK
        #
        user = self.user()
        root = ""
        systemctl_py = realpath(_systemctl_py)
        systemctl = "/usr/bin/systemctl" # path in container
        systemctl += " --user"
        # systemctl += " --{system}".format(**locals())
        testsleep = self.testname("sleep")
        logfile = os_path(root, "/var/log/"+testsleep+".log")
        bindir = os_path(root, "/usr/bin")
        begin = "{"
        ends = "}"
        shell_file(os_path(testdir, "zzz.init"), """
            #! /bin/bash
            logfile={logfile}
            start() {begin}
                ls -l  $NOTIFY_SOCKET
                {bindir}/{testsleep} 111 0<&- &>/dev/null &
                echo "MAINPID=$!" | socat -v -d - UNIX-CLIENT:$NOTIFY_SOCKET
                echo "READY=1" | socat -v -d - UNIX-CLIENT:$NOTIFY_SOCKET
                wait %1
                # ps -o pid,ppid,user,args
            {ends}
            stop() {begin}
                killall {testsleep}
            {ends}
            case "$1" in start)
               date "+START.%T" >> $logfile
               start >> $logfile 2>&1
               date "+start.%T" >> $logfile
            ;; stop)
               date "+STOP.%T" >> $logfile
               stop >> $logfile 2>&1
               date "+stop.%T" >> $logfile
            ;; restart)
               date "+RESTART.%T" >> $logfile
               stop >> $logfile 2>&1
               start >> $logfile 2>&1
               date "+.%T" >> $logfile
            ;; reload)
               date "+RELOAD.%T" >> $logfile
               echo "...." >> $logfile 2>&1
               date "+reload.%T" >> $logfile
            ;; esac
            echo "done$1" >&2
            exit 0
            """.format(**locals()))
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            [Service]
            {extra}
            Type=notify
            # PIDFile={root}/var/run/zzz.init.pid
            ExecStart={root}/usr/bin/zzz.init start
            ExecReload={root}/usr/bin/zzz.init reload
            ExecStop={root}/usr/bin/zzz.init stop
            TimeoutRestartSec=4
            TimeoutReloadSec=4
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))

        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} rmi {images}:{testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/ps || {package} install -y procps'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/killall || {package} install -y psmisc'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/socat || {package} install -y socat'"
        if sx____(cmd.format(**locals())): self.skipTest("unable to install socat in a container from "+image)
        if COVERAGE:
            cmd = "{docker} exec {testname} {package} install -y {python_coverage}"
            sx____(cmd.format(**locals()))
        self.prep_coverage(image, testname)
        cmd = "{docker} exec {testname} mkdir -p /etc/systemd/system /etc/systemd/user"
        sx____(cmd.format(**locals()))
        zzz_service = "/etc/systemd/system/zzz.service".format(**locals())
        cmd = "{docker} exec {testname} cp /bin/sleep {bindir}/{testsleep}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zzz.init {testname}:/usr/bin/zzz.init"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zzz.service {testname}:{zzz_service}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} touch {logfile}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} chmod 666 {logfile}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'grep nobody /etc/group || groupadd -g 65533 nobody'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} useradd -u 1001 somebody -g nobody -m"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl --version"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} chown somebody /tmp/.coverage"
        sx____(cmd.format(**locals()))
        #
        cmd = "{docker} commit -c 'CMD [\"/usr/bin/systemctl\"]' -c 'USER somebody' {testname} {images}:{testname}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} rm -f {testname}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} run -d --name {testname} {images}:{testname}"
        sh____(cmd.format(**locals()))
        #
        cmd = "{docker} exec {testname} {systemctl} enable zzz.service -vv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zzz.service not for --user mode"))
        #
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 3)
        # TODO?# self.assertTrue(greps(err, "Unit zzz.service not for --user mode"))
        self.assertEqual(out.strip(), "inactive")
        #
        logg.info("== 'start' shall start a service that is NOT is-active ")
        cmd = "{docker} exec {testname} {systemctl} start zzz.service -vv {quick}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zzz.service not for --user mode"))
        #
        logg.info("== 'stop' shall stop a service that is-active")
        cmd = "{docker} exec {testname} {systemctl} stop zzz.service -vv {quick}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zzz.service not for --user mode"))
        #
        logg.info("== 'restart' shall start a service that NOT is-active")
        cmd = "{docker} exec {testname} {systemctl} restart zzz.service -vv {quick}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zzz.service not for --user mode"))
        #
        logg.info("== 'reload' will NOT restart a service that is-active")
        cmd = "{docker} exec {testname} {systemctl} reload zzz.service -vv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zzz.service not for --user mode"))
        #
        logg.info("== 'reload-or-restart' will restart a service that is-active (if no ExecReload)")
        cmd = "{docker} exec {testname} {systemctl} reload-or-restart zzz.service -vv {quick}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zzz.service not for --user mode"))
        #
        logg.info("== 'kill' will bring is-active non-active as well (when the PID is known)")
        cmd = "{docker} exec {testname} {systemctl} kill zzz.service -vv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zzz.service not for --user mode"))
        #
        logg.info("== 'reload-or-try-restart' will not start a not-active service")
        cmd = "{docker} exec {testname} {systemctl} reload-or-try-restart zzz.service -vv {quick}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zzz.service not for --user mode"))
        #
        logg.info("== 'try-restart' will not start a not-active service")
        cmd = "{docker} exec {testname} {systemctl} try-restart zzz.service -vv {quick}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zzz.service not for --user mode"))
        #
        self.save_coverage(testname)
        #
        cmd = "{docker} rmi {images}:{testname}"
        sx____(cmd.format(**locals()))
        self.rm_docker(testname)
    def test_5240_bad_usermode_oneshot_service_functions(self) -> None:
        """ check that we are disallowed to manage oneshot services in a root env
            with basic run-service commands: start, stop, restart,
            reload, try-restart, reload-or-restart, kill and
            reload-or-try-restart."""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        self.bad_usermode_oneshot_service_functions("", testname, testdir)
        self.rm_testdir()
        self.end()
    def test_5241_bad_usermode_oneshot_service_functions_user(self) -> None:
        """ check that we are disallowed to manage oneshot services in a root env
            with basic run-service commands: start, stop, restart,
            reload, try-restart, reload-or-restart, kill and
            reload-or-try-restart."""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        self.bad_usermode_oneshot_service_functions("User=foo", testname, testdir)
        self.rm_testdir()
        self.end()
    def bad_usermode_oneshot_service_functions(self, extra: str, testname: str, testdir: str) -> None:
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        images = IMAGES
        image = self.local_image(COVERAGE or IMAGE or CENTOS)
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        python_coverage = coverage_package(image)
        if _python.endswith("python3") and "centos:7" in image:
            if SKIP: self.skipTest("no python3 on centos:7")
        docker = _docker
        package = package_tool(image)
        refresh = refresh_tool(image)
        sometime = SOMETIME or 188
        quick = QUICK
        #
        user = self.user()
        root = ""
        systemctl_py = realpath(_systemctl_py)
        systemctl = "/usr/bin/systemctl" # path in container
        systemctl += " --user"
        # systemctl += " --{system}".format(**locals())
        testsleep = self.testname("sleep")
        logfile = os_path(root, "/var/log/"+testsleep+".log")
        bindir = os_path(root, "/usr/bin")
        begin = "{"
        ends = "}"
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            [Service]
            {extra}
            Type=oneshot
            ExecStartPre={bindir}/backup {root}/var/tmp/test.1 {root}/var/tmp/test.2
            ExecStart=/usr/bin/touch {root}/var/tmp/test.1
            ExecStop=/bin/rm {root}/var/tmp/test.1
            ExecStopPost=/bin/rm -f {root}/var/tmp/test.2
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        shell_file(os_path(testdir, "backup"), """
           #! /bin/sh
           set -x
           test ! -f "$1" || mv -v "$1" "$2"
        """)

        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} rmi {images}:{testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/ps || {package} install -y procps'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/killall || {package} install -y psmisc'"
        sx____(cmd.format(**locals()))
        if COVERAGE:
            cmd = "{docker} exec {testname} {package} install -y {python_coverage}"
            sx____(cmd.format(**locals()))
        self.prep_coverage(image, testname)
        cmd = "{docker} exec {testname} mkdir -p /etc/systemd/system /etc/systemd/user"
        sx____(cmd.format(**locals()))
        zzz_service = "/etc/systemd/system/zzz.service".format(**locals())
        cmd = "{docker} exec {testname} cp /bin/sleep {bindir}/{testsleep}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zzz.service {testname}:{zzz_service}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} touch {logfile}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} chmod 666 {logfile}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'grep nobody /etc/group || groupadd -g 65533 nobody'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} useradd -u 1001 somebody -g nobody -m"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/backup {testname}:/usr/bin/backup"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} touch /var/tmp/test.0"
        sh____(cmd.format(**locals()))
        testfiles = output("{docker} exec {testname} find /var/tmp -name test.*".format(**locals()))
        logg.info("found testfiles:\n%s", testfiles)
        self.assertFalse(greps(testfiles, "/var/tmp/test.1"))
        self.assertFalse(greps(testfiles, "/var/tmp/test.2"))
        #
        cmd = "{docker} exec {testname} systemctl --version"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} chown somebody /tmp/.coverage"
        sx____(cmd.format(**locals()))
        #
        cmd = "{docker} commit -c 'CMD [\"/usr/bin/systemctl\"]' -c 'USER somebody' {testname} {images}:{testname}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} rm -f {testname}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} run -d --name {testname} {images}:{testname}"
        sh____(cmd.format(**locals()))
        #
        cmd = "{docker} exec {testname} {systemctl} enable zzz.service -vv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zzz.service not for --user mode"))
        #
        is_active = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zzz.service not for --user mode"))
        self.assertEqual(out.strip(), "")  # TODO#
        #
        logg.info("== 'start' shall start a service that is NOT is-active ")
        cmd = "{docker} exec {testname} {systemctl} start zzz.service -vvvv {quick}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zzz.service not for --user mode"))
        #
        logg.info("== 'stop' shall stop a service that is-active")
        cmd = "{docker} exec {testname} {systemctl} stop zzz.service -vv {quick}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zzz.service not for --user mode"))
        #
        logg.info("== 'restart' shall start a service that NOT is-active")
        cmd = "{docker} exec {testname} {systemctl} restart zzz.service -vv {quick}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zzz.service not for --user mode"))
        #
        logg.info("== 'reload' will NOT restart a service that is-active")
        cmd = "{docker} exec {testname} {systemctl} reload zzz.service -vv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zzz.service not for --user mode"))
        #
        logg.info("== 'reload-or-restart' will restart a service that is-active")
        cmd = "{docker} exec {testname} {systemctl} reload-or-restart zzz.service -vv {quick}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zzz.service not for --user mode"))
        #
        logg.info("== 'reload-or-try-restart' will not start a not-active service")
        cmd = "{docker} exec {testname} {systemctl} reload-or-try-restart zzz.service -vv {quick}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zzz.service not for --user mode"))
        #
        logg.info("== 'try-restart' will not start a not-active service")
        cmd = "{docker} exec {testname} {systemctl} try-restart zzz.service -vv {quick}"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zzz.service not for --user mode"))
        #
        self.save_coverage(testname)
        #
        cmd = "{docker} rmi {images}:{testname}"
        sx____(cmd.format(**locals()))
        self.rm_docker(testname)
    def test_5290_bad_usermode_other_commands(self) -> None:
        """ check that we are disallowed to manage oneshot services in a root env
            with other commands: enable, disable, mask, unmaks,..."""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        self.bad_usermode_other_commands("", testname, testdir)
        self.rm_testdir()
        self.end()
    def test_5291_bad_usermode_other_commands(self) -> None:
        """ check that we are disallowed to manage oneshot services in a root env
            with other commands: enable, disable, mask, unmaks,..."""
        self.begin()
        testname = self.testname()
        testdir = self.testdir()
        self.bad_usermode_other_commands("User=foo", testname, testdir)
        self.rm_testdir()
        self.end()
    def bad_usermode_other_commands(self, extra: str, testname: str, testdir: str) -> None:
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        images = IMAGES
        image = self.local_image(COVERAGE or IMAGE or CENTOS)
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        python_coverage = coverage_package(image)
        if _python.endswith("python3") and "centos:7" in image:
            if SKIP: self.skipTest("no python3 on centos:7")
        docker = _docker
        package = package_tool(image)
        refresh = refresh_tool(image)
        sometime = SOMETIME or 188
        quick = QUICK
        #
        user = self.user()
        root = ""
        systemctl_py = realpath(_systemctl_py)
        systemctl = "/usr/bin/systemctl" # path in container
        systemctl += " --user"
        # systemctl += " --{system}".format(**locals())
        testsleep = self.testname("sleep")
        logfile = os_path(root, "/var/log/"+testsleep+".log")
        bindir = os_path(root, "/usr/bin")
        begin = "{"
        ends = "}"
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            [Service]
            {extra}
            Type=simple
            ExecStart=/usr/bin/{testsleep} 11
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        shell_file(os_path(testdir, "backup"), """
           #! /bin/sh
           set -x
           test ! -f "$1" || mv -v "$1" "$2"
        """)

        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} rmi {images}:{testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/ps || {package} install -y procps'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/killall || {package} install -y psmisc'"
        sx____(cmd.format(**locals()))
        if COVERAGE:
            cmd = "{docker} exec {testname} {package} install -y {python_coverage}"
            sx____(cmd.format(**locals()))
        self.prep_coverage(image, testname)
        cmd = "{docker} exec {testname} mkdir -p /etc/systemd/system /etc/systemd/user"
        sx____(cmd.format(**locals()))
        zzz_service = "/etc/systemd/system/zzz.service".format(**locals())
        cmd = "{docker} exec {testname} cp /bin/sleep {bindir}/{testsleep}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zzz.service {testname}:{zzz_service}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'grep nobody /etc/group || groupadd -g 65533 nobody'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} useradd -u 1001 somebody -g nobody -m"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl --version"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} chown somebody /tmp/.coverage"
        sx____(cmd.format(**locals()))
        #
        cmd = "{docker} commit -c 'CMD [\"/usr/bin/systemctl\"]' -c 'USER somebody' {testname} {images}:{testname}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} rm -f {testname}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} run -d --name {testname} {images}:{testname}"
        sh____(cmd.format(**locals()))
        #
        cmd = "{docker} exec {testname} {systemctl} enable zzz.service -vv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zzz.service not for --user mode"))
        #
        cmd = "{docker} exec {testname} {systemctl} disable zzz.service -vv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zzz.service not for --user mode"))
        #
        cmd = "{docker} exec {testname} {systemctl} mask zzz.service -vv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zzz.service not for --user mode"))
        #
        cmd = "{docker} exec {testname} {systemctl} unmask zzz.service -vv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertTrue(greps(err, "Unit zzz.service not for --user mode"))
        #
        cmd = "{docker} exec {testname} {systemctl} is-active zzz.service -vv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 3)
        self.assertFalse(greps(err, "Unit zzz.service not for --user mode"))  # TODO
        self.assertEqual(out.strip(), "inactive")
        #
        cmd = "{docker} exec {testname} {systemctl} is-failed zzz.service -vv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertFalse(greps(err, "Unit zzz.service not for --user mode"))  # TODO
        self.assertEqual(out.strip(), "inactive")
        #
        cmd = "{docker} exec {testname} {systemctl} is-enabled zzz.service -vv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 1)
        self.assertFalse(greps(err, "Unit zzz.service not for --user mode"))  # TODO
        self.assertEqual(out.strip(), "disabled")
        #
        cmd = "{docker} exec {testname} {systemctl} status zzz.service -vv"
        out, err, end = output3(cmd.format(**locals()))
        logg.info(" %s =>%s \n%s\n%s", cmd, end, err, out)
        self.assertEqual(end, 3)
        #
        #
        self.save_coverage(testname)
        #
        cmd = "{docker} rmi {images}:{testname}"
        sx____(cmd.format(**locals()))
        self.rm_docker(testname)
    #
    #
    #
    #
    #
    #
    def test_5430_systemctl_py_start_simple(self) -> None:
        """ check that we can start simple services in a container"""
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        images = IMAGES
        image = self.local_image(COVERAGE and IMAGE or CENTOS)
        if _python.endswith("python3") and "centos:7" in image:
            if SKIP: self.skipTest("no python3 on centos:7")
        testname = self.testname()
        testdir = self.testdir()
        docker = _docker
        package = package_tool(image)
        refresh = refresh_tool(image)
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        python_coverage = coverage_package(image)
        systemctl_py = _systemctl_py
        sometime = SOMETIME or 188
        shell_file(os_path(testdir, "killall"), """
            #! /bin/sh
            ps -eo pid,comm | { while read pid comm; do
               if [ "$comm" = "$1" ]; then
                  echo kill $pid
                  kill $pid
               fi done } """)
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            [Service]
            Type=simple
            ExecStart=/usr/bin/testsleep 111
            ExecStop=/usr/bin/killall testsleep
            [Install]
            WantedBy=multi-user.target""")
        #
        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/ps || {package} install -y procps'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/killall || {package} install -y psmisc'"
        sx____(cmd.format(**locals()))
        if COVERAGE:
            cmd = "{docker} exec {testname} {package} install -y {python_coverage}"
            sx____(cmd.format(**locals()))
        self.prep_coverage(image, testname)
        cmd = "{docker} exec {testname} mkdir -p /etc/systemd/system /etc/systemd/user"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} cp /bin/sleep /usr/bin/testsleep"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/killall {testname}:/usr/bin/killall"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zzz.service {testname}:/etc/systemd/system/zzz.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl enable zzz.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl --version"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl default-services -vv"
        # sh____(cmd.format(**locals()))
        out = output(cmd.format(**locals()))
        logg.info("\n>\n%s", out)
        self.assertTrue(greps(out, "zzz.service"))
        self.assertEqual(len(lines(out)), 1)
        #
        cmd = "{docker} exec {testname} systemctl start zzz.service -vv"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} ps -eo pid,ppid,user,args"
        top = output(cmd.format(**locals()))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "testsleep"))
        #
        cmd = "{docker} exec {testname} systemctl stop zzz.service -vv"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} ps -eo pid,ppid,user,args"
        top = output(cmd.format(**locals()))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(running(greps(top, "testsleep")))
        #
        self.save_coverage(testname)
        #
        self.rm_docker(testname)
        self.rm_testdir()
    def test_5431_systemctl_py_start_extra_simple(self) -> None:
        """ check that we can start simple services in a container"""
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        images = IMAGES
        image = self.local_image(COVERAGE or IMAGE or CENTOS)
        if _python.endswith("python3") and "centos:7" in image:
            if SKIP: self.skipTest("no python3 on centos:7")
        testname = self.testname()
        testdir = self.testdir()
        docker = _docker
        package = package_tool(image)
        refresh = refresh_tool(image)
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        python_coverage = coverage_package(image)
        systemctl_py = _systemctl_py
        sometime = SOMETIME or 188
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            [Service]
            Type=simple
            ExecStart=/usr/bin/testsleep 111
            [Install]
            WantedBy=multi-user.target""")
        #
        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/ps || {package} install -y procps'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/killall || {package} install -y psmisc'"
        sx____(cmd.format(**locals()))
        if COVERAGE:
            cmd = "{docker} exec {testname} {package} install -y {python_coverage}"
            sx____(cmd.format(**locals()))
        self.prep_coverage(image, testname)
        cmd = "{docker} exec {testname} cp /bin/sleep /usr/bin/testsleep"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} mkdir -p /etc/systemd/system /etc/systemd/user"
        sx____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zzz.service {testname}:/etc/systemd/system/zzz.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl enable zzz.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl --version"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl default-services -vv"
        # sh____(cmd.format(**locals()))
        out = output(cmd.format(**locals()))
        logg.info("\n>\n%s", out)
        self.assertTrue(greps(out, "zzz.service"))
        self.assertEqual(len(lines(out)), 1)
        #
        cmd = "{docker} exec {testname} systemctl start zzz.service -vv"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} ps -eo pid,ppid,user,args"
        top = output(cmd.format(**locals()))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "testsleep"))
        #
        cmd = "{docker} exec {testname} systemctl stop zzz.service -vv"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} ps -eo pid,ppid,user,args"
        top = output(cmd.format(**locals()))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(running(greps(top, "testsleep")))
        #
        #
        self.save_coverage(testname)
        #
        self.rm_docker(testname)
        self.rm_testdir()
    def test_5432_systemctl_py_start_forking(self) -> None:
        """ check that we can start forking services in a container w/ PIDFile"""
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        images = IMAGES
        image = self.local_image(COVERAGE or IMAGE or CENTOS)
        if _python.endswith("python3") and "centos:7" in image:
            if SKIP: self.skipTest("no python3 on centos:7")
        testname = self.testname()
        testdir = self.testdir()
        docker = _docker
        package = package_tool(image)
        refresh = refresh_tool(image)
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        python_coverage = coverage_package(image)
        systemctl_py = _systemctl_py
        sometime = SOMETIME or 188
        shell_file(os_path(testdir, "killall"), """
            #! /bin/sh
            ps -eo pid,comm | { while read pid comm; do
               if [ "$comm" = "$1" ]; then
                  echo kill $pid
                  kill $pid
               fi done } """)
        shell_file(os_path(testdir, "zzz.init"), """
            #! /bin/bash
            case "$1" in start)
               [ -d /var/run ] || mkdir -p /var/run
               (testsleep 111 0<&- &>/dev/null &
                echo $! > /var/run/zzz.init.pid
               ) &
               wait %1
               ps -o pid,ppid,user,args
            ;; stop)
               killall testsleep
            ;; esac
            echo "done$1" >&2
            exit 0""")
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            [Service]
            Type=forking
            PIDFile=/var/run/zzz.init.pid
            ExecStart=/usr/bin/zzz.init start
            ExecStop=/usr/bin/zzz.init stop
            [Install]
            WantedBy=multi-user.target""")
        #
        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/ps || {package} install -y procps'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sx____(cmd.format(**locals()))
        if COVERAGE:
            cmd = "{docker} exec {testname} {package} install -y {python_coverage}"
            sx____(cmd.format(**locals()))
        self.prep_coverage(image, testname)
        cmd = "{docker} exec {testname} mkdir -p /etc/systemd/system /etc/systemd/user"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} cp /bin/sleep /usr/bin/testsleep"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/killall {testname}:/usr/bin/killall"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zzz.service {testname}:/etc/systemd/system/zzz.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zzz.init {testname}:/usr/bin/zzz.init"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl enable zzz.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl --version"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl default-services -vv"
        # sh____(cmd.format(**locals()))
        out = output(cmd.format(**locals()))
        logg.info("\n>\n%s", out)
        self.assertTrue(greps(out, "zzz.service"))
        self.assertEqual(len(lines(out)), 1)
        #
        cmd = "{docker} exec {testname} systemctl start zzz.service -vv"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} ps -eo pid,ppid,user,args"
        top = output(cmd.format(**locals()))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "testsleep"))
        #
        cmd = "{docker} exec {testname} systemctl stop zzz.service -vv"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} ps -eo pid,ppid,user,args"
        top = output(cmd.format(**locals()))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(running(greps(top, "testsleep")))
        #
        self.save_coverage(testname)
        #
        self.rm_docker(testname)
        self.rm_testdir()
    def test_5433_systemctl_py_start_forking_without_pid_file(self) -> None:
        """ check that we can start forking services in a container without PIDFile"""
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        images = IMAGES
        image = self.local_image(COVERAGE or IMAGE or CENTOS)
        if _python.endswith("python3") and "centos:7" in image:
            if SKIP: self.skipTest("no python3 on centos:7")
        testname = self.testname()
        testdir = self.testdir()
        docker = _docker
        package = package_tool(image)
        refresh = refresh_tool(image)
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        python_coverage = coverage_package(image)
        systemctl_py = _systemctl_py
        sometime = SOMETIME or 188
        shell_file(os_path(testdir, "killall"), """
            #! /bin/sh
            ps -eo pid,comm | { while read pid comm; do
               if [ "$comm" = "$1" ]; then
                  echo kill $pid
                  kill $pid
               fi done } """)
        shell_file(os_path(testdir, "zzz.init"), """
            #! /bin/bash
            case "$1" in start)
               (testsleep 111 0<&- &>/dev/null &) &
               wait %1
               ps -o pid,ppid,user,args >&2
            ;; stop)
               killall testsleep
               echo killed all testsleep >&2
               sleep 1
            ;; esac
            echo "done$1" >&2
            exit 0""")
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            [Service]
            Type=forking
            ExecStart=/usr/bin/zzz.init start
            ExecStop=/usr/bin/zzz.init stop
            [Install]
            WantedBy=multi-user.target""")
        #
        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/ps || {package} install -y procps'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sx____(cmd.format(**locals()))
        if COVERAGE:
            cmd = "{docker} exec {testname} {package} install -y {python_coverage}"
            sx____(cmd.format(**locals()))
        self.prep_coverage(image, testname)
        cmd = "{docker} exec {testname} mkdir -p /etc/systemd/system /etc/systemd/user"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} cp /bin/sleep /usr/bin/testsleep"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/killall {testname}:/usr/bin/killall"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zzz.service {testname}:/etc/systemd/system/zzz.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zzz.init {testname}:/usr/bin/zzz.init"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl enable zzz.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl --version"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl default-services -vv"
        # sh____(cmd.format(**locals()))
        out = output(cmd.format(**locals()))
        logg.info("\n>\n%s", out)
        self.assertTrue(greps(out, "zzz.service"))
        self.assertEqual(len(lines(out)), 1)
        #
        cmd = "{docker} exec {testname} systemctl start zzz.service -vv"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} ps -eo pid,ppid,user,args"
        top = output(cmd.format(**locals()))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "testsleep"))
        #
        cmd = "{docker} exec {testname} systemctl stop zzz.service -vv"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} ps -eo pid,ppid,user,args"
        top = output(cmd.format(**locals()))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(running(greps(top, "testsleep")))
        #
        self.save_coverage(testname)
        #
        self.rm_docker(testname)
        self.rm_testdir()
    def test_5435_systemctl_py_start_notify_by_timeout(self) -> None:
        """ check that we can start simple services in a container w/ notify timeout"""
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        images = IMAGES
        image = self.local_image(COVERAGE or IMAGE or CENTOS)
        if _python.endswith("python3") and "centos:7" in image:
            if SKIP: self.skipTest("no python3 on centos:7")
        testname = self.testname()
        testdir = self.testdir()
        docker = _docker
        package = package_tool(image)
        refresh = refresh_tool(image)
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        python_coverage = coverage_package(image)
        systemctl_py = _systemctl_py
        sometime = SOMETIME or 188
        shell_file(os_path(testdir, "killall"), """
            #! /bin/sh
            ps -eo pid,comm | { while read pid comm; do
               if [ "$comm" = "$1" ]; then
                  echo kill $pid
                  kill $pid
               fi done } """)
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            [Service]
            Type=notify
            ExecStart=/usr/bin/testsleep 111
            ExecStop=/usr/bin/killall testsleep
            TimeoutSec=4
            [Install]
            WantedBy=multi-user.target""")
        #
        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/ps || {package} install -y procps'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sx____(cmd.format(**locals()))
        if COVERAGE:
            cmd = "{docker} exec {testname} {package} install -y {python_coverage}"
            sx____(cmd.format(**locals()))
        self.prep_coverage(image, testname)
        cmd = "{docker} exec {testname} mkdir -p /etc/systemd/system /etc/systemd/user"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} cp /bin/sleep /usr/bin/testsleep"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/killall {testname}:/usr/bin/killall"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zzz.service {testname}:/etc/systemd/system/zzz.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl enable zzz.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl --version"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl default-services -vv"
        # sh____(cmd.format(**locals()))
        out = output(cmd.format(**locals()))
        logg.info("\n>\n%s", out)
        self.assertTrue(greps(out, "zzz.service"))
        self.assertEqual(len(lines(out)), 1)
        #
        cmd = "{docker} exec {testname} systemctl start zzz.service -vvvv"
        sx____(cmd.format(**locals())) # returncode = 1
        cmd = "{docker} exec {testname} ps -eo pid,ppid,user,args"
        top = output(cmd.format(**locals()))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "testsleep"))
        #
        cmd = "{docker} exec {testname} systemctl stop zzz.service -vv"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} ps -eo pid,ppid,user,args"
        top = output(cmd.format(**locals()))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(running(greps(top, "testsleep")))
        #
        self.save_coverage(testname)
        #
        self.rm_docker(testname)
        self.rm_testdir()
    def test_5500_systemctl_py_run_default_services_in_container(self) -> None:
        """ check that we can enable services in a docker container to be run as default-services"""
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        images = IMAGES
        image = self.local_image(COVERAGE or IMAGE or CENTOS)
        if _python.endswith("python3") and "centos:7" in image:
            if SKIP: self.skipTest("no python3 on centos:7")
        testname = self.testname()
        testdir = self.testdir()
        docker = _docker
        package = package_tool(image)
        refresh = refresh_tool(image)
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        python_coverage = coverage_package(image)
        systemctl_py = _systemctl_py
        sometime = SOMETIME or 188
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A""")
        text_file(os_path(testdir, "zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart=/usr/bin/testsleep 99
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(testdir, "zzc.service"), """
            [Unit]
            Description=Testing C
            [Service]
            Type=simple
            ExecStart=/usr/bin/testsleep 111
            [Install]
            WantedBy=multi-user.target""")
        #
        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/ps || {package} install -y procps'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sx____(cmd.format(**locals()))
        if COVERAGE:
            cmd = "{docker} exec {testname} {package} install -y {python_coverage}"
            sx____(cmd.format(**locals()))
        self.prep_coverage(image, testname)
        cmd = "{docker} exec {testname} mkdir -p /etc/systemd/system /etc/systemd/user"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} cp /bin/sleep /usr/bin/testsleep"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zza.service {testname}:/etc/systemd/system/zza.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zzb.service {testname}:/etc/systemd/system/zzb.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zzc.service {testname}:/etc/systemd/system/zzc.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl enable zzb.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl enable zzc.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl --version"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl default-services -vv"
        # sh____(cmd.format(**locals()))
        out2 = output(cmd.format(**locals()))
        logg.info("\n>\n%s", out2)
        cmd = "{docker} exec {testname} systemctl default -vvvv"
        # sh____(cmd.format(**locals()))
        out3 = output(cmd.format(**locals()))
        logg.info("\n>\n%s", out3)
        #
        cmd = "{docker} exec {testname} ps -eo pid,ppid,user,args"
        top = output(cmd.format(**locals()))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "testsleep 99"))
        self.assertTrue(greps(top, "testsleep 111"))
        #
        cmd = "{docker} exec {testname} systemctl halt -vvvv"
        # sh____(cmd.format(**locals()))
        out3 = output(cmd.format(**locals()))
        logg.info("\n>\n%s", out3)
        #
        cmd = "{docker} exec {testname} ps -eo pid,ppid,user,args"
        top = output(cmd.format(**locals()))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, "testsleep 99"))
        self.assertFalse(greps(top, "testsleep 111"))
        #
        self.save_coverage(testname)
        #
        self.rm_docker(testname)
        self.rm_testdir()
    def test_5520_systemctl_py_run_default_services_from_saved_container(self) -> None:
        """ check that we can enable services in a docker container to be run as default-services
            after it has been restarted from a commit-saved container image (with --init default)"""
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        images = IMAGES
        image = self.local_image(COVERAGE or IMAGE or CENTOS)
        if _python.endswith("python3") and "centos:7" in image:
            if SKIP: self.skipTest("no python3 on centos:7")
        testname = self.testname()
        testdir = self.testdir()
        docker = _docker
        package = package_tool(image)
        refresh = refresh_tool(image)
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        python_coverage = coverage_package(image)
        systemctl_py = _systemctl_py
        images = IMAGES
        sometime = SOMETIME or 188
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A""")
        text_file(os_path(testdir, "zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStartPre=/bin/echo starting B
            ExecStart=/usr/bin/testsleep 99
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(testdir, "zzc.service"), """
            [Unit]
            Description=Testing C
            [Service]
            Type=simple
            ExecStartPre=/bin/echo starting C
            ExecStart=/usr/bin/testsleep 111
            [Install]
            WantedBy=multi-user.target""")
        #
        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/ps || {package} install -y procps'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sx____(cmd.format(**locals()))
        if COVERAGE:
            cmd = "{docker} exec {testname} {package} install -y {python_coverage}"
            sx____(cmd.format(**locals()))
        self.prep_coverage(image, testname)
        cmd = "{docker} exec {testname} mkdir -p /etc/systemd/system /etc/systemd/user"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} cp /bin/sleep /usr/bin/testsleep"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zza.service {testname}:/etc/systemd/system/zza.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zzb.service {testname}:/etc/systemd/system/zzb.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zzc.service {testname}:/etc/systemd/system/zzc.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl enable zzb.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl enable zzc.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl --version"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl default-services -v"
        # sh____(cmd.format(**locals()))
        out2 = output(cmd.format(**locals()))
        logg.info("\n>\n%s", out2)
        #
        cmd = "{docker} commit -c 'CMD [\"/usr/bin/systemctl\",\"--init\",\"default\",\"-vv\"]'  {testname} {images}:{testname}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name {testname} {images}:{testname}"
        sh____(cmd.format(**locals()))
        time.sleep(3)
        #
        #
        cmd = "{docker} exec {testname} ps -eo pid,ppid,user,args"
        top = output(cmd.format(**locals()))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "testsleep 99"))
        self.assertTrue(greps(top, "testsleep 111"))
        #
        cmd = "{docker} logs {testname}"
        logs = output(cmd.format(**locals()))
        logg.info("------- docker logs\n>\n%s", logs)
        self.assertFalse(greps(logs, "starting B"))
        self.assertFalse(greps(logs, "starting C"))
        time.sleep(6) # INITLOOPS ticks at 5sec per default
        cmd = "{docker} logs {testname}"
        logs = output(cmd.format(**locals()))
        logg.info("------- docker logs\n>\n%s", logs)
        self.assertTrue(greps(logs, "starting B"))
        self.assertTrue(greps(logs, "starting C"))
        #
        cmd = "{docker} exec {testname} systemctl halt -vvvv"
        # sh____(cmd.format(**locals()))
        out3 = output(cmd.format(**locals()))
        logg.info("\n>\n%s", out3)
        #
        cmd = "{docker} exec {testname} ps -eo pid,ppid,user,args"
        top = output(cmd.format(**locals()))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, "testsleep 99"))
        self.assertFalse(greps(top, "testsleep 111"))
        #
        cmd = "{docker} logs {testname}"
        logs = output(cmd.format(**locals()))
        logg.info("------- docker logs\n>\n%s", logs)
        #
        self.save_coverage(testname)
        #
        cmd = "{docker} rmi {images}:{testname}"
        sx____(cmd.format(**locals()))
        self.rm_docker(testname)
        self.rm_testdir()
    def test_5530_systemctl_py_run_default_services_from_simple_saved_container(self) -> None:
        """ check that we can enable services in a docker container to be run as default-services
            after it has been restarted from a commit-saved container image (without any arg)"""
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        images = IMAGES
        image = self.local_image(COVERAGE or IMAGE or CENTOS)
        if _python.endswith("python3") and "centos:7" in image:
            if SKIP: self.skipTest("no python3 on centos:7")
        testname = self.testname()
        testdir = self.testdir()
        docker = _docker
        package = package_tool(image)
        refresh = refresh_tool(image)
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        python_coverage = coverage_package(image)
        systemctl_py = _systemctl_py
        images = IMAGES
        sometime = SOMETIME or 188
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A""")
        text_file(os_path(testdir, "zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart=/usr/bin/testsleep 99
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(testdir, "zzc.service"), """
            [Unit]
            Description=Testing C
            [Service]
            Type=simple
            ExecStart=/usr/bin/testsleep 111
            [Install]
            WantedBy=multi-user.target""")
        #
        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/ps || {package} install -y procps'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sx____(cmd.format(**locals()))
        if COVERAGE:
            cmd = "{docker} exec {testname} {package} install -y {python_coverage}"
            sx____(cmd.format(**locals()))
        self.prep_coverage(image, testname)
        cmd = "{docker} exec {testname} mkdir -p /etc/systemd/system /etc/systemd/user"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} cp /bin/sleep /usr/bin/testsleep"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zza.service {testname}:/etc/systemd/system/zza.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zzb.service {testname}:/etc/systemd/system/zzb.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zzc.service {testname}:/etc/systemd/system/zzc.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl enable zzb.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl enable zzc.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl --version"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl default-services -v"
        # sh____(cmd.format(**locals()))
        out2 = output(cmd.format(**locals()))
        logg.info("\n>\n%s", out2)
        #
        cmd = "{docker} commit -c 'CMD [\"/usr/bin/systemctl\"]'  {testname} {images}:{testname}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name {testname} {images}:{testname}"
        sh____(cmd.format(**locals()))
        time.sleep(3)
        #
        #
        cmd = "{docker} exec {testname} ps -eo pid,ppid,user,args"
        top = output(cmd.format(**locals()))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "testsleep 99"))
        self.assertTrue(greps(top, "testsleep 111"))
        #
        cmd = "{docker} exec {testname} systemctl halt -vvvv"
        # sh____(cmd.format(**locals()))
        out3 = output(cmd.format(**locals()))
        logg.info("\n>\n%s", out3)
        #
        cmd = "{docker} exec {testname} ps -eo pid,ppid,user,args"
        top = output(cmd.format(**locals()))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, "testsleep 99"))
        self.assertFalse(greps(top, "testsleep 111"))
        #
        #
        self.save_coverage(testname)
        #
        cmd = "{docker} rmi {images}:{testname}"
        sx____(cmd.format(**locals()))
        self.rm_docker(testname)
        self.rm_testdir()
    def test_5533_systemctl_py_run_default_services_from_single_service_saved_container(self) -> None:
        """ check that we can enable services in a docker container to be run as default-services
            after it has been restarted from a commit-saved container image"""
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        images = IMAGES
        image = self.local_image(COVERAGE or IMAGE or CENTOS)
        if _python.endswith("python3") and "centos:7" in image:
            if SKIP: self.skipTest("no python3 on centos:7")
        testname = self.testname()
        testdir = self.testdir()
        docker = _docker
        package = package_tool(image)
        refresh = refresh_tool(image)
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        python_coverage = coverage_package(image)
        systemctl_py = _systemctl_py
        sometime = SOMETIME or 188
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A""")
        text_file(os_path(testdir, "zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart=/usr/bin/testsleep 99
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(testdir, "zzc.service"), """
            [Unit]
            Description=Testing C
            [Service]
            Type=simple
            ExecStart=/usr/bin/testsleep 111
            [Install]
            WantedBy=multi-user.target""")
        #
        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/ps || {package} install -y procps'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sx____(cmd.format(**locals()))
        if COVERAGE:
            cmd = "{docker} exec {testname} {package} install -y {python_coverage}"
            sx____(cmd.format(**locals()))
        self.prep_coverage(image, testname)
        cmd = "{docker} exec {testname} mkdir -p /etc/systemd/system /etc/systemd/user"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} cp /bin/sleep /usr/bin/testsleep"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zza.service {testname}:/etc/systemd/system/zza.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zzb.service {testname}:/etc/systemd/system/zzb.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zzc.service {testname}:/etc/systemd/system/zzc.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl enable zzb.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl enable zzc.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl --version"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl default-services -v"
        # sh____(cmd.format(**locals()))
        out2 = output(cmd.format(**locals()))
        logg.info("\n>\n%s", out2)
        # .........................................vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
        cmd = "{docker} commit -c 'CMD [\"/usr/bin/systemctl\",\"init\",\"zzc.service\"]'  {testname} {images}:{testname}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name {testname} {images}:{testname}"
        sh____(cmd.format(**locals()))
        time.sleep(3)
        #
        #
        cmd = "{docker} exec {testname} ps -eo pid,ppid,user,args"
        top = output(cmd.format(**locals()))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, "testsleep 99")) # <<<<<<<<<< difference to 5033
        self.assertTrue(greps(top, "testsleep 111"))
        #
        cmd = "{docker} stop {testname}" # <<<
        # sh____(cmd.format(**locals()))
        out3 = output(cmd.format(**locals()))
        logg.info("\n>\n%s", out3)
        #
        cmd = "{docker} exec {testname} ps -eo pid,ppid,user,args"
        top = output(cmd.format(**locals()))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, "testsleep 99"))
        self.assertFalse(greps(top, "testsleep 111"))
        #
        #
        self.save_coverage(testname)
        #
        cmd = "{docker} rmi {images}:{testname}"
        sx____(cmd.format(**locals()))
        self.rm_docker(testname)
        self.rm_testdir()

    def test_5600_systemctl_py_list_units_running(self) -> None:
        """ check that we can enable services in a docker container to be run as default-services
            after it has been restarted and that we can filter the list of services shown"""
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        images = IMAGES
        image = self.local_image(COVERAGE or IMAGE or CENTOS)
        if _python.endswith("python3") and "centos:7" in image:
            if SKIP: self.skipTest("no python3 on centos:7")
        testname = self.testname()
        testdir = self.testdir()
        docker = _docker
        package = package_tool(image)
        refresh = refresh_tool(image)
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        python_coverage = coverage_package(image)
        systemctl_py = _systemctl_py
        sometime = SOMETIME or 188
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A""")
        text_file(os_path(testdir, "zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart=/usr/bin/testsleep 99
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(testdir, "zzc.service"), """
            [Unit]
            Description=Testing C
            [Service]
            Type=simple
            ExecStart=/usr/bin/testsleep 111
            [Install]
            WantedBy=multi-user.target""")
        #
        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/ps || {package} install -y procps'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sx____(cmd.format(**locals()))
        if COVERAGE:
            cmd = "{docker} exec {testname} {package} install -y {python_coverage}"
            sx____(cmd.format(**locals()))
        self.prep_coverage(image, testname)
        cmd = "{docker} exec {testname} mkdir -p /etc/systemd/system /etc/systemd/user"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} cp /bin/sleep /usr/bin/testsleep"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zza.service {testname}:/etc/systemd/system/zza.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zzb.service {testname}:/etc/systemd/system/zzb.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zzc.service {testname}:/etc/systemd/system/zzc.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl enable zzb.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl enable zzc.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl --version"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl default-services -v"
        # sh____(cmd.format(**locals()))
        out2 = output(cmd.format(**locals()))
        logg.info("\n>\n%s", out2)
        cmd = "{docker} exec {testname} bash -c 'grep nobody /etc/group || groupadd -g 65533 nobody'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} useradd -u 1001 somebody -g nobody -m"
        sh____(cmd.format(**locals()))
        # .........................................vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
        cmd = "{docker} commit -c 'CMD [\"/usr/bin/systemctl\"]'  {testname} {images}:{testname}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name {testname} {images}:{testname}"
        sh____(cmd.format(**locals()))
        time.sleep(3)
        #
        #
        cmd = "{docker} exec -u somebody {testname} ps -eo pid,ppid,user,args"
        top = output(cmd.format(**locals()))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "testsleep 99"))
        self.assertTrue(greps(top, "testsleep 111"))
        self.assertEqual(len(greps(top, "testsleep")), 2)
        self.assertEqual(len(greps(top, " 1 *.*systemctl")), 1)
        self.assertEqual(len(greps(top, " root ")), 3)
        self.assertEqual(len(greps(top, " somebody ")), 1)
        #
        check = "{docker} exec {testname} bash -c 'ls -ld /var/run/*.status; grep PID /var/run/*.status'"
        top = output(check.format(**locals()))
        logg.info("\n>>>\n%s", top)
        check = "{docker} exec {testname} systemctl list-units"
        top = output(check.format(**locals()))
        logg.info("\n>>>\n%s", top)
        self.assertEqual(len(greps(top, "zz")), 3)
        check = "{docker} exec {testname} systemctl list-units --state=running"
        top = output(check.format(**locals()))
        logg.info("\n>>>\n%s", top)
        self.assertEqual(len(greps(top, "zz")), 2)
        #
        cmd = "{docker} stop {testname}" # <<<
        # sh____(cmd.format(**locals()))
        out3 = output(cmd.format(**locals()))
        logg.info("\n>\n%s", out3)
        #
        self.save_coverage(testname)
        #
        cmd = "{docker} rmi {images}:{testname}"
        sx____(cmd.format(**locals()))
        self.rm_docker(testname)
        self.rm_testdir()

    def test_5700_systemctl_py_restart_failed_units(self) -> None:
        """ check that we can enable services in a docker container to be run as default-services
            and failed units are going to be restarted"""
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        images = IMAGES
        image = self.local_image(COVERAGE or IMAGE or CENTOS)
        if _python.endswith("python3") and "centos:7" in image:
            if SKIP: self.skipTest("no python3 on centos:7")
        testname = self.testname()
        testdir = self.testdir()
        docker = _docker
        package = package_tool(image)
        refresh = refresh_tool(image)
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        python_coverage = coverage_package(image)
        systemctl_py = _systemctl_py
        sometime = SOMETIME or 188
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart=/usr/bin/testsleepA 55
            Restart=on-failure
            RestartSec=5
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(testdir, "zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart=/usr/bin/testsleepB 99
            Restart=on-failure
            RestartSec=9
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(testdir, "zzc.service"), """
            [Unit]
            Description=Testing C
            [Service]
            Type=simple
            ExecStart=/usr/bin/testsleepC 111
            Restart=on-failure
            RestartSec=11
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(testdir, "zzd.service"), """
            [Unit]
            Description=Testing D
            [Service]
            Type=simple
            ExecStart=/usr/bin/testsleepD 122
            [Install]
            WantedBy=multi-user.target""")
        #
        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/ps || {package} install -y procps'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sx____(cmd.format(**locals()))
        if COVERAGE:
            cmd = "{docker} exec {testname} {package} install -y {python_coverage}"
            sx____(cmd.format(**locals()))
        self.prep_coverage(image, testname)
        cmd = "{docker} exec {testname} mkdir -p /etc/systemd/system /etc/systemd/user"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} cp /bin/sleep /usr/bin/testsleepA"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} cp /bin/sleep /usr/bin/testsleepB"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} cp /bin/sleep /usr/bin/testsleepC"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} cp /bin/sleep /usr/bin/testsleepD"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp /usr/bin/killall {testname}:/usr/local/bin/killall"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zza.service {testname}:/etc/systemd/system/zza.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zzb.service {testname}:/etc/systemd/system/zzb.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zzc.service {testname}:/etc/systemd/system/zzc.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zzd.service {testname}:/etc/systemd/system/zzd.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl enable zza.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl enable zzb.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl enable zzc.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl enable zzd.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl --version"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl default-services -v"
        # sh____(cmd.format(**locals()))
        out2 = output(cmd.format(**locals()))
        logg.info("\n>\n%s", out2)
        cmd = "{docker} exec {testname} bash -c 'grep nobody /etc/group || groupadd -g 65533 nobody'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} useradd -u 1001 somebody -g nobody -m"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} touch /var/log/systemctl.debug.log"
        sh____(cmd.format(**locals()))
        # .........................................vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
        cmd = "{docker} commit -c 'CMD [\"/usr/bin/systemctl\"]'  {testname} {images}:{testname}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name {testname} {images}:{testname}"
        sh____(cmd.format(**locals()))
        time.sleep(3)
        #
        #
        cmd = "{docker} exec -u somebody {testname} ps -eo pid,ppid,user,args"
        top = output(cmd.format(**locals()))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "testsleepA"))
        self.assertTrue(greps(top, "testsleepB"))
        self.assertTrue(greps(top, "testsleepC"))
        self.assertTrue(greps(top, "testsleepD"))
        self.assertEqual(len(greps(top, "testsleep")), 4)
        self.assertEqual(len(greps(top, " 1 *.*systemctl")), 1)
        self.assertEqual(len(greps(top, " root ")), 5)
        self.assertEqual(len(greps(top, " somebody ")), 1)
        #
        InitLoopSleep = 5
        time.sleep(InitLoopSleep+1)
        cmd = "{docker} cp {testname}:/var/log/systemctl.debug.log {testdir}/systemctl.debug.log"
        sh____(cmd.format(**locals()))
        check = "{docker} exec {testname} systemctl list-units --state=running --type=service"
        top = output(check.format(**locals()))
        logg.info("\n>>>\n%s", top)
        self.assertEqual(len(greps(top, "zz")), 4)
        #
        cmd = "{docker} cp {testname}:/var/log/systemctl.debug.log {testdir}/systemctl.debug.log"
        sh____(cmd.format(**locals()))
        log = lines(open(testdir+"/systemctl.debug.log"))
        # logg.info("systemctl.debug.log>\n\t%s", "\n\t".join(log))
        self.assertFalse(greps(log, "restart"))
        #
        cmd = "{docker} exec {testname} killall testsleepD" # <<<
        sh____(cmd.format(**locals()))
        #
        time.sleep(InitLoopSleep+1)
        cmd = "{docker} cp {testname}:/var/log/systemctl.debug.log {testdir}/systemctl.debug.log"
        sh____(cmd.format(**locals()))
        log = lines(open(testdir+"/systemctl.debug.log"))
        # logg.info("systemctl.debug.log>\n\t%s", "\n\t".join(log))
        self.assertFalse(greps(log, "restart"))
        #
        check = "{docker} exec {testname} systemctl list-units --state=running --type=service"
        top = output(check.format(**locals()))
        logg.info("\n>>>\n%s", top)
        self.assertEqual(len(greps(top, "zz")), 3)
        #
        cmd = "{docker} exec {testname} killall testsleepC" # <<<
        sh____(cmd.format(**locals()))
        #
        check = "{docker} exec {testname} systemctl list-units --state=running --type=service"
        top = output(check.format(**locals()))
        logg.info("\n>>>\n%s", top)
        self.assertEqual(len(greps(top, "zz")), 2)
        #
        time.sleep(InitLoopSleep+1) # max 5sec but RestartSec=9
        #
        check = "{docker} exec {testname} systemctl list-units --state=running --type=service"
        top = output(check.format(**locals()))
        logg.info("\n>>>\n%s", top)
        self.assertEqual(len(greps(top, "zz")), 2)
        #
        time.sleep(10) # to have RestartSec=9
        #
        check = "{docker} exec {testname} systemctl list-units --state=running --type=service"
        top = output(check.format(**locals()))
        logg.info("\n>>>\n%s", top)
        self.assertEqual(len(greps(top, "zz")), 3)
        #
        time.sleep(InitLoopSleep+1)
        cmd = "{docker} cp {testname}:/var/log/systemctl.debug.log {testdir}/systemctl.debug.log"
        sh____(cmd.format(**locals()))
        log = lines(open(testdir+"/systemctl.debug.log"))
        logg.info("systemctl.debug.log>\n\t%s", "\n\t".join(log))
        self.assertTrue(greps(log, "restart"))
        #
        self.assertTrue(greps(log, ".zzc.service. --- restarting failed unit"))
        self.assertTrue(greps(log, ".zzd.service. Current NoCheck .Restart=no."))
        #
        cmd = "{docker} stop {testname}" # <<<
        # sh____(cmd.format(**locals()))
        out3 = output(cmd.format(**locals()))
        logg.info("\n>\n%s", out3)
        #
        self.save_coverage(testname)
        #
        cmd = "{docker} cp {testname}:/var/log/systemctl.debug.log {testdir}/systemctl.debug.log"
        sh____(cmd.format(**locals()))
        log = lines(open(testdir+"/systemctl.debug.log"))
        #
        cmd = "{docker} rmi {images}:{testname}"
        sx____(cmd.format(**locals()))
        self.rm_docker(testname)
        self.rm_testdir()
    def test_5881_set_user(self) -> None:
        """ check that we can run a service with User= settings (for coverage) """
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        images = IMAGES
        image = self.local_image(COVERAGE or IMAGE or CENTOS)
        if _python.endswith("python3") and "centos:7" in image:
            if SKIP: self.skipTest("no python3 on centos:7")
        self.begin()
        self.rm_testdir()
        testname = self.testname()
        testdir = self.testdir()
        docker = _docker
        package = package_tool(image)
        refresh = refresh_tool(image)
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        python_coverage = coverage_package(image)
        systemctl_py = _systemctl_py
        sometime = SOMETIME or 188
        cov_option = "--system"
        if COVERAGE:
            cov_option = "-c EXEC_SPAWN=True -c EXEC_DUP2=False"
        testsleepA = self.testname("sleepA")
        bindir="/usr/bin"
        this_user="somebody"
        this_group="nobody"
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepA} 1
            User={this_user}
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        #
        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/ps || {package} install -y procps'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sx____(cmd.format(**locals()))
        if COVERAGE:
            cmd = "{docker} exec {testname} {package} install -y {python_coverage}"
            sx____(cmd.format(**locals()))
            cmd = "{docker} exec {testname} sed -i 's/raise *$/pass/' /usr/lib64/python3.6/site-packages/coverage/misc.py"
            sx____(cmd.format(**locals()))
        self.prep_coverage(image, testname, cov_option)
        #
        cmd = "{docker} exec {testname} mkdir -p /etc/systemd/system /etc/systemd/user"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} cp /bin/sleep /usr/bin/{testsleepA}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zza.service {testname}:/etc/systemd/system/zza.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl --version"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'grep nobody /etc/group || groupadd -g 65533 nobody'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} useradd -u 1001 somebody -g nobody -m"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} touch /var/log/systemctl.debug.log"
        sh____(cmd.format(**locals()))
        #
        cmd = "{docker} exec {testname} systemctl start zza.service -vvvv"
        out, err, rc = output3(cmd.format(**locals()))
        logg.info("\n>>>(%s)\n%s\n%s", rc, i2(err), out)
        if not COVERAGE:
            self.assertEqual(rc, 0)
        #
        cmd = "{docker} exec -u somebody {testname} ps -eo pid,ppid,euser,egroup,supgrp,args"
        top = clean(output(cmd.format(**locals())))
        logg.info("\n>>>\n%s", top)
        if not COVERAGE:
            self.assertTrue(greps(top, "somebody *nobody *nobody .*{testsleepA}".format(**locals())))
        #
        cmd = "{docker} exec {testname} find /tmp/ -name '.coverage*'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} stop {testname}"
        sh____(cmd.format(**locals()))
        self.save_coverage(testname)
        #
        cmd = "{docker} rmi {images}:{testname}"
        sx____(cmd.format(**locals()))
        self.rm_docker(testname)
        self.rm_testdir()
        self.end()
    def test_5882_set_user_and_group(self) -> None:
        """ check that we can run a service with User= Group= settings (for coverage) """
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        images = IMAGES
        image = self.local_image(COVERAGE or IMAGE or CENTOS)
        if _python.endswith("python3") and "centos:7" in image:
            if SKIP: self.skipTest("no python3 on centos:7")
        self.begin()
        self.rm_testdir()
        testname = self.testname()
        testdir = self.testdir()
        docker = _docker
        package = package_tool(image)
        refresh = refresh_tool(image)
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        python_coverage = coverage_package(image)
        systemctl_py = _systemctl_py
        sometime = SOMETIME or 188
        cov_option = "--system"
        if COVERAGE:
            cov_option = "-c EXEC_SPAWN=True -c EXEC_DUP2=False"
        testsleepA = self.testname("sleepA")
        bindir="/usr/bin"
        this_user="somebody"
        this_group="nobody"
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepA} 1
            User={this_user}
            Group={this_group}
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        #
        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/ps || {package} install -y procps'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sx____(cmd.format(**locals()))
        if COVERAGE:
            cmd = "{docker} exec {testname} {package} install -y {python_coverage}"
            sx____(cmd.format(**locals()))
        self.prep_coverage(image, testname)
        #
        cmd = "{docker} exec {testname} mkdir -p /etc/systemd/system /etc/systemd/user"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} cp /bin/sleep /usr/bin/{testsleepA}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zza.service {testname}:/etc/systemd/system/zza.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl --version"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'grep nobody /etc/group || groupadd -g 65533 nobody'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} useradd -u 1001 somebody -g nobody -m"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} touch /var/log/systemctl.debug.log"
        sh____(cmd.format(**locals()))
        #
        cmd = "{docker} exec {testname} systemctl  start zza.service -vvvv"
        out, err, rc = output3(cmd.format(**locals()))
        logg.info("\n>>>(%s)\n%s\n%s", rc, i2(err), out)
        if not COVERAGE:
            self.assertEqual(rc, 0)
        #
        cmd = "{docker} exec -u somebody {testname} ps -eo pid,ppid,euser,egroup,supgrp,args"
        top = clean(output(cmd.format(**locals())))
        logg.info("\n>>>\n%s", top)
        if not COVERAGE:
            self.assertTrue(greps(top, "somebody *nobody *nobody .*{testsleepA}".format(**locals())))
        #
        cmd = "{docker} stop {testname}"
        sh____(cmd.format(**locals()))
        self.save_coverage(testname)
        #
        cmd = "{docker} rmi {images}:{testname}"
        sx____(cmd.format(**locals()))
        self.rm_docker(testname)
        self.rm_testdir()
        self.end()
    def test_5883_set_group(self) -> None:
        """ check that we can run a service with Group= settings (for coverage) """
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        images = IMAGES
        image = self.local_image(COVERAGE or IMAGE or CENTOS)
        if _python.endswith("python3") and "centos:7" in image:
            if SKIP: self.skipTest("no python3 on centos:7")
        self.begin()
        self.rm_testdir()
        testname = self.testname()
        testdir = self.testdir()
        docker = _docker
        package = package_tool(image)
        refresh = refresh_tool(image)
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        python_coverage = coverage_package(image)
        systemctl_py = _systemctl_py
        sometime = SOMETIME or 188
        cov_option = "--system"
        if COVERAGE:
            cov_option = "-c EXEC_SPAWN=True -c EXEC_DUP2=False"
        testsleepA = self.testname("sleepA")
        bindir="/usr/bin"
        this_user="somebody"
        this_group="nobody"
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepA} 1
            Group={this_group}
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        #
        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/ps || {package} install -y procps'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sx____(cmd.format(**locals()))
        if COVERAGE:
            cmd = "{docker} exec {testname} {package} install -y {python_coverage}"
            sx____(cmd.format(**locals()))
        self.prep_coverage(image, testname)
        #
        cmd = "{docker} exec {testname} mkdir -p /etc/systemd/system /etc/systemd/user"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} cp /bin/sleep /usr/bin/{testsleepA}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zza.service {testname}:/etc/systemd/system/zza.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl --version"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'grep nobody /etc/group || groupadd -g 65533 nobody'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} useradd -u 1001 somebody -g nobody -m"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} touch /var/log/systemctl.debug.log"
        sh____(cmd.format(**locals()))
        #
        cmd = "{docker} exec {testname} systemctl  start zza.service -vvvv"
        out, err, rc = output3(cmd.format(**locals()))
        logg.info("\n>>>(%s)\n%s\n%s", rc, i2(err), out)
        if not COVERAGE:
            self.assertEqual(rc, 0)
        #
        cmd = "{docker} exec -u somebody {testname} ps -eo pid,ppid,euser,egroup,supgrp,args"
        top = clean(output(cmd.format(**locals())))
        logg.info("\n>>>\n%s", top)
        if not COVERAGE:
            self.assertTrue(greps(top, "root *nobody *nobody .*{testsleepA}".format(**locals())))
        #
        cmd = "{docker} stop {testname}"
        sh____(cmd.format(**locals()))
        self.save_coverage(testname)
        #
        cmd = "{docker} rmi {images}:{testname}"
        sx____(cmd.format(**locals()))
        self.rm_docker(testname)
        self.rm_testdir()
        self.end()
    def test_5884_set_user_and_group_and_supp_group(self) -> None:
        """ check that we can run a service with User= Group= SupplementaryGroups= settings (for coverage) """
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        images = IMAGES
        image = self.local_image(COVERAGE or IMAGE or CENTOS)
        if _python.endswith("python3") and "centos:7" in image:
            if SKIP: self.skipTest("no python3 on centos:7")
        self.begin()
        self.rm_testdir()
        testname = self.testname()
        testdir = self.testdir()
        docker = _docker
        package = package_tool(image)
        refresh = refresh_tool(image)
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        python_coverage = coverage_package(image)
        systemctl_py = _systemctl_py
        sometime = SOMETIME or 188
        cov_option = "--system"
        if COVERAGE:
            cov_option = "-c EXEC_SPAWN=True -c EXEC_DUP2=False"
        testsleepA = self.testname("sleepA")
        bindir="/usr/bin"
        this_user="somebody"
        this_group="nobody"
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepA} 1
            User={this_user}
            Group={this_group}
            SupplementaryGroups={this_group}
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        #
        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/ps || {package} install -y procps'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sx____(cmd.format(**locals()))
        if COVERAGE:
            cmd = "{docker} exec {testname} {package} install -y {python_coverage}"
            sx____(cmd.format(**locals()))
        self.prep_coverage(image, testname)
        #
        cmd = "{docker} exec {testname} mkdir -p /etc/systemd/system /etc/systemd/user"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} cp /bin/sleep /usr/bin/{testsleepA}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zza.service {testname}:/etc/systemd/system/zza.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl --version"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'grep nobody /etc/group || groupadd -g 65533 nobody'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} useradd -u 1001 somebody -g nobody -m"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} touch /var/log/systemctl.debug.log"
        sh____(cmd.format(**locals()))
        #
        cmd = "{docker} exec {testname} systemctl start zza.service -vvvv"
        out, err, rc = output3(cmd.format(**locals()))
        logg.info("\n>>>(%s)\n%s\n%s", rc, i2(err), out)
        if not COVERAGE:
            self.assertEqual(rc, 0)
        #
        cmd = "{docker} exec -u somebody {testname} ps -eo pid,ppid,euser,egroup,supgrp,args"
        top = clean(output(cmd.format(**locals())))
        logg.info("\n>>>\n%s", top)
        if not COVERAGE:
            self.assertTrue(greps(top, "somebody *nobody *nobody .*{testsleepA}".format(**locals())))
        #
        cmd = "{docker} stop {testname}"
        sh____(cmd.format(**locals()))
        self.save_coverage(testname)
        #
        cmd = "{docker} rmi {images}:{testname}"
        sx____(cmd.format(**locals()))
        self.rm_docker(testname)
        self.rm_testdir()
        self.end()
    def test_5885_set_user_and_supp_group(self) -> None:
        """ check that we can run a service with User= SupplementaryGroups= extra (for coverage) """
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        images = IMAGES
        image = self.local_image(COVERAGE or IMAGE or CENTOS)
        if _python.endswith("python3") and "centos:7" in image:
            if SKIP: self.skipTest("no python3 on centos:7")
        self.begin()
        self.rm_testdir()
        testname = self.testname()
        testdir = self.testdir()
        docker = _docker
        package = package_tool(image)
        refresh = refresh_tool(image)
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        python_coverage = coverage_package(image)
        systemctl_py = _systemctl_py
        sometime = SOMETIME or 188
        cov_option = "--system"
        if COVERAGE:
            cov_option = "-c EXEC_SPAWN=True -c EXEC_DUP2=False"
        testsleepA = self.testname("sleepA")
        bindir="/usr/bin"
        this_user="somebody"
        this_group="nobody"
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepA} 1
            User={this_user}
            SupplementaryGroups={this_group}
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        #
        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/ps || {package} install -y procps'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sx____(cmd.format(**locals()))
        if COVERAGE:
            cmd = "{docker} exec {testname} {package} install -y {python_coverage}"
            sx____(cmd.format(**locals()))
        self.prep_coverage(image, testname, cov_option)
        #
        cmd = "{docker} exec {testname} mkdir -p /etc/systemd/system /etc/systemd/user"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} cp /bin/sleep /usr/bin/{testsleepA}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zza.service {testname}:/etc/systemd/system/zza.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl --version"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'grep nobody /etc/group || groupadd -g 65533 nobody'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} useradd -u 1001 somebody -g nobody -m"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} touch /var/log/systemctl.debug.log"
        sh____(cmd.format(**locals()))
        #
        cmd = "{docker} exec {testname} systemctl start zza.service -vvvv"
        out, err, rc = output3(cmd.format(**locals()))
        logg.info("\n>>>(%s)\n%s\n%s", rc, i2(err), out)
        if not COVERAGE:
            self.assertEqual(rc, 0)
        #
        cmd = "{docker} exec -u somebody {testname} ps -eo pid,ppid,euser,egroup,supgrp,args"
        top = clean(output(cmd.format(**locals())))
        logg.info("\n>>>\n%s", top)
        if not COVERAGE:
            self.assertTrue(greps(top, "somebody *nobody *nobody .*{testsleepA}".format(**locals())))
        #
        cmd = "{docker} stop {testname}"
        sh____(cmd.format(**locals()))
        self.save_coverage(testname)
        #
        cmd = "{docker} rmi {images}:{testname}"
        sx____(cmd.format(**locals()))
        self.rm_docker(testname)
        self.rm_testdir()
        self.end()
    def test_5886_set_user_and_new_group(self) -> None:
        """ check that we can run a service with User= Group= settings (for coverage) """
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        images = IMAGES
        image = self.local_image(COVERAGE or IMAGE or CENTOS)
        if _python.endswith("python3") and "centos:7" in image:
            if SKIP: self.skipTest("no python3 on centos:7")
        self.begin()
        self.rm_testdir()
        testname = self.testname()
        testdir = self.testdir()
        docker = _docker
        package = package_tool(image)
        refresh = refresh_tool(image)
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        python_coverage = coverage_package(image)
        systemctl_py = _systemctl_py
        sometime = SOMETIME or 188
        cov_option = "--system"
        if COVERAGE:
            cov_option = "-c EXEC_SPAWN=True -c EXEC_DUP2=False"
        testsleepA = self.testname("sleepA")
        bindir="/usr/bin"
        this_user="somebody"
        this_group="nobody"
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepA} 1
            User={this_user}
            Group=wheel
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        #
        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/ps || {package} install -y procps'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sx____(cmd.format(**locals()))
        if COVERAGE:
            cmd = "{docker} exec {testname} {package} install -y {python_coverage}"
            sx____(cmd.format(**locals()))
        self.prep_coverage(image, testname)
        #
        cmd = "{docker} exec {testname} mkdir -p /etc/systemd/system /etc/systemd/user"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} cp /bin/sleep /usr/bin/{testsleepA}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zza.service {testname}:/etc/systemd/system/zza.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl --version"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'grep nobody /etc/group || groupadd -g 65533 nobody'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'grep wheel /etc/group || groupadd -g 87 wheel'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} useradd -u 1001 somebody -g nobody -m"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} touch /var/log/systemctl.debug.log"
        sh____(cmd.format(**locals()))
        #
        cmd = "{docker} exec {testname} systemctl  start zza.service -vvvv"
        out, err, rc = output3(cmd.format(**locals()))
        logg.info("\n>>>(%s)\n%s\n%s", rc, i2(err), out)
        if not COVERAGE:
            self.assertEqual(rc, 0)
        #
        cmd = "{docker} exec -u somebody {testname} ps -eo pid,ppid,euser,egroup,supgrp,args"
        top = clean(output(cmd.format(**locals())))
        logg.info("\n>>>\n%s", top)
        if not COVERAGE:
            self.assertTrue(greps(top, "somebody *wheel *wheel .*{testsleepA}".format(**locals())))
        #
        cmd = "{docker} stop {testname}"
        sh____(cmd.format(**locals()))
        self.save_coverage(testname)
        #
        cmd = "{docker} rmi {images}:{testname}"
        sx____(cmd.format(**locals()))
        self.rm_docker(testname)
        self.rm_testdir()
        self.end()
    def test_5887_set_new_group(self) -> None:
        """ check that we can run a service with Group= settings (for coverage) """
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        images = IMAGES
        image = self.local_image(COVERAGE or IMAGE or CENTOS)
        if _python.endswith("python3") and "centos:7" in image:
            if SKIP: self.skipTest("no python3 on centos:7")
        self.begin()
        self.rm_testdir()
        testname = self.testname()
        testdir = self.testdir()
        docker = _docker
        package = package_tool(image)
        refresh = refresh_tool(image)
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        python_coverage = coverage_package(image)
        systemctl_py = _systemctl_py
        sometime = SOMETIME or 188
        cov_option = "--system"
        if COVERAGE:
            cov_option = "-c EXEC_SPAWN=True -c EXEC_DUP2=False"
        testsleepA = self.testname("sleepA")
        bindir="/usr/bin"
        this_user="somebody"
        this_group="nobody"
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepA} 1
            Group=wheel
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        #
        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/ps || {package} install -y procps'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sx____(cmd.format(**locals()))
        if COVERAGE:
            cmd = "{docker} exec {testname} {package} install -y {python_coverage}"
            sx____(cmd.format(**locals()))
        self.prep_coverage(image, testname)
        #
        cmd = "{docker} exec {testname} mkdir -p /etc/systemd/system /etc/systemd/user"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} cp /bin/sleep /usr/bin/{testsleepA}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zza.service {testname}:/etc/systemd/system/zza.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl --version"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'grep nobody /etc/group || groupadd -g 65533 nobody'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'grep wheel /etc/group || groupadd -g 87 wheel'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} useradd -u 1001 somebody -g nobody -m"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} touch /var/log/systemctl.debug.log"
        sh____(cmd.format(**locals()))
        #
        cmd = "{docker} exec {testname} systemctl  start zza.service -vvvv"
        out, err, rc = output3(cmd.format(**locals()))
        logg.info("\n>>>(%s)\n%s\n%s", rc, i2(err), out)
        if not COVERAGE:
            self.assertEqual(rc, 0)
        #
        cmd = "{docker} exec -u somebody {testname} ps -eo pid,ppid,euser,egroup,supgrp,args"
        top = clean(output(cmd.format(**locals())))
        logg.info("\n>>>\n%s", top)
        if not COVERAGE:
            self.assertTrue(greps(top, "root *wheel *wheel .*{testsleepA}".format(**locals())))
        #
        cmd = "{docker} stop {testname}"
        sh____(cmd.format(**locals()))
        self.save_coverage(testname)
        #
        cmd = "{docker} rmi {images}:{testname}"
        sx____(cmd.format(**locals()))
        self.rm_docker(testname)
        self.rm_testdir()
        self.end()
    def test_5888_set_user_and_new_group_and_supp_group(self) -> None:
        """ check that we can run a service with User= Group= SupplementaryGroups= settings (for coverage) """
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        images = IMAGES
        image = self.local_image(COVERAGE or IMAGE or CENTOS)
        if _python.endswith("python3") and "centos:7" in image:
            if SKIP: self.skipTest("no python3 on centos:7")
        self.begin()
        self.rm_testdir()
        testname = self.testname()
        testdir = self.testdir()
        docker = _docker
        package = package_tool(image)
        refresh = refresh_tool(image)
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        python_coverage = coverage_package(image)
        systemctl_py = _systemctl_py
        sometime = SOMETIME or 188
        cov_option = "--system"
        if COVERAGE:
            cov_option = "-c EXEC_SPAWN=True -c EXEC_DUP2=False"
        testsleepA = self.testname("sleepA")
        bindir="/usr/bin"
        this_user="somebody"
        this_group="nobody"
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepA} 1
            User={this_user}
            Group=wheel
            SupplementaryGroups={this_group}
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        #
        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/ps || {package} install -y procps'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sx____(cmd.format(**locals()))
        if COVERAGE:
            cmd = "{docker} exec {testname} {package} install -y {python_coverage}"
            sx____(cmd.format(**locals()))
        self.prep_coverage(image, testname)
        #
        cmd = "{docker} exec {testname} mkdir -p /etc/systemd/system /etc/systemd/user"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} cp /bin/sleep /usr/bin/{testsleepA}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zza.service {testname}:/etc/systemd/system/zza.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl --version"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'grep nobody /etc/group || groupadd -g 65533 nobody'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'grep wheel /etc/group || groupadd -g 87 wheel'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} useradd -u 1001 somebody -g nobody -m"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} touch /var/log/systemctl.debug.log"
        sh____(cmd.format(**locals()))
        #
        cmd = "{docker} exec {testname} systemctl start zza.service -vvvv"
        out, err, rc = output3(cmd.format(**locals()))
        logg.info("\n>>>(%s)\n%s\n%s", rc, i2(err), out)
        if not COVERAGE:
            self.assertEqual(rc, 0)
        #
        cmd = "{docker} exec -u somebody {testname} ps -eo pid,ppid,euser,egroup,supgrp,args"
        top = clean(output(cmd.format(**locals())))
        logg.info("\n>>>\n%s", top)
        if not COVERAGE:
            self.assertTrue(greps(top, "somebody *wheel *nobody .*{testsleepA}".format(**locals())))
        #
        cmd = "{docker} stop {testname}"
        sh____(cmd.format(**locals()))
        self.save_coverage(testname)
        #
        cmd = "{docker} rmi {images}:{testname}"
        sx____(cmd.format(**locals()))
        self.rm_docker(testname)
        self.rm_testdir()
        self.end()
    def test_5889_set_user_and_new_supp_group(self) -> None:
        """ check that we can run a service with User= SupplementaryGroups= extra (for coverage) """
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        images = IMAGES
        image = self.local_image(COVERAGE or IMAGE or CENTOS)
        if _python.endswith("python3") and "centos:7" in image:
            if SKIP: self.skipTest("no python3 on centos:7")
        self.begin()
        self.rm_testdir()
        testname = self.testname()
        testdir = self.testdir()
        docker = _docker
        package = package_tool(image)
        refresh = refresh_tool(image)
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        python_coverage = coverage_package(image)
        systemctl_py = _systemctl_py
        sometime = SOMETIME or 188
        cov_option = "--system"
        if COVERAGE:
            cov_option = "-c EXEC_SPAWN=True -c EXEC_DUP2=False"
        testsleepA = self.testname("sleepA")
        bindir="/usr/bin"
        this_user="somebody"
        this_group="nobody"
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepA} 1
            User={this_user}
            SupplementaryGroups=wheel
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        #
        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/ps || {package} install -y procps'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sx____(cmd.format(**locals()))
        if COVERAGE:
            cmd = "{docker} exec {testname} {package} install -y {python_coverage}"
            sx____(cmd.format(**locals()))
        self.prep_coverage(image, testname, cov_option)
        #
        cmd = "{docker} exec {testname} mkdir -p /etc/systemd/system /etc/systemd/user"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} cp /bin/sleep /usr/bin/{testsleepA}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zza.service {testname}:/etc/systemd/system/zza.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl --version"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'grep nobody /etc/group || groupadd -g 65533 nobody'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'grep wheel /etc/group || groupadd -g 87 wheel'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} useradd -u 1001 somebody -g nobody -m"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} touch /var/log/systemctl.debug.log"
        sh____(cmd.format(**locals()))
        #
        cmd = "{docker} exec {testname} systemctl start zza.service -vvvv"
        out, err, rc = output3(cmd.format(**locals()))
        logg.info("\n>>>(%s)\n%s\n%s", rc, i2(err), out)
        if not COVERAGE:
            self.assertEqual(rc, 0)
        #
        cmd = "{docker} exec -u somebody {testname} ps -eo pid,ppid,euser,egroup,supgrp,args"
        top = clean(output(cmd.format(**locals())))
        logg.info("\n>>>\n%s", top)
        if not COVERAGE:
            self.assertTrue(greps(top, "somebody *nobody *wheel .*{testsleepA}".format(**locals())))
        #
        cmd = "{docker} stop {testname}"
        sh____(cmd.format(**locals()))
        self.save_coverage(testname)
        #
        cmd = "{docker} rmi {images}:{testname}"
        sx____(cmd.format(**locals()))
        self.rm_docker(testname)
        self.rm_testdir()
        self.end()
    def test_5891_set_user(self) -> None:
        """ check that we can run a service with User= settings (for coverage) """
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        images = IMAGES
        image = self.local_image(COVERAGE or IMAGE or CENTOS)
        if _python.endswith("python3") and "centos:7" in image:
            if SKIP: self.skipTest("no python3 on centos:7")
        self.begin()
        self.rm_testdir()
        testname = self.testname()
        testdir = self.testdir()
        docker = _docker
        package = package_tool(image)
        refresh = refresh_tool(image)
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        python_coverage = coverage_package(image)
        systemctl_py = _systemctl_py
        sometime = SOMETIME or 188
        cov_option = "--system"
        if COVERAGE:
            cov_option = "-c EXEC_SPAWN=True -c EXEC_DUP2=False"
        testsleepA = self.testname("sleepA")
        bindir="/usr/bin"
        this_user="somebody"
        this_group="nobody"
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepA} 1
            User={this_user}
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        #
        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/ps || {package} install -y procps'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sx____(cmd.format(**locals()))
        if COVERAGE:
            cmd = "{docker} exec {testname} {package} install -y {python_coverage}"
            sx____(cmd.format(**locals()))
            cmd = "{docker} exec {testname} sed -i 's/raise *$/pass/' /usr/lib64/python3.6/site-packages/coverage/misc.py"
            sx____(cmd.format(**locals()))
        self.prep_coverage(image, testname, cov_option)
        #
        cmd = "{docker} exec {testname} mkdir -p /etc/systemd/system /etc/systemd/user"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} cp /bin/sleep /usr/bin/{testsleepA}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zza.service {testname}:/etc/systemd/system/zza.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl --version"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'grep nobody /etc/group || groupadd -g 65533 nobody'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'grep trusted /etc/group || groupadd -g 88 trusted'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} useradd -u 1001 somebody -g nobody -G trusted -m"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} touch /var/log/systemctl.debug.log"
        sh____(cmd.format(**locals()))
        #
        cmd = "{docker} exec {testname} systemctl start zza.service -vvvv"
        out, err, rc = output3(cmd.format(**locals()))
        logg.info("\n>>>(%s)\n%s\n%s", rc, i2(err), out)
        if not COVERAGE:
            self.assertEqual(rc, 0)
        #
        cmd = "{docker} exec -u somebody {testname} ps -eo pid,ppid,euser,egroup,supgrp,args"
        top = clean(output(cmd.format(**locals())))
        logg.info("\n>>>\n%s", top)
        if not COVERAGE:
            self.assertTrue(greps(top, "somebody *nobody *trusted .*{testsleepA}".format(**locals())))
        #
        cmd = "{docker} exec {testname} find /tmp/ -name '.coverage*'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} stop {testname}"
        sh____(cmd.format(**locals()))
        self.save_coverage(testname)
        #
        cmd = "{docker} rmi {images}:{testname}"
        sx____(cmd.format(**locals()))
        self.rm_docker(testname)
        self.rm_testdir()
        self.end()
    def test_5892_set_user_and_group(self) -> None:
        """ check that we can run a service with User= Group= settings (for coverage) """
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        images = IMAGES
        image = self.local_image(COVERAGE or IMAGE or CENTOS)
        if _python.endswith("python3") and "centos:7" in image:
            if SKIP: self.skipTest("no python3 on centos:7")
        self.begin()
        self.rm_testdir()
        testname = self.testname()
        testdir = self.testdir()
        docker = _docker
        package = package_tool(image)
        refresh = refresh_tool(image)
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        python_coverage = coverage_package(image)
        systemctl_py = _systemctl_py
        sometime = SOMETIME or 188
        cov_option = "--system"
        if COVERAGE:
            cov_option = "-c EXEC_SPAWN=True -c EXEC_DUP2=False"
        testsleepA = self.testname("sleepA")
        bindir="/usr/bin"
        this_user="somebody"
        this_group="nobody"
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepA} 1
            User={this_user}
            Group={this_group}
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        #
        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/ps || {package} install -y procps'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sx____(cmd.format(**locals()))
        if COVERAGE:
            cmd = "{docker} exec {testname} {package} install -y {python_coverage}"
            sx____(cmd.format(**locals()))
        self.prep_coverage(image, testname)
        #
        cmd = "{docker} exec {testname} mkdir -p /etc/systemd/system /etc/systemd/user"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} cp /bin/sleep /usr/bin/{testsleepA}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zza.service {testname}:/etc/systemd/system/zza.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl --version"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'grep nobody /etc/group || groupadd -g 65533 nobody'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'grep trusted /etc/group || groupadd -g 88 trusted'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} useradd -u 1001 somebody -g nobody -G trusted -m"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} touch /var/log/systemctl.debug.log"
        sh____(cmd.format(**locals()))
        #
        cmd = "{docker} exec {testname} systemctl  start zza.service -vvvv"
        out, err, rc = output3(cmd.format(**locals()))
        logg.info("\n>>>(%s)\n%s\n%s", rc, i2(err), out)
        if not COVERAGE:
            self.assertEqual(rc, 0)
        #
        cmd = "{docker} exec -u somebody {testname} ps -eo pid,ppid,euser,egroup,supgrp,args"
        top = clean(output(cmd.format(**locals())))
        logg.info("\n>>>\n%s", top)
        if not COVERAGE:
            self.assertTrue(greps(top, "somebody *nobody *trusted .*{testsleepA}".format(**locals())))
        #
        cmd = "{docker} stop {testname}"
        sh____(cmd.format(**locals()))
        self.save_coverage(testname)
        #
        cmd = "{docker} rmi {images}:{testname}"
        sx____(cmd.format(**locals()))
        self.rm_docker(testname)
        self.rm_testdir()
        self.end()
    def test_5893_set_group(self) -> None:
        """ check that we can run a service with Group= settings (for coverage) """
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        images = IMAGES
        image = self.local_image(COVERAGE or IMAGE or CENTOS)
        if _python.endswith("python3") and "centos:7" in image:
            if SKIP: self.skipTest("no python3 on centos:7")
        self.begin()
        self.rm_testdir()
        testname = self.testname()
        testdir = self.testdir()
        docker = _docker
        package = package_tool(image)
        refresh = refresh_tool(image)
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        python_coverage = coverage_package(image)
        systemctl_py = _systemctl_py
        sometime = SOMETIME or 188
        cov_option = "--system"
        if COVERAGE:
            cov_option = "-c EXEC_SPAWN=True -c EXEC_DUP2=False"
        testsleepA = self.testname("sleepA")
        bindir="/usr/bin"
        this_user="somebody"
        this_group="nobody"
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepA} 1
            Group={this_group}
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        #
        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/ps || {package} install -y procps'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sx____(cmd.format(**locals()))
        if COVERAGE:
            cmd = "{docker} exec {testname} {package} install -y {python_coverage}"
            sx____(cmd.format(**locals()))
        self.prep_coverage(image, testname)
        #
        cmd = "{docker} exec {testname} mkdir -p /etc/systemd/system /etc/systemd/user"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} cp /bin/sleep /usr/bin/{testsleepA}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zza.service {testname}:/etc/systemd/system/zza.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl --version"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'grep nobody /etc/group || groupadd -g 65533 nobody'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'grep trusted /etc/group || groupadd -g 88 trusted'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} useradd -u 1001 somebody -g nobody -G trusted -m"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} touch /var/log/systemctl.debug.log"
        sh____(cmd.format(**locals()))
        #
        cmd = "{docker} exec {testname} systemctl  start zza.service -vvvv"
        out, err, rc = output3(cmd.format(**locals()))
        logg.info("\n>>>(%s)\n%s\n%s", rc, i2(err), out)
        if not COVERAGE:
            self.assertEqual(rc, 0)
        #
        cmd = "{docker} exec -u somebody {testname} ps -eo pid,ppid,euser,egroup,supgrp,args"
        top = clean(output(cmd.format(**locals())))
        logg.info("\n>>>\n%s", top)
        if not COVERAGE:
            self.assertTrue(greps(top, "root *nobody *nobody .*{testsleepA}".format(**locals())))
        #
        cmd = "{docker} stop {testname}"
        sh____(cmd.format(**locals()))
        self.save_coverage(testname)
        #
        cmd = "{docker} rmi {images}:{testname}"
        sx____(cmd.format(**locals()))
        self.rm_docker(testname)
        self.rm_testdir()
        self.end()
    def test_5894_set_user_and_group_and_supp_group(self) -> None:
        """ check that we can run a service with User= Group= SupplementaryGroups= settings (for coverage) """
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        images = IMAGES
        image = self.local_image(COVERAGE or IMAGE or CENTOS)
        if _python.endswith("python3") and "centos:7" in image:
            if SKIP: self.skipTest("no python3 on centos:7")
        self.begin()
        self.rm_testdir()
        testname = self.testname()
        testdir = self.testdir()
        docker = _docker
        package = package_tool(image)
        refresh = refresh_tool(image)
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        python_coverage = coverage_package(image)
        systemctl_py = _systemctl_py
        sometime = SOMETIME or 188
        cov_option = "--system"
        if COVERAGE:
            cov_option = "-c EXEC_SPAWN=True -c EXEC_DUP2=False"
        testsleepA = self.testname("sleepA")
        bindir="/usr/bin"
        this_user="somebody"
        this_group="nobody"
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepA} 1
            User={this_user}
            Group={this_group}
            SupplementaryGroups=trusted
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        #
        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/ps || {package} install -y procps'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sx____(cmd.format(**locals()))
        if COVERAGE:
            cmd = "{docker} exec {testname} {package} install -y {python_coverage}"
            sx____(cmd.format(**locals()))
        self.prep_coverage(image, testname)
        #
        cmd = "{docker} exec {testname} mkdir -p /etc/systemd/system /etc/systemd/user"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} cp /bin/sleep /usr/bin/{testsleepA}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zza.service {testname}:/etc/systemd/system/zza.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl --version"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'grep nobody /etc/group || groupadd -g 65533 nobody'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'grep trusted /etc/group || groupadd -g 88 trusted'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} useradd -u 1001 somebody -g nobody -G trusted -m"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} touch /var/log/systemctl.debug.log"
        sh____(cmd.format(**locals()))
        #
        cmd = "{docker} exec {testname} systemctl start zza.service -vvvv"
        out, err, rc = output3(cmd.format(**locals()))
        logg.info("\n>>>(%s)\n%s\n%s", rc, i2(err), out)
        if not COVERAGE:
            self.assertEqual(rc, 0)
        #
        cmd = "{docker} exec -u somebody {testname} ps -eo pid,ppid,euser,egroup,supgrp,args"
        top = clean(output(cmd.format(**locals())))
        logg.info("\n>>>\n%s", top)
        if not COVERAGE:
            self.assertTrue(greps(top, "somebody *nobody *trusted .*{testsleepA}".format(**locals())))
        #
        cmd = "{docker} stop {testname}"
        sh____(cmd.format(**locals()))
        self.save_coverage(testname)
        #
        cmd = "{docker} rmi {images}:{testname}"
        sx____(cmd.format(**locals()))
        self.rm_docker(testname)
        self.rm_testdir()
        self.end()
    def test_5895_set_user_and_supp_group(self) -> None:
        """ check that we can run a service with User= SupplementaryGroups= extra (for coverage) """
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        images = IMAGES
        image = self.local_image(COVERAGE or IMAGE or CENTOS)
        if _python.endswith("python3") and "centos:7" in image:
            if SKIP: self.skipTest("no python3 on centos:7")
        self.begin()
        self.rm_testdir()
        testname = self.testname()
        testdir = self.testdir()
        docker = _docker
        package = package_tool(image)
        refresh = refresh_tool(image)
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        python_coverage = coverage_package(image)
        systemctl_py = _systemctl_py
        sometime = SOMETIME or 188
        cov_option = "--system"
        if COVERAGE:
            cov_option = "-c EXEC_SPAWN=True -c EXEC_DUP2=False"
        testsleepA = self.testname("sleepA")
        bindir="/usr/bin"
        this_user="somebody"
        this_group="nobody"
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepA} 1
            User={this_user}
            SupplementaryGroups=trusted
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        #
        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/ps || {package} install -y procps'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sx____(cmd.format(**locals()))
        if COVERAGE:
            cmd = "{docker} exec {testname} {package} install -y {python_coverage}"
            sx____(cmd.format(**locals()))
        self.prep_coverage(image, testname, cov_option)
        #
        cmd = "{docker} exec {testname} mkdir -p /etc/systemd/system /etc/systemd/user"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} cp /bin/sleep /usr/bin/{testsleepA}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zza.service {testname}:/etc/systemd/system/zza.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl --version"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'grep nobody /etc/group || groupadd -g 65533 nobody'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'grep trusted /etc/group || groupadd -g 88 trusted'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} useradd -u 1001 somebody -g nobody -G trusted -m"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} touch /var/log/systemctl.debug.log"
        sh____(cmd.format(**locals()))
        #
        cmd = "{docker} exec {testname} systemctl start zza.service -vvvv"
        out, err, rc = output3(cmd.format(**locals()))
        logg.info("\n>>>(%s)\n%s\n%s", rc, i2(err), out)
        if not COVERAGE:
            self.assertEqual(rc, 0)
        #
        cmd = "{docker} exec -u somebody {testname} ps -eo pid,ppid,euser,egroup,supgrp,args"
        top = clean(output(cmd.format(**locals())))
        logg.info("\n>>>\n%s", top)
        if not COVERAGE:
            self.assertTrue(greps(top, "somebody *nobody *trusted .*{testsleepA}".format(**locals())))
        #
        cmd = "{docker} stop {testname}"
        sh____(cmd.format(**locals()))
        self.save_coverage(testname)
        #
        cmd = "{docker} rmi {images}:{testname}"
        sx____(cmd.format(**locals()))
        self.rm_docker(testname)
        self.rm_testdir()
        self.end()
    def test_5896_set_user_and_new_group(self) -> None:
        """ check that we can run a service with User= Group= settings (for coverage) """
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        images = IMAGES
        image = self.local_image(COVERAGE or IMAGE or CENTOS)
        if _python.endswith("python3") and "centos:7" in image:
            if SKIP: self.skipTest("no python3 on centos:7")
        self.begin()
        self.rm_testdir()
        testname = self.testname()
        testdir = self.testdir()
        docker = _docker
        package = package_tool(image)
        refresh = refresh_tool(image)
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        python_coverage = coverage_package(image)
        systemctl_py = _systemctl_py
        sometime = SOMETIME or 188
        cov_option = "--system"
        if COVERAGE:
            cov_option = "-c EXEC_SPAWN=True -c EXEC_DUP2=False"
        testsleepA = self.testname("sleepA")
        bindir="/usr/bin"
        this_user="somebody"
        this_group="nobody"
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepA} 1
            User={this_user}
            Group=wheel
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        #
        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/ps || {package} install -y procps'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sx____(cmd.format(**locals()))
        if COVERAGE:
            cmd = "{docker} exec {testname} {package} install -y {python_coverage}"
            sx____(cmd.format(**locals()))
        self.prep_coverage(image, testname)
        #
        cmd = "{docker} exec {testname} mkdir -p /etc/systemd/system /etc/systemd/user"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} cp /bin/sleep /usr/bin/{testsleepA}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zza.service {testname}:/etc/systemd/system/zza.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl --version"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'grep nobody /etc/group || groupadd -g 65533 nobody'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'grep trusted /etc/group || groupadd -g 88 trusted'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'grep wheel /etc/group || groupadd -g 87 wheel'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} useradd -u 1001 somebody -g nobody -G trusted -m"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} touch /var/log/systemctl.debug.log"
        sh____(cmd.format(**locals()))
        #
        cmd = "{docker} exec {testname} systemctl  start zza.service -vvvv"
        out, err, rc = output3(cmd.format(**locals()))
        logg.info("\n>>>(%s)\n%s\n%s", rc, i2(err), out)
        if not COVERAGE:
            self.assertEqual(rc, 0)
        #
        cmd = "{docker} exec -u somebody {testname} ps -eo pid,ppid,euser,egroup,supgrp,args"
        top = clean(output(cmd.format(**locals())))
        logg.info("\n>>>\n%s", top)
        if not COVERAGE:
            self.assertTrue(greps(top, "somebody *wheel *trusted .*{testsleepA}".format(**locals())))
        #
        cmd = "{docker} stop {testname}"
        sh____(cmd.format(**locals()))
        self.save_coverage(testname)
        #
        cmd = "{docker} rmi {images}:{testname}"
        sx____(cmd.format(**locals()))
        self.rm_docker(testname)
        self.rm_testdir()
        self.end()
    def test_5897_set_new_group(self) -> None:
        """ check that we can run a service with Group= settings (for coverage) """
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        images = IMAGES
        image = self.local_image(COVERAGE or IMAGE or CENTOS)
        if _python.endswith("python3") and "centos:7" in image:
            if SKIP: self.skipTest("no python3 on centos:7")
        self.begin()
        self.rm_testdir()
        testname = self.testname()
        testdir = self.testdir()
        docker = _docker
        package = package_tool(image)
        refresh = refresh_tool(image)
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        python_coverage = coverage_package(image)
        systemctl_py = _systemctl_py
        sometime = SOMETIME or 188
        cov_option = "--system"
        if COVERAGE:
            cov_option = "-c EXEC_SPAWN=True -c EXEC_DUP2=False"
        testsleepA = self.testname("sleepA")
        bindir="/usr/bin"
        this_user="somebody"
        this_group="nobody"
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepA} 1
            Group=wheel
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        #
        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/ps || {package} install -y procps'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sx____(cmd.format(**locals()))
        if COVERAGE:
            cmd = "{docker} exec {testname} {package} install -y {python_coverage}"
            sx____(cmd.format(**locals()))
        self.prep_coverage(image, testname)
        #
        cmd = "{docker} exec {testname} mkdir -p /etc/systemd/system /etc/systemd/user"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} cp /bin/sleep /usr/bin/{testsleepA}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zza.service {testname}:/etc/systemd/system/zza.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl --version"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'grep nobody /etc/group || groupadd -g 65533 nobody'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'grep trusted /etc/group || groupadd -g 88 trusted'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'grep wheel /etc/group || groupadd -g 87 wheel'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} useradd -u 1001 somebody -g nobody -G trusted -m"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} touch /var/log/systemctl.debug.log"
        sh____(cmd.format(**locals()))
        #
        cmd = "{docker} exec {testname} systemctl  start zza.service -vvvv"
        out, err, rc = output3(cmd.format(**locals()))
        logg.info("\n>>>(%s)\n%s\n%s", rc, i2(err), out)
        if not COVERAGE:
            self.assertEqual(rc, 0)
        #
        cmd = "{docker} exec -u somebody {testname} ps -eo pid,ppid,euser,egroup,supgrp,args"
        top = clean(output(cmd.format(**locals())))
        logg.info("\n>>>\n%s", top)
        if not COVERAGE:
            self.assertTrue(greps(top, "root *wheel *wheel .*{testsleepA}".format(**locals())))
        #
        cmd = "{docker} stop {testname}"
        sh____(cmd.format(**locals()))
        self.save_coverage(testname)
        #
        cmd = "{docker} rmi {images}:{testname}"
        sx____(cmd.format(**locals()))
        self.rm_docker(testname)
        self.rm_testdir()
        self.end()
    def test_5898_set_user_and_new_group_and_supp_group(self) -> None:
        """ check that we can run a service with User= Group= SupplementaryGroups= settings (for coverage) """
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        images = IMAGES
        image = self.local_image(COVERAGE or IMAGE or CENTOS)
        if _python.endswith("python3") and "centos:7" in image:
            if SKIP: self.skipTest("no python3 on centos:7")
        self.begin()
        self.rm_testdir()
        testname = self.testname()
        testdir = self.testdir()
        docker = _docker
        package = package_tool(image)
        refresh = refresh_tool(image)
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        python_coverage = coverage_package(image)
        systemctl_py = _systemctl_py
        sometime = SOMETIME or 188
        cov_option = "--system"
        if COVERAGE:
            cov_option = "-c EXEC_SPAWN=True -c EXEC_DUP2=False"
        testsleepA = self.testname("sleepA")
        bindir="/usr/bin"
        this_user="somebody"
        this_group="nobody"
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepA} 1
            User={this_user}
            Group=wheel
            SupplementaryGroups={this_group}
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        #
        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/ps || {package} install -y procps'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sx____(cmd.format(**locals()))
        if COVERAGE:
            cmd = "{docker} exec {testname} {package} install -y {python_coverage}"
            sx____(cmd.format(**locals()))
        self.prep_coverage(image, testname)
        #
        cmd = "{docker} exec {testname} mkdir -p /etc/systemd/system /etc/systemd/user"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} cp /bin/sleep /usr/bin/{testsleepA}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zza.service {testname}:/etc/systemd/system/zza.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl --version"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'grep nobody /etc/group || groupadd -g 65533 nobody'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'grep trusted /etc/group || groupadd -g 88 trusted'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'grep wheel /etc/group || groupadd -g 87 wheel'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} useradd -u 1001 somebody -g nobody -G trusted -m"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} touch /var/log/systemctl.debug.log"
        sh____(cmd.format(**locals()))
        #
        cmd = "{docker} exec {testname} systemctl start zza.service -vvvv"
        out, err, rc = output3(cmd.format(**locals()))
        logg.info("\n>>>(%s)\n%s\n%s", rc, i2(err), out)
        if not COVERAGE:
            self.assertEqual(rc, 0)
        #
        cmd = "{docker} exec -u somebody {testname} ps -eo pid,ppid,euser,egroup,supgrp,args"
        top = clean(output(cmd.format(**locals())))
        logg.info("\n>>>\n%s", top)
        if not COVERAGE:
            self.assertTrue(greps(top, "somebody *wheel *trusted,nobody .*{testsleepA}".format(**locals())))
        #
        cmd = "{docker} stop {testname}"
        sh____(cmd.format(**locals()))
        self.save_coverage(testname)
        #
        cmd = "{docker} rmi {images}:{testname}"
        sx____(cmd.format(**locals()))
        self.rm_docker(testname)
        self.rm_testdir()
        self.end()
    def test_5899_set_user_and_new_supp_group(self) -> None:
        """ check that we can run a service with User= SupplementaryGroups= extra (for coverage) """
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        images = IMAGES
        image = self.local_image(COVERAGE or IMAGE or CENTOS)
        if _python.endswith("python3") and "centos:7" in image:
            if SKIP: self.skipTest("no python3 on centos:7")
        self.begin()
        self.rm_testdir()
        testname = self.testname()
        testdir = self.testdir()
        docker = _docker
        package = package_tool(image)
        refresh = refresh_tool(image)
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        python_coverage = coverage_package(image)
        systemctl_py = _systemctl_py
        sometime = SOMETIME or 188
        cov_option = "--system"
        if COVERAGE:
            cov_option = "-c EXEC_SPAWN=True -c EXEC_DUP2=False"
        testsleepA = self.testname("sleepA")
        bindir="/usr/bin"
        this_user="somebody"
        this_group="nobody"
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A
            [Service]
            Type=simple
            ExecStart={bindir}/{testsleepA} 1
            User={this_user}
            SupplementaryGroups=wheel
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        #
        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/ps || {package} install -y procps'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sx____(cmd.format(**locals()))
        if COVERAGE:
            cmd = "{docker} exec {testname} {package} install -y {python_coverage}"
            sx____(cmd.format(**locals()))
        self.prep_coverage(image, testname, cov_option)
        #
        cmd = "{docker} exec {testname} mkdir -p /etc/systemd/system /etc/systemd/user"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} cp /bin/sleep /usr/bin/{testsleepA}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zza.service {testname}:/etc/systemd/system/zza.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl --version"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'grep nobody /etc/group || groupadd -g 65533 nobody'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'grep trusted /etc/group || groupadd -g 88 trusted'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'grep wheel /etc/group || groupadd -g 87 wheel'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} useradd -u 1001 somebody -g nobody -G trusted -m"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} touch /var/log/systemctl.debug.log"
        sh____(cmd.format(**locals()))
        #
        cmd = "{docker} exec {testname} systemctl start zza.service -vvvv"
        out, err, rc = output3(cmd.format(**locals()))
        logg.info("\n>>>(%s)\n%s\n%s", rc, i2(err), out)
        if not COVERAGE:
            self.assertEqual(rc, 0)
        #
        cmd = "{docker} exec -u somebody {testname} ps -eo pid,ppid,euser,egroup,supgrp,args"
        top = clean(output(cmd.format(**locals())))
        logg.info("\n>>>\n%s", top)
        if not COVERAGE:
            self.assertTrue(greps(top, "somebody *nobody *(wheel|trusted),(trusted|wheel) .*{testsleepA}".format(**locals())))
        #
        cmd = "{docker} stop {testname}"
        sh____(cmd.format(**locals()))
        self.save_coverage(testname)
        #
        cmd = "{docker} rmi {images}:{testname}"
        sx____(cmd.format(**locals()))
        self.rm_docker(testname)
        self.rm_testdir()
        self.end()

    def test_6130_run_default_services_from_simple_saved_container(self) -> None:
        """ check that we can enable services in a docker container to be run as default-services
            after it has been restarted from a commit-saved container image.
            This includes some corage on the init-services."""
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        images = IMAGES
        image = self.local_image(COVERAGE or IMAGE or CENTOS)
        testname = self.testname()
        testdir = self.testdir()
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        python_coverage = coverage_package(image)
        if _python.endswith("python3") and "centos:7" in image:
            if SKIP: self.skipTest("no python3 on centos:7")
        docker = _docker
        package = package_tool(image)
        refresh = refresh_tool(image)
        cov_option = "--system"
        if COVERAGE:
            cov_option = "-c EXEC_SPAWN=True"
        sometime = SOMETIME or 188
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A""")
        text_file(os_path(testdir, "zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart=/usr/bin/testsleep 99
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(testdir, "zzc.service"), """
            [Unit]
            Description=Testing C
            [Service]
            Type=simple
            ExecStart=/usr/bin/testsleep 111
            [Install]
            WantedBy=multi-user.target""")
        #
        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} cp /bin/sleep /usr/bin/testsleep"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/ps || {package} install -y procps'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sx____(cmd.format(**locals()))
        if COVERAGE:
            cmd = "{docker} exec {testname} {package} install -y {python_coverage}"
            sh____(cmd.format(**locals()))
        self.prep_coverage(image, testname)
        cmd = "{docker} exec {testname} systemctl --version"
        sh____(cmd.format(**locals()))
        #
        cmd = "{docker} exec {testname} mkdir -p /etc/systemd/system"
        sx____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zza.service {testname}:/etc/systemd/system/zza.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zzb.service {testname}:/etc/systemd/system/zzb.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zzc.service {testname}:/etc/systemd/system/zzc.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl enable zzb.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl enable zzc.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl default-services -v"
        # sh____(cmd.format(**locals()))
        out2 = output(cmd.format(**locals()))
        logg.info("\n>\n%s", out2)
        #
        cmd = "{docker} commit -c 'CMD [\"/usr/bin/systemctl\",\"{cov_option}\"]'  {testname} {images}:{testname}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name {testname} {images}:{testname}"
        sh____(cmd.format(**locals()))
        time.sleep(3)
        #
        cmd = "{docker} exec {testname} ps -eo pid,ppid,user,args"
        top = output(cmd.format(**locals()))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "testsleep 99"))
        self.assertTrue(greps(top, "testsleep 111"))
        #
        cmd = "{docker} exec {testname} systemctl halt -vvvv"
        # sh____(cmd.format(**locals()))
        out3 = output(cmd.format(**locals()))
        logg.info("\n>\n%s", out3)
        #
        cmd = "{docker} exec {testname} ps -eo pid,ppid,user,args"
        top = output(cmd.format(**locals()))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, "testsleep 99"))
        self.assertFalse(greps(top, "testsleep 111"))
        #
        self.save_coverage(testname)
        #
        cmd = "{docker} rmi {images}:{testname}"
        sx____(cmd.format(**locals()))
        self.rm_docker(testname)
        self.rm_testdir()
    def test_6133_run_default_services_from_single_service_saved_container(self) -> None:
        """ check that we can enable services in a docker container to be run as default-services
            after it has been restarted from a commit-saved container image.
            This includes some corage on the init-services."""
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        images = IMAGES
        image = self.local_image(COVERAGE or IMAGE or CENTOS)
        testname = self.testname()
        testdir = self.testdir()
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        python_coverage = coverage_package(image)
        if _python.endswith("python3") and "centos:7" in image:
            if SKIP: self.skipTest("no python3 on centos:7")
        docker = _docker
        package = package_tool(image)
        refresh = refresh_tool(image)
        cov_option = "--system"
        if COVERAGE:
            cov_option = "-c EXEC_SPAWN=True"
        sometime = SOMETIME or 188
        text_file(os_path(testdir, "zza.service"), """
            [Unit]
            Description=Testing A""")
        text_file(os_path(testdir, "zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart=/usr/bin/testsleep 99
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(testdir, "zzc.service"), """
            [Unit]
            Description=Testing C
            [Service]
            Type=simple
            ExecStart=/usr/bin/testsleep 111
            [Install]
            WantedBy=multi-user.target""")
        #
        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} cp /bin/sleep /usr/bin/testsleep"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/ps || {package} install -y procps'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sx____(cmd.format(**locals()))
        if COVERAGE:
            cmd = "{docker} exec {testname} {package} install -y {python_coverage}"
            sh____(cmd.format(**locals()))
        self.prep_coverage(image, testname)
        cmd = "{docker} exec {testname} systemctl --version"
        sh____(cmd.format(**locals()))
        #
        cmd = "{docker} exec {testname} mkdir -p /etc/systemd/system"
        sx____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zza.service {testname}:/etc/systemd/system/zza.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zzb.service {testname}:/etc/systemd/system/zzb.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zzc.service {testname}:/etc/systemd/system/zzc.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl enable zzb.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl enable zzc.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl default-services -v"
        # sh____(cmd.format(**locals()))
        out2 = output(cmd.format(**locals()))
        logg.info("\n>\n%s", out2)
        # .........................................vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
        cmd = "{docker} commit -c 'CMD [\"/usr/bin/systemctl\",\"init\",\"zzc.service\",\"{cov_option}\"]'  {testname} {images}:{testname}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name {testname} {images}:{testname}"
        sh____(cmd.format(**locals()))
        time.sleep(3)
        #
        #
        cmd = "{docker} exec {testname} ps -eo pid,ppid,user,args"
        top = output(cmd.format(**locals()))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, "testsleep 99")) # <<<<<<<<<< difference to 5033
        self.assertTrue(greps(top, "testsleep 111"))
        #
        cmd = "{docker} stop {testname}" # <<<
        # sh____(cmd.format(**locals()))
        out3 = output(cmd.format(**locals()))
        logg.info("\n>\n%s", out3)
        #
        cmd = "{docker} exec {testname} ps -eo pid,ppid,user,args"
        top = output(cmd.format(**locals()))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, "testsleep 99"))
        self.assertFalse(greps(top, "testsleep 111"))
        #
        self.save_coverage(testname)
        #
        cmd = "{docker} rmi {images}:{testname}"
        sx____(cmd.format(**locals()))
        self.rm_docker(testname)
        self.rm_testdir()
    def test_6160_systemctl_py_init_default_halt_to_exit_container(self) -> None:
        """ check that we can 'halt' in a docker container to stop the service
            and to exit the PID 1 as the last part of the service."""
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        images = IMAGES
        image = self.local_image(COVERAGE or IMAGE or CENTOS)
        testname = self.testname()
        testdir = self.testdir()
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        python_coverage = coverage_package(image)
        if _python.endswith("python3") and "centos:7" in image:
            if SKIP: self.skipTest("no python3 on centos:7")
        docker = _docker
        package = package_tool(image)
        refresh = refresh_tool(image)
        cov_option = "--system"
        if COVERAGE:
            cov_option = "-c EXEC_SPAWN=True"
        sometime = SOMETIME or 188
        text_file(os_path(testdir, "zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart=/usr/bin/testsleep 99
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(testdir, "zzc.service"), """
            [Unit]
            Description=Testing C
            [Service]
            Type=simple
            ExecStart=/usr/bin/testsleep 111
            [Install]
            WantedBy=multi-user.target""")
        #
        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} cp /bin/sleep /usr/bin/testsleep"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/ps || {package} install -y procps'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sx____(cmd.format(**locals()))
        if COVERAGE:
            cmd = "{docker} exec {testname} {package} install -y {python_coverage}"
            sh____(cmd.format(**locals()))
        self.prep_coverage(image, testname, cov_option)
        cmd = "{docker} exec {testname} systemctl --version"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} touch /var/log/systemctl.debug.log"
        sh____(cmd.format(**locals()))
        #
        cmd = "{docker} exec {testname} mkdir -p /etc/systemd/system"
        sx____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zzb.service {testname}:/etc/systemd/system/zzb.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zzc.service {testname}:/etc/systemd/system/zzc.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl enable zzb.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl enable zzc.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl default-services -v"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} touch /var/log/systemctl.debug.log {testdir}/systemctl.debug.log"
        # sh____(cmd.format(**locals()))
        out2 = output(cmd.format(**locals()))
        logg.info("\n>\n%s", out2)
        cmd = "{docker} commit -c 'CMD [\"/usr/bin/systemctl\",\"init\",\"{cov_option}\"]'  {testname} {images}:{testname}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name {testname} {images}:{testname}"
        sh____(cmd.format(**locals()))
        time.sleep(2)
        #
        cmd = "{docker} exec {testname} ps -eo pid,ppid,user,args"
        top = output(cmd.format(**locals()))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "testsleep 111"))
        #
        # vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv status check now
        cmd = "{docker} inspect {testname}"
        inspected = output(cmd.format(**locals()))
        state = json.loads(inspected)[0]["State"]
        logg.info("Status = %s", state["Status"])
        self.assertTrue(state["Running"])
        self.assertEqual(state["Status"], "running")
        #
        cmd = "{docker} exec {testname} systemctl halt"
        sh____(cmd.format(**locals()))
        #
        waits = 3
        for attempt in xrange(5):
            logg.info("[%s] waits %ss for the zombie-reaper to have cleaned up", attempt, waits)
            time.sleep(waits)
            cmd = "{docker} inspect {testname}"
            inspected = output(cmd.format(**locals()))
            state = json.loads(inspected)[0]["State"]
            logg.info("Status = %s", state["Status"])
            logg.info("ExitCode = %s", state["ExitCode"])
            if state["Status"] in ["exited"]:
                break
            cmd = "{docker} exec {testname} ps -eo pid,ppid,user,args"
            top = output(cmd.format(**locals()))
            logg.info("\n>>>\n%s", top)
        cmd = "{docker} cp {testname}:/var/log/systemctl.debug.log {testdir}/systemctl.debug.log"
        sh____(cmd.format(**locals()))
        log = lines(open(testdir+"/systemctl.debug.log"))
        logg.info("systemctl.debug.log>\n\t%s", "\n\t".join(log))
        #
        self.assertFalse(state["Running"])
        self.assertEqual(state["Status"], "exited")
        #
        cmd = "{docker} stop {testname}" # <<< this is a no-op now
        # sh____(cmd.format(**locals()))
        out3 = output(cmd.format(**locals()))
        logg.info("\n>\n%s", out3)
        #
        cmd = "{docker} cp {testname}:/var/log/systemctl.debug.log {testdir}/systemctl.debug.log"
        sh____(cmd.format(**locals()))
        log = lines(open(testdir+"/systemctl.debug.log"))
        logg.info("systemctl.debug.log>\n\t%s", "\n\t".join(log))
        self.assertTrue(greps(log, "no more procs - exit init-loop"))
        #
        cmd = "{docker} exec {testname} ps -eo pid,ppid,user,args"
        top = output(cmd.format(**locals()))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, "testsleep 99"))
        self.assertFalse(greps(top, "testsleep 111"))
        #
        self.save_coverage(testname)
        #
        cmd = "{docker} rmi {images}:{testname}"
        sx____(cmd.format(**locals()))
        self.rm_docker(testname)
        self.rm_testdir()
    def test_6170_systemctl_py_init_all_stop_last_service_to_exit_container(self) -> None:
        """ check that we can 'stop <service>' in a docker container to stop the service
            being the last service and to exit the PID 1 as the last part of the service."""
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        images = IMAGES
        image = self.local_image(COVERAGE or IMAGE or CENTOS)
        testname = self.testname()
        testdir = self.testdir()
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        python_coverage = coverage_package(image)
        if _python.endswith("python3") and "centos:7" in image:
            if SKIP: self.skipTest("no python3 on centos:7")
        docker = _docker
        package = package_tool(image)
        refresh = refresh_tool(image)
        cov_option = "--system"
        if COVERAGE:
            cov_option = "-c EXEC_SPAWN=True"
        sometime = SOMETIME or 188
        text_file(os_path(testdir, "zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart=/usr/bin/testsleep 99
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(testdir, "zzc.service"), """
            [Unit]
            Description=Testing C
            [Service]
            Type=simple
            ExecStart=/usr/bin/testsleep 111
            [Install]
            WantedBy=multi-user.target""")
        #
        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} cp /bin/sleep /usr/bin/testsleep"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/ps || {package} install -y procps'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sx____(cmd.format(**locals()))
        if COVERAGE:
            cmd = "{docker} exec {testname} {package} install -y {python_coverage}"
            sh____(cmd.format(**locals()))
        self.prep_coverage(image, testname, cov_option)
        cmd = "{docker} exec {testname} bash -c 'test -f /etc/init.d/ondemand && systemctl disable ondemand'" # ubuntu:16.04
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl --version"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} touch /var/log/systemctl.debug.log"
        sh____(cmd.format(**locals()))
        #
        cmd = "{docker} exec {testname} mkdir -p /etc/systemd/system"
        sx____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zzb.service {testname}:/etc/systemd/system/zzb.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zzc.service {testname}:/etc/systemd/system/zzc.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl enable zzb.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl enable zzc.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl default-services -v"
        # sh____(cmd.format(**locals()))
        out2 = output(cmd.format(**locals()))
        logg.info("\n>\n%s", out2)
        cmd = "{docker} commit -c 'CMD [\"/usr/bin/systemctl\",\"init\",\"--all\",\"{cov_option}\"]'  {testname} {images}:{testname}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name {testname} {images}:{testname}"
        sh____(cmd.format(**locals()))
        time.sleep(2)
        #
        cmd = "{docker} exec {testname} ps -eo pid,ppid,user,args"
        top = output(cmd.format(**locals()))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "testsleep 111"))
        #
        cmd = "{docker} inspect {testname}"
        inspected = output(cmd.format(**locals()))
        state = json.loads(inspected)[0]["State"]
        logg.info("Status = %s", state["Status"])
        self.assertTrue(state["Running"])
        self.assertEqual(state["Status"], "running")
        #
        cmd = "{docker} exec {testname} systemctl stop zzb.service" # <<<<<<<<<<<<<<<<<<<<<
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl stop zzc.service" # <<<<<<<<<<<<<<<<<<<<<
        sh____(cmd.format(**locals()))
        #
        waits = 3
        for attempt in xrange(5):
            logg.info("[%s] waits %ss for the zombie-reaper to have cleaned up", attempt, waits)
            time.sleep(waits)
            cmd = "{docker} inspect {testname}"
            inspected = output(cmd.format(**locals()))
            state = json.loads(inspected)[0]["State"]
            logg.info("Status = %s", state["Status"])
            logg.info("ExitCode = %s", state["ExitCode"])
            if state["Status"] in ["exited"]:
                break
            cmd = "{docker} exec {testname} ps -eo pid,ppid,user,args"
            top = output(cmd.format(**locals()))
            logg.info("\n>>>\n%s", top)
        cmd = "{docker} cp {testname}:/var/log/systemctl.debug.log {testdir}/systemctl.debug.log"
        sh____(cmd.format(**locals()))
        log = lines(open(testdir+"/systemctl.debug.log"))
        logg.info("systemctl.debug.log>\n\t%s", "\n\t".join(log))
        #
        self.assertFalse(state["Running"])
        self.assertEqual(state["Status"], "exited")
        #
        cmd = "{docker} stop {testname}" # <<< this is a no-op now
        # sh____(cmd.format(**locals()))
        out3 = output(cmd.format(**locals()))
        logg.info("\n>\n%s", out3)
        #
        cmd = "{docker} logs {testname}"
        logs = output(cmd.format(**locals()))
        logg.info("\n>\n%s", logs)
        #
        cmd = "{docker} cp {testname}:/var/log/systemctl.debug.log {testdir}/systemctl.debug.log"
        sh____(cmd.format(**locals()))
        log = lines(open(testdir+"/systemctl.debug.log"))
        logg.info("systemctl.debug.log>\n\t%s", "\n\t".join(log))
        self.assertTrue(greps(log, "no more procs - exit init-loop"))
        #
        cmd = "{docker} exec {testname} ps -eo pid,ppid,user,args"
        top = output(cmd.format(**locals()))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, "testsleep 99"))
        self.assertFalse(greps(top, "testsleep 111"))
        #
        self.save_coverage(testname)
        #
        cmd = "{docker} rmi {images}:{testname}"
        sx____(cmd.format(**locals()))
        self.rm_docker(testname)
        self.rm_testdir()
    def test_6180_systemctl_py_init_explicit_halt_to_exit_container(self) -> None:
        """ check that we can 'halt' in a docker container to stop the service
            and to exit the PID 1 as the last part of the service."""
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        images = IMAGES
        image = self.local_image(COVERAGE or IMAGE or CENTOS)
        testname = self.testname()
        testdir = self.testdir()
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        python_coverage = coverage_package(image)
        if _python.endswith("python3") and "centos:7" in image:
            if SKIP: self.skipTest("no python3 on centos:7")
        docker = _docker
        package = package_tool(image)
        refresh = refresh_tool(image)
        cov_option = "--system"
        if COVERAGE:
            cov_option = "-c EXEC_SPAWN=True"
        sometime = SOMETIME or 188
        text_file(os_path(testdir, "zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart=/usr/bin/testsleep 99
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(testdir, "zzc.service"), """
            [Unit]
            Description=Testing C
            [Service]
            Type=simple
            ExecStart=/usr/bin/testsleep 111
            [Install]
            WantedBy=multi-user.target""")
        #
        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} cp /bin/sleep /usr/bin/testsleep"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/ps || {package} install -y procps'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sx____(cmd.format(**locals()))
        if COVERAGE:
            cmd = "{docker} exec {testname} {package} install -y {python_coverage}"
            sh____(cmd.format(**locals()))
        self.prep_coverage(image, testname, cov_option)
        cmd = "{docker} exec {testname} systemctl --version"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} touch /var/log/systemctl.debug.log"
        sh____(cmd.format(**locals()))
        #
        cmd = "{docker} exec {testname} mkdir -p /etc/systemd/system"
        sx____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zzb.service {testname}:/etc/systemd/system/zzb.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zzc.service {testname}:/etc/systemd/system/zzc.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl enable zzb.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl enable zzc.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl default-services -v"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} touch /var/log/systemctl.debug.log {testdir}/systemctl.debug.log"
        # sh____(cmd.format(**locals()))
        out2 = output(cmd.format(**locals()))
        logg.info("\n>\n%s", out2)
        cmd = "{docker} commit -c 'CMD [\"/usr/bin/systemctl\",\"init\",\"zzc.service\",\"{cov_option}\"]'  {testname} {images}:{testname}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name {testname} {images}:{testname}"
        sh____(cmd.format(**locals()))
        time.sleep(2)
        #
        cmd = "{docker} exec {testname} ps -eo pid,ppid,user,args"
        top = output(cmd.format(**locals()))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "testsleep 111"))
        #
        # vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv status check now
        cmd = "{docker} inspect {testname}"
        inspected = output(cmd.format(**locals()))
        state = json.loads(inspected)[0]["State"]
        logg.info("Status = %s", state["Status"])
        self.assertTrue(state["Running"])
        self.assertEqual(state["Status"], "running")
        #
        cmd = "{docker} exec {testname} systemctl halt"
        sh____(cmd.format(**locals()))
        #
        waits = 3
        for attempt in xrange(10):
            logg.info("[%s] waits %ss for the zombie-reaper to have cleaned up", attempt, waits)
            time.sleep(waits)
            cmd = "{docker} inspect {testname}"
            inspected = output(cmd.format(**locals()))
            state = json.loads(inspected)[0]["State"]
            logg.info("Status = %s", state["Status"])
            logg.info("ExitCode = %s", state["ExitCode"])
            if state["Status"] in ["exited"]:
                break
            cmd = "{docker} exec {testname} ps -eo pid,ppid,user,args"
            top = output(cmd.format(**locals()))
            logg.info("\n>>>\n%s", top)
        self.assertFalse(state["Running"])
        self.assertEqual(state["Status"], "exited")
        #
        cmd = "{docker} stop {testname}" # <<< this is a no-op now
        # sh____(cmd.format(**locals()))
        out3 = output(cmd.format(**locals()))
        logg.info("\n>\n%s", out3)
        #
        cmd = "{docker} cp {testname}:/var/log/systemctl.debug.log {testdir}/systemctl.debug.log"
        sh____(cmd.format(**locals()))
        log = lines(open(testdir+"/systemctl.debug.log"))
        logg.info("systemctl.debug.log>\n\t%s", "\n\t".join(log))
        self.assertTrue(greps(log, "no more services - exit init-loop"))
        #
        cmd = "{docker} exec {testname} ps -eo pid,ppid,user,args"
        top = output(cmd.format(**locals()))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, "testsleep 99"))
        self.assertFalse(greps(top, "testsleep 111"))
        #
        self.save_coverage(testname)
        #
        cmd = "{docker} rmi {images}:{testname}"
        sx____(cmd.format(**locals()))
        self.rm_docker(testname)
        self.rm_testdir()
    def test_6190_systemctl_py_init_explicit_stop_last_service_to_exit_container(self) -> None:
        """ check that we can 'stop <service>' in a docker container to stop the service
            being the last service and to exit the PID 1 as the last part of the service."""
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        images = IMAGES
        image = self.local_image(COVERAGE or IMAGE or CENTOS)
        testname = self.testname()
        testdir = self.testdir()
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        python_coverage = coverage_package(image)
        if _python.endswith("python3") and "centos:7" in image:
            if SKIP: self.skipTest("no python3 on centos:7")
        docker = _docker
        package = package_tool(image)
        refresh = refresh_tool(image)
        cov_option = "--system"
        if COVERAGE:
            cov_option = "-c EXEC_SPAWN=True"
        sometime = SOMETIME or 188
        text_file(os_path(testdir, "zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            ExecStart=/usr/bin/testsleep 99
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(testdir, "zzc.service"), """
            [Unit]
            Description=Testing C
            [Service]
            Type=simple
            ExecStart=/usr/bin/testsleep 111
            [Install]
            WantedBy=multi-user.target""")
        #
        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} cp /bin/sleep /usr/bin/testsleep"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/ps || {package} install -y procps'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sx____(cmd.format(**locals()))
        if COVERAGE:
            cmd = "{docker} exec {testname} {package} install -y {python_coverage}"
            sh____(cmd.format(**locals()))
        self.prep_coverage(image, testname, cov_option)
        cmd = "{docker} exec {testname} systemctl --version"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} touch /var/log/systemctl.debug.log"
        sh____(cmd.format(**locals()))
        #
        cmd = "{docker} exec {testname} mkdir -p /etc/systemd/system"
        sx____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zzb.service {testname}:/etc/systemd/system/zzb.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zzc.service {testname}:/etc/systemd/system/zzc.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl enable zzb.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl enable zzc.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl default-services -v"
        # sh____(cmd.format(**locals()))
        out2 = output(cmd.format(**locals()))
        logg.info("\n>\n%s", out2)
        cmd = "{docker} commit -c 'CMD [\"/usr/bin/systemctl\",\"init\",\"zzc.service\",\"{cov_option}\"]'  {testname} {images}:{testname}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name {testname} {images}:{testname}"
        sh____(cmd.format(**locals()))
        time.sleep(2)
        #
        cmd = "{docker} exec {testname} ps -eo pid,ppid,user,args"
        top = output(cmd.format(**locals()))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "testsleep 111"))
        #
        cmd = "{docker} inspect {testname}"
        inspected = output(cmd.format(**locals()))
        state = json.loads(inspected)[0]["State"]
        logg.info("Status = %s", state["Status"])
        self.assertTrue(state["Running"])
        self.assertEqual(state["Status"], "running")
        #
        cmd = "{docker} exec {testname} systemctl stop zzc.service" # <<<<<<<<<<<<<<<<<<<<<
        sh____(cmd.format(**locals()))
        #
        waits = 3
        for attempt in xrange(10):
            logg.info("[%s] waits %ss for the zombie-reaper to have cleaned up", attempt, waits)
            time.sleep(waits)
            cmd = "{docker} inspect {testname}"
            inspected = output(cmd.format(**locals()))
            state = json.loads(inspected)[0]["State"]
            logg.info("Status = %s", state["Status"])
            logg.info("ExitCode = %s", state["ExitCode"])
            if state["Status"] in ["exited"]:
                break
            cmd = "{docker} exec {testname} ps -eo pid,ppid,user,args"
            top = output(cmd.format(**locals()))
            logg.info("\n>>>\n%s", top)
        self.assertFalse(state["Running"])
        self.assertEqual(state["Status"], "exited")
        #
        cmd = "{docker} stop {testname}" # <<< this is a no-op now
        # sh____(cmd.format(**locals()))
        out3 = output(cmd.format(**locals()))
        logg.info("\n>\n%s", out3)
        #
        cmd = "{docker} logs {testname}"
        logs = output(cmd.format(**locals()))
        logg.info("\n>\n%s", logs)
        #
        cmd = "{docker} cp {testname}:/var/log/systemctl.debug.log {testdir}/systemctl.debug.log"
        sh____(cmd.format(**locals()))
        log = lines(open(testdir+"/systemctl.debug.log"))
        logg.info("systemctl.debug.log>\n\t%s", "\n\t".join(log))
        self.assertTrue(greps(log, "no more services - exit init-loop"))
        #
        cmd = "{docker} exec {testname} ps -eo pid,ppid,user,args"
        top = output(cmd.format(**locals()))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, "testsleep 99"))
        self.assertFalse(greps(top, "testsleep 111"))
        #
        self.save_coverage(testname)
        #
        cmd = "{docker} rmi {images}:{testname}"
        sx____(cmd.format(**locals()))
        self.rm_docker(testname)
        self.rm_testdir()
    def test_6200_systemctl_py_switch_users_is_possible(self) -> None:
        """ check that we can put setuid/setgid definitions in a service
            specfile which also works on the pid file itself """
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        images = IMAGES
        image = self.local_image(COVERAGE or IMAGE or CENTOS)
        testname = self.testname()
        testdir = self.testdir()
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        python_coverage = coverage_package(image)
        if _python.endswith("python3") and "centos:7" in image:
            if SKIP: self.skipTest("no python3 on centos:7")
        docker = _docker
        package = package_tool(image)
        refresh = refresh_tool(image)
        cov_option = "--system"
        sometime = SOMETIME or 288
        text_file(os_path(testdir, "zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            User=somebody
            Group=root
            ExecStart=/usr/bin/testsleep 99
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(testdir, "zzc.service"), """
            [Unit]
            Description=Testing C
            [Service]
            Type=simple
            User=somebody
            ExecStart=/usr/bin/testsleep 111
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(testdir, "zzd.service"), """
            [Unit]
            Description=Testing D
            [Service]
            Type=simple
            Group=nobody
            ExecStart=/usr/bin/testsleep 122
            [Install]
            WantedBy=multi-user.target""")
        #
        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} cp /bin/sleep /usr/bin/testsleep"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/ps || {package} install -y procps'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sx____(cmd.format(**locals()))
        if COVERAGE:
            cmd = "{docker} exec {testname} {package} install -y {python_coverage}"
            sh____(cmd.format(**locals()))
        self.prep_coverage(image, testname)
        cmd = "{docker} exec {testname} systemctl --version"
        sh____(cmd.format(**locals()))
        #
        if COVERAGE:
            cmd = "{docker} exec {testname} touch /tmp/.coverage"
            sh____(cmd.format(**locals()))
            cmd = "{docker} exec {testname} chmod 777 /tmp/.coverage"
            sh____(cmd.format(**locals()))
        #
        cmd = "{docker} exec {testname} bash -c 'grep nobody /etc/group || groupadd -g 65533 nobody'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} useradd -u 1001 somebody -g nobody"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} mkdir -p /etc/systemd/system"
        sx____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zzb.service {testname}:/etc/systemd/system/zzb.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zzc.service {testname}:/etc/systemd/system/zzc.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zzd.service {testname}:/etc/systemd/system/zzd.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl start zzb.service -v"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl start zzc.service -v"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl start zzd.service -v"
        sh____(cmd.format(**locals()))
        #
        # first of all, it starts commands like the service specs without user/group
        cmd = "{docker} exec {testname} ps -eo pid,ppid,user,args"
        top = output(cmd.format(**locals()))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "testsleep 99"))
        self.assertTrue(greps(top, "testsleep 111"))
        # but really it has some user/group changed
        cmd = "{docker} exec {testname} ps -eo user,group,args"
        top = output(cmd.format(**locals()))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "somebody .*root .*testsleep 99"))
        self.assertTrue(greps(top, "somebody .*nobody .*testsleep 111"))
        self.assertTrue(greps(top, "root .*nobody .*testsleep 122"))
        # and the pid file has changed as well
        cmd = "{docker} exec {testname} ls -l /var/run/zzb.service.pid"
        out = output(cmd.format(**locals()))
        logg.info("found %s", out.strip())
        if TODO: self.assertTrue(greps(out, "somebody .*root .*zzb.service.pid"))
        cmd = "{docker} exec {testname} ls -l /var/run/zzc.service.pid"
        out = output(cmd.format(**locals()))
        logg.info("found %s", out.strip())
        if TODO: self.assertTrue(greps(out, "somebody .*nobody .*zzc.service.pid"))
        cmd = "{docker} exec {testname} ls -l /var/run/zzd.service.pid"
        out = output(cmd.format(**locals()))
        logg.info("found %s", out.strip())
        if TODO: self.assertTrue(greps(out, "root .*nobody .*zzd.service.pid"))
        #
        self.save_coverage(testname)
        #
        cmd = "{docker} rmi {images}:{testname}"
        sx____(cmd.format(**locals()))
        self.rm_docker(testname)
        self.rm_testdir()
    def test_6201_systemctl_py_switch_users_is_possible_from_saved_container(self) -> None:
        """ check that we can put setuid/setgid definitions in a service
            specfile which also works on the pid file itself """
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        images = IMAGES
        image = self.local_image(COVERAGE or IMAGE or CENTOS)
        testname = self.testname()
        testdir = self.testdir()
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        python_coverage = coverage_package(image)
        if _python.endswith("python3") and "centos:7" in image:
            if SKIP: self.skipTest("no python3 on centos:7")
        docker = _docker
        package = package_tool(image)
        refresh = refresh_tool(image)
        cov_option = "--system"
        if COVERAGE:
            cov_option = "-c EXEC_SPAWN=True"
        sometime = SOMETIME or 188
        text_file(os_path(testdir, "zzb.service"), """
            [Unit]
            Description=Testing B
            [Service]
            Type=simple
            User=somebody
            Group=root
            ExecStart=/usr/bin/testsleep 99
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(testdir, "zzc.service"), """
            [Unit]
            Description=Testing C
            [Service]
            Type=simple
            User=somebody
            ExecStart=/usr/bin/testsleep 111
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(testdir, "zzd.service"), """
            [Unit]
            Description=Testing D
            [Service]
            Type=simple
            Group=nobody
            ExecStart=/usr/bin/testsleep 122
            [Install]
            WantedBy=multi-user.target""")
        #
        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} cp /bin/sleep /usr/bin/testsleep"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/ps || {package} install -y procps'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sx____(cmd.format(**locals()))
        if COVERAGE:
            cmd = "{docker} exec {testname} {package} install -y {python_coverage}"
            sh____(cmd.format(**locals()))
        self.prep_coverage(image, testname)
        cmd = "{docker} exec {testname} systemctl --version"
        sh____(cmd.format(**locals()))
        #
        cmd = "{docker} exec {testname} bash -c 'grep nobody /etc/group || groupadd -g 65533 nobody'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} useradd -u 1001 somebody -g nobody"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} mkdir -p /etc/systemd/system"
        sx____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zzb.service {testname}:/etc/systemd/system/zzb.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zzc.service {testname}:/etc/systemd/system/zzc.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zzd.service {testname}:/etc/systemd/system/zzd.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl enable zzb.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl enable zzc.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl enable zzd.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl default-services -v"
        # sh____(cmd.format(**locals()))
        out2 = output(cmd.format(**locals()))
        logg.info("\n>\n%s", out2)
        # .........................................vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
        cmd = "{docker} commit -c 'CMD [\"/usr/bin/systemctl\",\"{cov_option}\"]'  {testname} {images}:{testname}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name {testname} {images}:{testname}"
        sh____(cmd.format(**locals()))
        time.sleep(5)
        #
        # first of all, it starts commands like the service specs without user/group
        cmd = "{docker} exec {testname} ps -eo pid,ppid,user,args"
        top = output(cmd.format(**locals()))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "testsleep 99"))
        self.assertTrue(greps(top, "testsleep 111"))
        self.assertTrue(greps(top, "testsleep 122"))
        # but really it has some user/group changed
        cmd = "{docker} exec {testname} ps -eo user,group,args"
        top = output(cmd.format(**locals()))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "somebody .*root .*testsleep 99"))
        self.assertTrue(greps(top, "somebody .*nobody .*testsleep 111"))
        self.assertTrue(greps(top, "root .*nobody .*testsleep 122"))
        # and the pid file has changed as well
        cmd = "{docker} exec {testname} ls -l /var/run/zzb.service.pid"
        out = output(cmd.format(**locals()))
        logg.info("found %s", out.strip())
        if TODO: self.assertTrue(greps(out, "somebody .*root .*zzb.service.pid"))
        cmd = "{docker} exec {testname} ls -l /var/run/zzc.service.pid"
        out = output(cmd.format(**locals()))
        logg.info("found %s", out.strip())
        if TODO: self.assertTrue(greps(out, "somebody .*nobody .*zzc.service.pid"))
        cmd = "{docker} exec {testname} ls -l /var/run/zzd.service.pid"
        out = output(cmd.format(**locals()))
        logg.info("found %s", out.strip())
        if TODO: self.assertTrue(greps(out, "root .*nobody .*zzd.service.pid"))
        #
        cmd = "{docker} stop {testname}" # <<<
        out3 = output(cmd.format(**locals()))
        logg.info("\n>\n%s", out3)
        #
        cmd = "{docker} exec {testname} ps -eo pid,ppid,user,args"
        top = output(cmd.format(**locals()))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, "testsleep 99"))
        self.assertFalse(greps(top, "testsleep 111"))
        self.assertFalse(greps(top, "testsleep 122"))
        #
        self.save_coverage(testname)
        #
        cmd = "{docker} rmi {images}:{testname}"
        sx____(cmd.format(**locals()))
        self.rm_docker(testname)
        self.rm_testdir()
    def test_6210_switch_users_and_workingdir_coverage(self) -> None:
        """ check that we can put workingdir and setuid/setgid definitions in a service
            and code parts for that are actually executed (test case without fork before) """
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        images = IMAGES
        image = self.local_image(COVERAGE or IMAGE or CENTOS)
        testname = self.testname()
        testdir = self.testdir()
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        python_coverage = coverage_package(image)
        if _python.endswith("python3") and "centos:7" in image:
            if SKIP: self.skipTest("no python3 on centos:7")
        docker = _docker
        package = package_tool(image)
        refresh = refresh_tool(image)
        testsleep_sh = os_path(testdir, "testsleep.sh")
        cov_option = "--system"
        if COVERAGE:
            cov_option = "-c EXEC_SPAWN=True"
        sometime = SOMETIME or 188
        shell_file(testsleep_sh, """
            #! /bin/sh
            logfile="/tmp/testsleep-$1.log"
            date > $logfile
            echo "pwd": `pwd` >> $logfile
            echo "user:" `id -un` >> $logfile
            echo "group:" `id -gn` >> $logfile
            testsleep $1
            """.format(**locals()))
        text_file(os_path(testdir, "zz4.service"), """
            [Unit]
            Description=Testing 4
            [Service]
            Type=simple
            User=somebody
            Group=root
            WorkingDirectory=/srv
            ExecStart=/usr/bin/testsleep.sh 4
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(testdir, "zz5.service"), """
            [Unit]
            Description=Testing 5
            [Service]
            Type=simple
            User=somebody
            WorkingDirectory=/srv
            ExecStart=/usr/bin/testsleep.sh 5
            [Install]
            WantedBy=multi-user.target""")
        text_file(os_path(testdir, "zz6.service"), """
            [Unit]
            Description=Testing 6
            [Service]
            Type=simple
            Group=nobody
            WorkingDirectory=/srv
            ExecStart=/usr/bin/testsleep.sh 6
            [Install]
            WantedBy=multi-user.target""")
        #
        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} cp /bin/sleep /usr/bin/testsleep"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testsleep_sh} {testname}:/usr/bin/testsleep.sh"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} chmod 755 /usr/bin/testsleep.sh"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sx____(cmd.format(**locals()))
        if COVERAGE:
            cmd = "{docker} exec {testname} {package} install -y {python_coverage}"
            sh____(cmd.format(**locals()))
        self.prep_coverage(image, testname, cov_option)
        cmd = "{docker} exec {testname} bash -c 'grep nobody /etc/group || groupadd -g 65533 nobody'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} useradd -u 1001 somebody -g nobody"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl --version"
        sh____(cmd.format(**locals()))
        #
        if COVERAGE:
            cmd = "{docker} exec {testname} touch /tmp/.coverage"
            sh____(cmd.format(**locals()))
            cmd = "{docker} exec {testname} chmod 777 /tmp/.coverage"  # << switched user may write
            sh____(cmd.format(**locals()))
        #
        cmd = "{docker} exec {testname} mkdir -p /etc/systemd/system"
        sx____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zz4.service {testname}:/etc/systemd/system/zz4.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zz5.service {testname}:/etc/systemd/system/zz5.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zz6.service {testname}:/etc/systemd/system/zz6.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl __test_start_unit zz4.service -vvvv {cov_option}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl __test_start_unit zz5.service -vv {cov_option}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl __test_start_unit zz6.service -vv {cov_option}"
        sh____(cmd.format(**locals()))
        #
        cmd = "{docker} cp {testname}:/tmp/testsleep-4.log {testdir}/"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testname}:/tmp/testsleep-5.log {testdir}/"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testname}:/tmp/testsleep-6.log {testdir}/"
        sh____(cmd.format(**locals()))
        log4 = lines(open(os_path(testdir, "testsleep-4.log")))
        log5 = lines(open(os_path(testdir, "testsleep-5.log")))
        log6 = lines(open(os_path(testdir, "testsleep-6.log")))
        logg.info("testsleep-4.log\n %s", "\n ".join(log4))
        logg.info("testsleep-5.log\n %s", "\n ".join(log5))
        logg.info("testsleep-6.log\n %s", "\n ".join(log6))
        self.assertTrue(greps(log4, "pwd: /srv"))
        self.assertTrue(greps(log5, "pwd: /srv"))
        self.assertTrue(greps(log6, "pwd: /srv"))
        self.assertTrue(greps(log4, "group: root"))
        self.assertTrue(greps(log4, "user: somebody"))
        self.assertTrue(greps(log5, "user: somebody"))
        self.assertTrue(greps(log5, "group: nobody"))
        self.assertTrue(greps(log6, "group: nobody"))
        self.assertTrue(greps(log6, "user: root"))
        #
        self.save_coverage(testname)
        #
        cmd = "{docker} rmi {images}:{testname}"
        sx____(cmd.format(**locals()))
        self.rm_docker(testname)
        self.rm_testdir()
    def test_6600_systemctl_py_can_reap_zombies_in_a_container(self) -> None:
        """ check that we can reap zombies in a container managed by systemctl.py"""
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        images = IMAGES
        image = self.local_image(COVERAGE or IMAGE or CENTOS)
        testname = self.testname()
        testdir = self.testdir()
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        python_coverage = coverage_package(image)
        cov_option = "--system"
        if COVERAGE:
            cov_option = "-c EXEC_SPAWN=True"
        if _python.endswith("python3") and "centos:7" in image:
            if SKIP: self.skipTest("no python3 on centos:7")
        docker = _docker
        package = package_tool(image)
        refresh = refresh_tool(image)
        sometime = SOMETIME or 188
        user = self.user()
        testsleep = self.testname("sleep")
        shell_file(os_path(testdir, "zzz.init"), """
            #! /bin/bash
            case "$1" in start)
               (/usr/bin/{testsleep} 111 0<&- &>/dev/null &) &
               wait %1
               # ps -o pid,ppid,user,args >&2
            ;; stop)
               killall {testsleep}
               echo killed all {testsleep} >&2
               sleep 1
            ;; esac
            echo "done$1" >&2
            exit 0
            """.format(**locals()))
        text_file(os_path(testdir, "zzz.service"), """
            [Unit]
            Description=Testing Z
            [Service]
            Type=forking
            ExecStart=/usr/bin/zzz.init start
            ExecStop=/usr/bin/zzz.init stop
            [Install]
            WantedBy=multi-user.target
            """.format(**locals()))
        #
        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} cp /bin/sleep /usr/bin/{testsleep}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} touch /var/log/systemctl.debug.log"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/ps || {package} install -y procps'"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sx____(cmd.format(**locals()))
        if COVERAGE:
            cmd = "{docker} exec {testname} {package} install -y {python_coverage}"
            sh____(cmd.format(**locals()))
        self.prep_coverage(image, testname, cov_option)
        cmd = "{docker} exec {testname} systemctl --version"
        sh____(cmd.format(**locals()))
        #
        cmd = "{docker} exec {testname} mkdir -p /etc/systemd/system"
        sx____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zzz.service {testname}:/etc/systemd/system/zzz.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {testdir}/zzz.init {testname}:/usr/bin/zzz.init"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl enable zzz.service"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl default-services -v"
        out2 = output(cmd.format(**locals()))
        logg.info("\n>\n%s", out2)
        #
        cmd = "{docker} commit -c 'CMD [\"/usr/bin/systemctl\",\"{cov_option}\"]'  {testname} {images}:{testname}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name {testname} {images}:{testname}"
        sh____(cmd.format(**locals()))
        time.sleep(3)
        #
        cmd = "{docker} exec {testname} ps -eo state,pid,ppid,user,args"
        top = output(cmd.format(**locals()))
        logg.info("\n>>>\n%s", top)
        # testsleep is running with parent-pid of '1'
        self.assertTrue(greps(top, " 1 root */usr/bin/.*sleep 111"))
        # and the pid '1' is systemctl (actually systemctl.py)
        self.assertTrue(greps(top, " 1 .* 0 .*systemctl"))
        # and let's check no zombies around so far:
        self.assertFalse(greps(top, "Z .*sleep.*<defunct>")) # <<< no zombie yet
        #
        # check the subprocess
        m = re.search(r"(?m)^(\S+)\s+(\d+)\s+(\d+)\s+(\S+.*sleep 111.*)$", top)
        if m:
            state, pid, ppid, args = m.groups()
        logg.info(" - sleep state = %s", state)
        logg.info(" - sleep pid = %s", pid)
        logg.info(" - sleep ppid = %s", ppid)
        logg.info(" - sleep args = %s", args)
        self.assertEqual(state, "S")
        self.assertEqual(ppid, "1")
        self.assertIn("sleep", args)
        #
        # and kill the subprocess
        cmd = "{docker} exec {testname} kill {pid}"
        sh____(cmd.format(**locals()))
        #
        time.sleep(1)
        cmd = "{docker} exec {testname} ps -eo state,pid,ppid,user,args"
        top = output(cmd.format(**locals()))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "Z .*sleep.*<defunct>")) # <<< we have zombie!
        for attempt in xrange(10):
            time.sleep(3)
            cmd = "{docker} exec {testname} ps -eo state,pid,ppid,user,args"
            top = output(cmd.format(**locals()))
            logg.info("\n[%s]>>>\n%s", attempt, top)
            if not greps(top, "<defunct>"):
                break
        #
        cmd = "{docker} exec {testname} ps -eo state,pid,ppid,user,args"
        top = output(cmd.format(**locals()))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, "Z .*sleep.*<defunct>")) # <<< and it's gone!
        time.sleep(1)
        #
        cmd = "{docker} stop {testname}"
        out3 = output(cmd.format(**locals()))
        logg.info("\n>\n%s", out3)
        #
        self.save_coverage(testname)
        #
        cmd = "{docker} rmi {images}:{testname}"
        sx____(cmd.format(**locals()))
        self.rm_docker(testname)
        self.rm_testdir()

    def test_7001_centos_httpd(self) -> None:
        """ WHEN using a systemd-enabled CentOS 7,
            THEN we can create an image with an Apache HTTP service
                 being installed and enabled.
            Without a special startup.sh script or container-cmd
            one can just start the image and in the container
            expecting that the service is started. Therefore,
            WHEN we start the image as a docker container
            THEN we can download the root html showing 'OK'
            because the test script has placed an index.html
            in the webserver containing that text. """
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        images = IMAGES
        image = self.local_image(IMAGE or CENTOS)
        if "centos" not in image:
            if SKIP: self.skipTest("centos-based test")
        if _python.endswith("python3") and "centos:7" in image:
            if SKIP: self.skipTest("no python3 on centos:7")
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        docker = _docker
        package = package_tool(image)
        refresh = refresh_tool(image)
        testname=self.testname()
        testport=self.testport()
        name="centos-httpd"
        systemctl_py = _systemctl_py
        sometime = SOMETIME or 288
        logg.info("%s:%s %s", testname, testport, image)
        # WHEN
        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {systemctl_py} {testname}:/usr/bin/systemctl"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {package} install -y httpd httpd-tools"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {systemctl_py} {testname}:/usr/bin/systemctl"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl enable httpd"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} sh -c 'echo TEST_OK > /var/www/html/index.html'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} commit -c 'CMD [\"/usr/bin/systemctl\"]'  {testname} {images}:{testname}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} stop {testname}"
        sx____(cmd.format(**locals()))
        #
        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run -d -p {testport}:80 --name {testname} {images}:{testname}"
        sh____(cmd.format(**locals()))
        # THEN
        tmp = self.testdir(testname)
        cmd = "sleep 5; wget -O {tmp}/{testname}.txt http://127.0.0.1:{testport}"
        sh____(cmd.format(**locals()))
        cmd = "grep OK {tmp}/{testname}.txt"
        sh____(cmd.format(**locals()))
        # CLEAN
        cmd = "{docker} rmi {images}:{testname}"
        sx____(cmd.format(**locals()))
        self.rm_docker(testname)
        self.rm_testdir()
    def test_7002_centos_postgres(self) -> None:
        """ WHEN using a systemd-enabled CentOS 7,
            THEN we can create an image with an PostgreSql DB service
                 being installed and enabled.
            Without a special startup.sh script or container-cmd
            one can just start the image and in the container
            expecting that the service is started. Therefore,
            WHEN we start the image as a docker container
            THEN we can see a specific role with an SQL query
            because the test script has created a new user account
            in the in the database with a known password. """
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        if not os.path.exists(PSQL_TOOL): self.skipTest("postgres tools missing on host")
        images = IMAGES
        image = self.local_image(IMAGE or CENTOS)
        if "centos:7" not in image:
            if SKIP: self.skipTest("centos:7 based test")
        if _python.endswith("python3") and "centos:7" in image:
            if SKIP: self.skipTest("no python3 on centos:7")
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        docker = _docker
        package = package_tool(image)
        refresh = refresh_tool(image)
        testname=self.testname()
        testport=self.testport()
        name="centos-postgres"
        systemctl_py = _systemctl_py
        sometime = SOMETIME or 288
        logg.info("%s:%s %s", testname, testport, image)
        psql = PSQL_TOOL
        PG = "/var/lib/pgsql/data"
        # WHEN
        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {systemctl_py} {testname}:/usr/bin/systemctl"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {package} install -y postgresql-server postgresql-utils"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {systemctl_py} {testname}:/usr/bin/systemctl"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} postgresql-setup initdb"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} sh -c \"sed -i -e 's/.*listen_addresses.*/listen_addresses = '\\\"'*'\\\"'/' {PG}/postgresql.conf\""
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} sh -c 'sed -i -e \"s/.*host.*ident/# &/\" {PG}/pg_hba.conf'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} sh -c 'echo \"host all all 0.0.0.0/0 md5\" >> {PG}/pg_hba.conf'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl start postgresql -vv"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} sh -c 'sleep 5; ps -ax'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} sh -c \"echo 'CREATE USER testuser_11 LOGIN ENCRYPTED PASSWORD '\\\"'Testuser.11'\\\" | runuser -u postgres /usr/bin/psql\""
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} sh -c \"echo 'CREATE USER testuser_OK LOGIN ENCRYPTED PASSWORD '\\\"'Testuser.OK'\\\" | runuser -u postgres /usr/bin/psql\""
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl stop postgresql -vv"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl enable postgresql"
        sh____(cmd.format(**locals()))
        cmd = "{docker} commit -c 'CMD [\"/usr/bin/systemctl\"]'  {testname} {images}:{testname}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} stop {testname}"
        sx____(cmd.format(**locals()))
        #
        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run -d -p {testport}:5432 --name {testname} {images}:{testname}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} sleep 5"
        sh____(cmd.format(**locals()))
        # THEN
        tmp = self.testdir(testname)
        login = "export PGUSER=testuser_11; export PGPASSWORD=Testuser.11"
        query = "SELECT rolname FROM pg_roles"
        cmd = "{login}; {psql} -p {testport} -h 127.0.0.1 -d postgres -c '{query}' > {tmp}/{testname}.txt"
        sh____(cmd.format(**locals()))
        cmd = "grep testuser_ok {tmp}/{testname}.txt"
        sh____(cmd.format(**locals()))
        # CLEAN
        cmd = "{docker} rmi {images}:{testname}"
        sx____(cmd.format(**locals()))
        self.rm_docker(testname)
        self.rm_testdir()
    def test_7003_opensuse_syslog(self) -> None:
        """ WHEN using a systemd-enabled CentOS 7 ..."""
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        images = IMAGES
        image = self.local_image(IMAGE or OPENSUSE)
        if "opensuse/leap" not in image:
            if SKIP: self.skipTest("opensuse/leap based test")
        if _python.endswith("python3") and "centos:7" in image:
            if SKIP: self.skipTest("no python3 on centos:7")
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        docker = _docker
        package = package_tool(image)
        refresh = refresh_tool(image)
        testname=self.testname()
        # testport=self.testport()
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        name="opensuse-syslog"
        systemctl_py = _systemctl_py
        sometime = SOMETIME or 288
        ## logg.info("%s:%s %s", testname, testport, image)
        # WHEN
        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {systemctl_py} {testname}:/usr/bin/systemctl"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {package} install -y rsyslog"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {systemctl_py} {testname}:/usr/bin/systemctl"
        sh____(cmd.format(**locals()))
        # ?# cmd = "{docker} exec {testname} systemctl enable syslog.socket"
        # ?# sh____(cmd.format(**locals()))
        #
        cmd = "{docker} exec {testname} systemctl start syslog.socket -vvv"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl is-active syslog.socket -vvv"
        sx____(cmd.format(**locals()))
        # -> it does currently return "inactive" but same for "syslog.service"
        #
        cmd = "{docker} exec {testname} systemctl stop syslog.socket -vvv"
        sh____(cmd.format(**locals()))
        # CLEAN
        cmd = "{docker} rmi {images}:{testname}"
        sx____(cmd.format(**locals()))
        self.rm_docker(testname)
        self.rm_testdir()
    def test_7011_centos_httpd_socket_notify(self) -> None:
        """ WHEN using an image for a systemd-enabled CentOS 7,
            THEN we can create an image with an Apache HTTP service
                 being installed and enabled.
            WHEN we start the image as a docker container
            THEN we can download the root html showing 'OK'
            and in the systemctl.debug.log we can see NOTIFY_SOCKET
            messages with Apache sending a READY and MAINPID value."""
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        images = IMAGES
        image = self.local_image(IMAGE or CENTOS)
        if "centos" not in image:
            if SKIP: self.skipTest("centos based test")
        if _python.endswith("python3") and "centos:7" in image:
            if SKIP: self.skipTest("no python3 on centos:7")
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        docker = _docker
        package = package_tool(image)
        refresh = refresh_tool(image)
        testname=self.testname()
        testdir = self.testdir(testname)
        testport=self.testport()
        systemctl_py = _systemctl_py
        sometime = SOMETIME or 288
        logg.info("%s:%s %s", testname, testport, image)
        #
        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {systemctl_py} {testname}:/usr/bin/systemctl"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {package} install -y httpd httpd-tools"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl enable httpd"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'echo TEST_OK > /var/www/html/index.html'"
        sh____(cmd.format(**locals()))
        #
        ## cmd = "{docker} commit -c 'CMD [\"/usr/bin/systemctl\",\"init\",\"-vv\"]'  {testname} {images}:{testname}"
        # sh____(cmd.format(**locals()))
        ## cmd = "{docker} rm --force {testname}"
        # sx____(cmd.format(**locals()))
        ## cmd = "{docker} run --detach --name {testname} {images}:{testname} sleep 200"
        # sh____(cmd.format(**locals()))
        # time.sleep(3)
        #
        container = ip_container(testname)
        cmd = "{docker} exec {testname} touch /var/log/systemctl.debug.log"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl start httpd"
        sh____(cmd.format(**locals()))
        # THEN
        time.sleep(5)
        cmd = "wget -O {testdir}/result.txt http://{container}:80"
        sh____(cmd.format(**locals()))
        cmd = "grep OK {testdir}/result.txt"
        sh____(cmd.format(**locals()))
        # STOP
        cmd = "{docker} exec {testname} systemctl status httpd"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl stop httpd"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl status httpd"
        sx____(cmd.format(**locals()))
        cmd = "{docker} cp {testname}:/var/log/systemctl.debug.log {testdir}/systemctl.debug.log"
        sh____(cmd.format(**locals()))
        # CHECK
        debug_log = lines(open(testdir+"/systemctl.debug.log"))
        if len(greps(debug_log, "Oops, ")):
            self.assertTrue(greps(debug_log, "Service directory option not supported: PrivateTmp=yes"))
            self.assertTrue(greps(debug_log, "unsupported directory settings. You need to create those before using the service."))
            self.assertGreater(len(greps(debug_log, " ERROR ")), 2)
        else:
            self.assertEqual(len(greps(debug_log, " ERROR ")), 0)
        self.assertTrue(greps(debug_log, "use NOTIFY_SOCKET="))
        self.assertTrue(greps(debug_log, "read_notify.*READY=1.*MAINPID="))
        self.assertTrue(greps(debug_log, "notify start done"))
        if "centos:7" in IMAGE:
            self.assertTrue(greps(debug_log, "stop '/bin/kill' '-WINCH'"))
            self.assertTrue(greps(debug_log, "wait for PID .* is done"))
        else:
            self.assertTrue(greps(debug_log, "no ExecStop => systemctl kill"))
            self.assertTrue(greps(debug_log, "done kill PID"))
        self.assertTrue(greps(debug_log, "wait [$]NOTIFY_SOCKET"))
        self.rm_docker(testname)
        self.rm_testdir()
    def test_7020_ubuntu_apache2_with_saved_container(self) -> None:
        """ WHEN using a systemd enabled Ubuntu as the base image
            THEN we can create an image with an Apache HTTP service
                 being installed and enabled.
            Without a special startup.sh script or container-cmd
            one can just start the image and in the container
            expecting that the service is started. Therefore,
            WHEN we start the image as a docker container
            THEN we can download the root html showing 'OK'
            because the test script has placed an index.html
            in the webserver containing that text. """
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        images = IMAGES
        image = self.local_image(IMAGE or UBUNTU)
        if "ubuntu" not in image:
            if SKIP: self.skipTest("ubuntu-based test")
        testname = self.testname()
        port=self.testport()
        systemctl_py = _systemctl_py
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        docker = _docker
        package = package_tool(image)
        refresh = refresh_tool(image)
        sometime = SOMETIME or 288
        logg.info("%s:%s %s", testname, port, image)
        #
        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {package} install -y apache2"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {systemctl_py} {testname}:/usr/bin/systemctl"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'grep python /bin/systemctl || test -L /bin/systemctl || ln -sf /usr/bin/systemctl /bin/systemctl'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl enable apache2"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'echo TEST_OK > /var/www/html/index.html'"
        sh____(cmd.format(**locals()))
        # .........................................
        cmd = "{docker} commit -c 'CMD [\"/usr/bin/systemctl\"]'  {testname} {images}:{testname}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} stop {testname}"
        sx____(cmd.format(**locals()))
        #
        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run -d -p {port}:80 --name {testname} {images}:{testname}"
        sh____(cmd.format(**locals()))
        # THEN
        tmp = self.testdir(testname)
        cmd = "sleep 5; wget -O {tmp}/{testname}.txt http://127.0.0.1:{port}"
        sh____(cmd.format(**locals()))
        cmd = "grep OK {tmp}/{testname}.txt"
        sh____(cmd.format(**locals()))
        # CLEAN
        cmd = "{docker} rmi {images}:{testname}"
        sx____(cmd.format(**locals()))
        self.rm_docker(testname)
        self.rm_testdir()
    def test_7502_centos_postgres_user_mode_container(self) -> None:
        """ WHEN using a systemd-enabled CentOS 7,
            THEN we can create an image with an PostgreSql DB service
                 being installed and enabled.
            Without a special startup.sh script or container-cmd
            one can just start the image and in the container
            expecting that the service is started. Instead of a normal root-based
            start we use a --user mode start here. But we do not use special
            user-mode *.service files."""
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        if not os.path.exists(PSQL_TOOL): self.skipTest("postgres tools missing on host")
        images = IMAGES
        image = self.local_image(IMAGE or CENTOS)
        if "centos:7" not in image:
            if SKIP: self.skipTest("centos:7 based test")
        if _python.endswith("python3") and "centos:7" in image:
            if SKIP: self.skipTest("no python3 on centos:7")
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        docker = _docker
        package = package_tool(image)
        refresh = refresh_tool(image)
        testname=self.testname()
        testport=self.testport()
        name="centos-postgres"
        systemctl_py = _systemctl_py
        sometime = SOMETIME or 288
        logg.info("%s:%s %s", testname, testport, image)
        psql = PSQL_TOOL
        PG = "/var/lib/pgsql/data"
        # WHEN
        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {systemctl_py} {testname}:/usr/bin/systemctl"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {package} install -y postgresql-server postgresql-utils"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {systemctl_py} {testname}:/usr/bin/systemctl"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} postgresql-setup initdb"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} sh -c \"sed -i -e 's/.*listen_addresses.*/listen_addresses = '\\\"'*'\\\"'/' {PG}/postgresql.conf\""
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} sh -c 'sed -i -e \"s/.*host.*ident/# &/\" {PG}/pg_hba.conf'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} sh -c 'echo \"host all all 0.0.0.0/0 md5\" >> {PG}/pg_hba.conf'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl start postgresql -vv"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} sh -c 'sleep 5; ps -ax'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} sh -c \"echo 'CREATE USER testuser_11 LOGIN ENCRYPTED PASSWORD '\\\"'Testuser.11'\\\" | runuser -u postgres /usr/bin/psql\""
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} sh -c \"echo 'CREATE USER testuser_OK LOGIN ENCRYPTED PASSWORD '\\\"'Testuser.OK'\\\" | runuser -u postgres /usr/bin/psql\""
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl stop postgresql -vv"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl enable postgresql"
        sh____(cmd.format(**locals()))
        cmd = "{docker} commit -c 'CMD [\"/usr/bin/systemctl\"]'  {testname} {images}:{testname}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} stop {testname}"
        sx____(cmd.format(**locals()))
        #
        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run -d -p {testport}:5432 --name {testname} -u postgres {images}:{testname}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} sleep 5"
        sh____(cmd.format(**locals()))
        ############ the PID-1 has been run in systemctl.py --user mode #####
        # THEN
        tmp = self.testdir(testname)
        login = "export PGUSER=testuser_11; export PGPASSWORD=Testuser.11"
        query = "SELECT rolname FROM pg_roles"
        cmd = "{login}; {psql} -p {testport} -h 127.0.0.1 -d postgres -c '{query}' > {tmp}/{testname}.txt"
        sh____(cmd.format(**locals()))
        cmd = "grep testuser_ok {tmp}/{testname}.txt"
        sh____(cmd.format(**locals()))
        # CLEAN
        cmd = "{docker} rmi {images}:{testname}"
        sx____(cmd.format(**locals()))
        self.rm_docker(testname)
        self.rm_testdir()
    # @unittest.expectedFailure
    def test_8001_issue_1_start_mariadb_centos(self) -> None:
        """ issue 1: mariadb on centos does not start"""
        # this was based on the expectation that "yum install mariadb" would allow
        # for a "systemctl start mysql" which in fact it doesn't. Double-checking
        # with "yum install mariadb-server" and "systemctl start mariadb" shows
        # that mariadb's unit file is buggy, because it does not specify a kill
        # signal that it's mysqld_safe controller does not ignore.
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        images = IMAGES
        image = self.local_image(IMAGE or CENTOS)
        if "centos" not in image:
            if SKIP: self.skipTest("centos-based test")
        if _python.endswith("python3") and "centos:7" in image:
            if SKIP: self.skipTest("no python3 on centos:7")
        # image = "centos:centos7.0.1406" # <<<< can not yum-install mariadb-server ?
        # image = "centos:centos7.1.1503"
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        docker = _docker
        package = package_tool(image)
        refresh = refresh_tool(image)
        testname = self.testname()
        testdir = self.testdir()
        systemctl_py = _systemctl_py
        sometime = SOMETIME or 288
        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        # mariadb has a TimeoutSec=300 in the unit config:
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {systemctl_py} {testname}:/usr/bin/systemctl"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} yum install -y mariadb"
        sh____(cmd.format(**locals()))
        if False:
            # expected in bug report but that one can not work:
            cmd = "{docker} exec {testname} systemctl enable mysql"
            sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl --version"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl list-unit-files --type=service"
        sh____(cmd.format(**locals()))
        out = output(cmd.format(**locals()))
        self.assertFalse(greps(out, "mysqld"))
        #
        cmd = "{docker} exec {testname} yum install -y mariadb-server"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl list-unit-files --type=service"
        sh____(cmd.format(**locals()))
        out = output(cmd.format(**locals()))
        self.assertTrue(greps(out, "mariadb.service"))
        #
        cmd = "{docker} exec {testname} systemctl start mariadb -vv"
        sh____(cmd.format(**locals()))
        #
        cmd = "{docker} exec {testname} ps -eo pid,ppid,user,args"
        top = output(cmd.format(**locals()))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "mysqld "))
        had_mysqld_safe = greps(top, "mysqld_safe ")
        #
        # NOTE: mariadb-5.5.52's mysqld_safe controller does ignore systemctl kill
        # but after a TimeoutSec=300 the 'systemctl kill' will send a SIGKILL to it
        # which leaves the mysqld to be still running -> this is an upstream error.
        cmd = "{docker} exec {testname} systemctl stop mariadb -vv"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} ps -eo pid,ppid,user,args"
        top = output(cmd.format(**locals()))
        logg.info("\n>>>\n%s", top)
        # self.assertFalse(greps(top, "mysqld "))
        if greps(top, "mysqld ") and had_mysqld_safe:
            logg.critical("mysqld still running => this is an uptream error!")
        #
        self.rm_docker(testname)
        self.rm_testdir()
    def test_8002_issue_2_start_rsyslog_centos(self) -> None:
        """ issue 2: rsyslog on centos does not start"""
        # this was based on a ";Requires=xy" line in the unit file
        # but our unit parser did not regard ";" as starting a comment
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        images = IMAGES
        image = self.local_image(IMAGE or CENTOS)
        if "centos" not in image:
            if SKIP: self.skipTest("centos-based test")
        if _python.endswith("python3") and "centos:7" in image:
            if SKIP: self.skipTest("no python3 on centos:7")
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        docker = _docker
        package = package_tool(image)
        refresh = refresh_tool(image)
        testname = self.testname()
        testdir = self.testdir()
        systemctl_py = _systemctl_py
        sometime = SOMETIME or 188
        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {systemctl_py} {testname}:/usr/bin/systemctl"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} yum install -y rsyslog"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl --version"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl list-unit-files --type=service"
        sh____(cmd.format(**locals()))
        out = output(cmd.format(**locals()))
        self.assertTrue(greps(out, "rsyslog.service.*enabled"))
        #
        cmd = "{docker} exec {testname} systemctl start rsyslog -vv"
        sh____(cmd.format(**locals()))
        #
        cmd = "{docker} exec {testname} ps -eo pid,ppid,user,args"
        top = output(cmd.format(**locals()))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "/usr/sbin/rsyslog"))
        #
        cmd = "{docker} exec {testname} systemctl stop rsyslog -vv"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} ps -eo pid,ppid,user,args"
        top = output(cmd.format(**locals()))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, "/usr/sbin/rsyslog"))
        #
        self.rm_docker(testname)
        self.rm_testdir()
    def test_8011_centos_httpd_socket_notify(self) -> None:
        """ start/restart behaviour if a httpd has failed - issue #11 """
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        images = IMAGES
        image = self.local_image(IMAGE or CENTOS)
        if "centos" not in image:
            if SKIP: self.skipTest("centos-based test")
        if _python.endswith("python3") and "centos:7" in image:
            if SKIP: self.skipTest("no python3 on centos:7")
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        docker = _docker
        package = package_tool(image)
        refresh = refresh_tool(image)
        testname=self.testname()
        testdir = self.testdir(testname)
        testport=self.testport()
        systemctl_py = _systemctl_py
        sometime = SOMETIME or 388
        logg.info("%s:%s %s", testname, testport, image)
        #
        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {systemctl_py} {testname}:/usr/bin/systemctl"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} yum install -y httpd httpd-tools"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl enable httpd"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'echo TEST_OK > /var/www/html/index.html'"
        sh____(cmd.format(**locals()))
        #
        container = ip_container(testname)
        cmd = "{docker} exec {testname} touch /var/log/systemctl.debug.log"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl start httpd"
        sh____(cmd.format(**locals()))
        # THEN
        time.sleep(5)
        cmd = "wget -O {testdir}/result.txt http://{container}:80"
        sh____(cmd.format(**locals()))
        cmd = "grep OK {testdir}/result.txt"
        sh____(cmd.format(**locals()))
        # STOP
        cmd = "{docker} exec {testname} systemctl status httpd"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl stop httpd"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl status httpd"
        #
        # CRASH
        cmd = "{docker} exec {testname} bash -c 'cp /etc/httpd/conf/httpd.conf /etc/httpd/conf/httpd.conf.orig'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'echo foo > /etc/httpd/conf/httpd.conf'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl start httpd"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertNotEqual(end, 0) # start failed
        cmd = "{docker} exec {testname} systemctl status httpd"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertNotEqual(end, 0)
        cmd = "{docker} exec {testname} systemctl restart httpd"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertNotEqual(end, 0) # restart failed
        #
        cmd = "{docker} exec {testname} bash -c 'cat /etc/httpd/conf/httpd.conf.orig > /etc/httpd/conf/httpd.conf'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl restart httpd"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0) # restart ok
        cmd = "{docker} exec {testname} systemctl stop httpd"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0) # down
        cmd = "{docker} exec {testname} systemctl status httpd"
        sx____(cmd.format(**locals()))
        #
        cmd = "{docker} cp {testname}:/var/log/systemctl.debug.log {testdir}/systemctl.debug.log"
        sh____(cmd.format(**locals()))
        #
        self.rm_docker(testname)
        self.rm_testdir()
    def test_8031_centos_nginx_restart(self) -> None:
        """ start/restart behaviour if a nginx has failed - issue #31 """
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        images = IMAGES
        image = self.local_image(IMAGE or CENTOS)
        if "centos" not in image:
            if SKIP: self.skipTest("centos-based test")
        if _python.endswith("python3") and "centos:7" in image:
            if SKIP: self.skipTest("no python3 on centos:7")
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        docker = _docker
        package = package_tool(image)
        refresh = refresh_tool(image)
        testname=self.testname()
        testdir = self.testdir(testname)
        testport=self.testport()
        systemctl_py = _systemctl_py
        sometime = SOMETIME or 388
        logg.info("%s:%s %s", testname, testport, image)
        #
        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {systemctl_py} {testname}:/usr/bin/systemctl"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {package} install -y epel-release"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {package} install -y nginx"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl enable nginx"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} rpm -q --list nginx"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'rm /usr/share/nginx/html/index.html'" # newer nginx is broken
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'echo TEST_OK > /usr/share/nginx/html/index.html'"
        sh____(cmd.format(**locals()))
        #
        container = ip_container(testname)
        cmd = "{docker} exec {testname} touch /var/log/systemctl.debug.log"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl start nginx"
        sh____(cmd.format(**locals()))
        # THEN
        time.sleep(5)
        cmd = "wget -O {testdir}/result.txt http://{container}:80"
        sh____(cmd.format(**locals()))
        cmd = "grep OK {testdir}/result.txt"
        sh____(cmd.format(**locals()))
        # STOP
        cmd = "{docker} exec {testname} systemctl status nginx"
        sh____(cmd.format(**locals()))
        #
        top = _recent(running(output(_top_list)))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "nginx"))
        #
        cmd = "{docker} exec {testname} systemctl restart nginx"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0) # restart ok
        top = _recent(running(output(_top_list)))
        logg.info("\n>>>\n%s", top)
        self.assertTrue(greps(top, "nginx"))
        #
        cmd = "{docker} exec {testname} systemctl status nginx"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl stop nginx"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(end, 0) # down
        cmd = "{docker} exec {testname} systemctl status nginx"
        sx____(cmd.format(**locals()))
        top = _recent(running(output(_top_list)))
        logg.info("\n>>>\n%s", top)
        self.assertFalse(greps(top, "nginx"))
        #
        cmd = "{docker} cp {testname}:/var/log/systemctl.debug.log {testdir}/systemctl.debug.log"
        sh____(cmd.format(**locals()))
        #
        self.rm_docker(testname)
        self.rm_testdir()
    def test_8034_testing_mask_unmask(self) -> None:
        """ Checking the issue 34 on Ubuntu """
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        images = IMAGES
        image = self.local_image(IMAGE or UBUNTU)
        docker = _docker
        package = package_tool(image)
        refresh = refresh_tool(image)
        testname = self.testname()
        testdir = self.testdir(testname)
        port=self.testport()
        python = os.path.basename(_python)
        python_x = python_package(_python, image)
        systemctl_py = _systemctl_py
        sometime = SOMETIME or 288
        logg.info("%s:%s %s", testname, port, image)
        #
        cmd = "{docker} rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "{docker} run --detach --name={testname} {image} sleep {sometime}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} cp {systemctl_py} {testname}:/usr/bin/systemctl"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {refresh}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} bash -c 'ls -l /usr/bin/{python} || {package} install -y {python_x}'"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} {package} install -y rsyslog"
        sh____(cmd.format(**locals()))
        ## container = ip_container(testname)
        cmd = "{docker} exec {testname} touch /var/log/systemctl.debug.log"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl status rsyslog.service"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} ls -l /etc/systemd/system"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl mask rsyslog.service"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl status rsyslog.service"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} ls -l /etc/systemd/system"
        sh____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl start rsyslog.service"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl unmask rsyslog.service"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} systemctl status rsyslog.service"
        sx____(cmd.format(**locals()))
        cmd = "{docker} exec {testname} ls -l /etc/systemd/system"
        sh____(cmd.format(**locals()))
        #
        cmd = "{docker} cp {testname}:/var/log/systemctl.debug.log {testdir}/systemctl.debug.log"
        sh____(cmd.format(**locals()))
        cmd = "{docker} stop {testname}"
        sh____(cmd.format(**locals()))
        cmd = "{docker} rm --force {testname}"
        sh____(cmd.format(**locals()))
        #
        self.rm_testdir()
    text_8051_serv = """# systemctl.py cat kubelet
[Unit]
Description=kubelet: The Kubernetes Node Agent
Documentation=https://kubernetes.io/docs/home/

[Service]
ExecStart=/usr/bin/kubelet
Restart=always
StartLimitInterval=0
RestartSec=10

[Install]
WantedBy=multi-user.target
"""
    text_8051_conf = """# cat /etc/systemd/system/kubelet.service.d/10-kubeadm.conf
# Note: This dropin only works with kubeadm and kubelet v1.11+
[Service]
Environment="KUBELET_KUBECONFIG_ARGS=--bootstrap-kubeconfig=/etc/kubernetes/bootstrap-kubelet.conf --kubeconfig=/etc/kubernetes/kubelet.conf"
Environment="KUBELET_CONFIG_ARGS=--config=/var/lib/kubelet/config.yaml"
# This is a file that "kubeadm init" and "kubeadm join" generates at runtime, populating the KUBELET_KUBEADM_ARGS variable dynamically
EnvironmentFile=-/var/lib/kubelet/kubeadm-flags.env
# This is a file that the user can use for overrides of the kubelet args as a last resort. Preferably, the user should use
# the .NodeRegistration.KubeletExtraArgs object in the configuration files instead. KUBELET_EXTRA_ARGS should be sourced from this file.
EnvironmentFile=-/etc/default/kubelet
ExecStart=
ExecStart=/usr/bin/kubelet $KUBELET_KUBECONFIG_ARGS $KUBELET_CONFIG_ARGS $KUBELET_KUBEADM_ARGS $KUBELET_EXTRA_ARGS
    """
    def test_8051_systemctl_extra_conf_dirs(self) -> None:
        """ checking issue #51 on extra conf dirs """
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/lib/systemd/system/kubelet.service"), self.text_8051_serv)
        text_file(os_path(root, "/lib/systemd/system/kubelet.service.d/10-kubeadm.conf"), self.text_8051_conf)
        #
        cmd = "{systemctl} environment kubelet -vvv"
        out, end = output2(cmd.format(**locals()))
        logg.debug(" %s =>%s\n%s", cmd, end, out)
        logg.info(" HAVE %s", greps(out, "HOME"))
        logg.info(" HAVE %s", greps(out, "KUBE"))
        self.assertTrue(greps(out, "KUBELET_CONFIG_ARGS=--config"))
        self.assertEqual(len(greps(out, "KUBE")), 2)
        cmd = "{systemctl} command kubelet -vvv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines(out)), 1)
        self.assertTrue(greps(out, "KUBELET_KUBECONFIG_ARGS"))
        self.rm_testdir()
        self.coverage()
    def test_8052_systemctl_extra_conf_dirs(self) -> None:
        """ checking issue #52 on extra conf dirs """
        testdir = self.testdir()
        root = self.root(testdir)
        systemctl = cover() + _systemctl_py + " --root=" + root
        text_file(os_path(root, "/lib/systemd/system/kubelet.service"), self.text_8051_serv)
        text_file(os_path(root, "/etc/systemd/system/kubelet.service.d/10-kubeadm.conf"), self.text_8051_conf)
        #
        cmd = "{systemctl} environment kubelet -vvv"
        out, end = output2(cmd.format(**locals()))
        logg.debug(" %s =>%s\n%s", cmd, end, out)
        logg.info(" HAVE %s", greps(out, "HOME"))
        logg.info(" HAVE %s", greps(out, "KUBE"))
        self.assertTrue(greps(out, "KUBELET_CONFIG_ARGS=--config"))
        self.assertEqual(len(greps(out, "KUBE")), 2)
        cmd = "{systemctl} command kubelet -vvv"
        out, end = output2(cmd.format(**locals()))
        logg.info(" %s =>%s\n%s", cmd, end, out)
        self.assertEqual(len(lines(out)), 1)
        self.assertTrue(greps(out, "KUBELET_KUBECONFIG_ARGS"))
        self.rm_testdir()
        self.coverage()
    def test_9531_centos7_lamp_stack(self) -> None:
        """ Check setup of Linux/Apache/Mariadb/Php on CentOs 7 with python2"""
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        python = _python or _python2
        if python.endswith("python3"): self.skipTest("no python3 on centos:7")
        testname=self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        dockerfile="test-centos7-lamp-stack.dockerfile"
        addhosts = self.local_addhosts(dockerfile)
        savename = docname(dockerfile)
        saveto = SAVETO
        images = IMAGES
        psql = PSQL_TOOL
        password = self.newpassword()
        # WHEN
        cmd = "docker build . -f {dockerfile} {addhosts} --build-arg PASSWORD={password} --tag {images}:{testname}"
        sh____(cmd.format(**locals()))
        cmd = "docker rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "docker run -d --name {testname} {images}:{testname}"
        sh____(cmd.format(**locals()))
        #
        container = self.ip_container(testname)
        # THEN
        for attempt in xrange(10):
            time.sleep(1)
            cmd = "wget -O {testdir}/result.txt http://{container}/phpMyAdmin"
            out, err, end = output3(cmd.format(**locals()))
            if "503 Service Unavailable" in err:
                logg.info("[%i] ..... 503 %s", attempt, greps(err, "503 "))
                continue
            if "200 OK" in err:
                logg.info("[%i] ..... 200 %s", attempt, greps(err, "200 "))
                break
            logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = "wget -O {testdir}/result.txt http://{container}/phpMyAdmin"
        sh____(cmd.format(**locals()))
        cmd = "grep '<h1>.*>phpMyAdmin<' {testdir}/result.txt"
        sh____(cmd.format(**locals()))
        #cmd = "docker cp {testname}:/var/log/systemctl.log {testdir}/systemctl.log"
        # sh____(cmd.format(**locals()))
        # SAVE
        cmd = "docker stop {testname}"
        sh____(cmd.format(**locals()))
        cmd = "docker rm --force {testname}"
        sh____(cmd.format(**locals()))
        cmd = "docker rmi {saveto}/{savename}:latest"
        sx____(cmd.format(**locals()))
        cmd = "docker tag {images}:{testname} {saveto}/{savename}:latest"
        sh____(cmd.format(**locals()))
        cmd = "docker rmi {images}:{testname}"
        sx____(cmd.format(**locals()))
        self.rm_testdir()
    def test_9541_opensuse15_lamp_stack_php7(self) -> None:
        """ Check setup of Linux/Apache/Mariadb/Php" on Opensuse later than 15.x"""
        if not os.path.exists(DOCKER_SOCKET): self.skipTest("docker-based test")
        testname=self.testname()
        testdir = self.testdir()
        root = self.root(testdir)
        dockerfile="test-opensuse15-lamp-stack.dockerfile"
        addhosts = self.local_addhosts(dockerfile)
        savename = docname(dockerfile)
        saveto = SAVETO
        images = IMAGES
        psql = PSQL_TOOL
        password = self.newpassword()
        # WHEN
        cmd = "docker build . -f {dockerfile} {addhosts} --build-arg PASSWORD={password} --tag {images}:{testname}"
        sh____(cmd.format(**locals()))
        cmd = "docker rm --force {testname}"
        sx____(cmd.format(**locals()))
        cmd = "docker run -d --name {testname} {images}:{testname}"
        sh____(cmd.format(**locals()))
        #
        container = self.ip_container(testname)
        # THEN
        for attempt in xrange(10):
            time.sleep(1)
            cmd = "wget -O {testdir}/result.txt http://{container}/phpMyAdmin"
            out, err, end = output3(cmd.format(**locals()))
            if "503 Service Unavailable" in err:
                logg.info("[%i] ..... 503 %s", attempt, greps(err, "503 "))
                continue
            if "200 OK" in err:
                logg.info("[%i] ..... 200 %s", attempt, greps(err, "200 "))
                break
            logg.info(" %s =>%s\n%s", cmd, end, out)
        cmd = "wget -O {testdir}/result.txt http://{container}/phpMyAdmin"
        sh____(cmd.format(**locals()))
        cmd = "grep '<h1>.*>phpMyAdmin<' {testdir}/result.txt"
        sh____(cmd.format(**locals()))
        #cmd = "docker cp {testname}:/var/log/systemctl.log {testdir}/systemctl.log"
        # sh____(cmd.format(**locals()))
        # SAVE
        cmd = "docker stop {testname}"
        sh____(cmd.format(**locals()))
        cmd = "docker rm --force {testname}"
        sh____(cmd.format(**locals()))
        cmd = "docker rmi {saveto}/{savename}:latest"
        sx____(cmd.format(**locals()))
        cmd = "docker tag {images}:{testname} {saveto}/{savename}:latest"
        sh____(cmd.format(**locals()))
        cmd = "docker rmi {images}:{testname}"
        sx____(cmd.format(**locals()))
        self.rm_testdir()
    def test_9999_drop_local_mirrors(self) -> None:
        """ a helper when using images from https://github.com/gdraheim/docker-mirror-packages-repo"
            which create containers according to self.local_image(IMAGE) """
        docker = _docker
        containers = output("{docker} ps -a".format(**locals()))
        for line in lines(containers):
            found = re.search("\\b(opensuse-repo-\\d[.\\d]*)\\b", line)
            if found:
                container = found.group(1)
                logg.info("     ---> drop %s", container)
                sx____("{docker} rm -f {container}".format(**locals()))
            found = re.search("\\b(centos-repo-\\d[.\\d]*)\\b", line)
            if found:
                container = found.group(1)
                logg.info("     ---> drop %s", container)
                sx____("{docker} rm -f {container}".format(**locals()))
            found = re.search("\\b(ubuntu-repo-\\d[.\\d]*)\\b", line)
            if found:
                container = found.group(1)
                logg.info("     ---> drop %s", container)
                sx____("{docker} rm -f {container}".format(**locals()))

if __name__ == "__main__":
    from optparse import OptionParser
    _o = OptionParser("%prog [options] test*",
                      epilog=__doc__.strip().split("\n")[0])
    _o.add_option("-v", "--verbose", action="count", default=0,
                  help="increase logging level [%default]")
    _o.add_option("--with", metavar="FILE", dest="systemctl_py", default=_systemctl_py,
                  help="systemctl.py file to be tested (%default)")
    _o.add_option("-D", "--docker", metavar="EXE", default=_docker,
                  help="use another docker container tool [%default]")
    _o.add_option("-p", "--python", metavar="EXE", default=_python,
                  help="use another python execution engine [%default]")
    _o.add_option("-a", "--coverage", action="count", default=0,
                  help="gather coverage.py data (use -aa for new set) [%default]")
    _o.add_option("-l", "--logfile", metavar="FILE", default="",
                  help="additionally save the output log to a file [%default]")
    _o.add_option("--keep", action="count", default=KEEP,
                  help="keep tempdir and other data after testcase [%default]")
    _o.add_option("--failfast", action="store_true", default=False,
                  help="Stop the test run on the first error or failure. [%default]")
    _o.add_option("--xmlresults", metavar="FILE", default=None,
                  help="capture results as a junit xml file [%default]")
    _o.add_option("--sometime", metavar="SECONDS", default=SOMETIME,
                  help="SOMETIME=%default (use 666)")
    _o.add_option("--todo", action="store_true", default=TODO,
                  help="enable TODO outtakes [%default])")
    _o.add_option("-f", "--force", action="store_true", default=False,
                  help="enable the skipped IMAGE and PYTHON versions [%default])")
    _o.add_option("-C", "--chdir", metavar="PATH", default="",
                  help="change directory before running tests {%default}")
    _o.add_option("--opensuse", metavar="NAME", default=OPENSUSE,
                  help="OPENSUSE=%default")
    _o.add_option("--ubuntu", metavar="NAME", default=UBUNTU,
                  help="UBUNTU=%default")
    _o.add_option("--centos", metavar="NAME", default=CENTOS,
                  help="CENTOS=%default")
    _o.add_option("--image", metavar="NAME", default=IMAGE,
                  help="IMAGE=%default (or CENTOS)")
    opt, args = _o.parse_args()
    logging.basicConfig(level = logging.WARNING - opt.verbose * 5)
    SKIP = not opt.force
    TODO = opt.todo
    KEEP = opt.keep
    #
    OPENSUSE = opt.opensuse
    UBUNTU = opt.ubuntu
    CENTOS = opt.centos
    IMAGE = opt.image
    if CENTOS in CENTOSVER:
        CENTOS = CENTOSVER[CENTOS]
    if ":" not in CENTOS:
        CENTOS = "centos:" + CENTOS
    if ":" not in OPENSUSE and "42" in OPENSUSE:
        OPENSUSE = "opensuse:" + OPENSUSE
    if ":" not in OPENSUSE:
        OPENSUSE = "opensuse/leap:" + OPENSUSE
    if ":" not in UBUNTU:
        UBUNTU = "ubuntu:" + UBUNTU
    if OPENSUSE not in TESTED_OS:
        logg.warning("  --opensuse '%s' was never TESTED!!!", OPENSUSE)
        beep()
        time.sleep(2)
    if UBUNTU not in TESTED_OS:
        logg.warning("  --ubuntu '%s' was never TESTED!!!", UBUNTU)
        beep()
        time.sleep(2)
    if CENTOS not in TESTED_OS:
        logg.warning("  --centos '%s' was never TESTED!!!", CENTOS)
        beep()
        time.sleep(2)
    if IMAGE and IMAGE not in TESTED_OS:
        logg.warning("  --image '%s' was never TESTED!!!", IMAGE)
        beep()
        time.sleep(2)
    #
    _systemctl_py = opt.systemctl_py
    _python = opt.python
    _docker = opt.docker
    #
    if opt.chdir:
        os.chdir(opt.chdir)
    #
    logfile = None
    if opt.logfile:
        if os.path.exists(opt.logfile):
            os.remove(opt.logfile)
        logfile = logging.FileHandler(opt.logfile)
        logfile.setFormatter(logging.Formatter("%(levelname)s:%(relativeCreated)d:%(message)s"))
        logging.getLogger().addHandler(logfile)
        logg.info("log diverted to %s", opt.logfile)
    #
    if opt.coverage:
        COVERAGE = detect_local_system() # so that coverage files can be merged
        if opt.coverage > 1:
            if os.path.exists(".coverage"):
                logg.info("rm .coverage")
                os.remove(".coverage")
    # unittest.main()
    suite = unittest.TestSuite()
    if not args: args = ["test_*"]
    for arg in args:
        for classname in sorted(globals()):
            if not classname.endswith("Test"):
                continue
            testclass = globals()[classname]
            for method in sorted(dir(testclass)):
                if "*" not in arg: arg += "*"
                if len(arg) > 2 and arg[1] == "_": 
                    arg = "test" + arg[1:]
                if fnmatch(method, arg):
                    suite.addTest(testclass(method))
    # select runner
    xmlresults = None
    if opt.xmlresults:
        if os.path.exists(opt.xmlresults):
            os.remove(opt.xmlresults)
        xmlresults = open(opt.xmlresults, "wb")
        logg.info("xml results into %s", opt.xmlresults)
    if not logfile:
        if xmlresults:
            import xmlrunner # type: ignore
            Runner = xmlrunner.XMLTestRunner
            result = Runner(xmlresults).run(suite)
        else:
            Runner = unittest.TextTestRunner
            result = Runner(verbosity=opt.verbose, failfast=opt.failfast).run(suite)
    else:
        Runner = unittest.TextTestRunner
        if xmlresults:
            import xmlrunner
            Runner = xmlrunner.XMLTestRunner
        result = Runner(logfile.stream, verbosity=opt.verbose).run(suite) # type: ignore
    if opt.coverage:
        print(" " + coverage_tool() + " combine")
        print(" " + coverage_tool() + " report " + _systemctl_py)
        print(" " + coverage_tool() + " annotate " + _systemctl_py)
    if not result.wasSuccessful():
        sys.exit(1)
